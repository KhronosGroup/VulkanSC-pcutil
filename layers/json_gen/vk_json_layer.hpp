/*
 * Copyright (c) 2020-2025 The Khronos Group Inc.
 * Copyright (c) 2020-2025 LunarG, Inc.
 * Copyright (c) 2020-2025 Advanced Micro Devices, Inc.
 * Copyright (c) 2022-2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * Copyright (c) 2025 RasterGrid Kft.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
#pragma once
#define VK_NO_PROTOTYPES
#include <vulkan/vulkan_core.h>
#undef VK_NO_PROTOTYPES
#include <array>
#include <vector>
#include <memory>
#include <unordered_set>
#include <atomic>
#include <mutex>
#include <string_view>
#include <optional>
#include <variant>

#include "allocator.h"
#include <vulkan/utility/vk_concurrent_unordered_map.hpp>
#include <vulkan/utility/vk_safe_struct.hpp>

namespace vk_json {

struct DeviceData;

struct LayerSettings {};

struct PhysicalDeviceData {
    VkPhysicalDevice physical_device = VK_NULL_HANDLE;
    bool lower_has_pipeline_props = false;
    uint32_t api_version;
};

struct DeviceFeatures {
    DeviceFeatures(const VkDeviceCreateInfo* ci);
    DeviceFeatures() = default;

    bool pipeline_props;
};

struct YcbcrData {
    YcbcrData(const VkSamplerYcbcrConversionCreateInfo* ci, DeviceData& device_data);
    YcbcrData() = default;

    vku::safe_VkSamplerYcbcrConversionCreateInfo create_info;
    std::uintptr_t unique_obj_id;
};

struct SamplerData {
    SamplerData(const VkSamplerCreateInfo* ci, DeviceData& device_data);
    SamplerData() = default;

    vku::safe_VkSamplerCreateInfo create_info;
    std::optional<YcbcrData> ycbcr_data;
    std::uintptr_t unique_obj_id;
};

struct DescriptorSetLayoutData {
    DescriptorSetLayoutData(const VkDescriptorSetLayoutCreateInfo* ci, DeviceData& device_data);
    DescriptorSetLayoutData() = default;

    vku::safe_VkDescriptorSetLayoutCreateInfo create_info;
    std::vector<SamplerData> immutable_sampler_data;
    std::uintptr_t unique_obj_id;
};

struct PipelineLayoutData {
    PipelineLayoutData(const VkPipelineLayoutCreateInfo* ci, DeviceData& device_data);
    PipelineLayoutData() = default;

    vku::safe_VkPipelineLayoutCreateInfo create_info;
    std::vector<DescriptorSetLayoutData> descriptor_set_layout_data;
    std::uintptr_t unique_obj_id;
};

struct ShaderModuleData {
    ShaderModuleData(const VkShaderModuleCreateInfo* ci);
    ShaderModuleData() = default;

    vku::safe_VkShaderModuleCreateInfo create_info;
};

struct RenderPassData {
    RenderPassData(const VkRenderPassCreateInfo* ci);
    RenderPassData() = default;

    vku::safe_VkRenderPassCreateInfo create_info;
};

struct RenderPass2Data {
    RenderPass2Data(const VkRenderPassCreateInfo2* ci);
    RenderPass2Data() = default;

    vku::safe_VkRenderPassCreateInfo2 create_info;
};

struct ImageViewData {
    ImageViewData(const VkImageViewCreateInfo* ci);
    ImageViewData() = default;

    vku::safe_VkImageViewCreateInfo create_info;
};

struct GraphicsPipelineData {
    GraphicsPipelineData(const VkGraphicsPipelineCreateInfo* ci, DeviceData& device_data);
    GraphicsPipelineData() = default;

    vku::safe_VkGraphicsPipelineCreateInfo create_info;
    PipelineLayoutData pipeline_layout_data;
    std::variant<RenderPassData, RenderPass2Data> renderpass_data;
    std::vector<ShaderModuleData> shader_module_data;
    std::array<uint8_t, VK_UUID_SIZE> uuid;
    std::uintptr_t unique_obj_id;

    void GenJsonUuidAndWriteToDisk(DeviceData& device_data);
};

struct ComputePipelineData {
    ComputePipelineData(const VkComputePipelineCreateInfo* ci, DeviceData& device_data);
    ComputePipelineData() = default;

    vku::safe_VkComputePipelineCreateInfo create_info;
    PipelineLayoutData pipeline_layout_data;
    ShaderModuleData shader_module_data;
    std::array<uint8_t, VK_UUID_SIZE> uuid;
    std::uintptr_t unique_obj_id;

    void GenJsonUuidAndWriteToDisk(DeviceData& device_data);
};

struct ObjectResCreateInfo {
    /// NOTE: the JSON gen layer does not help with:
    ///
    ///       uint32_t pipelineCacheCreateInfoCount;
    ///       const VkPipelineCacheCreateInfo* pPipelineCacheCreateInfos;
    ///       uint32_t pipelinePoolSizeCount;
    ///       const VkPipelinePoolSize* pPipelinePoolSizes;
    ///
    ///       It is assumed that the user of the layer cosnumes the output of
    ///       the layer via the pcreader utilities to parse the number of
    ///       pipeline cache entries and their respective size generated by
    ///       the layer.
    std::atomic<uint32_t> semaphoreRequestCount, semaphoreHighWatermark;
    std::atomic<uint32_t> commandBufferRequestCount, commandBufferHighWatermark;
    std::atomic<uint32_t> fenceRequestCount, fenceHighWatermark;
    std::atomic<uint32_t> deviceMemoryRequestCount, deviceMemoryHighWatermark;
    std::atomic<uint32_t> bufferRequestCount, bufferHighWatermark;
    std::atomic<uint32_t> imageRequestCount, imageHighWatermark;
    std::atomic<uint32_t> eventRequestCount, eventHighWatermark;
    std::atomic<uint32_t> queryPoolRequestCount, queryPoolHighWatermark;
    std::atomic<uint32_t> bufferViewRequestCount, bufferViewHighWatermark;
    std::atomic<uint32_t> imageViewRequestCount, imageViewHighWatermark;
    std::atomic<uint32_t> layeredImageViewRequestCount, layeredImageViewHighWatermark;
    std::atomic<uint32_t> pipelineCacheRequestCount, pipelineCacheHighWatermark;
    std::atomic<uint32_t> pipelineLayoutRequestCount, pipelineLayoutHighWatermark;
    std::atomic<uint32_t> renderPassRequestCount, renderPassHighWatermark;
    std::atomic<uint32_t> graphicsPipelineRequestCount, graphicsPipelineHighWatermark;
    std::atomic<uint32_t> computePipelineRequestCount, computePipelineHighWatermark;
    std::atomic<uint32_t> descriptorSetLayoutRequestCount, descriptorSetLayoutHighWatermark;
    std::atomic<uint32_t> samplerRequestCount, samplerHighWatermark;
    std::atomic<uint32_t> descriptorPoolRequestCount, descriptorPoolHighWatermark;
    std::atomic<uint32_t> descriptorSetRequestCount, descriptorSetHighWatermark;
    std::atomic<uint32_t> framebufferRequestCount, framebufferHighWatermark;
    std::atomic<uint32_t> commandPoolRequestCount, commandPoolHighWatermark;
    std::atomic<uint32_t> samplerYcbcrConversionRequestCount, samplerYcbcrConversionHighWatermark;
    std::atomic<uint32_t> swapchainRequestCount, swapchainHighWatermark;
    std::atomic<uint32_t> subpassDescriptionRequestCount, subpassDescriptionHighWatermark;
    std::atomic<uint32_t> attachmentDescriptionRequestCount, attachmentDescriptionHighWatermark;
    std::atomic<uint32_t> descriptorSetLayoutBindingRequestCount, descriptorSetLayoutBindingHighWatermark;
    std::atomic<uint32_t> descriptorSetLayoutBindingLimit;
    std::atomic<uint32_t> maxImageViewMipLevels;
    std::atomic<uint32_t> maxImageViewArrayLayers;
    std::atomic<uint32_t> maxLayeredImageViewMipLevels;
    std::atomic<uint32_t> maxOcclusionQueriesPerPool;
    std::atomic<uint32_t> maxPipelineStatisticsQueriesPerPool;
    std::atomic<uint32_t> maxTimestampQueriesPerPool;
    std::atomic<uint32_t> maxImmutableSamplersPerDescriptorSetLayout;
};

#define DECLARE_HOOK(fn) PFN_vk##fn fn
struct InstanceData {
    InstanceData(VkInstance instance, PFN_vkGetInstanceProcAddr gpa, const VkAllocationCallbacks* alloc);
    InstanceData() = delete;
    InstanceData(const InstanceData&) = delete;
    InstanceData& operator=(const InstanceData&) = delete;

    std::shared_ptr<PhysicalDeviceData> GetPhysicalDeviceData(VkPhysicalDevice physical_device) const;

    VkInstance instance;
    uint32_t api_version;
    LayerSettings layer_settings;
    const VkAllocationCallbacks* allocator;
    struct InstanceDispatchTable {
        DECLARE_HOOK(GetInstanceProcAddr);
        DECLARE_HOOK(CreateInstance);
        DECLARE_HOOK(DestroyInstance);
        DECLARE_HOOK(CreateDevice);
        DECLARE_HOOK(EnumeratePhysicalDevices);
        DECLARE_HOOK(EnumerateDeviceExtensionProperties);
        DECLARE_HOOK(EnumerateInstanceExtensionProperties);
        DECLARE_HOOK(GetPhysicalDeviceFeatures2);
        DECLARE_HOOK(GetPhysicalDeviceFeatures2KHR);
        DECLARE_HOOK(GetPhysicalDeviceProperties);
    } vtable;

    vku::concurrent::unordered_map<VkPhysicalDevice, std::shared_ptr<PhysicalDeviceData>> physical_device_map;

    std::atomic<std::uintptr_t> unique_obj_id_counter;
};

struct DeviceData {
    DeviceData(VkDevice device, const VkDeviceCreateInfo* ci, PFN_vkGetDeviceProcAddr gpa, bool enable,
               const VkAllocationCallbacks* alloc, InstanceData& instance_data);
    DeviceData() = delete;
    DeviceData(const DeviceData&) = delete;
    DeviceData& operator=(const DeviceData&) = delete;
    ~DeviceData();

    VkDevice device;
    vku::safe_VkDeviceCreateInfo create_info;
    struct DeviceDispatchTable {
        DECLARE_HOOK(GetDeviceProcAddr);
        DECLARE_HOOK(DestroyDevice);
        DECLARE_HOOK(CreateSemaphore);
        DECLARE_HOOK(DestroySemaphore);
        DECLARE_HOOK(CreateShaderModule);
        DECLARE_HOOK(DestroyShaderModule);
        DECLARE_HOOK(AllocateMemory);
        // FreeMemory doesn not exist in SC.
        DECLARE_HOOK(CreatePipelineCache);
        DECLARE_HOOK(DestroyPipelineCache);
        DECLARE_HOOK(CreateGraphicsPipelines);
        DECLARE_HOOK(CreateComputePipelines);
        DECLARE_HOOK(DestroyPipeline);
        DECLARE_HOOK(CreateDescriptorSetLayout);
        DECLARE_HOOK(DestroyDescriptorSetLayout);
        DECLARE_HOOK(CreatePipelineLayout);
        DECLARE_HOOK(DestroyPipelineLayout);
        DECLARE_HOOK(CreateRenderPass);
        DECLARE_HOOK(CreateRenderPass2);
        DECLARE_HOOK(DestroyRenderPass);
        DECLARE_HOOK(CreateSampler);
        DECLARE_HOOK(DestroySampler);
        DECLARE_HOOK(CreateSamplerYcbcrConversion);
        DECLARE_HOOK(DestroySamplerYcbcrConversion);
        DECLARE_HOOK(CreateSwapchainKHR);
        DECLARE_HOOK(DestroySwapchainKHR);
        DECLARE_HOOK(CreateImage);
        DECLARE_HOOK(DestroyImage);
        DECLARE_HOOK(CreateImageView);
        DECLARE_HOOK(DestroyImageView);
        DECLARE_HOOK(AllocateCommandBuffers);
        // FreeCommandBuffers does not release memory, only CommandPool reset does.
        DECLARE_HOOK(CreateFence);
        DECLARE_HOOK(DestroyFence);
        DECLARE_HOOK(CreateBuffer);
        DECLARE_HOOK(DestroyBuffer);
        DECLARE_HOOK(CreateBufferView);
        DECLARE_HOOK(DestroyBufferView);
        DECLARE_HOOK(CreateEvent);
        DECLARE_HOOK(DestroyEvent);
        DECLARE_HOOK(CreateQueryPool);
        // DestroyQueryPool does not exist in SC.
        DECLARE_HOOK(CreateDescriptorPool);
        // DestroyDescriptorPool does not exist in SC.
        DECLARE_HOOK(AllocateDescriptorSets);
        DECLARE_HOOK(FreeDescriptorSets);
        DECLARE_HOOK(CreateFramebuffer);
        DECLARE_HOOK(DestroyFramebuffer);
        DECLARE_HOOK(CreateCommandPool);
        // DestroyCommandPool does not exist in SC.
        // Releasing memory upon command pool reset requires command buffer tracking
        DECLARE_HOOK(GetPipelinePropertiesEXT);
    } vtable;
    const VkAllocationCallbacks* allocator;

    vku::concurrent::unordered_map<VkSamplerYcbcrConversion, std::shared_ptr<YcbcrData>> ycbcr_map;
    vku::concurrent::unordered_map<VkSampler, std::shared_ptr<SamplerData>> sampler_map;
    vku::concurrent::unordered_map<VkDescriptorSetLayout, std::shared_ptr<DescriptorSetLayoutData>> descriptor_set_layout_map;
    vku::concurrent::unordered_map<VkPipelineLayout, std::shared_ptr<PipelineLayoutData>> pipeline_layout_map;
    vku::concurrent::unordered_map<VkShaderModule, std::shared_ptr<ShaderModuleData>> shader_module_map;
    vku::concurrent::unordered_map<VkPipeline, std::shared_ptr<GraphicsPipelineData>> graphics_pipeline_map;
    vku::concurrent::unordered_map<VkPipeline, std::shared_ptr<ComputePipelineData>> compute_pipeline_map;
    vku::concurrent::unordered_map<VkRenderPass, std::shared_ptr<RenderPassData>> renderpass_map;
    vku::concurrent::unordered_map<VkRenderPass, std::shared_ptr<RenderPass2Data>> renderpass2_map;
    vku::concurrent::unordered_map<VkImageView, std::shared_ptr<ImageViewData>> image_view_map;
    ObjectResCreateInfo obj_res_info;

    std::atomic<std::uintptr_t> unique_obj_id_counter;
    uintptr_t unique_obj_id;

    std::string base_dir_path;
    std::string process_name;

    void writeDeviceObjResHeader();
};
#undef DECLARE_HOOK

std::string getProcessName();
std::string getBaseDirectoryPath();

struct OwningVpjShaderFilenames;
OwningVpjShaderFilenames get_shader_filenames(const VkGraphicsPipelineCreateInfo& ci, const std::string& prefix,
                                              const uint32_t index);
OwningVpjShaderFilenames get_shader_filenames(const VkComputePipelineCreateInfo& ci, const std::string& prefix,
                                              const uint32_t index);
}  // namespace vk_json
