
// *** THIS FILE IS GENERATED - DO NOT EDIT ***
// See json_parse_generator.py for modifications

/*
 * Copyright (c) 2024-2025 The Khronos Group Inc.
 * Copyright (c) 2024-2025 RasterGrid Kft.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#pragma once
// NOLINTBEGIN
#include <json/json.h>
#include <vulkan/vulkan.h>

#include <string>
#include <sstream>
#include <string_view>
#include <unordered_map>
#include <algorithm>

#include "vksc_pipeline_json_base.hpp"

namespace pcjson {

class ParserBase : protected Base {
  private:
    VkShaderModule parse_VkShaderModule(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return reinterpret_cast<VkShaderModule>((void*)parse_string(json, l));
        } else if (json.isUInt()) {
            return VkShaderModule(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkShaderModule(0);
        }
    }

    VkPipelineLayout parse_VkPipelineLayout(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return reinterpret_cast<VkPipelineLayout>((void*)parse_string(json, l));
        } else if (json.isUInt()) {
            return VkPipelineLayout(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkPipelineLayout(0);
        }
    }

    VkRenderPass parse_VkRenderPass(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return reinterpret_cast<VkRenderPass>((void*)parse_string(json, l));
        } else if (json.isUInt()) {
            return VkRenderPass(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkRenderPass(0);
        }
    }

    VkPipeline parse_VkPipeline(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return reinterpret_cast<VkPipeline>((void*)parse_string(json, l));
        } else if (json.isUInt()) {
            return VkPipeline(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkPipeline(0);
        }
    }

    VkSamplerYcbcrConversion parse_VkSamplerYcbcrConversion(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return reinterpret_cast<VkSamplerYcbcrConversion>((void*)parse_string(json, l));
        } else if (json.isUInt()) {
            return VkSamplerYcbcrConversion(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkSamplerYcbcrConversion(0);
        }
    }

    VkSampler parse_VkSampler(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return reinterpret_cast<VkSampler>((void*)parse_string(json, l));
        } else if (json.isUInt()) {
            return VkSampler(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkSampler(0);
        }
    }

    VkDescriptorSetLayout parse_VkDescriptorSetLayout(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return reinterpret_cast<VkDescriptorSetLayout>((void*)parse_string(json, l));
        } else if (json.isUInt()) {
            return VkDescriptorSetLayout(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkDescriptorSetLayout(0);
        }
    }

    VkStructureType parse_VkStructureType_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkStructureType> map = {
            std::make_pair("VK_STRUCTURE_TYPE_APPLICATION_INFO", VK_STRUCTURE_TYPE_APPLICATION_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO", VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO", VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO", VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SUBMIT_INFO", VK_STRUCTURE_TYPE_SUBMIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO", VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE", VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE),
            std::make_pair("VK_STRUCTURE_TYPE_FENCE_CREATE_INFO", VK_STRUCTURE_TYPE_FENCE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO", VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EVENT_CREATE_INFO", VK_STRUCTURE_TYPE_EVENT_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO", VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO", VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO", VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO", VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO", VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO", VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO", VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO", VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO", VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO",
                           VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO", VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO", VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET", VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET", VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET),
            std::make_pair("VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO", VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO", VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO", VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO", VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO", VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO", VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO", VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER", VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER", VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_BARRIER", VK_STRUCTURE_TYPE_MEMORY_BARRIER),
            std::make_pair("VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO", VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO", VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO", VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO", VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS", VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO", VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO", VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO",
                           VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO",
                           VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO", VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO",
                           VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO",
                           VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO", VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2",
                           VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2",
                           VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2", VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2", VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2", VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2),
            std::make_pair("VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2", VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2", VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2", VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO",
                           VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO", VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO",
                           VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO", VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2", VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO",
                           VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO", VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO", VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO",
                           VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES",
                           VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES",
                           VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES", VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES", VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO",
                           VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO", VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES", VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO", VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO", VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES", VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT", VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO", VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2", VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2),
            std::make_pair("VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2", VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2),
            std::make_pair("VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2", VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2),
            std::make_pair("VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2", VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2", VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO", VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SUBPASS_END_INFO", VK_STRUCTURE_TYPE_SUBPASS_END_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO",
                           VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO",
                           VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT",
                           VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE",
                           VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO", VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO",
                           VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO",
                           VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO",
                           VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT",
                           VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT),
            std::make_pair("VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT",
                           VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO", VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO", VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO", VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO", VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO", VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO",
                           VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO",
                           VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO",
                           VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES", VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO", VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO", VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_BARRIER_2", VK_STRUCTURE_TYPE_MEMORY_BARRIER_2),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2", VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2", VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2),
            std::make_pair("VK_STRUCTURE_TYPE_DEPENDENCY_INFO", VK_STRUCTURE_TYPE_DEPENDENCY_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SUBMIT_INFO_2", VK_STRUCTURE_TYPE_SUBMIT_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO", VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO", VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2", VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2", VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2", VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2", VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2", VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2", VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_COPY_2", VK_STRUCTURE_TYPE_BUFFER_COPY_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_COPY_2", VK_STRUCTURE_TYPE_IMAGE_COPY_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_BLIT_2", VK_STRUCTURE_TYPE_IMAGE_BLIT_2),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2", VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2", VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK",
                           VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO",
                           VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_RENDERING_INFO", VK_STRUCTURE_TYPE_RENDERING_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO", VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO", VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO",
                           VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3", VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS",
                           VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS",
                           VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO",
                           VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES",
                           VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_MAP_INFO", VK_STRUCTURE_TYPE_MEMORY_MAP_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO", VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_RENDERING_AREA_INFO", VK_STRUCTURE_TYPE_RENDERING_AREA_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO", VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2", VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2", VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO",
                           VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO",
                           VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO",
                           VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS", VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO", VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO", VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO", VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO", VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY", VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY", VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO", VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO", VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO",
                           VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO", VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE", VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE),
            std::make_pair("VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY",
                           VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO",
                           VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO",
                           VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION", VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE", VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE),
            std::make_pair("VK_STRUCTURE_TYPE_FAULT_DATA", VK_STRUCTURE_TYPE_FAULT_DATA),
            std::make_pair("VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO", VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO", VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR", VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PRESENT_INFO_KHR", VK_STRUCTURE_TYPE_PRESENT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR",
                           VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR", VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR",
                           VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR", VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR", VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR",
                           VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR", VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR", VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR", VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV",
                           VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT", VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR", VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR", VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR", VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR", VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR", VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR", VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT", VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT", VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT", VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT", VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_HDR_METADATA_EXT", VK_STRUCTURE_TYPE_HDR_METADATA_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR",
                           VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR", VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR", VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR",
                           VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR",
                           VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR", VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR", VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR",
                           VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR",
                           VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR", VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR", VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR", VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR", VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR", VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR", VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR",
                           VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT",
                           VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT", VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT", VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT",
                           VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT", VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT",
                           VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT", VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT",
                           VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT",
                           VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT",
                           VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR",
                           VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR",
                           VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR",
                           VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT", VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR", VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT",
                           VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT",
                           VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV", VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV", VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV", VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV", VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV",
                           VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV",
                           VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV", VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV", VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV", VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV", VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV", VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT", VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV",
                           VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV",
                           VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV",
                           VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT", VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX", VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX),
            std::make_pair("VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX",
                           VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX", VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX", VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX),
            std::make_pair("VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR", VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkStructureType constant: " << v;
            return static_cast<VkStructureType>(0);
        }
    }

    VkPipelineCreateFlagBits parse_VkPipelineCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkPipelineCreateFlagBits>(0)),
            std::make_pair("VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT", VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT),
            std::make_pair("VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT",
                           VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT),
            std::make_pair("VK_PIPELINE_CREATE_DISPATCH_BASE_BIT", VK_PIPELINE_CREATE_DISPATCH_BASE_BIT),
            std::make_pair("VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT",
                           VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT),
            std::make_pair("VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT", VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT),
            std::make_pair("VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT", VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT),
            std::make_pair("VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT", VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineCreateFlagBits bit: " << v;
            return static_cast<VkPipelineCreateFlagBits>(0);
        }
    }

    VkPipelineShaderStageCreateFlagBits parse_VkPipelineShaderStageCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineShaderStageCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkPipelineShaderStageCreateFlagBits>(0)),
            std::make_pair("VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT",
                           VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT),
            std::make_pair("VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT",
                           VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineShaderStageCreateFlagBits bit: " << v;
            return static_cast<VkPipelineShaderStageCreateFlagBits>(0);
        }
    }

    VkShaderStageFlagBits parse_VkShaderStageFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkShaderStageFlagBits> map = {
            std::make_pair("0", static_cast<VkShaderStageFlagBits>(0)),
            std::make_pair("VK_SHADER_STAGE_VERTEX_BIT", VK_SHADER_STAGE_VERTEX_BIT),
            std::make_pair("VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT", VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT),
            std::make_pair("VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT", VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT),
            std::make_pair("VK_SHADER_STAGE_GEOMETRY_BIT", VK_SHADER_STAGE_GEOMETRY_BIT),
            std::make_pair("VK_SHADER_STAGE_FRAGMENT_BIT", VK_SHADER_STAGE_FRAGMENT_BIT),
            std::make_pair("VK_SHADER_STAGE_COMPUTE_BIT", VK_SHADER_STAGE_COMPUTE_BIT),
            std::make_pair("VK_SHADER_STAGE_ALL_GRAPHICS", VK_SHADER_STAGE_ALL_GRAPHICS),
            std::make_pair("VK_SHADER_STAGE_ALL", VK_SHADER_STAGE_ALL)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkShaderStageFlagBits bit: " << v;
            return static_cast<VkShaderStageFlagBits>(0);
        }
    }

    VkObjectType parse_VkObjectType_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkObjectType> map = {
            std::make_pair("VK_OBJECT_TYPE_UNKNOWN", VK_OBJECT_TYPE_UNKNOWN),
            std::make_pair("VK_OBJECT_TYPE_INSTANCE", VK_OBJECT_TYPE_INSTANCE),
            std::make_pair("VK_OBJECT_TYPE_PHYSICAL_DEVICE", VK_OBJECT_TYPE_PHYSICAL_DEVICE),
            std::make_pair("VK_OBJECT_TYPE_DEVICE", VK_OBJECT_TYPE_DEVICE),
            std::make_pair("VK_OBJECT_TYPE_QUEUE", VK_OBJECT_TYPE_QUEUE),
            std::make_pair("VK_OBJECT_TYPE_SEMAPHORE", VK_OBJECT_TYPE_SEMAPHORE),
            std::make_pair("VK_OBJECT_TYPE_COMMAND_BUFFER", VK_OBJECT_TYPE_COMMAND_BUFFER),
            std::make_pair("VK_OBJECT_TYPE_FENCE", VK_OBJECT_TYPE_FENCE),
            std::make_pair("VK_OBJECT_TYPE_DEVICE_MEMORY", VK_OBJECT_TYPE_DEVICE_MEMORY),
            std::make_pair("VK_OBJECT_TYPE_BUFFER", VK_OBJECT_TYPE_BUFFER),
            std::make_pair("VK_OBJECT_TYPE_IMAGE", VK_OBJECT_TYPE_IMAGE),
            std::make_pair("VK_OBJECT_TYPE_EVENT", VK_OBJECT_TYPE_EVENT),
            std::make_pair("VK_OBJECT_TYPE_QUERY_POOL", VK_OBJECT_TYPE_QUERY_POOL),
            std::make_pair("VK_OBJECT_TYPE_BUFFER_VIEW", VK_OBJECT_TYPE_BUFFER_VIEW),
            std::make_pair("VK_OBJECT_TYPE_IMAGE_VIEW", VK_OBJECT_TYPE_IMAGE_VIEW),
            std::make_pair("VK_OBJECT_TYPE_SHADER_MODULE", VK_OBJECT_TYPE_SHADER_MODULE),
            std::make_pair("VK_OBJECT_TYPE_PIPELINE_CACHE", VK_OBJECT_TYPE_PIPELINE_CACHE),
            std::make_pair("VK_OBJECT_TYPE_PIPELINE_LAYOUT", VK_OBJECT_TYPE_PIPELINE_LAYOUT),
            std::make_pair("VK_OBJECT_TYPE_RENDER_PASS", VK_OBJECT_TYPE_RENDER_PASS),
            std::make_pair("VK_OBJECT_TYPE_PIPELINE", VK_OBJECT_TYPE_PIPELINE),
            std::make_pair("VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT", VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT),
            std::make_pair("VK_OBJECT_TYPE_SAMPLER", VK_OBJECT_TYPE_SAMPLER),
            std::make_pair("VK_OBJECT_TYPE_DESCRIPTOR_POOL", VK_OBJECT_TYPE_DESCRIPTOR_POOL),
            std::make_pair("VK_OBJECT_TYPE_DESCRIPTOR_SET", VK_OBJECT_TYPE_DESCRIPTOR_SET),
            std::make_pair("VK_OBJECT_TYPE_FRAMEBUFFER", VK_OBJECT_TYPE_FRAMEBUFFER),
            std::make_pair("VK_OBJECT_TYPE_COMMAND_POOL", VK_OBJECT_TYPE_COMMAND_POOL),
            std::make_pair("VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION", VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION),
            std::make_pair("VK_OBJECT_TYPE_PRIVATE_DATA_SLOT", VK_OBJECT_TYPE_PRIVATE_DATA_SLOT),
            std::make_pair("VK_OBJECT_TYPE_SURFACE_KHR", VK_OBJECT_TYPE_SURFACE_KHR),
            std::make_pair("VK_OBJECT_TYPE_SWAPCHAIN_KHR", VK_OBJECT_TYPE_SWAPCHAIN_KHR),
            std::make_pair("VK_OBJECT_TYPE_DISPLAY_KHR", VK_OBJECT_TYPE_DISPLAY_KHR),
            std::make_pair("VK_OBJECT_TYPE_DISPLAY_MODE_KHR", VK_OBJECT_TYPE_DISPLAY_MODE_KHR),
            std::make_pair("VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT", VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT),
            std::make_pair("VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV", VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkObjectType constant: " << v;
            return static_cast<VkObjectType>(0);
        }
    }

    VkPipelineRobustnessBufferBehavior parse_VkPipelineRobustnessBufferBehavior_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineRobustnessBufferBehavior> map = {
            std::make_pair("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT",
                           VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT),
            std::make_pair("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED", VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED),
            std::make_pair("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS",
                           VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS),
            std::make_pair("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2",
                           VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineRobustnessBufferBehavior constant: " << v;
            return static_cast<VkPipelineRobustnessBufferBehavior>(0);
        }
    }

    VkPipelineRobustnessImageBehavior parse_VkPipelineRobustnessImageBehavior_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineRobustnessImageBehavior> map = {
            std::make_pair("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT",
                           VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT),
            std::make_pair("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED", VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED),
            std::make_pair("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS",
                           VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS),
            std::make_pair("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2",
                           VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineRobustnessImageBehavior constant: " << v;
            return static_cast<VkPipelineRobustnessImageBehavior>(0);
        }
    }

    VkVertexInputRate parse_VkVertexInputRate_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkVertexInputRate> map = {
            std::make_pair("VK_VERTEX_INPUT_RATE_VERTEX", VK_VERTEX_INPUT_RATE_VERTEX),
            std::make_pair("VK_VERTEX_INPUT_RATE_INSTANCE", VK_VERTEX_INPUT_RATE_INSTANCE)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkVertexInputRate constant: " << v;
            return static_cast<VkVertexInputRate>(0);
        }
    }

    VkFormat parse_VkFormat_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkFormat> map = {
            std::make_pair("VK_FORMAT_UNDEFINED", VK_FORMAT_UNDEFINED),
            std::make_pair("VK_FORMAT_R4G4_UNORM_PACK8", VK_FORMAT_R4G4_UNORM_PACK8),
            std::make_pair("VK_FORMAT_R4G4B4A4_UNORM_PACK16", VK_FORMAT_R4G4B4A4_UNORM_PACK16),
            std::make_pair("VK_FORMAT_B4G4R4A4_UNORM_PACK16", VK_FORMAT_B4G4R4A4_UNORM_PACK16),
            std::make_pair("VK_FORMAT_R5G6B5_UNORM_PACK16", VK_FORMAT_R5G6B5_UNORM_PACK16),
            std::make_pair("VK_FORMAT_B5G6R5_UNORM_PACK16", VK_FORMAT_B5G6R5_UNORM_PACK16),
            std::make_pair("VK_FORMAT_R5G5B5A1_UNORM_PACK16", VK_FORMAT_R5G5B5A1_UNORM_PACK16),
            std::make_pair("VK_FORMAT_B5G5R5A1_UNORM_PACK16", VK_FORMAT_B5G5R5A1_UNORM_PACK16),
            std::make_pair("VK_FORMAT_A1R5G5B5_UNORM_PACK16", VK_FORMAT_A1R5G5B5_UNORM_PACK16),
            std::make_pair("VK_FORMAT_R8_UNORM", VK_FORMAT_R8_UNORM),
            std::make_pair("VK_FORMAT_R8_SNORM", VK_FORMAT_R8_SNORM),
            std::make_pair("VK_FORMAT_R8_USCALED", VK_FORMAT_R8_USCALED),
            std::make_pair("VK_FORMAT_R8_SSCALED", VK_FORMAT_R8_SSCALED),
            std::make_pair("VK_FORMAT_R8_UINT", VK_FORMAT_R8_UINT),
            std::make_pair("VK_FORMAT_R8_SINT", VK_FORMAT_R8_SINT),
            std::make_pair("VK_FORMAT_R8_SRGB", VK_FORMAT_R8_SRGB),
            std::make_pair("VK_FORMAT_R8G8_UNORM", VK_FORMAT_R8G8_UNORM),
            std::make_pair("VK_FORMAT_R8G8_SNORM", VK_FORMAT_R8G8_SNORM),
            std::make_pair("VK_FORMAT_R8G8_USCALED", VK_FORMAT_R8G8_USCALED),
            std::make_pair("VK_FORMAT_R8G8_SSCALED", VK_FORMAT_R8G8_SSCALED),
            std::make_pair("VK_FORMAT_R8G8_UINT", VK_FORMAT_R8G8_UINT),
            std::make_pair("VK_FORMAT_R8G8_SINT", VK_FORMAT_R8G8_SINT),
            std::make_pair("VK_FORMAT_R8G8_SRGB", VK_FORMAT_R8G8_SRGB),
            std::make_pair("VK_FORMAT_R8G8B8_UNORM", VK_FORMAT_R8G8B8_UNORM),
            std::make_pair("VK_FORMAT_R8G8B8_SNORM", VK_FORMAT_R8G8B8_SNORM),
            std::make_pair("VK_FORMAT_R8G8B8_USCALED", VK_FORMAT_R8G8B8_USCALED),
            std::make_pair("VK_FORMAT_R8G8B8_SSCALED", VK_FORMAT_R8G8B8_SSCALED),
            std::make_pair("VK_FORMAT_R8G8B8_UINT", VK_FORMAT_R8G8B8_UINT),
            std::make_pair("VK_FORMAT_R8G8B8_SINT", VK_FORMAT_R8G8B8_SINT),
            std::make_pair("VK_FORMAT_R8G8B8_SRGB", VK_FORMAT_R8G8B8_SRGB),
            std::make_pair("VK_FORMAT_B8G8R8_UNORM", VK_FORMAT_B8G8R8_UNORM),
            std::make_pair("VK_FORMAT_B8G8R8_SNORM", VK_FORMAT_B8G8R8_SNORM),
            std::make_pair("VK_FORMAT_B8G8R8_USCALED", VK_FORMAT_B8G8R8_USCALED),
            std::make_pair("VK_FORMAT_B8G8R8_SSCALED", VK_FORMAT_B8G8R8_SSCALED),
            std::make_pair("VK_FORMAT_B8G8R8_UINT", VK_FORMAT_B8G8R8_UINT),
            std::make_pair("VK_FORMAT_B8G8R8_SINT", VK_FORMAT_B8G8R8_SINT),
            std::make_pair("VK_FORMAT_B8G8R8_SRGB", VK_FORMAT_B8G8R8_SRGB),
            std::make_pair("VK_FORMAT_R8G8B8A8_UNORM", VK_FORMAT_R8G8B8A8_UNORM),
            std::make_pair("VK_FORMAT_R8G8B8A8_SNORM", VK_FORMAT_R8G8B8A8_SNORM),
            std::make_pair("VK_FORMAT_R8G8B8A8_USCALED", VK_FORMAT_R8G8B8A8_USCALED),
            std::make_pair("VK_FORMAT_R8G8B8A8_SSCALED", VK_FORMAT_R8G8B8A8_SSCALED),
            std::make_pair("VK_FORMAT_R8G8B8A8_UINT", VK_FORMAT_R8G8B8A8_UINT),
            std::make_pair("VK_FORMAT_R8G8B8A8_SINT", VK_FORMAT_R8G8B8A8_SINT),
            std::make_pair("VK_FORMAT_R8G8B8A8_SRGB", VK_FORMAT_R8G8B8A8_SRGB),
            std::make_pair("VK_FORMAT_B8G8R8A8_UNORM", VK_FORMAT_B8G8R8A8_UNORM),
            std::make_pair("VK_FORMAT_B8G8R8A8_SNORM", VK_FORMAT_B8G8R8A8_SNORM),
            std::make_pair("VK_FORMAT_B8G8R8A8_USCALED", VK_FORMAT_B8G8R8A8_USCALED),
            std::make_pair("VK_FORMAT_B8G8R8A8_SSCALED", VK_FORMAT_B8G8R8A8_SSCALED),
            std::make_pair("VK_FORMAT_B8G8R8A8_UINT", VK_FORMAT_B8G8R8A8_UINT),
            std::make_pair("VK_FORMAT_B8G8R8A8_SINT", VK_FORMAT_B8G8R8A8_SINT),
            std::make_pair("VK_FORMAT_B8G8R8A8_SRGB", VK_FORMAT_B8G8R8A8_SRGB),
            std::make_pair("VK_FORMAT_A8B8G8R8_UNORM_PACK32", VK_FORMAT_A8B8G8R8_UNORM_PACK32),
            std::make_pair("VK_FORMAT_A8B8G8R8_SNORM_PACK32", VK_FORMAT_A8B8G8R8_SNORM_PACK32),
            std::make_pair("VK_FORMAT_A8B8G8R8_USCALED_PACK32", VK_FORMAT_A8B8G8R8_USCALED_PACK32),
            std::make_pair("VK_FORMAT_A8B8G8R8_SSCALED_PACK32", VK_FORMAT_A8B8G8R8_SSCALED_PACK32),
            std::make_pair("VK_FORMAT_A8B8G8R8_UINT_PACK32", VK_FORMAT_A8B8G8R8_UINT_PACK32),
            std::make_pair("VK_FORMAT_A8B8G8R8_SINT_PACK32", VK_FORMAT_A8B8G8R8_SINT_PACK32),
            std::make_pair("VK_FORMAT_A8B8G8R8_SRGB_PACK32", VK_FORMAT_A8B8G8R8_SRGB_PACK32),
            std::make_pair("VK_FORMAT_A2R10G10B10_UNORM_PACK32", VK_FORMAT_A2R10G10B10_UNORM_PACK32),
            std::make_pair("VK_FORMAT_A2R10G10B10_SNORM_PACK32", VK_FORMAT_A2R10G10B10_SNORM_PACK32),
            std::make_pair("VK_FORMAT_A2R10G10B10_USCALED_PACK32", VK_FORMAT_A2R10G10B10_USCALED_PACK32),
            std::make_pair("VK_FORMAT_A2R10G10B10_SSCALED_PACK32", VK_FORMAT_A2R10G10B10_SSCALED_PACK32),
            std::make_pair("VK_FORMAT_A2R10G10B10_UINT_PACK32", VK_FORMAT_A2R10G10B10_UINT_PACK32),
            std::make_pair("VK_FORMAT_A2R10G10B10_SINT_PACK32", VK_FORMAT_A2R10G10B10_SINT_PACK32),
            std::make_pair("VK_FORMAT_A2B10G10R10_UNORM_PACK32", VK_FORMAT_A2B10G10R10_UNORM_PACK32),
            std::make_pair("VK_FORMAT_A2B10G10R10_SNORM_PACK32", VK_FORMAT_A2B10G10R10_SNORM_PACK32),
            std::make_pair("VK_FORMAT_A2B10G10R10_USCALED_PACK32", VK_FORMAT_A2B10G10R10_USCALED_PACK32),
            std::make_pair("VK_FORMAT_A2B10G10R10_SSCALED_PACK32", VK_FORMAT_A2B10G10R10_SSCALED_PACK32),
            std::make_pair("VK_FORMAT_A2B10G10R10_UINT_PACK32", VK_FORMAT_A2B10G10R10_UINT_PACK32),
            std::make_pair("VK_FORMAT_A2B10G10R10_SINT_PACK32", VK_FORMAT_A2B10G10R10_SINT_PACK32),
            std::make_pair("VK_FORMAT_R16_UNORM", VK_FORMAT_R16_UNORM),
            std::make_pair("VK_FORMAT_R16_SNORM", VK_FORMAT_R16_SNORM),
            std::make_pair("VK_FORMAT_R16_USCALED", VK_FORMAT_R16_USCALED),
            std::make_pair("VK_FORMAT_R16_SSCALED", VK_FORMAT_R16_SSCALED),
            std::make_pair("VK_FORMAT_R16_UINT", VK_FORMAT_R16_UINT),
            std::make_pair("VK_FORMAT_R16_SINT", VK_FORMAT_R16_SINT),
            std::make_pair("VK_FORMAT_R16_SFLOAT", VK_FORMAT_R16_SFLOAT),
            std::make_pair("VK_FORMAT_R16G16_UNORM", VK_FORMAT_R16G16_UNORM),
            std::make_pair("VK_FORMAT_R16G16_SNORM", VK_FORMAT_R16G16_SNORM),
            std::make_pair("VK_FORMAT_R16G16_USCALED", VK_FORMAT_R16G16_USCALED),
            std::make_pair("VK_FORMAT_R16G16_SSCALED", VK_FORMAT_R16G16_SSCALED),
            std::make_pair("VK_FORMAT_R16G16_UINT", VK_FORMAT_R16G16_UINT),
            std::make_pair("VK_FORMAT_R16G16_SINT", VK_FORMAT_R16G16_SINT),
            std::make_pair("VK_FORMAT_R16G16_SFLOAT", VK_FORMAT_R16G16_SFLOAT),
            std::make_pair("VK_FORMAT_R16G16B16_UNORM", VK_FORMAT_R16G16B16_UNORM),
            std::make_pair("VK_FORMAT_R16G16B16_SNORM", VK_FORMAT_R16G16B16_SNORM),
            std::make_pair("VK_FORMAT_R16G16B16_USCALED", VK_FORMAT_R16G16B16_USCALED),
            std::make_pair("VK_FORMAT_R16G16B16_SSCALED", VK_FORMAT_R16G16B16_SSCALED),
            std::make_pair("VK_FORMAT_R16G16B16_UINT", VK_FORMAT_R16G16B16_UINT),
            std::make_pair("VK_FORMAT_R16G16B16_SINT", VK_FORMAT_R16G16B16_SINT),
            std::make_pair("VK_FORMAT_R16G16B16_SFLOAT", VK_FORMAT_R16G16B16_SFLOAT),
            std::make_pair("VK_FORMAT_R16G16B16A16_UNORM", VK_FORMAT_R16G16B16A16_UNORM),
            std::make_pair("VK_FORMAT_R16G16B16A16_SNORM", VK_FORMAT_R16G16B16A16_SNORM),
            std::make_pair("VK_FORMAT_R16G16B16A16_USCALED", VK_FORMAT_R16G16B16A16_USCALED),
            std::make_pair("VK_FORMAT_R16G16B16A16_SSCALED", VK_FORMAT_R16G16B16A16_SSCALED),
            std::make_pair("VK_FORMAT_R16G16B16A16_UINT", VK_FORMAT_R16G16B16A16_UINT),
            std::make_pair("VK_FORMAT_R16G16B16A16_SINT", VK_FORMAT_R16G16B16A16_SINT),
            std::make_pair("VK_FORMAT_R16G16B16A16_SFLOAT", VK_FORMAT_R16G16B16A16_SFLOAT),
            std::make_pair("VK_FORMAT_R32_UINT", VK_FORMAT_R32_UINT),
            std::make_pair("VK_FORMAT_R32_SINT", VK_FORMAT_R32_SINT),
            std::make_pair("VK_FORMAT_R32_SFLOAT", VK_FORMAT_R32_SFLOAT),
            std::make_pair("VK_FORMAT_R32G32_UINT", VK_FORMAT_R32G32_UINT),
            std::make_pair("VK_FORMAT_R32G32_SINT", VK_FORMAT_R32G32_SINT),
            std::make_pair("VK_FORMAT_R32G32_SFLOAT", VK_FORMAT_R32G32_SFLOAT),
            std::make_pair("VK_FORMAT_R32G32B32_UINT", VK_FORMAT_R32G32B32_UINT),
            std::make_pair("VK_FORMAT_R32G32B32_SINT", VK_FORMAT_R32G32B32_SINT),
            std::make_pair("VK_FORMAT_R32G32B32_SFLOAT", VK_FORMAT_R32G32B32_SFLOAT),
            std::make_pair("VK_FORMAT_R32G32B32A32_UINT", VK_FORMAT_R32G32B32A32_UINT),
            std::make_pair("VK_FORMAT_R32G32B32A32_SINT", VK_FORMAT_R32G32B32A32_SINT),
            std::make_pair("VK_FORMAT_R32G32B32A32_SFLOAT", VK_FORMAT_R32G32B32A32_SFLOAT),
            std::make_pair("VK_FORMAT_R64_UINT", VK_FORMAT_R64_UINT),
            std::make_pair("VK_FORMAT_R64_SINT", VK_FORMAT_R64_SINT),
            std::make_pair("VK_FORMAT_R64_SFLOAT", VK_FORMAT_R64_SFLOAT),
            std::make_pair("VK_FORMAT_R64G64_UINT", VK_FORMAT_R64G64_UINT),
            std::make_pair("VK_FORMAT_R64G64_SINT", VK_FORMAT_R64G64_SINT),
            std::make_pair("VK_FORMAT_R64G64_SFLOAT", VK_FORMAT_R64G64_SFLOAT),
            std::make_pair("VK_FORMAT_R64G64B64_UINT", VK_FORMAT_R64G64B64_UINT),
            std::make_pair("VK_FORMAT_R64G64B64_SINT", VK_FORMAT_R64G64B64_SINT),
            std::make_pair("VK_FORMAT_R64G64B64_SFLOAT", VK_FORMAT_R64G64B64_SFLOAT),
            std::make_pair("VK_FORMAT_R64G64B64A64_UINT", VK_FORMAT_R64G64B64A64_UINT),
            std::make_pair("VK_FORMAT_R64G64B64A64_SINT", VK_FORMAT_R64G64B64A64_SINT),
            std::make_pair("VK_FORMAT_R64G64B64A64_SFLOAT", VK_FORMAT_R64G64B64A64_SFLOAT),
            std::make_pair("VK_FORMAT_B10G11R11_UFLOAT_PACK32", VK_FORMAT_B10G11R11_UFLOAT_PACK32),
            std::make_pair("VK_FORMAT_E5B9G9R9_UFLOAT_PACK32", VK_FORMAT_E5B9G9R9_UFLOAT_PACK32),
            std::make_pair("VK_FORMAT_D16_UNORM", VK_FORMAT_D16_UNORM),
            std::make_pair("VK_FORMAT_X8_D24_UNORM_PACK32", VK_FORMAT_X8_D24_UNORM_PACK32),
            std::make_pair("VK_FORMAT_D32_SFLOAT", VK_FORMAT_D32_SFLOAT),
            std::make_pair("VK_FORMAT_S8_UINT", VK_FORMAT_S8_UINT),
            std::make_pair("VK_FORMAT_D16_UNORM_S8_UINT", VK_FORMAT_D16_UNORM_S8_UINT),
            std::make_pair("VK_FORMAT_D24_UNORM_S8_UINT", VK_FORMAT_D24_UNORM_S8_UINT),
            std::make_pair("VK_FORMAT_D32_SFLOAT_S8_UINT", VK_FORMAT_D32_SFLOAT_S8_UINT),
            std::make_pair("VK_FORMAT_BC1_RGB_UNORM_BLOCK", VK_FORMAT_BC1_RGB_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC1_RGB_SRGB_BLOCK", VK_FORMAT_BC1_RGB_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_BC1_RGBA_UNORM_BLOCK", VK_FORMAT_BC1_RGBA_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC1_RGBA_SRGB_BLOCK", VK_FORMAT_BC1_RGBA_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_BC2_UNORM_BLOCK", VK_FORMAT_BC2_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC2_SRGB_BLOCK", VK_FORMAT_BC2_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_BC3_UNORM_BLOCK", VK_FORMAT_BC3_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC3_SRGB_BLOCK", VK_FORMAT_BC3_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_BC4_UNORM_BLOCK", VK_FORMAT_BC4_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC4_SNORM_BLOCK", VK_FORMAT_BC4_SNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC5_UNORM_BLOCK", VK_FORMAT_BC5_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC5_SNORM_BLOCK", VK_FORMAT_BC5_SNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC6H_UFLOAT_BLOCK", VK_FORMAT_BC6H_UFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_BC6H_SFLOAT_BLOCK", VK_FORMAT_BC6H_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_BC7_UNORM_BLOCK", VK_FORMAT_BC7_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC7_SRGB_BLOCK", VK_FORMAT_BC7_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK", VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK", VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK", VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK", VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK", VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK", VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_EAC_R11_UNORM_BLOCK", VK_FORMAT_EAC_R11_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_EAC_R11_SNORM_BLOCK", VK_FORMAT_EAC_R11_SNORM_BLOCK),
            std::make_pair("VK_FORMAT_EAC_R11G11_UNORM_BLOCK", VK_FORMAT_EAC_R11G11_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_EAC_R11G11_SNORM_BLOCK", VK_FORMAT_EAC_R11G11_SNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_4x4_UNORM_BLOCK", VK_FORMAT_ASTC_4x4_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_4x4_SRGB_BLOCK", VK_FORMAT_ASTC_4x4_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_5x4_UNORM_BLOCK", VK_FORMAT_ASTC_5x4_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_5x4_SRGB_BLOCK", VK_FORMAT_ASTC_5x4_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_5x5_UNORM_BLOCK", VK_FORMAT_ASTC_5x5_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_5x5_SRGB_BLOCK", VK_FORMAT_ASTC_5x5_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_6x5_UNORM_BLOCK", VK_FORMAT_ASTC_6x5_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_6x5_SRGB_BLOCK", VK_FORMAT_ASTC_6x5_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_6x6_UNORM_BLOCK", VK_FORMAT_ASTC_6x6_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_6x6_SRGB_BLOCK", VK_FORMAT_ASTC_6x6_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x5_UNORM_BLOCK", VK_FORMAT_ASTC_8x5_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x5_SRGB_BLOCK", VK_FORMAT_ASTC_8x5_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x6_UNORM_BLOCK", VK_FORMAT_ASTC_8x6_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x6_SRGB_BLOCK", VK_FORMAT_ASTC_8x6_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x8_UNORM_BLOCK", VK_FORMAT_ASTC_8x8_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x8_SRGB_BLOCK", VK_FORMAT_ASTC_8x8_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x5_UNORM_BLOCK", VK_FORMAT_ASTC_10x5_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x5_SRGB_BLOCK", VK_FORMAT_ASTC_10x5_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x6_UNORM_BLOCK", VK_FORMAT_ASTC_10x6_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x6_SRGB_BLOCK", VK_FORMAT_ASTC_10x6_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x8_UNORM_BLOCK", VK_FORMAT_ASTC_10x8_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x8_SRGB_BLOCK", VK_FORMAT_ASTC_10x8_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x10_UNORM_BLOCK", VK_FORMAT_ASTC_10x10_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x10_SRGB_BLOCK", VK_FORMAT_ASTC_10x10_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_12x10_UNORM_BLOCK", VK_FORMAT_ASTC_12x10_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_12x10_SRGB_BLOCK", VK_FORMAT_ASTC_12x10_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_12x12_UNORM_BLOCK", VK_FORMAT_ASTC_12x12_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_12x12_SRGB_BLOCK", VK_FORMAT_ASTC_12x12_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_G8B8G8R8_422_UNORM", VK_FORMAT_G8B8G8R8_422_UNORM),
            std::make_pair("VK_FORMAT_B8G8R8G8_422_UNORM", VK_FORMAT_B8G8R8G8_422_UNORM),
            std::make_pair("VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM", VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM),
            std::make_pair("VK_FORMAT_G8_B8R8_2PLANE_420_UNORM", VK_FORMAT_G8_B8R8_2PLANE_420_UNORM),
            std::make_pair("VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM", VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM),
            std::make_pair("VK_FORMAT_G8_B8R8_2PLANE_422_UNORM", VK_FORMAT_G8_B8R8_2PLANE_422_UNORM),
            std::make_pair("VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM", VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM),
            std::make_pair("VK_FORMAT_R10X6_UNORM_PACK16", VK_FORMAT_R10X6_UNORM_PACK16),
            std::make_pair("VK_FORMAT_R10X6G10X6_UNORM_2PACK16", VK_FORMAT_R10X6G10X6_UNORM_2PACK16),
            std::make_pair("VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16", VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16),
            std::make_pair("VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16", VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16),
            std::make_pair("VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16", VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16),
            std::make_pair("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16",
                           VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16",
                           VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16",
                           VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16",
                           VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16",
                           VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_R12X4_UNORM_PACK16", VK_FORMAT_R12X4_UNORM_PACK16),
            std::make_pair("VK_FORMAT_R12X4G12X4_UNORM_2PACK16", VK_FORMAT_R12X4G12X4_UNORM_2PACK16),
            std::make_pair("VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16", VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16),
            std::make_pair("VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16", VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16),
            std::make_pair("VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16", VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16),
            std::make_pair("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16",
                           VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16",
                           VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16",
                           VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16",
                           VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16",
                           VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G16B16G16R16_422_UNORM", VK_FORMAT_G16B16G16R16_422_UNORM),
            std::make_pair("VK_FORMAT_B16G16R16G16_422_UNORM", VK_FORMAT_B16G16R16G16_422_UNORM),
            std::make_pair("VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM", VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM),
            std::make_pair("VK_FORMAT_G16_B16R16_2PLANE_420_UNORM", VK_FORMAT_G16_B16R16_2PLANE_420_UNORM),
            std::make_pair("VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM", VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM),
            std::make_pair("VK_FORMAT_G16_B16R16_2PLANE_422_UNORM", VK_FORMAT_G16_B16R16_2PLANE_422_UNORM),
            std::make_pair("VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM", VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM),
            std::make_pair("VK_FORMAT_G8_B8R8_2PLANE_444_UNORM", VK_FORMAT_G8_B8R8_2PLANE_444_UNORM),
            std::make_pair("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16",
                           VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16",
                           VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G16_B16R16_2PLANE_444_UNORM", VK_FORMAT_G16_B16R16_2PLANE_444_UNORM),
            std::make_pair("VK_FORMAT_A4R4G4B4_UNORM_PACK16", VK_FORMAT_A4R4G4B4_UNORM_PACK16),
            std::make_pair("VK_FORMAT_A4B4G4R4_UNORM_PACK16", VK_FORMAT_A4B4G4R4_UNORM_PACK16),
            std::make_pair("VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK", VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK", VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK", VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK", VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK", VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK", VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK", VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK", VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK", VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK", VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK", VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK", VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK", VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK", VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_A1B5G5R5_UNORM_PACK16", VK_FORMAT_A1B5G5R5_UNORM_PACK16),
            std::make_pair("VK_FORMAT_A8_UNORM", VK_FORMAT_A8_UNORM)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkFormat constant: " << v;
            return static_cast<VkFormat>(0);
        }
    }

    VkPrimitiveTopology parse_VkPrimitiveTopology_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPrimitiveTopology> map = {
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_POINT_LIST", VK_PRIMITIVE_TOPOLOGY_POINT_LIST),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_LINE_LIST", VK_PRIMITIVE_TOPOLOGY_LINE_LIST),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_LINE_STRIP", VK_PRIMITIVE_TOPOLOGY_LINE_STRIP),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST", VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP", VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN", VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY", VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY", VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY",
                           VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY",
                           VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_PATCH_LIST", VK_PRIMITIVE_TOPOLOGY_PATCH_LIST)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPrimitiveTopology constant: " << v;
            return static_cast<VkPrimitiveTopology>(0);
        }
    }

    VkTessellationDomainOrigin parse_VkTessellationDomainOrigin_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkTessellationDomainOrigin> map = {
            std::make_pair("VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT", VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT),
            std::make_pair("VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT", VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkTessellationDomainOrigin constant: " << v;
            return static_cast<VkTessellationDomainOrigin>(0);
        }
    }

    VkPolygonMode parse_VkPolygonMode_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPolygonMode> map = {
            std::make_pair("VK_POLYGON_MODE_FILL", VK_POLYGON_MODE_FILL),
            std::make_pair("VK_POLYGON_MODE_LINE", VK_POLYGON_MODE_LINE),
            std::make_pair("VK_POLYGON_MODE_POINT", VK_POLYGON_MODE_POINT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPolygonMode constant: " << v;
            return static_cast<VkPolygonMode>(0);
        }
    }

    VkCullModeFlagBits parse_VkCullModeFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkCullModeFlagBits> map = {
            std::make_pair("0", static_cast<VkCullModeFlagBits>(0)), std::make_pair("VK_CULL_MODE_NONE", VK_CULL_MODE_NONE),
            std::make_pair("VK_CULL_MODE_FRONT_BIT", VK_CULL_MODE_FRONT_BIT),
            std::make_pair("VK_CULL_MODE_BACK_BIT", VK_CULL_MODE_BACK_BIT),
            std::make_pair("VK_CULL_MODE_FRONT_AND_BACK", VK_CULL_MODE_FRONT_AND_BACK)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkCullModeFlagBits bit: " << v;
            return static_cast<VkCullModeFlagBits>(0);
        }
    }

    VkFrontFace parse_VkFrontFace_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkFrontFace> map = {
            std::make_pair("VK_FRONT_FACE_COUNTER_CLOCKWISE", VK_FRONT_FACE_COUNTER_CLOCKWISE),
            std::make_pair("VK_FRONT_FACE_CLOCKWISE", VK_FRONT_FACE_CLOCKWISE)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkFrontFace constant: " << v;
            return static_cast<VkFrontFace>(0);
        }
    }

    VkConservativeRasterizationModeEXT parse_VkConservativeRasterizationModeEXT_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkConservativeRasterizationModeEXT> map = {
            std::make_pair("VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT),
            std::make_pair("VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT",
                           VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT),
            std::make_pair("VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT",
                           VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkConservativeRasterizationModeEXT constant: " << v;
            return static_cast<VkConservativeRasterizationModeEXT>(0);
        }
    }

    VkLineRasterizationMode parse_VkLineRasterizationMode_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkLineRasterizationMode> map = {
            std::make_pair("VK_LINE_RASTERIZATION_MODE_DEFAULT", VK_LINE_RASTERIZATION_MODE_DEFAULT),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_RECTANGULAR", VK_LINE_RASTERIZATION_MODE_RECTANGULAR),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_BRESENHAM", VK_LINE_RASTERIZATION_MODE_BRESENHAM),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH", VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkLineRasterizationMode constant: " << v;
            return static_cast<VkLineRasterizationMode>(0);
        }
    }

    VkSampleCountFlagBits parse_VkSampleCountFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSampleCountFlagBits> map = {
            std::make_pair("0", static_cast<VkSampleCountFlagBits>(0)),
            std::make_pair("VK_SAMPLE_COUNT_1_BIT", VK_SAMPLE_COUNT_1_BIT),
            std::make_pair("VK_SAMPLE_COUNT_2_BIT", VK_SAMPLE_COUNT_2_BIT),
            std::make_pair("VK_SAMPLE_COUNT_4_BIT", VK_SAMPLE_COUNT_4_BIT),
            std::make_pair("VK_SAMPLE_COUNT_8_BIT", VK_SAMPLE_COUNT_8_BIT),
            std::make_pair("VK_SAMPLE_COUNT_16_BIT", VK_SAMPLE_COUNT_16_BIT),
            std::make_pair("VK_SAMPLE_COUNT_32_BIT", VK_SAMPLE_COUNT_32_BIT),
            std::make_pair("VK_SAMPLE_COUNT_64_BIT", VK_SAMPLE_COUNT_64_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSampleCountFlagBits bit: " << v;
            return static_cast<VkSampleCountFlagBits>(0);
        }
    }

    VkCompareOp parse_VkCompareOp_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkCompareOp> map = {
            std::make_pair("VK_COMPARE_OP_NEVER", VK_COMPARE_OP_NEVER),
            std::make_pair("VK_COMPARE_OP_LESS", VK_COMPARE_OP_LESS),
            std::make_pair("VK_COMPARE_OP_EQUAL", VK_COMPARE_OP_EQUAL),
            std::make_pair("VK_COMPARE_OP_LESS_OR_EQUAL", VK_COMPARE_OP_LESS_OR_EQUAL),
            std::make_pair("VK_COMPARE_OP_GREATER", VK_COMPARE_OP_GREATER),
            std::make_pair("VK_COMPARE_OP_NOT_EQUAL", VK_COMPARE_OP_NOT_EQUAL),
            std::make_pair("VK_COMPARE_OP_GREATER_OR_EQUAL", VK_COMPARE_OP_GREATER_OR_EQUAL),
            std::make_pair("VK_COMPARE_OP_ALWAYS", VK_COMPARE_OP_ALWAYS)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkCompareOp constant: " << v;
            return static_cast<VkCompareOp>(0);
        }
    }

    VkStencilOp parse_VkStencilOp_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkStencilOp> map = {
            std::make_pair("VK_STENCIL_OP_KEEP", VK_STENCIL_OP_KEEP),
            std::make_pair("VK_STENCIL_OP_ZERO", VK_STENCIL_OP_ZERO),
            std::make_pair("VK_STENCIL_OP_REPLACE", VK_STENCIL_OP_REPLACE),
            std::make_pair("VK_STENCIL_OP_INCREMENT_AND_CLAMP", VK_STENCIL_OP_INCREMENT_AND_CLAMP),
            std::make_pair("VK_STENCIL_OP_DECREMENT_AND_CLAMP", VK_STENCIL_OP_DECREMENT_AND_CLAMP),
            std::make_pair("VK_STENCIL_OP_INVERT", VK_STENCIL_OP_INVERT),
            std::make_pair("VK_STENCIL_OP_INCREMENT_AND_WRAP", VK_STENCIL_OP_INCREMENT_AND_WRAP),
            std::make_pair("VK_STENCIL_OP_DECREMENT_AND_WRAP", VK_STENCIL_OP_DECREMENT_AND_WRAP)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkStencilOp constant: " << v;
            return static_cast<VkStencilOp>(0);
        }
    }

    VkLogicOp parse_VkLogicOp_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkLogicOp> map = {
            std::make_pair("VK_LOGIC_OP_CLEAR", VK_LOGIC_OP_CLEAR),
            std::make_pair("VK_LOGIC_OP_AND", VK_LOGIC_OP_AND),
            std::make_pair("VK_LOGIC_OP_AND_REVERSE", VK_LOGIC_OP_AND_REVERSE),
            std::make_pair("VK_LOGIC_OP_COPY", VK_LOGIC_OP_COPY),
            std::make_pair("VK_LOGIC_OP_AND_INVERTED", VK_LOGIC_OP_AND_INVERTED),
            std::make_pair("VK_LOGIC_OP_NO_OP", VK_LOGIC_OP_NO_OP),
            std::make_pair("VK_LOGIC_OP_XOR", VK_LOGIC_OP_XOR),
            std::make_pair("VK_LOGIC_OP_OR", VK_LOGIC_OP_OR),
            std::make_pair("VK_LOGIC_OP_NOR", VK_LOGIC_OP_NOR),
            std::make_pair("VK_LOGIC_OP_EQUIVALENT", VK_LOGIC_OP_EQUIVALENT),
            std::make_pair("VK_LOGIC_OP_INVERT", VK_LOGIC_OP_INVERT),
            std::make_pair("VK_LOGIC_OP_OR_REVERSE", VK_LOGIC_OP_OR_REVERSE),
            std::make_pair("VK_LOGIC_OP_COPY_INVERTED", VK_LOGIC_OP_COPY_INVERTED),
            std::make_pair("VK_LOGIC_OP_OR_INVERTED", VK_LOGIC_OP_OR_INVERTED),
            std::make_pair("VK_LOGIC_OP_NAND", VK_LOGIC_OP_NAND),
            std::make_pair("VK_LOGIC_OP_SET", VK_LOGIC_OP_SET)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkLogicOp constant: " << v;
            return static_cast<VkLogicOp>(0);
        }
    }

    VkBlendFactor parse_VkBlendFactor_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkBlendFactor> map = {
            std::make_pair("VK_BLEND_FACTOR_ZERO", VK_BLEND_FACTOR_ZERO),
            std::make_pair("VK_BLEND_FACTOR_ONE", VK_BLEND_FACTOR_ONE),
            std::make_pair("VK_BLEND_FACTOR_SRC_COLOR", VK_BLEND_FACTOR_SRC_COLOR),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR", VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR),
            std::make_pair("VK_BLEND_FACTOR_DST_COLOR", VK_BLEND_FACTOR_DST_COLOR),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR", VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR),
            std::make_pair("VK_BLEND_FACTOR_SRC_ALPHA", VK_BLEND_FACTOR_SRC_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA", VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_DST_ALPHA", VK_BLEND_FACTOR_DST_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA", VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_CONSTANT_COLOR", VK_BLEND_FACTOR_CONSTANT_COLOR),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR", VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR),
            std::make_pair("VK_BLEND_FACTOR_CONSTANT_ALPHA", VK_BLEND_FACTOR_CONSTANT_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA", VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_SRC_ALPHA_SATURATE", VK_BLEND_FACTOR_SRC_ALPHA_SATURATE),
            std::make_pair("VK_BLEND_FACTOR_SRC1_COLOR", VK_BLEND_FACTOR_SRC1_COLOR),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR", VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR),
            std::make_pair("VK_BLEND_FACTOR_SRC1_ALPHA", VK_BLEND_FACTOR_SRC1_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkBlendFactor constant: " << v;
            return static_cast<VkBlendFactor>(0);
        }
    }

    VkBlendOp parse_VkBlendOp_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkBlendOp> map = {
            std::make_pair("VK_BLEND_OP_ADD", VK_BLEND_OP_ADD),
            std::make_pair("VK_BLEND_OP_SUBTRACT", VK_BLEND_OP_SUBTRACT),
            std::make_pair("VK_BLEND_OP_REVERSE_SUBTRACT", VK_BLEND_OP_REVERSE_SUBTRACT),
            std::make_pair("VK_BLEND_OP_MIN", VK_BLEND_OP_MIN),
            std::make_pair("VK_BLEND_OP_MAX", VK_BLEND_OP_MAX),
            std::make_pair("VK_BLEND_OP_ZERO_EXT", VK_BLEND_OP_ZERO_EXT),
            std::make_pair("VK_BLEND_OP_SRC_EXT", VK_BLEND_OP_SRC_EXT),
            std::make_pair("VK_BLEND_OP_DST_EXT", VK_BLEND_OP_DST_EXT),
            std::make_pair("VK_BLEND_OP_SRC_OVER_EXT", VK_BLEND_OP_SRC_OVER_EXT),
            std::make_pair("VK_BLEND_OP_DST_OVER_EXT", VK_BLEND_OP_DST_OVER_EXT),
            std::make_pair("VK_BLEND_OP_SRC_IN_EXT", VK_BLEND_OP_SRC_IN_EXT),
            std::make_pair("VK_BLEND_OP_DST_IN_EXT", VK_BLEND_OP_DST_IN_EXT),
            std::make_pair("VK_BLEND_OP_SRC_OUT_EXT", VK_BLEND_OP_SRC_OUT_EXT),
            std::make_pair("VK_BLEND_OP_DST_OUT_EXT", VK_BLEND_OP_DST_OUT_EXT),
            std::make_pair("VK_BLEND_OP_SRC_ATOP_EXT", VK_BLEND_OP_SRC_ATOP_EXT),
            std::make_pair("VK_BLEND_OP_DST_ATOP_EXT", VK_BLEND_OP_DST_ATOP_EXT),
            std::make_pair("VK_BLEND_OP_XOR_EXT", VK_BLEND_OP_XOR_EXT),
            std::make_pair("VK_BLEND_OP_MULTIPLY_EXT", VK_BLEND_OP_MULTIPLY_EXT),
            std::make_pair("VK_BLEND_OP_SCREEN_EXT", VK_BLEND_OP_SCREEN_EXT),
            std::make_pair("VK_BLEND_OP_OVERLAY_EXT", VK_BLEND_OP_OVERLAY_EXT),
            std::make_pair("VK_BLEND_OP_DARKEN_EXT", VK_BLEND_OP_DARKEN_EXT),
            std::make_pair("VK_BLEND_OP_LIGHTEN_EXT", VK_BLEND_OP_LIGHTEN_EXT),
            std::make_pair("VK_BLEND_OP_COLORDODGE_EXT", VK_BLEND_OP_COLORDODGE_EXT),
            std::make_pair("VK_BLEND_OP_COLORBURN_EXT", VK_BLEND_OP_COLORBURN_EXT),
            std::make_pair("VK_BLEND_OP_HARDLIGHT_EXT", VK_BLEND_OP_HARDLIGHT_EXT),
            std::make_pair("VK_BLEND_OP_SOFTLIGHT_EXT", VK_BLEND_OP_SOFTLIGHT_EXT),
            std::make_pair("VK_BLEND_OP_DIFFERENCE_EXT", VK_BLEND_OP_DIFFERENCE_EXT),
            std::make_pair("VK_BLEND_OP_EXCLUSION_EXT", VK_BLEND_OP_EXCLUSION_EXT),
            std::make_pair("VK_BLEND_OP_INVERT_EXT", VK_BLEND_OP_INVERT_EXT),
            std::make_pair("VK_BLEND_OP_INVERT_RGB_EXT", VK_BLEND_OP_INVERT_RGB_EXT),
            std::make_pair("VK_BLEND_OP_LINEARDODGE_EXT", VK_BLEND_OP_LINEARDODGE_EXT),
            std::make_pair("VK_BLEND_OP_LINEARBURN_EXT", VK_BLEND_OP_LINEARBURN_EXT),
            std::make_pair("VK_BLEND_OP_VIVIDLIGHT_EXT", VK_BLEND_OP_VIVIDLIGHT_EXT),
            std::make_pair("VK_BLEND_OP_LINEARLIGHT_EXT", VK_BLEND_OP_LINEARLIGHT_EXT),
            std::make_pair("VK_BLEND_OP_PINLIGHT_EXT", VK_BLEND_OP_PINLIGHT_EXT),
            std::make_pair("VK_BLEND_OP_HARDMIX_EXT", VK_BLEND_OP_HARDMIX_EXT),
            std::make_pair("VK_BLEND_OP_HSL_HUE_EXT", VK_BLEND_OP_HSL_HUE_EXT),
            std::make_pair("VK_BLEND_OP_HSL_SATURATION_EXT", VK_BLEND_OP_HSL_SATURATION_EXT),
            std::make_pair("VK_BLEND_OP_HSL_COLOR_EXT", VK_BLEND_OP_HSL_COLOR_EXT),
            std::make_pair("VK_BLEND_OP_HSL_LUMINOSITY_EXT", VK_BLEND_OP_HSL_LUMINOSITY_EXT),
            std::make_pair("VK_BLEND_OP_PLUS_EXT", VK_BLEND_OP_PLUS_EXT),
            std::make_pair("VK_BLEND_OP_PLUS_CLAMPED_EXT", VK_BLEND_OP_PLUS_CLAMPED_EXT),
            std::make_pair("VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT", VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT),
            std::make_pair("VK_BLEND_OP_PLUS_DARKER_EXT", VK_BLEND_OP_PLUS_DARKER_EXT),
            std::make_pair("VK_BLEND_OP_MINUS_EXT", VK_BLEND_OP_MINUS_EXT),
            std::make_pair("VK_BLEND_OP_MINUS_CLAMPED_EXT", VK_BLEND_OP_MINUS_CLAMPED_EXT),
            std::make_pair("VK_BLEND_OP_CONTRAST_EXT", VK_BLEND_OP_CONTRAST_EXT),
            std::make_pair("VK_BLEND_OP_INVERT_OVG_EXT", VK_BLEND_OP_INVERT_OVG_EXT),
            std::make_pair("VK_BLEND_OP_RED_EXT", VK_BLEND_OP_RED_EXT),
            std::make_pair("VK_BLEND_OP_GREEN_EXT", VK_BLEND_OP_GREEN_EXT),
            std::make_pair("VK_BLEND_OP_BLUE_EXT", VK_BLEND_OP_BLUE_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkBlendOp constant: " << v;
            return static_cast<VkBlendOp>(0);
        }
    }

    VkColorComponentFlagBits parse_VkColorComponentFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkColorComponentFlagBits> map = {
            std::make_pair("0", static_cast<VkColorComponentFlagBits>(0)),
            std::make_pair("VK_COLOR_COMPONENT_R_BIT", VK_COLOR_COMPONENT_R_BIT),
            std::make_pair("VK_COLOR_COMPONENT_G_BIT", VK_COLOR_COMPONENT_G_BIT),
            std::make_pair("VK_COLOR_COMPONENT_B_BIT", VK_COLOR_COMPONENT_B_BIT),
            std::make_pair("VK_COLOR_COMPONENT_A_BIT", VK_COLOR_COMPONENT_A_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkColorComponentFlagBits bit: " << v;
            return static_cast<VkColorComponentFlagBits>(0);
        }
    }

    VkBlendOverlapEXT parse_VkBlendOverlapEXT_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkBlendOverlapEXT> map = {
            std::make_pair("VK_BLEND_OVERLAP_UNCORRELATED_EXT", VK_BLEND_OVERLAP_UNCORRELATED_EXT),
            std::make_pair("VK_BLEND_OVERLAP_DISJOINT_EXT", VK_BLEND_OVERLAP_DISJOINT_EXT),
            std::make_pair("VK_BLEND_OVERLAP_CONJOINT_EXT", VK_BLEND_OVERLAP_CONJOINT_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkBlendOverlapEXT constant: " << v;
            return static_cast<VkBlendOverlapEXT>(0);
        }
    }

    VkDynamicState parse_VkDynamicState_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkDynamicState> map = {
            std::make_pair("VK_DYNAMIC_STATE_VIEWPORT", VK_DYNAMIC_STATE_VIEWPORT),
            std::make_pair("VK_DYNAMIC_STATE_SCISSOR", VK_DYNAMIC_STATE_SCISSOR),
            std::make_pair("VK_DYNAMIC_STATE_LINE_WIDTH", VK_DYNAMIC_STATE_LINE_WIDTH),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_BIAS", VK_DYNAMIC_STATE_DEPTH_BIAS),
            std::make_pair("VK_DYNAMIC_STATE_BLEND_CONSTANTS", VK_DYNAMIC_STATE_BLEND_CONSTANTS),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_BOUNDS", VK_DYNAMIC_STATE_DEPTH_BOUNDS),
            std::make_pair("VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK", VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK),
            std::make_pair("VK_DYNAMIC_STATE_STENCIL_WRITE_MASK", VK_DYNAMIC_STATE_STENCIL_WRITE_MASK),
            std::make_pair("VK_DYNAMIC_STATE_STENCIL_REFERENCE", VK_DYNAMIC_STATE_STENCIL_REFERENCE),
            std::make_pair("VK_DYNAMIC_STATE_CULL_MODE", VK_DYNAMIC_STATE_CULL_MODE),
            std::make_pair("VK_DYNAMIC_STATE_FRONT_FACE", VK_DYNAMIC_STATE_FRONT_FACE),
            std::make_pair("VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY", VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY),
            std::make_pair("VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT", VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT),
            std::make_pair("VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT", VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT),
            std::make_pair("VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE", VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE", VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE", VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_COMPARE_OP", VK_DYNAMIC_STATE_DEPTH_COMPARE_OP),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE", VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE", VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_STENCIL_OP", VK_DYNAMIC_STATE_STENCIL_OP),
            std::make_pair("VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE", VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE", VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE", VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_LINE_STIPPLE", VK_DYNAMIC_STATE_LINE_STIPPLE),
            std::make_pair("VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT", VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT", VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT", VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT", VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT),
            std::make_pair("VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR", VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR),
            std::make_pair("VK_DYNAMIC_STATE_VERTEX_INPUT_EXT", VK_DYNAMIC_STATE_VERTEX_INPUT_EXT),
            std::make_pair("VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT", VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT),
            std::make_pair("VK_DYNAMIC_STATE_LOGIC_OP_EXT", VK_DYNAMIC_STATE_LOGIC_OP_EXT),
            std::make_pair("VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT", VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkDynamicState constant: " << v;
            return static_cast<VkDynamicState>(0);
        }
    }

    VkPipelineCreateFlagBits2 parse_VkPipelineCreateFlagBits2_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineCreateFlagBits2> map = {
            std::make_pair("0", static_cast<VkPipelineCreateFlagBits2>(0)),
            std::make_pair("VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT", VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT", VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_DERIVATIVE_BIT", VK_PIPELINE_CREATE_2_DERIVATIVE_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT",
                           VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT", VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT",
                           VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT", VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT", VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT", VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineCreateFlagBits2 bit: " << v;
            return static_cast<VkPipelineCreateFlagBits2>(0);
        }
    }

    VkPipelineCreationFeedbackFlagBits parse_VkPipelineCreationFeedbackFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineCreationFeedbackFlagBits> map = {
            std::make_pair("0", static_cast<VkPipelineCreationFeedbackFlagBits>(0)),
            std::make_pair("VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT", VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT),
            std::make_pair("VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT",
                           VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT),
            std::make_pair("VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT",
                           VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineCreationFeedbackFlagBits bit: " << v;
            return static_cast<VkPipelineCreationFeedbackFlagBits>(0);
        }
    }

    VkDiscardRectangleModeEXT parse_VkDiscardRectangleModeEXT_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkDiscardRectangleModeEXT> map = {
            std::make_pair("VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT", VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT),
            std::make_pair("VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT", VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkDiscardRectangleModeEXT constant: " << v;
            return static_cast<VkDiscardRectangleModeEXT>(0);
        }
    }

    VkFragmentShadingRateCombinerOpKHR parse_VkFragmentShadingRateCombinerOpKHR_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkFragmentShadingRateCombinerOpKHR> map = {
            std::make_pair("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR", VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR),
            std::make_pair("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR", VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR),
            std::make_pair("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR", VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR),
            std::make_pair("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR", VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR),
            std::make_pair("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR", VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkFragmentShadingRateCombinerOpKHR constant: " << v;
            return static_cast<VkFragmentShadingRateCombinerOpKHR>(0);
        }
    }

    VkPipelineMatchControl parse_VkPipelineMatchControl_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineMatchControl> map = {std::make_pair(
            "VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH", VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineMatchControl constant: " << v;
            return static_cast<VkPipelineMatchControl>(0);
        }
    }

    VkSamplerYcbcrModelConversion parse_VkSamplerYcbcrModelConversion_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSamplerYcbcrModelConversion> map = {
            std::make_pair("VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY", VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY),
            std::make_pair("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY", VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY),
            std::make_pair("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709", VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709),
            std::make_pair("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601", VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601),
            std::make_pair("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020", VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSamplerYcbcrModelConversion constant: " << v;
            return static_cast<VkSamplerYcbcrModelConversion>(0);
        }
    }

    VkSamplerYcbcrRange parse_VkSamplerYcbcrRange_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSamplerYcbcrRange> map = {
            std::make_pair("VK_SAMPLER_YCBCR_RANGE_ITU_FULL", VK_SAMPLER_YCBCR_RANGE_ITU_FULL),
            std::make_pair("VK_SAMPLER_YCBCR_RANGE_ITU_NARROW", VK_SAMPLER_YCBCR_RANGE_ITU_NARROW)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSamplerYcbcrRange constant: " << v;
            return static_cast<VkSamplerYcbcrRange>(0);
        }
    }

    VkComponentSwizzle parse_VkComponentSwizzle_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkComponentSwizzle> map = {
            std::make_pair("VK_COMPONENT_SWIZZLE_IDENTITY", VK_COMPONENT_SWIZZLE_IDENTITY),
            std::make_pair("VK_COMPONENT_SWIZZLE_ZERO", VK_COMPONENT_SWIZZLE_ZERO),
            std::make_pair("VK_COMPONENT_SWIZZLE_ONE", VK_COMPONENT_SWIZZLE_ONE),
            std::make_pair("VK_COMPONENT_SWIZZLE_R", VK_COMPONENT_SWIZZLE_R),
            std::make_pair("VK_COMPONENT_SWIZZLE_G", VK_COMPONENT_SWIZZLE_G),
            std::make_pair("VK_COMPONENT_SWIZZLE_B", VK_COMPONENT_SWIZZLE_B),
            std::make_pair("VK_COMPONENT_SWIZZLE_A", VK_COMPONENT_SWIZZLE_A)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkComponentSwizzle constant: " << v;
            return static_cast<VkComponentSwizzle>(0);
        }
    }

    VkChromaLocation parse_VkChromaLocation_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkChromaLocation> map = {
            std::make_pair("VK_CHROMA_LOCATION_COSITED_EVEN", VK_CHROMA_LOCATION_COSITED_EVEN),
            std::make_pair("VK_CHROMA_LOCATION_MIDPOINT", VK_CHROMA_LOCATION_MIDPOINT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkChromaLocation constant: " << v;
            return static_cast<VkChromaLocation>(0);
        }
    }

    VkFilter parse_VkFilter_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkFilter> map = {std::make_pair("VK_FILTER_NEAREST", VK_FILTER_NEAREST),
                                                                     std::make_pair("VK_FILTER_LINEAR", VK_FILTER_LINEAR),
                                                                     std::make_pair("VK_FILTER_CUBIC_EXT", VK_FILTER_CUBIC_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkFilter constant: " << v;
            return static_cast<VkFilter>(0);
        }
    }

    VkSamplerCreateFlagBits parse_VkSamplerCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSamplerCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkSamplerCreateFlagBits>(0)),

        };
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSamplerCreateFlagBits bit: " << v;
            return static_cast<VkSamplerCreateFlagBits>(0);
        }
    }

    VkSamplerMipmapMode parse_VkSamplerMipmapMode_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSamplerMipmapMode> map = {
            std::make_pair("VK_SAMPLER_MIPMAP_MODE_NEAREST", VK_SAMPLER_MIPMAP_MODE_NEAREST),
            std::make_pair("VK_SAMPLER_MIPMAP_MODE_LINEAR", VK_SAMPLER_MIPMAP_MODE_LINEAR)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSamplerMipmapMode constant: " << v;
            return static_cast<VkSamplerMipmapMode>(0);
        }
    }

    VkSamplerAddressMode parse_VkSamplerAddressMode_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSamplerAddressMode> map = {
            std::make_pair("VK_SAMPLER_ADDRESS_MODE_REPEAT", VK_SAMPLER_ADDRESS_MODE_REPEAT),
            std::make_pair("VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT", VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT),
            std::make_pair("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE),
            std::make_pair("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER", VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER),
            std::make_pair("VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE", VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSamplerAddressMode constant: " << v;
            return static_cast<VkSamplerAddressMode>(0);
        }
    }

    VkBorderColor parse_VkBorderColor_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkBorderColor> map = {
            std::make_pair("VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK", VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK),
            std::make_pair("VK_BORDER_COLOR_INT_TRANSPARENT_BLACK", VK_BORDER_COLOR_INT_TRANSPARENT_BLACK),
            std::make_pair("VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK", VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK),
            std::make_pair("VK_BORDER_COLOR_INT_OPAQUE_BLACK", VK_BORDER_COLOR_INT_OPAQUE_BLACK),
            std::make_pair("VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE", VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE),
            std::make_pair("VK_BORDER_COLOR_INT_OPAQUE_WHITE", VK_BORDER_COLOR_INT_OPAQUE_WHITE),
            std::make_pair("VK_BORDER_COLOR_FLOAT_CUSTOM_EXT", VK_BORDER_COLOR_FLOAT_CUSTOM_EXT),
            std::make_pair("VK_BORDER_COLOR_INT_CUSTOM_EXT", VK_BORDER_COLOR_INT_CUSTOM_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkBorderColor constant: " << v;
            return static_cast<VkBorderColor>(0);
        }
    }

    VkSamplerReductionMode parse_VkSamplerReductionMode_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSamplerReductionMode> map = {
            std::make_pair("VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE", VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE),
            std::make_pair("VK_SAMPLER_REDUCTION_MODE_MIN", VK_SAMPLER_REDUCTION_MODE_MIN),
            std::make_pair("VK_SAMPLER_REDUCTION_MODE_MAX", VK_SAMPLER_REDUCTION_MODE_MAX)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSamplerReductionMode constant: " << v;
            return static_cast<VkSamplerReductionMode>(0);
        }
    }

    VkDescriptorSetLayoutCreateFlagBits parse_VkDescriptorSetLayoutCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkDescriptorSetLayoutCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkDescriptorSetLayoutCreateFlagBits>(0)),
            std::make_pair("VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT",
                           VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT),
            std::make_pair("VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT",
                           VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkDescriptorSetLayoutCreateFlagBits bit: " << v;
            return static_cast<VkDescriptorSetLayoutCreateFlagBits>(0);
        }
    }

    VkDescriptorType parse_VkDescriptorType_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkDescriptorType> map = {
            std::make_pair("VK_DESCRIPTOR_TYPE_SAMPLER", VK_DESCRIPTOR_TYPE_SAMPLER),
            std::make_pair("VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER", VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER),
            std::make_pair("VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE", VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE),
            std::make_pair("VK_DESCRIPTOR_TYPE_STORAGE_IMAGE", VK_DESCRIPTOR_TYPE_STORAGE_IMAGE),
            std::make_pair("VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER", VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER),
            std::make_pair("VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER", VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER),
            std::make_pair("VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER", VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER),
            std::make_pair("VK_DESCRIPTOR_TYPE_STORAGE_BUFFER", VK_DESCRIPTOR_TYPE_STORAGE_BUFFER),
            std::make_pair("VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC", VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC),
            std::make_pair("VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC", VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC),
            std::make_pair("VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT", VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT),
            std::make_pair("VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK", VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkDescriptorType constant: " << v;
            return static_cast<VkDescriptorType>(0);
        }
    }

    VkDescriptorBindingFlagBits parse_VkDescriptorBindingFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkDescriptorBindingFlagBits> map = {
            std::make_pair("0", static_cast<VkDescriptorBindingFlagBits>(0)),
            std::make_pair("VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT", VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT),
            std::make_pair("VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT",
                           VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT),
            std::make_pair("VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT", VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT),
            std::make_pair("VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT",
                           VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkDescriptorBindingFlagBits bit: " << v;
            return static_cast<VkDescriptorBindingFlagBits>(0);
        }
    }

    VkPipelineLayoutCreateFlagBits parse_VkPipelineLayoutCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineLayoutCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkPipelineLayoutCreateFlagBits>(0)),

        };
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineLayoutCreateFlagBits bit: " << v;
            return static_cast<VkPipelineLayoutCreateFlagBits>(0);
        }
    }

    VkRenderPassCreateFlagBits parse_VkRenderPassCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkRenderPassCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkRenderPassCreateFlagBits>(0)),

        };
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkRenderPassCreateFlagBits bit: " << v;
            return static_cast<VkRenderPassCreateFlagBits>(0);
        }
    }

    VkAttachmentDescriptionFlagBits parse_VkAttachmentDescriptionFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkAttachmentDescriptionFlagBits> map = {
            std::make_pair("0", static_cast<VkAttachmentDescriptionFlagBits>(0)),
            std::make_pair("VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT", VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkAttachmentDescriptionFlagBits bit: " << v;
            return static_cast<VkAttachmentDescriptionFlagBits>(0);
        }
    }

    VkAttachmentLoadOp parse_VkAttachmentLoadOp_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkAttachmentLoadOp> map = {
            std::make_pair("VK_ATTACHMENT_LOAD_OP_LOAD", VK_ATTACHMENT_LOAD_OP_LOAD),
            std::make_pair("VK_ATTACHMENT_LOAD_OP_CLEAR", VK_ATTACHMENT_LOAD_OP_CLEAR),
            std::make_pair("VK_ATTACHMENT_LOAD_OP_DONT_CARE", VK_ATTACHMENT_LOAD_OP_DONT_CARE),
            std::make_pair("VK_ATTACHMENT_LOAD_OP_NONE", VK_ATTACHMENT_LOAD_OP_NONE)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkAttachmentLoadOp constant: " << v;
            return static_cast<VkAttachmentLoadOp>(0);
        }
    }

    VkAttachmentStoreOp parse_VkAttachmentStoreOp_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkAttachmentStoreOp> map = {
            std::make_pair("VK_ATTACHMENT_STORE_OP_STORE", VK_ATTACHMENT_STORE_OP_STORE),
            std::make_pair("VK_ATTACHMENT_STORE_OP_DONT_CARE", VK_ATTACHMENT_STORE_OP_DONT_CARE),
            std::make_pair("VK_ATTACHMENT_STORE_OP_NONE", VK_ATTACHMENT_STORE_OP_NONE)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkAttachmentStoreOp constant: " << v;
            return static_cast<VkAttachmentStoreOp>(0);
        }
    }

    VkImageLayout parse_VkImageLayout_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkImageLayout> map = {
            std::make_pair("VK_IMAGE_LAYOUT_UNDEFINED", VK_IMAGE_LAYOUT_UNDEFINED),
            std::make_pair("VK_IMAGE_LAYOUT_GENERAL", VK_IMAGE_LAYOUT_GENERAL),
            std::make_pair("VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL", VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL", VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL", VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL", VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_PREINITIALIZED", VK_IMAGE_LAYOUT_PREINITIALIZED),
            std::make_pair("VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL",
                           VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL",
                           VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL", VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL", VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL", VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL", VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL", VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ", VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ),
            std::make_pair("VK_IMAGE_LAYOUT_PRESENT_SRC_KHR", VK_IMAGE_LAYOUT_PRESENT_SRC_KHR),
            std::make_pair("VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR", VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR),
            std::make_pair("VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR",
                           VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkImageLayout constant: " << v;
            return static_cast<VkImageLayout>(0);
        }
    }

    VkSubpassDescriptionFlagBits parse_VkSubpassDescriptionFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSubpassDescriptionFlagBits> map = {
            std::make_pair("0", static_cast<VkSubpassDescriptionFlagBits>(0)),

        };
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSubpassDescriptionFlagBits bit: " << v;
            return static_cast<VkSubpassDescriptionFlagBits>(0);
        }
    }

    VkPipelineBindPoint parse_VkPipelineBindPoint_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineBindPoint> map = {
            std::make_pair("VK_PIPELINE_BIND_POINT_GRAPHICS", VK_PIPELINE_BIND_POINT_GRAPHICS),
            std::make_pair("VK_PIPELINE_BIND_POINT_COMPUTE", VK_PIPELINE_BIND_POINT_COMPUTE)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineBindPoint constant: " << v;
            return static_cast<VkPipelineBindPoint>(0);
        }
    }

    VkPipelineStageFlagBits parse_VkPipelineStageFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineStageFlagBits> map = {
            std::make_pair("0", static_cast<VkPipelineStageFlagBits>(0)),
            std::make_pair("VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT", VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT),
            std::make_pair("VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT", VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_VERTEX_INPUT_BIT", VK_PIPELINE_STAGE_VERTEX_INPUT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_VERTEX_SHADER_BIT", VK_PIPELINE_STAGE_VERTEX_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT", VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT",
                           VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT", VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT", VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT", VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT", VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT", VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_TRANSFER_BIT", VK_PIPELINE_STAGE_TRANSFER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT", VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT),
            std::make_pair("VK_PIPELINE_STAGE_HOST_BIT", VK_PIPELINE_STAGE_HOST_BIT),
            std::make_pair("VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT", VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_ALL_COMMANDS_BIT", VK_PIPELINE_STAGE_ALL_COMMANDS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_NONE", VK_PIPELINE_STAGE_NONE),
            std::make_pair("VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR",
                           VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineStageFlagBits bit: " << v;
            return static_cast<VkPipelineStageFlagBits>(0);
        }
    }

    VkAccessFlagBits parse_VkAccessFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkAccessFlagBits> map = {
            std::make_pair("0", static_cast<VkAccessFlagBits>(0)),
            std::make_pair("VK_ACCESS_INDIRECT_COMMAND_READ_BIT", VK_ACCESS_INDIRECT_COMMAND_READ_BIT),
            std::make_pair("VK_ACCESS_INDEX_READ_BIT", VK_ACCESS_INDEX_READ_BIT),
            std::make_pair("VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT", VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT),
            std::make_pair("VK_ACCESS_UNIFORM_READ_BIT", VK_ACCESS_UNIFORM_READ_BIT),
            std::make_pair("VK_ACCESS_INPUT_ATTACHMENT_READ_BIT", VK_ACCESS_INPUT_ATTACHMENT_READ_BIT),
            std::make_pair("VK_ACCESS_SHADER_READ_BIT", VK_ACCESS_SHADER_READ_BIT),
            std::make_pair("VK_ACCESS_SHADER_WRITE_BIT", VK_ACCESS_SHADER_WRITE_BIT),
            std::make_pair("VK_ACCESS_COLOR_ATTACHMENT_READ_BIT", VK_ACCESS_COLOR_ATTACHMENT_READ_BIT),
            std::make_pair("VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT", VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT),
            std::make_pair("VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT", VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT),
            std::make_pair("VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT", VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT),
            std::make_pair("VK_ACCESS_TRANSFER_READ_BIT", VK_ACCESS_TRANSFER_READ_BIT),
            std::make_pair("VK_ACCESS_TRANSFER_WRITE_BIT", VK_ACCESS_TRANSFER_WRITE_BIT),
            std::make_pair("VK_ACCESS_HOST_READ_BIT", VK_ACCESS_HOST_READ_BIT),
            std::make_pair("VK_ACCESS_HOST_WRITE_BIT", VK_ACCESS_HOST_WRITE_BIT),
            std::make_pair("VK_ACCESS_MEMORY_READ_BIT", VK_ACCESS_MEMORY_READ_BIT),
            std::make_pair("VK_ACCESS_MEMORY_WRITE_BIT", VK_ACCESS_MEMORY_WRITE_BIT),
            std::make_pair("VK_ACCESS_NONE", VK_ACCESS_NONE),
            std::make_pair("VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT",
                           VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT),
            std::make_pair("VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR",
                           VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkAccessFlagBits bit: " << v;
            return static_cast<VkAccessFlagBits>(0);
        }
    }

    VkDependencyFlagBits parse_VkDependencyFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkDependencyFlagBits> map = {
            std::make_pair("0", static_cast<VkDependencyFlagBits>(0)),
            std::make_pair("VK_DEPENDENCY_BY_REGION_BIT", VK_DEPENDENCY_BY_REGION_BIT),
            std::make_pair("VK_DEPENDENCY_DEVICE_GROUP_BIT", VK_DEPENDENCY_DEVICE_GROUP_BIT),
            std::make_pair("VK_DEPENDENCY_VIEW_LOCAL_BIT", VK_DEPENDENCY_VIEW_LOCAL_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkDependencyFlagBits bit: " << v;
            return static_cast<VkDependencyFlagBits>(0);
        }
    }

    VkImageAspectFlagBits parse_VkImageAspectFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkImageAspectFlagBits> map = {
            std::make_pair("0", static_cast<VkImageAspectFlagBits>(0)),
            std::make_pair("VK_IMAGE_ASPECT_COLOR_BIT", VK_IMAGE_ASPECT_COLOR_BIT),
            std::make_pair("VK_IMAGE_ASPECT_DEPTH_BIT", VK_IMAGE_ASPECT_DEPTH_BIT),
            std::make_pair("VK_IMAGE_ASPECT_STENCIL_BIT", VK_IMAGE_ASPECT_STENCIL_BIT),
            std::make_pair("VK_IMAGE_ASPECT_METADATA_BIT", VK_IMAGE_ASPECT_METADATA_BIT),
            std::make_pair("VK_IMAGE_ASPECT_PLANE_0_BIT", VK_IMAGE_ASPECT_PLANE_0_BIT),
            std::make_pair("VK_IMAGE_ASPECT_PLANE_1_BIT", VK_IMAGE_ASPECT_PLANE_1_BIT),
            std::make_pair("VK_IMAGE_ASPECT_PLANE_2_BIT", VK_IMAGE_ASPECT_PLANE_2_BIT),
            std::make_pair("VK_IMAGE_ASPECT_NONE", VK_IMAGE_ASPECT_NONE),
            std::make_pair("VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT", VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT),
            std::make_pair("VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT", VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT),
            std::make_pair("VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT", VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT),
            std::make_pair("VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT", VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkImageAspectFlagBits bit: " << v;
            return static_cast<VkImageAspectFlagBits>(0);
        }
    }

    VkResolveModeFlagBits parse_VkResolveModeFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkResolveModeFlagBits> map = {
            std::make_pair("0", static_cast<VkResolveModeFlagBits>(0)),
            std::make_pair("VK_RESOLVE_MODE_NONE", VK_RESOLVE_MODE_NONE),
            std::make_pair("VK_RESOLVE_MODE_SAMPLE_ZERO_BIT", VK_RESOLVE_MODE_SAMPLE_ZERO_BIT),
            std::make_pair("VK_RESOLVE_MODE_AVERAGE_BIT", VK_RESOLVE_MODE_AVERAGE_BIT),
            std::make_pair("VK_RESOLVE_MODE_MIN_BIT", VK_RESOLVE_MODE_MIN_BIT),
            std::make_pair("VK_RESOLVE_MODE_MAX_BIT", VK_RESOLVE_MODE_MAX_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkResolveModeFlagBits bit: " << v;
            return static_cast<VkResolveModeFlagBits>(0);
        }
    }

    VkPipelineStageFlagBits2 parse_VkPipelineStageFlagBits2_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineStageFlagBits2> map = {
            std::make_pair("0", static_cast<VkPipelineStageFlagBits2>(0)),
            std::make_pair("VK_PIPELINE_STAGE_2_NONE", VK_PIPELINE_STAGE_2_NONE),
            std::make_pair("VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT", VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT", VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT", VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT", VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT",
                           VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT",
                           VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT", VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT", VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT", VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT", VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT", VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT", VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT", VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT", VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_HOST_BIT", VK_PIPELINE_STAGE_2_HOST_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT", VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_COPY_BIT", VK_PIPELINE_STAGE_2_COPY_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_RESOLVE_BIT", VK_PIPELINE_STAGE_2_RESOLVE_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_BLIT_BIT", VK_PIPELINE_STAGE_2_BLIT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_CLEAR_BIT", VK_PIPELINE_STAGE_2_CLEAR_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT", VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT", VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT", VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT", VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT),
            std::make_pair("VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT", VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT),
            std::make_pair("VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT", VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT),
            std::make_pair("VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR",
                           VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR",
                           VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT",
                           VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT),
            std::make_pair("VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT", VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT),
            std::make_pair("VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT", VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineStageFlagBits2 bit: " << v;
            return static_cast<VkPipelineStageFlagBits2>(0);
        }
    }

    VkAccessFlagBits2 parse_VkAccessFlagBits2_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkAccessFlagBits2> map = {
            std::make_pair("0", static_cast<VkAccessFlagBits2>(0)),
            std::make_pair("VK_ACCESS_2_NONE", VK_ACCESS_2_NONE),
            std::make_pair("VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT", VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT),
            std::make_pair("VK_ACCESS_2_INDEX_READ_BIT", VK_ACCESS_2_INDEX_READ_BIT),
            std::make_pair("VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT", VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT),
            std::make_pair("VK_ACCESS_2_UNIFORM_READ_BIT", VK_ACCESS_2_UNIFORM_READ_BIT),
            std::make_pair("VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT", VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT),
            std::make_pair("VK_ACCESS_2_SHADER_READ_BIT", VK_ACCESS_2_SHADER_READ_BIT),
            std::make_pair("VK_ACCESS_2_SHADER_WRITE_BIT", VK_ACCESS_2_SHADER_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT", VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT),
            std::make_pair("VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT", VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT", VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT),
            std::make_pair("VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT", VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_TRANSFER_READ_BIT", VK_ACCESS_2_TRANSFER_READ_BIT),
            std::make_pair("VK_ACCESS_2_TRANSFER_WRITE_BIT", VK_ACCESS_2_TRANSFER_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_HOST_READ_BIT", VK_ACCESS_2_HOST_READ_BIT),
            std::make_pair("VK_ACCESS_2_HOST_WRITE_BIT", VK_ACCESS_2_HOST_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_MEMORY_READ_BIT", VK_ACCESS_2_MEMORY_READ_BIT),
            std::make_pair("VK_ACCESS_2_MEMORY_WRITE_BIT", VK_ACCESS_2_MEMORY_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_SHADER_SAMPLED_READ_BIT", VK_ACCESS_2_SHADER_SAMPLED_READ_BIT),
            std::make_pair("VK_ACCESS_2_SHADER_STORAGE_READ_BIT", VK_ACCESS_2_SHADER_STORAGE_READ_BIT),
            std::make_pair("VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT", VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT", VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT),
            std::make_pair("VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT",
                           VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT),
            std::make_pair("VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT",
                           VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT),
            std::make_pair("VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT", VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT),
            std::make_pair("VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT", VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT),
            std::make_pair("VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT", VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT),
            std::make_pair("VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR",
                           VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR", VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR", VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR),
            std::make_pair("VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT", VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT),
            std::make_pair("VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT",
                           VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkAccessFlagBits2 bit: " << v;
            return static_cast<VkAccessFlagBits2>(0);
        }
    }

    VkPipelineCacheCreateFlagBits parse_VkPipelineCacheCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineCacheCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkPipelineCacheCreateFlagBits>(0)),
            std::make_pair("VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT",
                           VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT),
            std::make_pair("VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT", VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT),
            std::make_pair("VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT",
                           VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineCacheCreateFlagBits bit: " << v;
            return static_cast<VkPipelineCacheCreateFlagBits>(0);
        }
    }

  protected:
    int8_t parse_int8_t(const Json::Value& v, const LocationScope&) {
        if (v.isInt() && v.asInt() >= INT8_MIN && v.asInt() <= INT8_MAX) {
            return v.asInt();
        } else {
            Error() << "Not an 8-bit signed integer";
            return 0;
        }
    }

    int16_t parse_int16_t(const Json::Value& v, const LocationScope&) {
        if (v.isInt() && v.asInt() >= INT16_MIN && v.asInt() <= INT16_MAX) {
            return v.asInt();
        } else {
            Error() << "Not a 16-bit signed integer";
            return 0;
        }
    }

    int32_t parse_int32_t(const Json::Value& v, const LocationScope&) {
        if (v.isInt() && v.asInt() >= INT32_MIN && v.asInt() <= INT32_MAX) {
            return v.asInt();
        } else {
            Error() << "Not a 32-bit signed integer";
            return 0;
        }
    }

    int64_t parse_int64_t(const Json::Value& v, const LocationScope&) {
        if (v.isInt64()) {
            return v.asInt64();
        } else {
            Error() << "Not a 64-bit signed integer";
            return 0;
        }
    }

    uint8_t parse_uint8_t(const Json::Value& v, const LocationScope&) {
        if (v.isUInt() && v.asUInt() <= UINT8_MAX) {
            return v.asUInt();
        } else {
            Error() << "Not an 8-bit unsigned integer";
            return 0;
        }
    }

    uint16_t parse_uint16_t(const Json::Value& v, const LocationScope&) {
        if (v.isUInt() && v.asUInt() <= UINT16_MAX) {
            return v.asUInt();
        } else {
            Error() << "Not a 16-bit unsigned integer";
            return 0;
        }
    }

    uint32_t parse_uint32_t(const Json::Value& v, const LocationScope&) {
        if (v.isUInt() && v.asUInt() <= UINT32_MAX) {
            return v.asUInt();
        } else {
            Error() << "Not a 32-bit unsigned integer";
            return 0;
        }
    }

    uint64_t parse_uint64_t(const Json::Value& v, const LocationScope&) {
        if (v.isUInt64()) {
            return v.asUInt64();
        } else {
            Error() << "Not a 64-bit unsigned integer";
            return 0;
        }
    }

    float parse_float(const Json::Value& v, const LocationScope& l) {
        if (v.isDouble()) {
            return v.asFloat();
        } else {
            Error() << "Not a 32-bit floating-point value";
            return 0;
        }
    }

    size_t parse_size_t(const Json::Value& v, const LocationScope& l) { return parse_uint64_t(v, l); }

    VkDeviceSize parse_VkDeviceSize(const Json::Value& v, const LocationScope& l) { return parse_uint64_t(v, l); }

    const char* parse_string(const Json::Value& v, const LocationScope&) {
        if (v.isString()) {
            const char *first, *last;
            v.getString(&first, &last);
            auto str_size = std::distance(first, last);
            auto dst = AllocMem<char>(str_size + 1);  // null-terminator
            std::copy(first, last, dst);
            dst[str_size] = '\0';
            return dst;
        } else {
            Error() << "Not a string";
            return nullptr;
        }
    }

    void* parse_binary(const Json::Value& json, const LocationScope& l) {
        if (!json.isString()) {
            Error() << "Not a base64 encoded binary";
            return nullptr;
        }

        auto src_buffer = json.asString();
        size_t src_idx = 0;
        uint8_t* dst_buffer = AllocMem<uint8_t>(src_buffer.size() * 3);

        for (auto c : src_buffer) {
            uint8_t decoded_bits = 0;
            if ('A' <= c && c <= 'Z') {
                decoded_bits = uint8_t(c - 'A');
            } else if ('a' <= c && c <= 'z') {
                decoded_bits = uint8_t(('Z' - 'A' + 1) + (c - 'a'));
            }
            if ('0' <= c && c <= '9') {
                decoded_bits = uint8_t(('Z' - 'A' + 1) + ('z' - 'a' + 1) + (c - '0'));
            } else if (c == '+') {
                decoded_bits = uint8_t(('Z' - 'A' + 1) + ('z' - 'a' + 1) + ('9' - '0' + 1));
            } else if (c == '/') {
                decoded_bits = uint8_t(('Z' - 'A' + 1) + ('z' - 'a' + 1) + ('9' - '0' + 2));
            } else {
                Error() << "Invalid base64 character '" << c << "'";
                return nullptr;
            }

            auto dst_ptr = &dst_buffer[(src_idx >> 2) * 3];

            switch (src_idx % 4) {
                case 0:
                    dst_ptr[0] |= decoded_bits << 2;
                    break;
                case 1:
                    dst_ptr[0] = uint8_t(dst_ptr[0] | uint8_t(decoded_bits >> 4));
                    dst_ptr[1] = uint8_t(dst_ptr[1] | uint8_t((decoded_bits & 0xF) << 4));
                    break;
                case 2:
                    dst_ptr[1] = uint8_t(dst_ptr[1] | uint8_t(decoded_bits >> 2));
                    dst_ptr[2] = uint8_t(dst_ptr[2] | uint8_t((decoded_bits & 0x3) << 6));
                    break;
                case 3:
                    dst_ptr[2] |= decoded_bits;
                    break;
                default:
                    break;
            }

            src_idx++;
        }

        return dst_buffer;
    }

    VkBool32 parse_VkBool32(const Json::Value& v, const LocationScope&) {
        if (v.isString()) {
            auto value = v.asString();
            if (value == "VK_TRUE")
                return VK_TRUE;
            else if (value == "VK_FALSE")
                return VK_FALSE;
            else {
                Error() << "VKBool32 string is neither VK_TRUE nor VK_FALSE";
                return 0;
            }
        } else if (v.isUInt() && v.asUInt() <= UINT32_MAX) {
            return v.asUInt();
        } else {
            Error() << "Not a 32-bit unsigned integer";
            return 0;
        }
    }

    VkSampleMask parse_VkSampleMask(const Json::Value& v, const LocationScope& l) { return parse_uint32_t(v, l); }

    VkStructureType parse_VkStructureType(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkStructureType_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkStructureType>(0);
        }
    }

    VkPipelineCreateFlagBits parse_VkPipelineCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineCreateFlagBits>(0);
        }
    }

    VkPipelineShaderStageCreateFlagBits parse_VkPipelineShaderStageCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineShaderStageCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineShaderStageCreateFlagBits>(0);
        }
    }

    VkShaderStageFlagBits parse_VkShaderStageFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkShaderStageFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkShaderStageFlagBits>(0);
        }
    }

    VkObjectType parse_VkObjectType(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkObjectType_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkObjectType>(0);
        }
    }

    VkPipelineRobustnessBufferBehavior parse_VkPipelineRobustnessBufferBehavior(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineRobustnessBufferBehavior_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineRobustnessBufferBehavior>(0);
        }
    }

    VkPipelineRobustnessImageBehavior parse_VkPipelineRobustnessImageBehavior(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineRobustnessImageBehavior_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineRobustnessImageBehavior>(0);
        }
    }

    VkVertexInputRate parse_VkVertexInputRate(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkVertexInputRate_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkVertexInputRate>(0);
        }
    }

    VkFormat parse_VkFormat(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkFormat_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkFormat>(0);
        }
    }

    VkPrimitiveTopology parse_VkPrimitiveTopology(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPrimitiveTopology_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPrimitiveTopology>(0);
        }
    }

    VkTessellationDomainOrigin parse_VkTessellationDomainOrigin(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkTessellationDomainOrigin_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkTessellationDomainOrigin>(0);
        }
    }

    VkPolygonMode parse_VkPolygonMode(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPolygonMode_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPolygonMode>(0);
        }
    }

    VkCullModeFlagBits parse_VkCullModeFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkCullModeFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkCullModeFlagBits>(0);
        }
    }

    VkFrontFace parse_VkFrontFace(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkFrontFace_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkFrontFace>(0);
        }
    }

    VkConservativeRasterizationModeEXT parse_VkConservativeRasterizationModeEXT(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkConservativeRasterizationModeEXT_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkConservativeRasterizationModeEXT>(0);
        }
    }

    VkLineRasterizationMode parse_VkLineRasterizationMode(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkLineRasterizationMode_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkLineRasterizationMode>(0);
        }
    }

    VkSampleCountFlagBits parse_VkSampleCountFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSampleCountFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSampleCountFlagBits>(0);
        }
    }

    VkCompareOp parse_VkCompareOp(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkCompareOp_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkCompareOp>(0);
        }
    }

    VkStencilOp parse_VkStencilOp(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkStencilOp_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkStencilOp>(0);
        }
    }

    VkLogicOp parse_VkLogicOp(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkLogicOp_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkLogicOp>(0);
        }
    }

    VkBlendFactor parse_VkBlendFactor(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkBlendFactor_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkBlendFactor>(0);
        }
    }

    VkBlendOp parse_VkBlendOp(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkBlendOp_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkBlendOp>(0);
        }
    }

    VkColorComponentFlagBits parse_VkColorComponentFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkColorComponentFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkColorComponentFlagBits>(0);
        }
    }

    VkBlendOverlapEXT parse_VkBlendOverlapEXT(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkBlendOverlapEXT_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkBlendOverlapEXT>(0);
        }
    }

    VkDynamicState parse_VkDynamicState(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkDynamicState_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkDynamicState>(0);
        }
    }

    VkPipelineCreateFlagBits2 parse_VkPipelineCreateFlagBits2(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineCreateFlagBits2_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineCreateFlagBits2>(0);
        }
    }

    VkPipelineCreationFeedbackFlagBits parse_VkPipelineCreationFeedbackFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineCreationFeedbackFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineCreationFeedbackFlagBits>(0);
        }
    }

    VkDiscardRectangleModeEXT parse_VkDiscardRectangleModeEXT(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkDiscardRectangleModeEXT_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkDiscardRectangleModeEXT>(0);
        }
    }

    VkFragmentShadingRateCombinerOpKHR parse_VkFragmentShadingRateCombinerOpKHR(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkFragmentShadingRateCombinerOpKHR_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkFragmentShadingRateCombinerOpKHR>(0);
        }
    }

    VkPipelineMatchControl parse_VkPipelineMatchControl(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineMatchControl_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineMatchControl>(0);
        }
    }

    VkSamplerYcbcrModelConversion parse_VkSamplerYcbcrModelConversion(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSamplerYcbcrModelConversion_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSamplerYcbcrModelConversion>(0);
        }
    }

    VkSamplerYcbcrRange parse_VkSamplerYcbcrRange(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSamplerYcbcrRange_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSamplerYcbcrRange>(0);
        }
    }

    VkComponentSwizzle parse_VkComponentSwizzle(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkComponentSwizzle_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkComponentSwizzle>(0);
        }
    }

    VkChromaLocation parse_VkChromaLocation(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkChromaLocation_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkChromaLocation>(0);
        }
    }

    VkFilter parse_VkFilter(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkFilter_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkFilter>(0);
        }
    }

    VkSamplerCreateFlagBits parse_VkSamplerCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSamplerCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSamplerCreateFlagBits>(0);
        }
    }

    VkSamplerMipmapMode parse_VkSamplerMipmapMode(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSamplerMipmapMode_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSamplerMipmapMode>(0);
        }
    }

    VkSamplerAddressMode parse_VkSamplerAddressMode(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSamplerAddressMode_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSamplerAddressMode>(0);
        }
    }

    VkBorderColor parse_VkBorderColor(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkBorderColor_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkBorderColor>(0);
        }
    }

    VkSamplerReductionMode parse_VkSamplerReductionMode(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSamplerReductionMode_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSamplerReductionMode>(0);
        }
    }

    VkDescriptorSetLayoutCreateFlagBits parse_VkDescriptorSetLayoutCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkDescriptorSetLayoutCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkDescriptorSetLayoutCreateFlagBits>(0);
        }
    }

    VkDescriptorType parse_VkDescriptorType(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkDescriptorType_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkDescriptorType>(0);
        }
    }

    VkDescriptorBindingFlagBits parse_VkDescriptorBindingFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkDescriptorBindingFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkDescriptorBindingFlagBits>(0);
        }
    }

    VkPipelineLayoutCreateFlagBits parse_VkPipelineLayoutCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineLayoutCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineLayoutCreateFlagBits>(0);
        }
    }

    VkRenderPassCreateFlagBits parse_VkRenderPassCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkRenderPassCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkRenderPassCreateFlagBits>(0);
        }
    }

    VkAttachmentDescriptionFlagBits parse_VkAttachmentDescriptionFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkAttachmentDescriptionFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkAttachmentDescriptionFlagBits>(0);
        }
    }

    VkAttachmentLoadOp parse_VkAttachmentLoadOp(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkAttachmentLoadOp_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkAttachmentLoadOp>(0);
        }
    }

    VkAttachmentStoreOp parse_VkAttachmentStoreOp(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkAttachmentStoreOp_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkAttachmentStoreOp>(0);
        }
    }

    VkImageLayout parse_VkImageLayout(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkImageLayout_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkImageLayout>(0);
        }
    }

    VkSubpassDescriptionFlagBits parse_VkSubpassDescriptionFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSubpassDescriptionFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSubpassDescriptionFlagBits>(0);
        }
    }

    VkPipelineBindPoint parse_VkPipelineBindPoint(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineBindPoint_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineBindPoint>(0);
        }
    }

    VkPipelineStageFlagBits parse_VkPipelineStageFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineStageFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineStageFlagBits>(0);
        }
    }

    VkAccessFlagBits parse_VkAccessFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkAccessFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkAccessFlagBits>(0);
        }
    }

    VkDependencyFlagBits parse_VkDependencyFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkDependencyFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkDependencyFlagBits>(0);
        }
    }

    VkImageAspectFlagBits parse_VkImageAspectFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkImageAspectFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkImageAspectFlagBits>(0);
        }
    }

    VkResolveModeFlagBits parse_VkResolveModeFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkResolveModeFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkResolveModeFlagBits>(0);
        }
    }

    VkPipelineStageFlagBits2 parse_VkPipelineStageFlagBits2(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineStageFlagBits2_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineStageFlagBits2>(0);
        }
    }

    VkAccessFlagBits2 parse_VkAccessFlagBits2(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkAccessFlagBits2_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkAccessFlagBits2>(0);
        }
    }

    VkPipelineCacheCreateFlagBits parse_VkPipelineCacheCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineCacheCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineCacheCreateFlagBits>(0);
        }
    }

    VkPipelineCreateFlags parse_VkPipelineCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkPipelineCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineShaderStageCreateFlags parse_VkPipelineShaderStageCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkPipelineShaderStageCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineShaderStageCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineVertexInputStateCreateFlags parse_VkPipelineVertexInputStateCreateFlags(const Json::Value& json,
                                                                                      const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineVertexInputStateCreateFlags>(0);
    }

    VkPipelineInputAssemblyStateCreateFlags parse_VkPipelineInputAssemblyStateCreateFlags(const Json::Value& json,
                                                                                          const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineInputAssemblyStateCreateFlags>(0);
    }

    VkPipelineTessellationStateCreateFlags parse_VkPipelineTessellationStateCreateFlags(const Json::Value& json,
                                                                                        const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineTessellationStateCreateFlags>(0);
    }

    VkPipelineViewportStateCreateFlags parse_VkPipelineViewportStateCreateFlags(const Json::Value& json, const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineViewportStateCreateFlags>(0);
    }

    VkPipelineRasterizationStateCreateFlags parse_VkPipelineRasterizationStateCreateFlags(const Json::Value& json,
                                                                                          const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineRasterizationStateCreateFlags>(0);
    }

    VkCullModeFlags parse_VkCullModeFlags(const Json::Value& json, const LocationScope& l) {
        VkCullModeFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkCullModeFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineRasterizationConservativeStateCreateFlagsEXT parse_VkPipelineRasterizationConservativeStateCreateFlagsEXT(
        const Json::Value& json, const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineRasterizationConservativeStateCreateFlagsEXT>(0);
    }

    VkPipelineRasterizationDepthClipStateCreateFlagsEXT parse_VkPipelineRasterizationDepthClipStateCreateFlagsEXT(
        const Json::Value& json, const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineRasterizationDepthClipStateCreateFlagsEXT>(0);
    }

    VkPipelineMultisampleStateCreateFlags parse_VkPipelineMultisampleStateCreateFlags(const Json::Value& json,
                                                                                      const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineMultisampleStateCreateFlags>(0);
    }

    VkPipelineDepthStencilStateCreateFlags parse_VkPipelineDepthStencilStateCreateFlags(const Json::Value& json,
                                                                                        const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineDepthStencilStateCreateFlags>(0);
    }

    VkPipelineColorBlendStateCreateFlags parse_VkPipelineColorBlendStateCreateFlags(const Json::Value& json,
                                                                                    const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineColorBlendStateCreateFlags>(0);
    }

    VkColorComponentFlags parse_VkColorComponentFlags(const Json::Value& json, const LocationScope& l) {
        VkColorComponentFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkColorComponentFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineDynamicStateCreateFlags parse_VkPipelineDynamicStateCreateFlags(const Json::Value& json, const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineDynamicStateCreateFlags>(0);
    }

    VkPipelineCreateFlags2 parse_VkPipelineCreateFlags2(const Json::Value& json, const LocationScope& l) {
        VkPipelineCreateFlags2 result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineCreateFlagBits2_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineCreationFeedbackFlags parse_VkPipelineCreationFeedbackFlags(const Json::Value& json, const LocationScope& l) {
        VkPipelineCreationFeedbackFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineCreationFeedbackFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineDiscardRectangleStateCreateFlagsEXT parse_VkPipelineDiscardRectangleStateCreateFlagsEXT(const Json::Value& json,
                                                                                                      const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineDiscardRectangleStateCreateFlagsEXT>(0);
    }

    VkSamplerCreateFlags parse_VkSamplerCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkSamplerCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkSamplerCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkDescriptorSetLayoutCreateFlags parse_VkDescriptorSetLayoutCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkDescriptorSetLayoutCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkDescriptorSetLayoutCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkShaderStageFlags parse_VkShaderStageFlags(const Json::Value& json, const LocationScope& l) {
        VkShaderStageFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkShaderStageFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkDescriptorBindingFlags parse_VkDescriptorBindingFlags(const Json::Value& json, const LocationScope& l) {
        VkDescriptorBindingFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkDescriptorBindingFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineLayoutCreateFlags parse_VkPipelineLayoutCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkPipelineLayoutCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineLayoutCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkRenderPassCreateFlags parse_VkRenderPassCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkRenderPassCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkRenderPassCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkAttachmentDescriptionFlags parse_VkAttachmentDescriptionFlags(const Json::Value& json, const LocationScope& l) {
        VkAttachmentDescriptionFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkAttachmentDescriptionFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkSubpassDescriptionFlags parse_VkSubpassDescriptionFlags(const Json::Value& json, const LocationScope& l) {
        VkSubpassDescriptionFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkSubpassDescriptionFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineStageFlags parse_VkPipelineStageFlags(const Json::Value& json, const LocationScope& l) {
        VkPipelineStageFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineStageFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkAccessFlags parse_VkAccessFlags(const Json::Value& json, const LocationScope& l) {
        VkAccessFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkAccessFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkDependencyFlags parse_VkDependencyFlags(const Json::Value& json, const LocationScope& l) {
        VkDependencyFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkDependencyFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkImageAspectFlags parse_VkImageAspectFlags(const Json::Value& json, const LocationScope& l) {
        VkImageAspectFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkImageAspectFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineStageFlags2 parse_VkPipelineStageFlags2(const Json::Value& json, const LocationScope& l) {
        VkPipelineStageFlags2 result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineStageFlagBits2_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkAccessFlags2 parse_VkAccessFlags2(const Json::Value& json, const LocationScope& l) {
        VkAccessFlags2 result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkAccessFlagBits2_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineCacheCreateFlags parse_VkPipelineCacheCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkPipelineCacheCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineCacheCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkShaderModuleCreateInfo parse_VkShaderModuleCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkShaderModuleCreateInfo s{VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, nullptr};

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        const auto& json_pnext = json["pNext"];
        if (!json_pnext.isString() || json_pnext.asString() != "NULL") {
            Error() << "Unexpected non-NULL pNext";
        }

        const auto& json_flags = json["flags"];
        if (!json_flags.isUInt() || json_flags.asUInt() != 0) {
            Error() << "Unexpected non-zero flags";
        }

        s.codeSize = parse_size_t(json["codeSize"], CreateScope("codeSize"));
        s.pCode = reinterpret_cast<const uint32_t*>(parse_binary(json["pCode"], CreateScope("pCode")));

        return s;
    }

    VkPipelineShaderStageCreateInfo parse_VkPipelineShaderStageCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineShaderStageCreateInfo s = parse_VkPipelineShaderStageCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: {
                    auto next = AllocMem<VkDebugUtilsObjectNameInfoEXT>();
                    current_pnext_ref = "pNext<VkDebugUtilsObjectNameInfoEXT>";
                    *next = parse_VkDebugUtilsObjectNameInfoEXT_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineRobustnessCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineRobustnessCreateInfo>";
                    *next = parse_VkPipelineRobustnessCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>";
                    *next = parse_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineVertexInputStateCreateInfo parse_VkPipelineVertexInputStateCreateInfo(const Json::Value& json,
                                                                                    const LocationScope& l) {
        VkPipelineVertexInputStateCreateInfo s = parse_VkPipelineVertexInputStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineVertexInputDivisorStateCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineVertexInputDivisorStateCreateInfo>";
                    *next = parse_VkPipelineVertexInputDivisorStateCreateInfo_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineInputAssemblyStateCreateInfo parse_VkPipelineInputAssemblyStateCreateInfo(const Json::Value& json,
                                                                                        const LocationScope& l) {
        VkPipelineInputAssemblyStateCreateInfo s = parse_VkPipelineInputAssemblyStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineTessellationStateCreateInfo parse_VkPipelineTessellationStateCreateInfo(const Json::Value& json,
                                                                                      const LocationScope& l) {
        VkPipelineTessellationStateCreateInfo s = parse_VkPipelineTessellationStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineTessellationDomainOriginStateCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineTessellationDomainOriginStateCreateInfo>";
                    *next = parse_VkPipelineTessellationDomainOriginStateCreateInfo_contents(*json_next,
                                                                                             CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineViewportStateCreateInfo parse_VkPipelineViewportStateCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineViewportStateCreateInfo s = parse_VkPipelineViewportStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineRasterizationStateCreateInfo parse_VkPipelineRasterizationStateCreateInfo(const Json::Value& json,
                                                                                        const LocationScope& l) {
        VkPipelineRasterizationStateCreateInfo s = parse_VkPipelineRasterizationStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkPipelineRasterizationConservativeStateCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkPipelineRasterizationConservativeStateCreateInfoEXT>";
                    *next = parse_VkPipelineRasterizationConservativeStateCreateInfoEXT_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkPipelineRasterizationDepthClipStateCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkPipelineRasterizationDepthClipStateCreateInfoEXT>";
                    *next = parse_VkPipelineRasterizationDepthClipStateCreateInfoEXT_contents(*json_next,
                                                                                              CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineRasterizationLineStateCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineRasterizationLineStateCreateInfo>";
                    *next =
                        parse_VkPipelineRasterizationLineStateCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkSampleLocationsInfoEXT parse_VkSampleLocationsInfoEXT(const Json::Value& json, const LocationScope& l) {
        VkSampleLocationsInfoEXT s = parse_VkSampleLocationsInfoEXT_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineMultisampleStateCreateInfo parse_VkPipelineMultisampleStateCreateInfo(const Json::Value& json,
                                                                                    const LocationScope& l) {
        VkPipelineMultisampleStateCreateInfo s = parse_VkPipelineMultisampleStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkPipelineSampleLocationsStateCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkPipelineSampleLocationsStateCreateInfoEXT>";
                    *next = parse_VkPipelineSampleLocationsStateCreateInfoEXT_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineDepthStencilStateCreateInfo parse_VkPipelineDepthStencilStateCreateInfo(const Json::Value& json,
                                                                                      const LocationScope& l) {
        VkPipelineDepthStencilStateCreateInfo s = parse_VkPipelineDepthStencilStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineColorBlendStateCreateInfo parse_VkPipelineColorBlendStateCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineColorBlendStateCreateInfo s = parse_VkPipelineColorBlendStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkPipelineColorBlendAdvancedStateCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkPipelineColorBlendAdvancedStateCreateInfoEXT>";
                    *next = parse_VkPipelineColorBlendAdvancedStateCreateInfoEXT_contents(*json_next,
                                                                                          CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkPipelineColorWriteCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkPipelineColorWriteCreateInfoEXT>";
                    *next = parse_VkPipelineColorWriteCreateInfoEXT_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineDynamicStateCreateInfo parse_VkPipelineDynamicStateCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineDynamicStateCreateInfo s = parse_VkPipelineDynamicStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkGraphicsPipelineCreateInfo parse_VkGraphicsPipelineCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkGraphicsPipelineCreateInfo s = parse_VkGraphicsPipelineCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineCreateFlags2CreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineCreateFlags2CreateInfo>";
                    *next = parse_VkPipelineCreateFlags2CreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineCreationFeedbackCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineCreationFeedbackCreateInfo>";
                    *next = parse_VkPipelineCreationFeedbackCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkPipelineDiscardRectangleStateCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkPipelineDiscardRectangleStateCreateInfoEXT>";
                    *next = parse_VkPipelineDiscardRectangleStateCreateInfoEXT_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR: {
                    auto next = AllocMem<VkPipelineFragmentShadingRateStateCreateInfoKHR>();
                    current_pnext_ref = "pNext<VkPipelineFragmentShadingRateStateCreateInfoKHR>";
                    *next = parse_VkPipelineFragmentShadingRateStateCreateInfoKHR_contents(*json_next,
                                                                                           CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineOfflineCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineOfflineCreateInfo>";
                    *next = parse_VkPipelineOfflineCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineRenderingCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineRenderingCreateInfo>";
                    *next = parse_VkPipelineRenderingCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineRobustnessCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineRobustnessCreateInfo>";
                    *next = parse_VkPipelineRobustnessCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO: {
                    auto next = AllocMem<VkRenderingAttachmentLocationInfo>();
                    current_pnext_ref = "pNext<VkRenderingAttachmentLocationInfo>";
                    *next = parse_VkRenderingAttachmentLocationInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO: {
                    auto next = AllocMem<VkRenderingInputAttachmentIndexInfo>();
                    current_pnext_ref = "pNext<VkRenderingInputAttachmentIndexInfo>";
                    *next = parse_VkRenderingInputAttachmentIndexInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkComputePipelineCreateInfo parse_VkComputePipelineCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkComputePipelineCreateInfo s = parse_VkComputePipelineCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineCreateFlags2CreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineCreateFlags2CreateInfo>";
                    *next = parse_VkPipelineCreateFlags2CreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineCreationFeedbackCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineCreationFeedbackCreateInfo>";
                    *next = parse_VkPipelineCreationFeedbackCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineOfflineCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineOfflineCreateInfo>";
                    *next = parse_VkPipelineOfflineCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineRobustnessCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineRobustnessCreateInfo>";
                    *next = parse_VkPipelineRobustnessCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkSamplerYcbcrConversionCreateInfo parse_VkSamplerYcbcrConversionCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkSamplerYcbcrConversionCreateInfo s = parse_VkSamplerYcbcrConversionCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
#ifdef VK_USE_PLATFORM_SCREEN_QNX

                case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX: {
                    auto next = AllocMem<VkExternalFormatQNX>();
                    current_pnext_ref = "pNext<VkExternalFormatQNX>";
                    *next = parse_VkExternalFormatQNX_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }
#endif  // VK_USE_PLATFORM_SCREEN_QNX

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkSamplerCreateInfo parse_VkSamplerCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkSamplerCreateInfo s = parse_VkSamplerCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkSamplerCustomBorderColorCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkSamplerCustomBorderColorCreateInfoEXT>";
                    *next =
                        parse_VkSamplerCustomBorderColorCreateInfoEXT_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: {
                    auto next = AllocMem<VkSamplerReductionModeCreateInfo>();
                    current_pnext_ref = "pNext<VkSamplerReductionModeCreateInfo>";
                    *next = parse_VkSamplerReductionModeCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: {
                    auto next = AllocMem<VkSamplerYcbcrConversionInfo>();
                    current_pnext_ref = "pNext<VkSamplerYcbcrConversionInfo>";
                    *next = parse_VkSamplerYcbcrConversionInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkDescriptorSetLayoutCreateInfo parse_VkDescriptorSetLayoutCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkDescriptorSetLayoutCreateInfo s = parse_VkDescriptorSetLayoutCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: {
                    auto next = AllocMem<VkDescriptorSetLayoutBindingFlagsCreateInfo>();
                    current_pnext_ref = "pNext<VkDescriptorSetLayoutBindingFlagsCreateInfo>";
                    *next = parse_VkDescriptorSetLayoutBindingFlagsCreateInfo_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineLayoutCreateInfo parse_VkPipelineLayoutCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineLayoutCreateInfo s = parse_VkPipelineLayoutCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPhysicalDeviceFeatures2 parse_VkPhysicalDeviceFeatures2(const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceFeatures2 s = parse_VkPhysicalDeviceFeatures2_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: {
                    auto next = AllocMem<VkPhysicalDevice16BitStorageFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDevice16BitStorageFeatures>";
                    *next = parse_VkPhysicalDevice16BitStorageFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDevice4444FormatsFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDevice4444FormatsFeaturesEXT>";
                    *next = parse_VkPhysicalDevice4444FormatsFeaturesEXT_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: {
                    auto next = AllocMem<VkPhysicalDevice8BitStorageFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDevice8BitStorageFeatures>";
                    *next = parse_VkPhysicalDevice8BitStorageFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceASTCDecodeFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceASTCDecodeFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceASTCDecodeFeaturesEXT_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT_contents(*json_next,
                                                                                             CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceBufferDeviceAddressFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceBufferDeviceAddressFeatures>";
                    *next = parse_VkPhysicalDeviceBufferDeviceAddressFeatures_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceColorWriteEnableFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceColorWriteEnableFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceColorWriteEnableFeaturesEXT_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceCustomBorderColorFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceCustomBorderColorFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceCustomBorderColorFeaturesEXT_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceDepthClipEnableFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceDepthClipEnableFeaturesEXT>";
                    *next =
                        parse_VkPhysicalDeviceDepthClipEnableFeaturesEXT_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceDescriptorIndexingFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceDescriptorIndexingFeatures>";
                    *next =
                        parse_VkPhysicalDeviceDescriptorIndexingFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceDynamicRenderingFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceDynamicRenderingFeatures>";
                    *next =
                        parse_VkPhysicalDeviceDynamicRenderingFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceDynamicRenderingLocalReadFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceDynamicRenderingLocalReadFeatures>";
                    *next = parse_VkPhysicalDeviceDynamicRenderingLocalReadFeatures_contents(*json_next,
                                                                                             CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>";
                    *next = parse_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT_contents(*json_next,
                                                                                            CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT_contents(*json_next,
                                                                                           CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

#ifdef VK_USE_PLATFORM_SCI

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV: {
                    auto next = AllocMem<VkPhysicalDeviceExternalMemorySciBufFeaturesNV>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceExternalMemorySciBufFeaturesNV>";
                    *next = parse_VkPhysicalDeviceExternalMemorySciBufFeaturesNV_contents(*json_next,
                                                                                          CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }
#endif  // VK_USE_PLATFORM_SCI

#ifdef VK_USE_PLATFORM_SCREEN_QNX

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX: {
                    auto next = AllocMem<VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>";
                    *next = parse_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }
#endif  // VK_USE_PLATFORM_SCREEN_QNX

#ifdef VK_USE_PLATFORM_SCI

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV: {
                    auto next = AllocMem<VkPhysicalDeviceExternalSciSync2FeaturesNV>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceExternalSciSync2FeaturesNV>";
                    *next =
                        parse_VkPhysicalDeviceExternalSciSync2FeaturesNV_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }
#endif  // VK_USE_PLATFORM_SCI

#ifdef VK_USE_PLATFORM_SCI

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV: {
                    auto next = AllocMem<VkPhysicalDeviceExternalSciSyncFeaturesNV>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceExternalSciSyncFeaturesNV>";
                    *next =
                        parse_VkPhysicalDeviceExternalSciSyncFeaturesNV_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }
#endif  // VK_USE_PLATFORM_SCI

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT_contents(*json_next,
                                                                                              CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: {
                    auto next = AllocMem<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>";
                    *next = parse_VkPhysicalDeviceFragmentShadingRateFeaturesKHR_contents(*json_next,
                                                                                          CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceGlobalPriorityQueryFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceGlobalPriorityQueryFeatures>";
                    *next = parse_VkPhysicalDeviceGlobalPriorityQueryFeatures_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceHostImageCopyFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceHostImageCopyFeatures>";
                    *next = parse_VkPhysicalDeviceHostImageCopyFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceHostQueryResetFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceHostQueryResetFeatures>";
                    *next = parse_VkPhysicalDeviceHostQueryResetFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceImageRobustnessFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceImageRobustnessFeatures>";
                    *next =
                        parse_VkPhysicalDeviceImageRobustnessFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceImagelessFramebufferFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceImagelessFramebufferFeatures>";
                    *next = parse_VkPhysicalDeviceImagelessFramebufferFeatures_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceIndexTypeUint8Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceIndexTypeUint8Features>";
                    *next = parse_VkPhysicalDeviceIndexTypeUint8Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceInlineUniformBlockFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceInlineUniformBlockFeatures>";
                    *next =
                        parse_VkPhysicalDeviceInlineUniformBlockFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceLineRasterizationFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceLineRasterizationFeatures>";
                    *next =
                        parse_VkPhysicalDeviceLineRasterizationFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceMaintenance4Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceMaintenance4Features>";
                    *next = parse_VkPhysicalDeviceMaintenance4Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceMaintenance5Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceMaintenance5Features>";
                    *next = parse_VkPhysicalDeviceMaintenance5Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceMaintenance6Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceMaintenance6Features>";
                    *next = parse_VkPhysicalDeviceMaintenance6Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceMultiviewFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceMultiviewFeatures>";
                    *next = parse_VkPhysicalDeviceMultiviewFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: {
                    auto next = AllocMem<VkPhysicalDevicePerformanceQueryFeaturesKHR>();
                    current_pnext_ref = "pNext<VkPhysicalDevicePerformanceQueryFeaturesKHR>";
                    *next = parse_VkPhysicalDevicePerformanceQueryFeaturesKHR_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES: {
                    auto next = AllocMem<VkPhysicalDevicePipelineCreationCacheControlFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDevicePipelineCreationCacheControlFeatures>";
                    *next = parse_VkPhysicalDevicePipelineCreationCacheControlFeatures_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDevicePipelineProtectedAccessFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDevicePipelineProtectedAccessFeatures>";
                    *next = parse_VkPhysicalDevicePipelineProtectedAccessFeatures_contents(*json_next,
                                                                                           CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDevicePipelineRobustnessFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDevicePipelineRobustnessFeatures>";
                    *next =
                        parse_VkPhysicalDevicePipelineRobustnessFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: {
                    auto next = AllocMem<VkPhysicalDevicePrivateDataFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDevicePrivateDataFeatures>";
                    *next = parse_VkPhysicalDevicePrivateDataFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceProtectedMemoryFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceProtectedMemoryFeatures>";
                    *next =
                        parse_VkPhysicalDeviceProtectedMemoryFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR: {
                    auto next = AllocMem<VkPhysicalDeviceRobustness2FeaturesKHR>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceRobustness2FeaturesKHR>";
                    *next = parse_VkPhysicalDeviceRobustness2FeaturesKHR_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceSamplerYcbcrConversionFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceSamplerYcbcrConversionFeatures>";
                    *next = parse_VkPhysicalDeviceSamplerYcbcrConversionFeatures_contents(*json_next,
                                                                                          CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceScalarBlockLayoutFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceScalarBlockLayoutFeatures>";
                    *next =
                        parse_VkPhysicalDeviceScalarBlockLayoutFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>";
                    *next = parse_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderAtomicInt64Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderAtomicInt64Features>";
                    *next =
                        parse_VkPhysicalDeviceShaderAtomicInt64Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: {
                    auto next = AllocMem<VkPhysicalDeviceShaderClockFeaturesKHR>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderClockFeaturesKHR>";
                    *next = parse_VkPhysicalDeviceShaderClockFeaturesKHR_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>";
                    *next = parse_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderDrawParametersFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderDrawParametersFeatures>";
                    *next = parse_VkPhysicalDeviceShaderDrawParametersFeatures_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderExpectAssumeFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderExpectAssumeFeatures>";
                    *next =
                        parse_VkPhysicalDeviceShaderExpectAssumeFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderFloat16Int8Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderFloat16Int8Features>";
                    *next =
                        parse_VkPhysicalDeviceShaderFloat16Int8Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderFloatControls2Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderFloatControls2Features>";
                    *next = parse_VkPhysicalDeviceShaderFloatControls2Features_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>";
                    *next = parse_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT_contents(*json_next,
                                                                                             CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderIntegerDotProductFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderIntegerDotProductFeatures>";
                    *next = parse_VkPhysicalDeviceShaderIntegerDotProductFeatures_contents(*json_next,
                                                                                           CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>";
                    *next = parse_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderSubgroupRotateFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderSubgroupRotateFeatures>";
                    *next = parse_VkPhysicalDeviceShaderSubgroupRotateFeatures_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderTerminateInvocationFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderTerminateInvocationFeatures>";
                    *next = parse_VkPhysicalDeviceShaderTerminateInvocationFeatures_contents(*json_next,
                                                                                             CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceSubgroupSizeControlFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceSubgroupSizeControlFeatures>";
                    *next = parse_VkPhysicalDeviceSubgroupSizeControlFeatures_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceSynchronization2Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceSynchronization2Features>";
                    *next =
                        parse_VkPhysicalDeviceSynchronization2Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT_contents(*json_next,
                                                                                           CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceTextureCompressionASTCHDRFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceTextureCompressionASTCHDRFeatures>";
                    *next = parse_VkPhysicalDeviceTextureCompressionASTCHDRFeatures_contents(*json_next,
                                                                                             CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceTimelineSemaphoreFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceTimelineSemaphoreFeatures>";
                    *next =
                        parse_VkPhysicalDeviceTimelineSemaphoreFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>";
                    *next = parse_VkPhysicalDeviceUniformBufferStandardLayoutFeatures_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVariablePointersFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVariablePointersFeatures>";
                    *next =
                        parse_VkPhysicalDeviceVariablePointersFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVertexAttributeDivisorFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVertexAttributeDivisorFeatures>";
                    *next = parse_VkPhysicalDeviceVertexAttributeDivisorFeatures_contents(*json_next,
                                                                                          CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT_contents(*json_next,
                                                                                              CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVulkan11Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVulkan11Features>";
                    *next = parse_VkPhysicalDeviceVulkan11Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVulkan12Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVulkan12Features>";
                    *next = parse_VkPhysicalDeviceVulkan12Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVulkan13Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVulkan13Features>";
                    *next = parse_VkPhysicalDeviceVulkan13Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVulkan14Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVulkan14Features>";
                    *next = parse_VkPhysicalDeviceVulkan14Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVulkanMemoryModelFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVulkanMemoryModelFeatures>";
                    *next =
                        parse_VkPhysicalDeviceVulkanMemoryModelFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVulkanSC10Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVulkanSC10Features>";
                    *next = parse_VkPhysicalDeviceVulkanSC10Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT_contents(*json_next,
                                                                                            CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>";
                    *next = parse_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkRenderPassCreateInfo parse_VkRenderPassCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkRenderPassCreateInfo s = parse_VkRenderPassCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: {
                    auto next = AllocMem<VkRenderPassInputAttachmentAspectCreateInfo>();
                    current_pnext_ref = "pNext<VkRenderPassInputAttachmentAspectCreateInfo>";
                    *next = parse_VkRenderPassInputAttachmentAspectCreateInfo_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: {
                    auto next = AllocMem<VkRenderPassMultiviewCreateInfo>();
                    current_pnext_ref = "pNext<VkRenderPassMultiviewCreateInfo>";
                    *next = parse_VkRenderPassMultiviewCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkAttachmentDescription2 parse_VkAttachmentDescription2(const Json::Value& json, const LocationScope& l) {
        VkAttachmentDescription2 s = parse_VkAttachmentDescription2_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: {
                    auto next = AllocMem<VkAttachmentDescriptionStencilLayout>();
                    current_pnext_ref = "pNext<VkAttachmentDescriptionStencilLayout>";
                    *next = parse_VkAttachmentDescriptionStencilLayout_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkAttachmentReference2 parse_VkAttachmentReference2(const Json::Value& json, const LocationScope& l) {
        VkAttachmentReference2 s = parse_VkAttachmentReference2_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: {
                    auto next = AllocMem<VkAttachmentReferenceStencilLayout>();
                    current_pnext_ref = "pNext<VkAttachmentReferenceStencilLayout>";
                    *next = parse_VkAttachmentReferenceStencilLayout_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkSubpassDescription2 parse_VkSubpassDescription2(const Json::Value& json, const LocationScope& l) {
        VkSubpassDescription2 s = parse_VkSubpassDescription2_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: {
                    auto next = AllocMem<VkFragmentShadingRateAttachmentInfoKHR>();
                    current_pnext_ref = "pNext<VkFragmentShadingRateAttachmentInfoKHR>";
                    *next = parse_VkFragmentShadingRateAttachmentInfoKHR_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: {
                    auto next = AllocMem<VkSubpassDescriptionDepthStencilResolve>();
                    current_pnext_ref = "pNext<VkSubpassDescriptionDepthStencilResolve>";
                    *next =
                        parse_VkSubpassDescriptionDepthStencilResolve_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkSubpassDependency2 parse_VkSubpassDependency2(const Json::Value& json, const LocationScope& l) {
        VkSubpassDependency2 s = parse_VkSubpassDependency2_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2: {
                    auto next = AllocMem<VkMemoryBarrier2>();
                    current_pnext_ref = "pNext<VkMemoryBarrier2>";
                    *next = parse_VkMemoryBarrier2_contents(*json_next, CreateScope(current_pnext_ref, true));
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkRenderPassCreateInfo2 parse_VkRenderPassCreateInfo2(const Json::Value& json, const LocationScope& l) {
        VkRenderPassCreateInfo2 s = parse_VkRenderPassCreateInfo2_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineCacheCreateInfo parse_VkPipelineCacheCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineCacheCreateInfo s = parse_VkPipelineCacheCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelinePoolSize parse_VkPipelinePoolSize(const Json::Value& json, const LocationScope& l) {
        VkPipelinePoolSize s = parse_VkPipelinePoolSize_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkDeviceObjectReservationCreateInfo parse_VkDeviceObjectReservationCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkDeviceObjectReservationCreateInfo s = parse_VkDeviceObjectReservationCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineOfflineCreateInfo parse_VkPipelineOfflineCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineOfflineCreateInfo s = parse_VkPipelineOfflineCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (json_stype.asString() != "VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO") {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || json_next->asString() != "NULL") {
            Error() << "Invalid pNext format";
        }
        return s;
    }

  private:
    VkSpecializationMapEntry parse_VkSpecializationMapEntry_contents(const Json::Value& json, const LocationScope& l) {
        VkSpecializationMapEntry s{};
        s.constantID = parse_uint32_t(json["constantID"], CreateScope("constantID"));
        s.offset = parse_uint32_t(json["offset"], CreateScope("offset"));
        s.size = parse_size_t(json["size"], CreateScope("size"));
        return s;
    }

    VkSpecializationMapEntry* parse_VkSpecializationMapEntry_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkSpecializationMapEntry>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkSpecializationMapEntry_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkSpecializationInfo parse_VkSpecializationInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkSpecializationInfo s{};
        s.mapEntryCount = parse_uint32_t(json["mapEntryCount"], CreateScope("mapEntryCount"));
        s.pMapEntries = parse_VkSpecializationMapEntry_array(json["pMapEntries"], CreateScope("pMapEntries"));
        s.dataSize = parse_size_t(json["dataSize"], CreateScope("dataSize"));
        s.pData = parse_binary(json["pData"], CreateScope("pData"));
        return s;
    }

    VkSpecializationInfo* parse_VkSpecializationInfo_pointer(const Json::Value& json, const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<VkSpecializationInfo>(1);
        dst_buffer[0] = parse_VkSpecializationInfo_contents(json, l);

        return dst_buffer;
    }

    VkPipelineShaderStageCreateInfo parse_VkPipelineShaderStageCreateInfo_contents(const Json::Value& json,
                                                                                   const LocationScope& l) {
        VkPipelineShaderStageCreateInfo s{};
        s.flags = parse_VkPipelineShaderStageCreateFlags(json["flags"], CreateScope("flags"));
        s.stage = parse_VkShaderStageFlagBits(json["stage"], CreateScope("stage"));
        s.module = parse_VkShaderModule(json["module"], CreateScope("module"));
        s.pName = parse_string(json["pName"], CreateScope("pName"));
        s.pSpecializationInfo = parse_VkSpecializationInfo_pointer(json["pSpecializationInfo"], CreateScope("pSpecializationInfo"));
        return s;
    }

    VkDebugUtilsObjectNameInfoEXT parse_VkDebugUtilsObjectNameInfoEXT_contents(const Json::Value& json, const LocationScope& l) {
        VkDebugUtilsObjectNameInfoEXT s{};
        s.objectType = parse_VkObjectType(json["objectType"], CreateScope("objectType"));
        s.objectHandle = parse_uint64_t(json["objectHandle"], CreateScope("objectHandle"));
        s.pObjectName = parse_string(json["pObjectName"], CreateScope("pObjectName"));
        return s;
    }

    VkPipelineRobustnessCreateInfo parse_VkPipelineRobustnessCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelineRobustnessCreateInfo s{};
        s.storageBuffers = parse_VkPipelineRobustnessBufferBehavior(json["storageBuffers"], CreateScope("storageBuffers"));
        s.uniformBuffers = parse_VkPipelineRobustnessBufferBehavior(json["uniformBuffers"], CreateScope("uniformBuffers"));
        s.vertexInputs = parse_VkPipelineRobustnessBufferBehavior(json["vertexInputs"], CreateScope("vertexInputs"));
        s.images = parse_VkPipelineRobustnessImageBehavior(json["images"], CreateScope("images"));
        return s;
    }

    VkPipelineShaderStageRequiredSubgroupSizeCreateInfo parse_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineShaderStageRequiredSubgroupSizeCreateInfo s{};
        s.requiredSubgroupSize = parse_uint32_t(json["requiredSubgroupSize"], CreateScope("requiredSubgroupSize"));
        return s;
    }

    VkPipelineShaderStageCreateInfo* parse_VkPipelineShaderStageCreateInfo_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkPipelineShaderStageCreateInfo>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkPipelineShaderStageCreateInfo(json[i], l);
        }

        return dst_buffer;
    }

    VkVertexInputBindingDescription parse_VkVertexInputBindingDescription_contents(const Json::Value& json,
                                                                                   const LocationScope& l) {
        VkVertexInputBindingDescription s{};
        s.binding = parse_uint32_t(json["binding"], CreateScope("binding"));
        s.stride = parse_uint32_t(json["stride"], CreateScope("stride"));
        s.inputRate = parse_VkVertexInputRate(json["inputRate"], CreateScope("inputRate"));
        return s;
    }

    VkVertexInputBindingDescription* parse_VkVertexInputBindingDescription_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkVertexInputBindingDescription>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkVertexInputBindingDescription_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkVertexInputAttributeDescription parse_VkVertexInputAttributeDescription_contents(const Json::Value& json,
                                                                                       const LocationScope& l) {
        VkVertexInputAttributeDescription s{};
        s.location = parse_uint32_t(json["location"], CreateScope("location"));
        s.binding = parse_uint32_t(json["binding"], CreateScope("binding"));
        s.format = parse_VkFormat(json["format"], CreateScope("format"));
        s.offset = parse_uint32_t(json["offset"], CreateScope("offset"));
        return s;
    }

    VkVertexInputAttributeDescription* parse_VkVertexInputAttributeDescription_array(const Json::Value& json,
                                                                                     const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkVertexInputAttributeDescription>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkVertexInputAttributeDescription_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkPipelineVertexInputStateCreateInfo parse_VkPipelineVertexInputStateCreateInfo_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPipelineVertexInputStateCreateInfo s{};
        s.flags = parse_VkPipelineVertexInputStateCreateFlags(json["flags"], CreateScope("flags"));
        s.vertexBindingDescriptionCount =
            parse_uint32_t(json["vertexBindingDescriptionCount"], CreateScope("vertexBindingDescriptionCount"));
        s.pVertexBindingDescriptions = parse_VkVertexInputBindingDescription_array(json["pVertexBindingDescriptions"],
                                                                                   CreateScope("pVertexBindingDescriptions"));
        s.vertexAttributeDescriptionCount =
            parse_uint32_t(json["vertexAttributeDescriptionCount"], CreateScope("vertexAttributeDescriptionCount"));
        s.pVertexAttributeDescriptions = parse_VkVertexInputAttributeDescription_array(json["pVertexAttributeDescriptions"],
                                                                                       CreateScope("pVertexAttributeDescriptions"));
        return s;
    }

    VkVertexInputBindingDivisorDescription parse_VkVertexInputBindingDivisorDescription_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkVertexInputBindingDivisorDescription s{};
        s.binding = parse_uint32_t(json["binding"], CreateScope("binding"));
        s.divisor = parse_uint32_t(json["divisor"], CreateScope("divisor"));
        return s;
    }

    VkVertexInputBindingDivisorDescription* parse_VkVertexInputBindingDivisorDescription_array(const Json::Value& json,
                                                                                               const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkVertexInputBindingDivisorDescription>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkVertexInputBindingDivisorDescription_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkPipelineVertexInputDivisorStateCreateInfo parse_VkPipelineVertexInputDivisorStateCreateInfo_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPipelineVertexInputDivisorStateCreateInfo s{};
        s.vertexBindingDivisorCount = parse_uint32_t(json["vertexBindingDivisorCount"], CreateScope("vertexBindingDivisorCount"));
        s.pVertexBindingDivisors = parse_VkVertexInputBindingDivisorDescription_array(json["pVertexBindingDivisors"],
                                                                                      CreateScope("pVertexBindingDivisors"));
        return s;
    }

    VkPipelineVertexInputStateCreateInfo* parse_VkPipelineVertexInputStateCreateInfo_pointer(const Json::Value& json,
                                                                                             const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<VkPipelineVertexInputStateCreateInfo>(1);
        dst_buffer[0] = parse_VkPipelineVertexInputStateCreateInfo(json, l);

        return dst_buffer;
    }

    VkPipelineInputAssemblyStateCreateInfo parse_VkPipelineInputAssemblyStateCreateInfo_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPipelineInputAssemblyStateCreateInfo s{};
        s.flags = parse_VkPipelineInputAssemblyStateCreateFlags(json["flags"], CreateScope("flags"));
        s.topology = parse_VkPrimitiveTopology(json["topology"], CreateScope("topology"));
        s.primitiveRestartEnable = parse_VkBool32(json["primitiveRestartEnable"], CreateScope("primitiveRestartEnable"));
        return s;
    }

    VkPipelineInputAssemblyStateCreateInfo* parse_VkPipelineInputAssemblyStateCreateInfo_pointer(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<VkPipelineInputAssemblyStateCreateInfo>(1);
        dst_buffer[0] = parse_VkPipelineInputAssemblyStateCreateInfo(json, l);

        return dst_buffer;
    }

    VkPipelineTessellationStateCreateInfo parse_VkPipelineTessellationStateCreateInfo_contents(const Json::Value& json,
                                                                                               const LocationScope& l) {
        VkPipelineTessellationStateCreateInfo s{};
        s.flags = parse_VkPipelineTessellationStateCreateFlags(json["flags"], CreateScope("flags"));
        s.patchControlPoints = parse_uint32_t(json["patchControlPoints"], CreateScope("patchControlPoints"));
        return s;
    }

    VkPipelineTessellationDomainOriginStateCreateInfo parse_VkPipelineTessellationDomainOriginStateCreateInfo_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineTessellationDomainOriginStateCreateInfo s{};
        s.domainOrigin = parse_VkTessellationDomainOrigin(json["domainOrigin"], CreateScope("domainOrigin"));
        return s;
    }

    VkPipelineTessellationStateCreateInfo* parse_VkPipelineTessellationStateCreateInfo_pointer(const Json::Value& json,
                                                                                               const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<VkPipelineTessellationStateCreateInfo>(1);
        dst_buffer[0] = parse_VkPipelineTessellationStateCreateInfo(json, l);

        return dst_buffer;
    }

    VkViewport parse_VkViewport_contents(const Json::Value& json, const LocationScope& l) {
        VkViewport s{};
        s.x = parse_float(json["x"], CreateScope("x"));
        s.y = parse_float(json["y"], CreateScope("y"));
        s.width = parse_float(json["width"], CreateScope("width"));
        s.height = parse_float(json["height"], CreateScope("height"));
        s.minDepth = parse_float(json["minDepth"], CreateScope("minDepth"));
        s.maxDepth = parse_float(json["maxDepth"], CreateScope("maxDepth"));
        return s;
    }

    VkViewport* parse_VkViewport_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkViewport>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkViewport_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkOffset2D parse_VkOffset2D_contents(const Json::Value& json, const LocationScope& l) {
        VkOffset2D s{};
        s.x = parse_int32_t(json["x"], CreateScope("x"));
        s.y = parse_int32_t(json["y"], CreateScope("y"));
        return s;
    }

    VkExtent2D parse_VkExtent2D_contents(const Json::Value& json, const LocationScope& l) {
        VkExtent2D s{};
        s.width = parse_uint32_t(json["width"], CreateScope("width"));
        s.height = parse_uint32_t(json["height"], CreateScope("height"));
        return s;
    }

    VkRect2D parse_VkRect2D_contents(const Json::Value& json, const LocationScope& l) {
        VkRect2D s{};
        s.offset = parse_VkOffset2D_contents(json["offset"], CreateScope("offset"));
        s.extent = parse_VkExtent2D_contents(json["extent"], CreateScope("extent"));
        return s;
    }

    VkRect2D* parse_VkRect2D_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkRect2D>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkRect2D_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkPipelineViewportStateCreateInfo parse_VkPipelineViewportStateCreateInfo_contents(const Json::Value& json,
                                                                                       const LocationScope& l) {
        VkPipelineViewportStateCreateInfo s{};
        s.flags = parse_VkPipelineViewportStateCreateFlags(json["flags"], CreateScope("flags"));
        s.viewportCount = parse_uint32_t(json["viewportCount"], CreateScope("viewportCount"));
        s.pViewports = parse_VkViewport_array(json["pViewports"], CreateScope("pViewports"));
        s.scissorCount = parse_uint32_t(json["scissorCount"], CreateScope("scissorCount"));
        s.pScissors = parse_VkRect2D_array(json["pScissors"], CreateScope("pScissors"));
        return s;
    }

    VkPipelineViewportStateCreateInfo* parse_VkPipelineViewportStateCreateInfo_pointer(const Json::Value& json,
                                                                                       const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<VkPipelineViewportStateCreateInfo>(1);
        dst_buffer[0] = parse_VkPipelineViewportStateCreateInfo(json, l);

        return dst_buffer;
    }

    VkPipelineRasterizationStateCreateInfo parse_VkPipelineRasterizationStateCreateInfo_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPipelineRasterizationStateCreateInfo s{};
        s.flags = parse_VkPipelineRasterizationStateCreateFlags(json["flags"], CreateScope("flags"));
        s.depthClampEnable = parse_VkBool32(json["depthClampEnable"], CreateScope("depthClampEnable"));
        s.rasterizerDiscardEnable = parse_VkBool32(json["rasterizerDiscardEnable"], CreateScope("rasterizerDiscardEnable"));
        s.polygonMode = parse_VkPolygonMode(json["polygonMode"], CreateScope("polygonMode"));
        s.cullMode = parse_VkCullModeFlags(json["cullMode"], CreateScope("cullMode"));
        s.frontFace = parse_VkFrontFace(json["frontFace"], CreateScope("frontFace"));
        s.depthBiasEnable = parse_VkBool32(json["depthBiasEnable"], CreateScope("depthBiasEnable"));
        s.depthBiasConstantFactor = parse_float(json["depthBiasConstantFactor"], CreateScope("depthBiasConstantFactor"));
        s.depthBiasClamp = parse_float(json["depthBiasClamp"], CreateScope("depthBiasClamp"));
        s.depthBiasSlopeFactor = parse_float(json["depthBiasSlopeFactor"], CreateScope("depthBiasSlopeFactor"));
        s.lineWidth = parse_float(json["lineWidth"], CreateScope("lineWidth"));
        return s;
    }

    VkPipelineRasterizationConservativeStateCreateInfoEXT parse_VkPipelineRasterizationConservativeStateCreateInfoEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineRasterizationConservativeStateCreateInfoEXT s{};
        s.flags = parse_VkPipelineRasterizationConservativeStateCreateFlagsEXT(json["flags"], CreateScope("flags"));
        s.conservativeRasterizationMode = parse_VkConservativeRasterizationModeEXT(json["conservativeRasterizationMode"],
                                                                                   CreateScope("conservativeRasterizationMode"));
        s.extraPrimitiveOverestimationSize =
            parse_float(json["extraPrimitiveOverestimationSize"], CreateScope("extraPrimitiveOverestimationSize"));
        return s;
    }

    VkPipelineRasterizationDepthClipStateCreateInfoEXT parse_VkPipelineRasterizationDepthClipStateCreateInfoEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineRasterizationDepthClipStateCreateInfoEXT s{};
        s.flags = parse_VkPipelineRasterizationDepthClipStateCreateFlagsEXT(json["flags"], CreateScope("flags"));
        s.depthClipEnable = parse_VkBool32(json["depthClipEnable"], CreateScope("depthClipEnable"));
        return s;
    }

    VkPipelineRasterizationLineStateCreateInfo parse_VkPipelineRasterizationLineStateCreateInfo_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPipelineRasterizationLineStateCreateInfo s{};
        s.lineRasterizationMode =
            parse_VkLineRasterizationMode(json["lineRasterizationMode"], CreateScope("lineRasterizationMode"));
        s.stippledLineEnable = parse_VkBool32(json["stippledLineEnable"], CreateScope("stippledLineEnable"));
        s.lineStippleFactor = parse_uint32_t(json["lineStippleFactor"], CreateScope("lineStippleFactor"));
        s.lineStipplePattern = parse_uint16_t(json["lineStipplePattern"], CreateScope("lineStipplePattern"));
        return s;
    }

    VkPipelineRasterizationStateCreateInfo* parse_VkPipelineRasterizationStateCreateInfo_pointer(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<VkPipelineRasterizationStateCreateInfo>(1);
        dst_buffer[0] = parse_VkPipelineRasterizationStateCreateInfo(json, l);

        return dst_buffer;
    }

    VkSampleMask* parse_VkSampleMask_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkSampleMask>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkSampleMask(json[i], l);
        }

        return dst_buffer;
    }

    VkPipelineMultisampleStateCreateInfo parse_VkPipelineMultisampleStateCreateInfo_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPipelineMultisampleStateCreateInfo s{};
        s.flags = parse_VkPipelineMultisampleStateCreateFlags(json["flags"], CreateScope("flags"));
        s.rasterizationSamples = parse_VkSampleCountFlagBits(json["rasterizationSamples"], CreateScope("rasterizationSamples"));
        s.sampleShadingEnable = parse_VkBool32(json["sampleShadingEnable"], CreateScope("sampleShadingEnable"));
        s.minSampleShading = parse_float(json["minSampleShading"], CreateScope("minSampleShading"));
        s.pSampleMask = parse_VkSampleMask_array(json["pSampleMask"], CreateScope("pSampleMask"));
        s.alphaToCoverageEnable = parse_VkBool32(json["alphaToCoverageEnable"], CreateScope("alphaToCoverageEnable"));
        s.alphaToOneEnable = parse_VkBool32(json["alphaToOneEnable"], CreateScope("alphaToOneEnable"));
        return s;
    }

    VkSampleLocationEXT parse_VkSampleLocationEXT_contents(const Json::Value& json, const LocationScope& l) {
        VkSampleLocationEXT s{};
        s.x = parse_float(json["x"], CreateScope("x"));
        s.y = parse_float(json["y"], CreateScope("y"));
        return s;
    }

    VkSampleLocationEXT* parse_VkSampleLocationEXT_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkSampleLocationEXT>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkSampleLocationEXT_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkSampleLocationsInfoEXT parse_VkSampleLocationsInfoEXT_contents(const Json::Value& json, const LocationScope& l) {
        VkSampleLocationsInfoEXT s{};
        s.sampleLocationsPerPixel =
            parse_VkSampleCountFlagBits(json["sampleLocationsPerPixel"], CreateScope("sampleLocationsPerPixel"));
        s.sampleLocationGridSize = parse_VkExtent2D_contents(json["sampleLocationGridSize"], CreateScope("sampleLocationGridSize"));
        s.sampleLocationsCount = parse_uint32_t(json["sampleLocationsCount"], CreateScope("sampleLocationsCount"));
        s.pSampleLocations = parse_VkSampleLocationEXT_array(json["pSampleLocations"], CreateScope("pSampleLocations"));
        return s;
    }

    VkPipelineSampleLocationsStateCreateInfoEXT parse_VkPipelineSampleLocationsStateCreateInfoEXT_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPipelineSampleLocationsStateCreateInfoEXT s{};
        s.sampleLocationsEnable = parse_VkBool32(json["sampleLocationsEnable"], CreateScope("sampleLocationsEnable"));
        s.sampleLocationsInfo = parse_VkSampleLocationsInfoEXT(json["sampleLocationsInfo"], CreateScope("sampleLocationsInfo"));
        return s;
    }

    VkPipelineMultisampleStateCreateInfo* parse_VkPipelineMultisampleStateCreateInfo_pointer(const Json::Value& json,
                                                                                             const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<VkPipelineMultisampleStateCreateInfo>(1);
        dst_buffer[0] = parse_VkPipelineMultisampleStateCreateInfo(json, l);

        return dst_buffer;
    }

    VkStencilOpState parse_VkStencilOpState_contents(const Json::Value& json, const LocationScope& l) {
        VkStencilOpState s{};
        s.failOp = parse_VkStencilOp(json["failOp"], CreateScope("failOp"));
        s.passOp = parse_VkStencilOp(json["passOp"], CreateScope("passOp"));
        s.depthFailOp = parse_VkStencilOp(json["depthFailOp"], CreateScope("depthFailOp"));
        s.compareOp = parse_VkCompareOp(json["compareOp"], CreateScope("compareOp"));
        s.compareMask = parse_uint32_t(json["compareMask"], CreateScope("compareMask"));
        s.writeMask = parse_uint32_t(json["writeMask"], CreateScope("writeMask"));
        s.reference = parse_uint32_t(json["reference"], CreateScope("reference"));
        return s;
    }

    VkPipelineDepthStencilStateCreateInfo parse_VkPipelineDepthStencilStateCreateInfo_contents(const Json::Value& json,
                                                                                               const LocationScope& l) {
        VkPipelineDepthStencilStateCreateInfo s{};
        s.flags = parse_VkPipelineDepthStencilStateCreateFlags(json["flags"], CreateScope("flags"));
        s.depthTestEnable = parse_VkBool32(json["depthTestEnable"], CreateScope("depthTestEnable"));
        s.depthWriteEnable = parse_VkBool32(json["depthWriteEnable"], CreateScope("depthWriteEnable"));
        s.depthCompareOp = parse_VkCompareOp(json["depthCompareOp"], CreateScope("depthCompareOp"));
        s.depthBoundsTestEnable = parse_VkBool32(json["depthBoundsTestEnable"], CreateScope("depthBoundsTestEnable"));
        s.stencilTestEnable = parse_VkBool32(json["stencilTestEnable"], CreateScope("stencilTestEnable"));
        s.front = parse_VkStencilOpState_contents(json["front"], CreateScope("front"));
        s.back = parse_VkStencilOpState_contents(json["back"], CreateScope("back"));
        s.minDepthBounds = parse_float(json["minDepthBounds"], CreateScope("minDepthBounds"));
        s.maxDepthBounds = parse_float(json["maxDepthBounds"], CreateScope("maxDepthBounds"));
        return s;
    }

    VkPipelineDepthStencilStateCreateInfo* parse_VkPipelineDepthStencilStateCreateInfo_pointer(const Json::Value& json,
                                                                                               const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<VkPipelineDepthStencilStateCreateInfo>(1);
        dst_buffer[0] = parse_VkPipelineDepthStencilStateCreateInfo(json, l);

        return dst_buffer;
    }

    VkPipelineColorBlendAttachmentState parse_VkPipelineColorBlendAttachmentState_contents(const Json::Value& json,
                                                                                           const LocationScope& l) {
        VkPipelineColorBlendAttachmentState s{};
        s.blendEnable = parse_VkBool32(json["blendEnable"], CreateScope("blendEnable"));
        s.srcColorBlendFactor = parse_VkBlendFactor(json["srcColorBlendFactor"], CreateScope("srcColorBlendFactor"));
        s.dstColorBlendFactor = parse_VkBlendFactor(json["dstColorBlendFactor"], CreateScope("dstColorBlendFactor"));
        s.colorBlendOp = parse_VkBlendOp(json["colorBlendOp"], CreateScope("colorBlendOp"));
        s.srcAlphaBlendFactor = parse_VkBlendFactor(json["srcAlphaBlendFactor"], CreateScope("srcAlphaBlendFactor"));
        s.dstAlphaBlendFactor = parse_VkBlendFactor(json["dstAlphaBlendFactor"], CreateScope("dstAlphaBlendFactor"));
        s.alphaBlendOp = parse_VkBlendOp(json["alphaBlendOp"], CreateScope("alphaBlendOp"));
        s.colorWriteMask = parse_VkColorComponentFlags(json["colorWriteMask"], CreateScope("colorWriteMask"));
        return s;
    }

    VkPipelineColorBlendAttachmentState* parse_VkPipelineColorBlendAttachmentState_array(const Json::Value& json,
                                                                                         const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkPipelineColorBlendAttachmentState>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkPipelineColorBlendAttachmentState_contents(json[i], l);
        }

        return dst_buffer;
    }

    void parse_float_fixed_size_array(float* dst, const Json::Value& json, const LocationScope& l) {
        if (!json.isArray()) {
            Error() << "Not an array";
            return;
        }

        auto count = json.size();
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst[i] = parse_float(json[i], l);
        }
    }

    VkPipelineColorBlendStateCreateInfo parse_VkPipelineColorBlendStateCreateInfo_contents(const Json::Value& json,
                                                                                           const LocationScope& l) {
        VkPipelineColorBlendStateCreateInfo s{};
        s.flags = parse_VkPipelineColorBlendStateCreateFlags(json["flags"], CreateScope("flags"));
        s.logicOpEnable = parse_VkBool32(json["logicOpEnable"], CreateScope("logicOpEnable"));
        s.logicOp = parse_VkLogicOp(json["logicOp"], CreateScope("logicOp"));
        s.attachmentCount = parse_uint32_t(json["attachmentCount"], CreateScope("attachmentCount"));
        s.pAttachments = parse_VkPipelineColorBlendAttachmentState_array(json["pAttachments"], CreateScope("pAttachments"));
        parse_float_fixed_size_array(s.blendConstants, json["blendConstants"], CreateScope("blendConstants"));
        return s;
    }

    VkPipelineColorBlendAdvancedStateCreateInfoEXT parse_VkPipelineColorBlendAdvancedStateCreateInfoEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineColorBlendAdvancedStateCreateInfoEXT s{};
        s.srcPremultiplied = parse_VkBool32(json["srcPremultiplied"], CreateScope("srcPremultiplied"));
        s.dstPremultiplied = parse_VkBool32(json["dstPremultiplied"], CreateScope("dstPremultiplied"));
        s.blendOverlap = parse_VkBlendOverlapEXT(json["blendOverlap"], CreateScope("blendOverlap"));
        return s;
    }

    VkBool32* parse_VkBool32_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkBool32>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkBool32(json[i], l);
        }

        return dst_buffer;
    }

    VkPipelineColorWriteCreateInfoEXT parse_VkPipelineColorWriteCreateInfoEXT_contents(const Json::Value& json,
                                                                                       const LocationScope& l) {
        VkPipelineColorWriteCreateInfoEXT s{};
        s.attachmentCount = parse_uint32_t(json["attachmentCount"], CreateScope("attachmentCount"));
        s.pColorWriteEnables = parse_VkBool32_array(json["pColorWriteEnables"], CreateScope("pColorWriteEnables"));
        return s;
    }

    VkPipelineColorBlendStateCreateInfo* parse_VkPipelineColorBlendStateCreateInfo_pointer(const Json::Value& json,
                                                                                           const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<VkPipelineColorBlendStateCreateInfo>(1);
        dst_buffer[0] = parse_VkPipelineColorBlendStateCreateInfo(json, l);

        return dst_buffer;
    }

    VkDynamicState* parse_VkDynamicState_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkDynamicState>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkDynamicState(json[i], l);
        }

        return dst_buffer;
    }

    VkPipelineDynamicStateCreateInfo parse_VkPipelineDynamicStateCreateInfo_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkPipelineDynamicStateCreateInfo s{};
        s.flags = parse_VkPipelineDynamicStateCreateFlags(json["flags"], CreateScope("flags"));
        s.dynamicStateCount = parse_uint32_t(json["dynamicStateCount"], CreateScope("dynamicStateCount"));
        s.pDynamicStates = parse_VkDynamicState_array(json["pDynamicStates"], CreateScope("pDynamicStates"));
        return s;
    }

    VkPipelineDynamicStateCreateInfo* parse_VkPipelineDynamicStateCreateInfo_pointer(const Json::Value& json,
                                                                                     const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<VkPipelineDynamicStateCreateInfo>(1);
        dst_buffer[0] = parse_VkPipelineDynamicStateCreateInfo(json, l);

        return dst_buffer;
    }

    VkGraphicsPipelineCreateInfo parse_VkGraphicsPipelineCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkGraphicsPipelineCreateInfo s{};
        s.flags = parse_VkPipelineCreateFlags(json["flags"], CreateScope("flags"));
        s.stageCount = parse_uint32_t(json["stageCount"], CreateScope("stageCount"));
        s.pStages = parse_VkPipelineShaderStageCreateInfo_array(json["pStages"], CreateScope("pStages"));
        s.pVertexInputState =
            parse_VkPipelineVertexInputStateCreateInfo_pointer(json["pVertexInputState"], CreateScope("pVertexInputState"));
        s.pInputAssemblyState =
            parse_VkPipelineInputAssemblyStateCreateInfo_pointer(json["pInputAssemblyState"], CreateScope("pInputAssemblyState"));
        s.pTessellationState =
            parse_VkPipelineTessellationStateCreateInfo_pointer(json["pTessellationState"], CreateScope("pTessellationState"));
        s.pViewportState = parse_VkPipelineViewportStateCreateInfo_pointer(json["pViewportState"], CreateScope("pViewportState"));
        s.pRasterizationState =
            parse_VkPipelineRasterizationStateCreateInfo_pointer(json["pRasterizationState"], CreateScope("pRasterizationState"));
        s.pMultisampleState =
            parse_VkPipelineMultisampleStateCreateInfo_pointer(json["pMultisampleState"], CreateScope("pMultisampleState"));
        s.pDepthStencilState =
            parse_VkPipelineDepthStencilStateCreateInfo_pointer(json["pDepthStencilState"], CreateScope("pDepthStencilState"));
        s.pColorBlendState =
            parse_VkPipelineColorBlendStateCreateInfo_pointer(json["pColorBlendState"], CreateScope("pColorBlendState"));
        s.pDynamicState = parse_VkPipelineDynamicStateCreateInfo_pointer(json["pDynamicState"], CreateScope("pDynamicState"));
        s.layout = parse_VkPipelineLayout(json["layout"], CreateScope("layout"));
        s.renderPass = parse_VkRenderPass(json["renderPass"], CreateScope("renderPass"));
        s.subpass = parse_uint32_t(json["subpass"], CreateScope("subpass"));
        s.basePipelineHandle = parse_VkPipeline(json["basePipelineHandle"], CreateScope("basePipelineHandle"));
        s.basePipelineIndex = parse_int32_t(json["basePipelineIndex"], CreateScope("basePipelineIndex"));
        return s;
    }

    VkPipelineCreateFlags2CreateInfo parse_VkPipelineCreateFlags2CreateInfo_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkPipelineCreateFlags2CreateInfo s{};
        s.flags = parse_VkPipelineCreateFlags2(json["flags"], CreateScope("flags"));
        return s;
    }

    VkPipelineCreationFeedback parse_VkPipelineCreationFeedback_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelineCreationFeedback s{};
        s.flags = parse_VkPipelineCreationFeedbackFlags(json["flags"], CreateScope("flags"));
        s.duration = parse_uint64_t(json["duration"], CreateScope("duration"));
        return s;
    }

    VkPipelineCreationFeedback* parse_VkPipelineCreationFeedback_pointer(const Json::Value& json, const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<VkPipelineCreationFeedback>(1);
        dst_buffer[0] = parse_VkPipelineCreationFeedback_contents(json, l);

        return dst_buffer;
    }

    VkPipelineCreationFeedback* parse_VkPipelineCreationFeedback_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkPipelineCreationFeedback>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkPipelineCreationFeedback_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkPipelineCreationFeedbackCreateInfo parse_VkPipelineCreationFeedbackCreateInfo_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPipelineCreationFeedbackCreateInfo s{};
        s.pPipelineCreationFeedback =
            parse_VkPipelineCreationFeedback_pointer(json["pPipelineCreationFeedback"], CreateScope("pPipelineCreationFeedback"));
        s.pipelineStageCreationFeedbackCount =
            parse_uint32_t(json["pipelineStageCreationFeedbackCount"], CreateScope("pipelineStageCreationFeedbackCount"));
        s.pPipelineStageCreationFeedbacks = parse_VkPipelineCreationFeedback_array(json["pPipelineStageCreationFeedbacks"],
                                                                                   CreateScope("pPipelineStageCreationFeedbacks"));
        return s;
    }

    VkPipelineDiscardRectangleStateCreateInfoEXT parse_VkPipelineDiscardRectangleStateCreateInfoEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineDiscardRectangleStateCreateInfoEXT s{};
        s.flags = parse_VkPipelineDiscardRectangleStateCreateFlagsEXT(json["flags"], CreateScope("flags"));
        s.discardRectangleMode = parse_VkDiscardRectangleModeEXT(json["discardRectangleMode"], CreateScope("discardRectangleMode"));
        s.discardRectangleCount = parse_uint32_t(json["discardRectangleCount"], CreateScope("discardRectangleCount"));
        s.pDiscardRectangles = parse_VkRect2D_array(json["pDiscardRectangles"], CreateScope("pDiscardRectangles"));
        return s;
    }

    void parse_VkFragmentShadingRateCombinerOpKHR_fixed_size_array(VkFragmentShadingRateCombinerOpKHR* dst, const Json::Value& json,
                                                                   const LocationScope& l) {
        if (!json.isArray()) {
            Error() << "Not an array";
            return;
        }

        auto count = json.size();
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst[i] = parse_VkFragmentShadingRateCombinerOpKHR(json[i], l);
        }
    }

    VkPipelineFragmentShadingRateStateCreateInfoKHR parse_VkPipelineFragmentShadingRateStateCreateInfoKHR_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineFragmentShadingRateStateCreateInfoKHR s{};
        s.fragmentSize = parse_VkExtent2D_contents(json["fragmentSize"], CreateScope("fragmentSize"));
        parse_VkFragmentShadingRateCombinerOpKHR_fixed_size_array(s.combinerOps, json["combinerOps"], CreateScope("combinerOps"));
        return s;
    }

    void parse_uint8_t_fixed_size_array(uint8_t* dst, const Json::Value& json, const LocationScope& l) {
        if (!json.isArray()) {
            Error() << "Not an array";
            return;
        }

        auto count = json.size();
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst[i] = parse_uint8_t(json[i], l);
        }
    }

    VkPipelineOfflineCreateInfo parse_VkPipelineOfflineCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelineOfflineCreateInfo s{};
        parse_uint8_t_fixed_size_array(s.pipelineIdentifier, json["pipelineIdentifier"], CreateScope("pipelineIdentifier"));
        s.matchControl = parse_VkPipelineMatchControl(json["matchControl"], CreateScope("matchControl"));
        s.poolEntrySize = parse_VkDeviceSize(json["poolEntrySize"], CreateScope("poolEntrySize"));
        return s;
    }

    VkFormat* parse_VkFormat_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkFormat>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkFormat(json[i], l);
        }

        return dst_buffer;
    }

    VkPipelineRenderingCreateInfo parse_VkPipelineRenderingCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelineRenderingCreateInfo s{};
        s.viewMask = parse_uint32_t(json["viewMask"], CreateScope("viewMask"));
        s.colorAttachmentCount = parse_uint32_t(json["colorAttachmentCount"], CreateScope("colorAttachmentCount"));
        s.pColorAttachmentFormats = parse_VkFormat_array(json["pColorAttachmentFormats"], CreateScope("pColorAttachmentFormats"));
        s.depthAttachmentFormat = parse_VkFormat(json["depthAttachmentFormat"], CreateScope("depthAttachmentFormat"));
        s.stencilAttachmentFormat = parse_VkFormat(json["stencilAttachmentFormat"], CreateScope("stencilAttachmentFormat"));
        return s;
    }

    uint32_t* parse_uint32_t_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<uint32_t>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_uint32_t(json[i], l);
        }

        return dst_buffer;
    }

    VkRenderingAttachmentLocationInfo parse_VkRenderingAttachmentLocationInfo_contents(const Json::Value& json,
                                                                                       const LocationScope& l) {
        VkRenderingAttachmentLocationInfo s{};
        s.colorAttachmentCount = parse_uint32_t(json["colorAttachmentCount"], CreateScope("colorAttachmentCount"));
        s.pColorAttachmentLocations =
            parse_uint32_t_array(json["pColorAttachmentLocations"], CreateScope("pColorAttachmentLocations"));
        return s;
    }

    uint32_t* parse_uint32_t_pointer(const Json::Value& json, const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<uint32_t>(1);
        dst_buffer[0] = parse_uint32_t(json, l);

        return dst_buffer;
    }

    VkRenderingInputAttachmentIndexInfo parse_VkRenderingInputAttachmentIndexInfo_contents(const Json::Value& json,
                                                                                           const LocationScope& l) {
        VkRenderingInputAttachmentIndexInfo s{};
        s.colorAttachmentCount = parse_uint32_t(json["colorAttachmentCount"], CreateScope("colorAttachmentCount"));
        s.pColorAttachmentInputIndices =
            parse_uint32_t_array(json["pColorAttachmentInputIndices"], CreateScope("pColorAttachmentInputIndices"));
        s.pDepthInputAttachmentIndex =
            parse_uint32_t_pointer(json["pDepthInputAttachmentIndex"], CreateScope("pDepthInputAttachmentIndex"));
        s.pStencilInputAttachmentIndex =
            parse_uint32_t_pointer(json["pStencilInputAttachmentIndex"], CreateScope("pStencilInputAttachmentIndex"));
        return s;
    }

    VkComputePipelineCreateInfo parse_VkComputePipelineCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkComputePipelineCreateInfo s{};
        s.flags = parse_VkPipelineCreateFlags(json["flags"], CreateScope("flags"));
        s.stage = parse_VkPipelineShaderStageCreateInfo(json["stage"], CreateScope("stage"));
        s.layout = parse_VkPipelineLayout(json["layout"], CreateScope("layout"));
        s.basePipelineHandle = parse_VkPipeline(json["basePipelineHandle"], CreateScope("basePipelineHandle"));
        s.basePipelineIndex = parse_int32_t(json["basePipelineIndex"], CreateScope("basePipelineIndex"));
        return s;
    }

    VkComponentMapping parse_VkComponentMapping_contents(const Json::Value& json, const LocationScope& l) {
        VkComponentMapping s{};
        s.r = parse_VkComponentSwizzle(json["r"], CreateScope("r"));
        s.g = parse_VkComponentSwizzle(json["g"], CreateScope("g"));
        s.b = parse_VkComponentSwizzle(json["b"], CreateScope("b"));
        s.a = parse_VkComponentSwizzle(json["a"], CreateScope("a"));
        return s;
    }

    VkSamplerYcbcrConversionCreateInfo parse_VkSamplerYcbcrConversionCreateInfo_contents(const Json::Value& json,
                                                                                         const LocationScope& l) {
        VkSamplerYcbcrConversionCreateInfo s{};
        s.format = parse_VkFormat(json["format"], CreateScope("format"));
        s.ycbcrModel = parse_VkSamplerYcbcrModelConversion(json["ycbcrModel"], CreateScope("ycbcrModel"));
        s.ycbcrRange = parse_VkSamplerYcbcrRange(json["ycbcrRange"], CreateScope("ycbcrRange"));
        s.components = parse_VkComponentMapping_contents(json["components"], CreateScope("components"));
        s.xChromaOffset = parse_VkChromaLocation(json["xChromaOffset"], CreateScope("xChromaOffset"));
        s.yChromaOffset = parse_VkChromaLocation(json["yChromaOffset"], CreateScope("yChromaOffset"));
        s.chromaFilter = parse_VkFilter(json["chromaFilter"], CreateScope("chromaFilter"));
        s.forceExplicitReconstruction =
            parse_VkBool32(json["forceExplicitReconstruction"], CreateScope("forceExplicitReconstruction"));
        return s;
    }

#ifdef VK_USE_PLATFORM_SCREEN_QNX

    VkExternalFormatQNX parse_VkExternalFormatQNX_contents(const Json::Value& json, const LocationScope& l) {
        VkExternalFormatQNX s{};
        s.externalFormat = parse_uint64_t(json["externalFormat"], CreateScope("externalFormat"));
        return s;
    }
#endif  // VK_USE_PLATFORM_SCREEN_QNX

    VkSamplerCreateInfo parse_VkSamplerCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkSamplerCreateInfo s{};
        s.flags = parse_VkSamplerCreateFlags(json["flags"], CreateScope("flags"));
        s.magFilter = parse_VkFilter(json["magFilter"], CreateScope("magFilter"));
        s.minFilter = parse_VkFilter(json["minFilter"], CreateScope("minFilter"));
        s.mipmapMode = parse_VkSamplerMipmapMode(json["mipmapMode"], CreateScope("mipmapMode"));
        s.addressModeU = parse_VkSamplerAddressMode(json["addressModeU"], CreateScope("addressModeU"));
        s.addressModeV = parse_VkSamplerAddressMode(json["addressModeV"], CreateScope("addressModeV"));
        s.addressModeW = parse_VkSamplerAddressMode(json["addressModeW"], CreateScope("addressModeW"));
        s.mipLodBias = parse_float(json["mipLodBias"], CreateScope("mipLodBias"));
        s.anisotropyEnable = parse_VkBool32(json["anisotropyEnable"], CreateScope("anisotropyEnable"));
        s.maxAnisotropy = parse_float(json["maxAnisotropy"], CreateScope("maxAnisotropy"));
        s.compareEnable = parse_VkBool32(json["compareEnable"], CreateScope("compareEnable"));
        s.compareOp = parse_VkCompareOp(json["compareOp"], CreateScope("compareOp"));
        s.minLod = parse_float(json["minLod"], CreateScope("minLod"));
        s.maxLod = parse_float(json["maxLod"], CreateScope("maxLod"));
        s.borderColor = parse_VkBorderColor(json["borderColor"], CreateScope("borderColor"));
        s.unnormalizedCoordinates = parse_VkBool32(json["unnormalizedCoordinates"], CreateScope("unnormalizedCoordinates"));
        return s;
    }

    void parse_int32_t_fixed_size_array(int32_t* dst, const Json::Value& json, const LocationScope& l) {
        if (!json.isArray()) {
            Error() << "Not an array";
            return;
        }

        auto count = json.size();
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst[i] = parse_int32_t(json[i], l);
        }
    }

    void parse_uint32_t_fixed_size_array(uint32_t* dst, const Json::Value& json, const LocationScope& l) {
        if (!json.isArray()) {
            Error() << "Not an array";
            return;
        }

        auto count = json.size();
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst[i] = parse_uint32_t(json[i], l);
        }
    }

    VkClearColorValue parse_VkClearColorValue_contents(const Json::Value& json, const LocationScope& l) {
        VkClearColorValue s{};
        parse_float_fixed_size_array(s.float32, json["float32"], CreateScope("float32"));
        parse_int32_t_fixed_size_array(s.int32, json["int32"], CreateScope("int32"));
        parse_uint32_t_fixed_size_array(s.uint32, json["uint32"], CreateScope("uint32"));
        return s;
    }

    VkSamplerCustomBorderColorCreateInfoEXT parse_VkSamplerCustomBorderColorCreateInfoEXT_contents(const Json::Value& json,
                                                                                                   const LocationScope& l) {
        VkSamplerCustomBorderColorCreateInfoEXT s{};
        s.customBorderColor = parse_VkClearColorValue_contents(json["customBorderColor"], CreateScope("customBorderColor"));
        s.format = parse_VkFormat(json["format"], CreateScope("format"));
        return s;
    }

    VkSamplerReductionModeCreateInfo parse_VkSamplerReductionModeCreateInfo_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkSamplerReductionModeCreateInfo s{};
        s.reductionMode = parse_VkSamplerReductionMode(json["reductionMode"], CreateScope("reductionMode"));
        return s;
    }

    VkSamplerYcbcrConversionInfo parse_VkSamplerYcbcrConversionInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkSamplerYcbcrConversionInfo s{};
        s.conversion = parse_VkSamplerYcbcrConversion(json["conversion"], CreateScope("conversion"));
        return s;
    }

    VkSampler* parse_VkSampler_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkSampler>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkSampler(json[i], l);
        }

        return dst_buffer;
    }

    VkDescriptorSetLayoutBinding parse_VkDescriptorSetLayoutBinding_contents(const Json::Value& json, const LocationScope& l) {
        VkDescriptorSetLayoutBinding s{};
        s.binding = parse_uint32_t(json["binding"], CreateScope("binding"));
        s.descriptorType = parse_VkDescriptorType(json["descriptorType"], CreateScope("descriptorType"));
        s.descriptorCount = parse_uint32_t(json["descriptorCount"], CreateScope("descriptorCount"));
        s.stageFlags = parse_VkShaderStageFlags(json["stageFlags"], CreateScope("stageFlags"));
        s.pImmutableSamplers = parse_VkSampler_array(json["pImmutableSamplers"], CreateScope("pImmutableSamplers"));
        return s;
    }

    VkDescriptorSetLayoutBinding* parse_VkDescriptorSetLayoutBinding_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkDescriptorSetLayoutBinding>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkDescriptorSetLayoutBinding_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkDescriptorSetLayoutCreateInfo parse_VkDescriptorSetLayoutCreateInfo_contents(const Json::Value& json,
                                                                                   const LocationScope& l) {
        VkDescriptorSetLayoutCreateInfo s{};
        s.flags = parse_VkDescriptorSetLayoutCreateFlags(json["flags"], CreateScope("flags"));
        s.bindingCount = parse_uint32_t(json["bindingCount"], CreateScope("bindingCount"));
        s.pBindings = parse_VkDescriptorSetLayoutBinding_array(json["pBindings"], CreateScope("pBindings"));
        return s;
    }

    VkDescriptorBindingFlags* parse_VkDescriptorBindingFlags_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkDescriptorBindingFlags>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkDescriptorBindingFlags(json[i], l);
        }

        return dst_buffer;
    }

    VkDescriptorSetLayoutBindingFlagsCreateInfo parse_VkDescriptorSetLayoutBindingFlagsCreateInfo_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkDescriptorSetLayoutBindingFlagsCreateInfo s{};
        s.bindingCount = parse_uint32_t(json["bindingCount"], CreateScope("bindingCount"));
        s.pBindingFlags = parse_VkDescriptorBindingFlags_array(json["pBindingFlags"], CreateScope("pBindingFlags"));
        return s;
    }

    VkDescriptorSetLayout* parse_VkDescriptorSetLayout_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkDescriptorSetLayout>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkDescriptorSetLayout(json[i], l);
        }

        return dst_buffer;
    }

    VkPushConstantRange parse_VkPushConstantRange_contents(const Json::Value& json, const LocationScope& l) {
        VkPushConstantRange s{};
        s.stageFlags = parse_VkShaderStageFlags(json["stageFlags"], CreateScope("stageFlags"));
        s.offset = parse_uint32_t(json["offset"], CreateScope("offset"));
        s.size = parse_uint32_t(json["size"], CreateScope("size"));
        return s;
    }

    VkPushConstantRange* parse_VkPushConstantRange_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkPushConstantRange>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkPushConstantRange_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkPipelineLayoutCreateInfo parse_VkPipelineLayoutCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelineLayoutCreateInfo s{};
        s.flags = parse_VkPipelineLayoutCreateFlags(json["flags"], CreateScope("flags"));
        s.setLayoutCount = parse_uint32_t(json["setLayoutCount"], CreateScope("setLayoutCount"));
        s.pSetLayouts = parse_VkDescriptorSetLayout_array(json["pSetLayouts"], CreateScope("pSetLayouts"));
        s.pushConstantRangeCount = parse_uint32_t(json["pushConstantRangeCount"], CreateScope("pushConstantRangeCount"));
        s.pPushConstantRanges = parse_VkPushConstantRange_array(json["pPushConstantRanges"], CreateScope("pPushConstantRanges"));
        return s;
    }

    VkPhysicalDeviceFeatures parse_VkPhysicalDeviceFeatures_contents(const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceFeatures s{};
        s.robustBufferAccess = parse_VkBool32(json["robustBufferAccess"], CreateScope("robustBufferAccess"));
        s.fullDrawIndexUint32 = parse_VkBool32(json["fullDrawIndexUint32"], CreateScope("fullDrawIndexUint32"));
        s.imageCubeArray = parse_VkBool32(json["imageCubeArray"], CreateScope("imageCubeArray"));
        s.independentBlend = parse_VkBool32(json["independentBlend"], CreateScope("independentBlend"));
        s.geometryShader = parse_VkBool32(json["geometryShader"], CreateScope("geometryShader"));
        s.tessellationShader = parse_VkBool32(json["tessellationShader"], CreateScope("tessellationShader"));
        s.sampleRateShading = parse_VkBool32(json["sampleRateShading"], CreateScope("sampleRateShading"));
        s.dualSrcBlend = parse_VkBool32(json["dualSrcBlend"], CreateScope("dualSrcBlend"));
        s.logicOp = parse_VkBool32(json["logicOp"], CreateScope("logicOp"));
        s.multiDrawIndirect = parse_VkBool32(json["multiDrawIndirect"], CreateScope("multiDrawIndirect"));
        s.drawIndirectFirstInstance = parse_VkBool32(json["drawIndirectFirstInstance"], CreateScope("drawIndirectFirstInstance"));
        s.depthClamp = parse_VkBool32(json["depthClamp"], CreateScope("depthClamp"));
        s.depthBiasClamp = parse_VkBool32(json["depthBiasClamp"], CreateScope("depthBiasClamp"));
        s.fillModeNonSolid = parse_VkBool32(json["fillModeNonSolid"], CreateScope("fillModeNonSolid"));
        s.depthBounds = parse_VkBool32(json["depthBounds"], CreateScope("depthBounds"));
        s.wideLines = parse_VkBool32(json["wideLines"], CreateScope("wideLines"));
        s.largePoints = parse_VkBool32(json["largePoints"], CreateScope("largePoints"));
        s.alphaToOne = parse_VkBool32(json["alphaToOne"], CreateScope("alphaToOne"));
        s.multiViewport = parse_VkBool32(json["multiViewport"], CreateScope("multiViewport"));
        s.samplerAnisotropy = parse_VkBool32(json["samplerAnisotropy"], CreateScope("samplerAnisotropy"));
        s.textureCompressionETC2 = parse_VkBool32(json["textureCompressionETC2"], CreateScope("textureCompressionETC2"));
        s.textureCompressionASTC_LDR =
            parse_VkBool32(json["textureCompressionASTC_LDR"], CreateScope("textureCompressionASTC_LDR"));
        s.textureCompressionBC = parse_VkBool32(json["textureCompressionBC"], CreateScope("textureCompressionBC"));
        s.occlusionQueryPrecise = parse_VkBool32(json["occlusionQueryPrecise"], CreateScope("occlusionQueryPrecise"));
        s.pipelineStatisticsQuery = parse_VkBool32(json["pipelineStatisticsQuery"], CreateScope("pipelineStatisticsQuery"));
        s.vertexPipelineStoresAndAtomics =
            parse_VkBool32(json["vertexPipelineStoresAndAtomics"], CreateScope("vertexPipelineStoresAndAtomics"));
        s.fragmentStoresAndAtomics = parse_VkBool32(json["fragmentStoresAndAtomics"], CreateScope("fragmentStoresAndAtomics"));
        s.shaderTessellationAndGeometryPointSize =
            parse_VkBool32(json["shaderTessellationAndGeometryPointSize"], CreateScope("shaderTessellationAndGeometryPointSize"));
        s.shaderImageGatherExtended = parse_VkBool32(json["shaderImageGatherExtended"], CreateScope("shaderImageGatherExtended"));
        s.shaderStorageImageExtendedFormats =
            parse_VkBool32(json["shaderStorageImageExtendedFormats"], CreateScope("shaderStorageImageExtendedFormats"));
        s.shaderStorageImageMultisample =
            parse_VkBool32(json["shaderStorageImageMultisample"], CreateScope("shaderStorageImageMultisample"));
        s.shaderStorageImageReadWithoutFormat =
            parse_VkBool32(json["shaderStorageImageReadWithoutFormat"], CreateScope("shaderStorageImageReadWithoutFormat"));
        s.shaderStorageImageWriteWithoutFormat =
            parse_VkBool32(json["shaderStorageImageWriteWithoutFormat"], CreateScope("shaderStorageImageWriteWithoutFormat"));
        s.shaderUniformBufferArrayDynamicIndexing =
            parse_VkBool32(json["shaderUniformBufferArrayDynamicIndexing"], CreateScope("shaderUniformBufferArrayDynamicIndexing"));
        s.shaderSampledImageArrayDynamicIndexing =
            parse_VkBool32(json["shaderSampledImageArrayDynamicIndexing"], CreateScope("shaderSampledImageArrayDynamicIndexing"));
        s.shaderStorageBufferArrayDynamicIndexing =
            parse_VkBool32(json["shaderStorageBufferArrayDynamicIndexing"], CreateScope("shaderStorageBufferArrayDynamicIndexing"));
        s.shaderStorageImageArrayDynamicIndexing =
            parse_VkBool32(json["shaderStorageImageArrayDynamicIndexing"], CreateScope("shaderStorageImageArrayDynamicIndexing"));
        s.shaderClipDistance = parse_VkBool32(json["shaderClipDistance"], CreateScope("shaderClipDistance"));
        s.shaderCullDistance = parse_VkBool32(json["shaderCullDistance"], CreateScope("shaderCullDistance"));
        s.shaderFloat64 = parse_VkBool32(json["shaderFloat64"], CreateScope("shaderFloat64"));
        s.shaderInt64 = parse_VkBool32(json["shaderInt64"], CreateScope("shaderInt64"));
        s.shaderInt16 = parse_VkBool32(json["shaderInt16"], CreateScope("shaderInt16"));
        s.shaderResourceResidency = parse_VkBool32(json["shaderResourceResidency"], CreateScope("shaderResourceResidency"));
        s.shaderResourceMinLod = parse_VkBool32(json["shaderResourceMinLod"], CreateScope("shaderResourceMinLod"));
        s.sparseBinding = parse_VkBool32(json["sparseBinding"], CreateScope("sparseBinding"));
        s.sparseResidencyBuffer = parse_VkBool32(json["sparseResidencyBuffer"], CreateScope("sparseResidencyBuffer"));
        s.sparseResidencyImage2D = parse_VkBool32(json["sparseResidencyImage2D"], CreateScope("sparseResidencyImage2D"));
        s.sparseResidencyImage3D = parse_VkBool32(json["sparseResidencyImage3D"], CreateScope("sparseResidencyImage3D"));
        s.sparseResidency2Samples = parse_VkBool32(json["sparseResidency2Samples"], CreateScope("sparseResidency2Samples"));
        s.sparseResidency4Samples = parse_VkBool32(json["sparseResidency4Samples"], CreateScope("sparseResidency4Samples"));
        s.sparseResidency8Samples = parse_VkBool32(json["sparseResidency8Samples"], CreateScope("sparseResidency8Samples"));
        s.sparseResidency16Samples = parse_VkBool32(json["sparseResidency16Samples"], CreateScope("sparseResidency16Samples"));
        s.sparseResidencyAliased = parse_VkBool32(json["sparseResidencyAliased"], CreateScope("sparseResidencyAliased"));
        s.variableMultisampleRate = parse_VkBool32(json["variableMultisampleRate"], CreateScope("variableMultisampleRate"));
        s.inheritedQueries = parse_VkBool32(json["inheritedQueries"], CreateScope("inheritedQueries"));
        return s;
    }

    VkPhysicalDeviceFeatures2 parse_VkPhysicalDeviceFeatures2_contents(const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceFeatures2 s{};
        s.features = parse_VkPhysicalDeviceFeatures_contents(json["features"], CreateScope("features"));
        return s;
    }

    VkPhysicalDevice16BitStorageFeatures parse_VkPhysicalDevice16BitStorageFeatures_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPhysicalDevice16BitStorageFeatures s{};
        s.storageBuffer16BitAccess = parse_VkBool32(json["storageBuffer16BitAccess"], CreateScope("storageBuffer16BitAccess"));
        s.uniformAndStorageBuffer16BitAccess =
            parse_VkBool32(json["uniformAndStorageBuffer16BitAccess"], CreateScope("uniformAndStorageBuffer16BitAccess"));
        s.storagePushConstant16 = parse_VkBool32(json["storagePushConstant16"], CreateScope("storagePushConstant16"));
        s.storageInputOutput16 = parse_VkBool32(json["storageInputOutput16"], CreateScope("storageInputOutput16"));
        return s;
    }

    VkPhysicalDevice4444FormatsFeaturesEXT parse_VkPhysicalDevice4444FormatsFeaturesEXT_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPhysicalDevice4444FormatsFeaturesEXT s{};
        s.formatA4R4G4B4 = parse_VkBool32(json["formatA4R4G4B4"], CreateScope("formatA4R4G4B4"));
        s.formatA4B4G4R4 = parse_VkBool32(json["formatA4B4G4R4"], CreateScope("formatA4B4G4R4"));
        return s;
    }

    VkPhysicalDevice8BitStorageFeatures parse_VkPhysicalDevice8BitStorageFeatures_contents(const Json::Value& json,
                                                                                           const LocationScope& l) {
        VkPhysicalDevice8BitStorageFeatures s{};
        s.storageBuffer8BitAccess = parse_VkBool32(json["storageBuffer8BitAccess"], CreateScope("storageBuffer8BitAccess"));
        s.uniformAndStorageBuffer8BitAccess =
            parse_VkBool32(json["uniformAndStorageBuffer8BitAccess"], CreateScope("uniformAndStorageBuffer8BitAccess"));
        s.storagePushConstant8 = parse_VkBool32(json["storagePushConstant8"], CreateScope("storagePushConstant8"));
        return s;
    }

    VkPhysicalDeviceASTCDecodeFeaturesEXT parse_VkPhysicalDeviceASTCDecodeFeaturesEXT_contents(const Json::Value& json,
                                                                                               const LocationScope& l) {
        VkPhysicalDeviceASTCDecodeFeaturesEXT s{};
        s.decodeModeSharedExponent = parse_VkBool32(json["decodeModeSharedExponent"], CreateScope("decodeModeSharedExponent"));
        return s;
    }

    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT parse_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT s{};
        s.advancedBlendCoherentOperations =
            parse_VkBool32(json["advancedBlendCoherentOperations"], CreateScope("advancedBlendCoherentOperations"));
        return s;
    }

    VkPhysicalDeviceBufferDeviceAddressFeatures parse_VkPhysicalDeviceBufferDeviceAddressFeatures_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPhysicalDeviceBufferDeviceAddressFeatures s{};
        s.bufferDeviceAddress = parse_VkBool32(json["bufferDeviceAddress"], CreateScope("bufferDeviceAddress"));
        s.bufferDeviceAddressCaptureReplay =
            parse_VkBool32(json["bufferDeviceAddressCaptureReplay"], CreateScope("bufferDeviceAddressCaptureReplay"));
        s.bufferDeviceAddressMultiDevice =
            parse_VkBool32(json["bufferDeviceAddressMultiDevice"], CreateScope("bufferDeviceAddressMultiDevice"));
        return s;
    }

    VkPhysicalDeviceColorWriteEnableFeaturesEXT parse_VkPhysicalDeviceColorWriteEnableFeaturesEXT_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPhysicalDeviceColorWriteEnableFeaturesEXT s{};
        s.colorWriteEnable = parse_VkBool32(json["colorWriteEnable"], CreateScope("colorWriteEnable"));
        return s;
    }

    VkPhysicalDeviceCustomBorderColorFeaturesEXT parse_VkPhysicalDeviceCustomBorderColorFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceCustomBorderColorFeaturesEXT s{};
        s.customBorderColors = parse_VkBool32(json["customBorderColors"], CreateScope("customBorderColors"));
        s.customBorderColorWithoutFormat =
            parse_VkBool32(json["customBorderColorWithoutFormat"], CreateScope("customBorderColorWithoutFormat"));
        return s;
    }

    VkPhysicalDeviceDepthClipEnableFeaturesEXT parse_VkPhysicalDeviceDepthClipEnableFeaturesEXT_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPhysicalDeviceDepthClipEnableFeaturesEXT s{};
        s.depthClipEnable = parse_VkBool32(json["depthClipEnable"], CreateScope("depthClipEnable"));
        return s;
    }

    VkPhysicalDeviceDescriptorIndexingFeatures parse_VkPhysicalDeviceDescriptorIndexingFeatures_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPhysicalDeviceDescriptorIndexingFeatures s{};
        s.shaderInputAttachmentArrayDynamicIndexing = parse_VkBool32(json["shaderInputAttachmentArrayDynamicIndexing"],
                                                                     CreateScope("shaderInputAttachmentArrayDynamicIndexing"));
        s.shaderUniformTexelBufferArrayDynamicIndexing = parse_VkBool32(
            json["shaderUniformTexelBufferArrayDynamicIndexing"], CreateScope("shaderUniformTexelBufferArrayDynamicIndexing"));
        s.shaderStorageTexelBufferArrayDynamicIndexing = parse_VkBool32(
            json["shaderStorageTexelBufferArrayDynamicIndexing"], CreateScope("shaderStorageTexelBufferArrayDynamicIndexing"));
        s.shaderUniformBufferArrayNonUniformIndexing = parse_VkBool32(json["shaderUniformBufferArrayNonUniformIndexing"],
                                                                      CreateScope("shaderUniformBufferArrayNonUniformIndexing"));
        s.shaderSampledImageArrayNonUniformIndexing = parse_VkBool32(json["shaderSampledImageArrayNonUniformIndexing"],
                                                                     CreateScope("shaderSampledImageArrayNonUniformIndexing"));
        s.shaderStorageBufferArrayNonUniformIndexing = parse_VkBool32(json["shaderStorageBufferArrayNonUniformIndexing"],
                                                                      CreateScope("shaderStorageBufferArrayNonUniformIndexing"));
        s.shaderStorageImageArrayNonUniformIndexing = parse_VkBool32(json["shaderStorageImageArrayNonUniformIndexing"],
                                                                     CreateScope("shaderStorageImageArrayNonUniformIndexing"));
        s.shaderInputAttachmentArrayNonUniformIndexing = parse_VkBool32(
            json["shaderInputAttachmentArrayNonUniformIndexing"], CreateScope("shaderInputAttachmentArrayNonUniformIndexing"));
        s.shaderUniformTexelBufferArrayNonUniformIndexing =
            parse_VkBool32(json["shaderUniformTexelBufferArrayNonUniformIndexing"],
                           CreateScope("shaderUniformTexelBufferArrayNonUniformIndexing"));
        s.shaderStorageTexelBufferArrayNonUniformIndexing =
            parse_VkBool32(json["shaderStorageTexelBufferArrayNonUniformIndexing"],
                           CreateScope("shaderStorageTexelBufferArrayNonUniformIndexing"));
        s.descriptorBindingUniformBufferUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingUniformBufferUpdateAfterBind"], CreateScope("descriptorBindingUniformBufferUpdateAfterBind"));
        s.descriptorBindingSampledImageUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingSampledImageUpdateAfterBind"], CreateScope("descriptorBindingSampledImageUpdateAfterBind"));
        s.descriptorBindingStorageImageUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingStorageImageUpdateAfterBind"], CreateScope("descriptorBindingStorageImageUpdateAfterBind"));
        s.descriptorBindingStorageBufferUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingStorageBufferUpdateAfterBind"], CreateScope("descriptorBindingStorageBufferUpdateAfterBind"));
        s.descriptorBindingUniformTexelBufferUpdateAfterBind =
            parse_VkBool32(json["descriptorBindingUniformTexelBufferUpdateAfterBind"],
                           CreateScope("descriptorBindingUniformTexelBufferUpdateAfterBind"));
        s.descriptorBindingStorageTexelBufferUpdateAfterBind =
            parse_VkBool32(json["descriptorBindingStorageTexelBufferUpdateAfterBind"],
                           CreateScope("descriptorBindingStorageTexelBufferUpdateAfterBind"));
        s.descriptorBindingUpdateUnusedWhilePending = parse_VkBool32(json["descriptorBindingUpdateUnusedWhilePending"],
                                                                     CreateScope("descriptorBindingUpdateUnusedWhilePending"));
        s.descriptorBindingPartiallyBound =
            parse_VkBool32(json["descriptorBindingPartiallyBound"], CreateScope("descriptorBindingPartiallyBound"));
        s.descriptorBindingVariableDescriptorCount = parse_VkBool32(json["descriptorBindingVariableDescriptorCount"],
                                                                    CreateScope("descriptorBindingVariableDescriptorCount"));
        s.runtimeDescriptorArray = parse_VkBool32(json["runtimeDescriptorArray"], CreateScope("runtimeDescriptorArray"));
        return s;
    }

    VkPhysicalDeviceDynamicRenderingFeatures parse_VkPhysicalDeviceDynamicRenderingFeatures_contents(const Json::Value& json,
                                                                                                     const LocationScope& l) {
        VkPhysicalDeviceDynamicRenderingFeatures s{};
        s.dynamicRendering = parse_VkBool32(json["dynamicRendering"], CreateScope("dynamicRendering"));
        return s;
    }

    VkPhysicalDeviceDynamicRenderingLocalReadFeatures parse_VkPhysicalDeviceDynamicRenderingLocalReadFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceDynamicRenderingLocalReadFeatures s{};
        s.dynamicRenderingLocalRead = parse_VkBool32(json["dynamicRenderingLocalRead"], CreateScope("dynamicRenderingLocalRead"));
        return s;
    }

    VkPhysicalDeviceExtendedDynamicState2FeaturesEXT parse_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceExtendedDynamicState2FeaturesEXT s{};
        s.extendedDynamicState2 = parse_VkBool32(json["extendedDynamicState2"], CreateScope("extendedDynamicState2"));
        s.extendedDynamicState2LogicOp =
            parse_VkBool32(json["extendedDynamicState2LogicOp"], CreateScope("extendedDynamicState2LogicOp"));
        s.extendedDynamicState2PatchControlPoints =
            parse_VkBool32(json["extendedDynamicState2PatchControlPoints"], CreateScope("extendedDynamicState2PatchControlPoints"));
        return s;
    }

    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT parse_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceExtendedDynamicStateFeaturesEXT s{};
        s.extendedDynamicState = parse_VkBool32(json["extendedDynamicState"], CreateScope("extendedDynamicState"));
        return s;
    }

#ifdef VK_USE_PLATFORM_SCI

    VkPhysicalDeviceExternalMemorySciBufFeaturesNV parse_VkPhysicalDeviceExternalMemorySciBufFeaturesNV_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceExternalMemorySciBufFeaturesNV s{};
        s.sciBufImport = parse_VkBool32(json["sciBufImport"], CreateScope("sciBufImport"));
        s.sciBufExport = parse_VkBool32(json["sciBufExport"], CreateScope("sciBufExport"));
        return s;
    }
#endif  // VK_USE_PLATFORM_SCI

#ifdef VK_USE_PLATFORM_SCREEN_QNX

    VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX parse_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX s{};
        s.screenBufferImport = parse_VkBool32(json["screenBufferImport"], CreateScope("screenBufferImport"));
        return s;
    }
#endif  // VK_USE_PLATFORM_SCREEN_QNX

#ifdef VK_USE_PLATFORM_SCI

    VkPhysicalDeviceExternalSciSync2FeaturesNV parse_VkPhysicalDeviceExternalSciSync2FeaturesNV_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPhysicalDeviceExternalSciSync2FeaturesNV s{};
        s.sciSyncFence = parse_VkBool32(json["sciSyncFence"], CreateScope("sciSyncFence"));
        s.sciSyncSemaphore2 = parse_VkBool32(json["sciSyncSemaphore2"], CreateScope("sciSyncSemaphore2"));
        s.sciSyncImport = parse_VkBool32(json["sciSyncImport"], CreateScope("sciSyncImport"));
        s.sciSyncExport = parse_VkBool32(json["sciSyncExport"], CreateScope("sciSyncExport"));
        return s;
    }
#endif  // VK_USE_PLATFORM_SCI

#ifdef VK_USE_PLATFORM_SCI

    VkPhysicalDeviceExternalSciSyncFeaturesNV parse_VkPhysicalDeviceExternalSciSyncFeaturesNV_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceExternalSciSyncFeaturesNV s{};
        s.sciSyncFence = parse_VkBool32(json["sciSyncFence"], CreateScope("sciSyncFence"));
        s.sciSyncSemaphore = parse_VkBool32(json["sciSyncSemaphore"], CreateScope("sciSyncSemaphore"));
        s.sciSyncImport = parse_VkBool32(json["sciSyncImport"], CreateScope("sciSyncImport"));
        s.sciSyncExport = parse_VkBool32(json["sciSyncExport"], CreateScope("sciSyncExport"));
        return s;
    }
#endif  // VK_USE_PLATFORM_SCI

    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT parse_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT s{};
        s.fragmentShaderSampleInterlock =
            parse_VkBool32(json["fragmentShaderSampleInterlock"], CreateScope("fragmentShaderSampleInterlock"));
        s.fragmentShaderPixelInterlock =
            parse_VkBool32(json["fragmentShaderPixelInterlock"], CreateScope("fragmentShaderPixelInterlock"));
        s.fragmentShaderShadingRateInterlock =
            parse_VkBool32(json["fragmentShaderShadingRateInterlock"], CreateScope("fragmentShaderShadingRateInterlock"));
        return s;
    }

    VkPhysicalDeviceFragmentShadingRateFeaturesKHR parse_VkPhysicalDeviceFragmentShadingRateFeaturesKHR_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceFragmentShadingRateFeaturesKHR s{};
        s.pipelineFragmentShadingRate =
            parse_VkBool32(json["pipelineFragmentShadingRate"], CreateScope("pipelineFragmentShadingRate"));
        s.primitiveFragmentShadingRate =
            parse_VkBool32(json["primitiveFragmentShadingRate"], CreateScope("primitiveFragmentShadingRate"));
        s.attachmentFragmentShadingRate =
            parse_VkBool32(json["attachmentFragmentShadingRate"], CreateScope("attachmentFragmentShadingRate"));
        return s;
    }

    VkPhysicalDeviceGlobalPriorityQueryFeatures parse_VkPhysicalDeviceGlobalPriorityQueryFeatures_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPhysicalDeviceGlobalPriorityQueryFeatures s{};
        s.globalPriorityQuery = parse_VkBool32(json["globalPriorityQuery"], CreateScope("globalPriorityQuery"));
        return s;
    }

    VkPhysicalDeviceHostImageCopyFeatures parse_VkPhysicalDeviceHostImageCopyFeatures_contents(const Json::Value& json,
                                                                                               const LocationScope& l) {
        VkPhysicalDeviceHostImageCopyFeatures s{};
        s.hostImageCopy = parse_VkBool32(json["hostImageCopy"], CreateScope("hostImageCopy"));
        return s;
    }

    VkPhysicalDeviceHostQueryResetFeatures parse_VkPhysicalDeviceHostQueryResetFeatures_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPhysicalDeviceHostQueryResetFeatures s{};
        s.hostQueryReset = parse_VkBool32(json["hostQueryReset"], CreateScope("hostQueryReset"));
        return s;
    }

    VkPhysicalDeviceImageRobustnessFeatures parse_VkPhysicalDeviceImageRobustnessFeatures_contents(const Json::Value& json,
                                                                                                   const LocationScope& l) {
        VkPhysicalDeviceImageRobustnessFeatures s{};
        s.robustImageAccess = parse_VkBool32(json["robustImageAccess"], CreateScope("robustImageAccess"));
        return s;
    }

    VkPhysicalDeviceImagelessFramebufferFeatures parse_VkPhysicalDeviceImagelessFramebufferFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceImagelessFramebufferFeatures s{};
        s.imagelessFramebuffer = parse_VkBool32(json["imagelessFramebuffer"], CreateScope("imagelessFramebuffer"));
        return s;
    }

    VkPhysicalDeviceIndexTypeUint8Features parse_VkPhysicalDeviceIndexTypeUint8Features_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPhysicalDeviceIndexTypeUint8Features s{};
        s.indexTypeUint8 = parse_VkBool32(json["indexTypeUint8"], CreateScope("indexTypeUint8"));
        return s;
    }

    VkPhysicalDeviceInlineUniformBlockFeatures parse_VkPhysicalDeviceInlineUniformBlockFeatures_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPhysicalDeviceInlineUniformBlockFeatures s{};
        s.inlineUniformBlock = parse_VkBool32(json["inlineUniformBlock"], CreateScope("inlineUniformBlock"));
        s.descriptorBindingInlineUniformBlockUpdateAfterBind =
            parse_VkBool32(json["descriptorBindingInlineUniformBlockUpdateAfterBind"],
                           CreateScope("descriptorBindingInlineUniformBlockUpdateAfterBind"));
        return s;
    }

    VkPhysicalDeviceLineRasterizationFeatures parse_VkPhysicalDeviceLineRasterizationFeatures_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceLineRasterizationFeatures s{};
        s.rectangularLines = parse_VkBool32(json["rectangularLines"], CreateScope("rectangularLines"));
        s.bresenhamLines = parse_VkBool32(json["bresenhamLines"], CreateScope("bresenhamLines"));
        s.smoothLines = parse_VkBool32(json["smoothLines"], CreateScope("smoothLines"));
        s.stippledRectangularLines = parse_VkBool32(json["stippledRectangularLines"], CreateScope("stippledRectangularLines"));
        s.stippledBresenhamLines = parse_VkBool32(json["stippledBresenhamLines"], CreateScope("stippledBresenhamLines"));
        s.stippledSmoothLines = parse_VkBool32(json["stippledSmoothLines"], CreateScope("stippledSmoothLines"));
        return s;
    }

    VkPhysicalDeviceMaintenance4Features parse_VkPhysicalDeviceMaintenance4Features_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPhysicalDeviceMaintenance4Features s{};
        s.maintenance4 = parse_VkBool32(json["maintenance4"], CreateScope("maintenance4"));
        return s;
    }

    VkPhysicalDeviceMaintenance5Features parse_VkPhysicalDeviceMaintenance5Features_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPhysicalDeviceMaintenance5Features s{};
        s.maintenance5 = parse_VkBool32(json["maintenance5"], CreateScope("maintenance5"));
        return s;
    }

    VkPhysicalDeviceMaintenance6Features parse_VkPhysicalDeviceMaintenance6Features_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPhysicalDeviceMaintenance6Features s{};
        s.maintenance6 = parse_VkBool32(json["maintenance6"], CreateScope("maintenance6"));
        return s;
    }

    VkPhysicalDeviceMultiviewFeatures parse_VkPhysicalDeviceMultiviewFeatures_contents(const Json::Value& json,
                                                                                       const LocationScope& l) {
        VkPhysicalDeviceMultiviewFeatures s{};
        s.multiview = parse_VkBool32(json["multiview"], CreateScope("multiview"));
        s.multiviewGeometryShader = parse_VkBool32(json["multiviewGeometryShader"], CreateScope("multiviewGeometryShader"));
        s.multiviewTessellationShader =
            parse_VkBool32(json["multiviewTessellationShader"], CreateScope("multiviewTessellationShader"));
        return s;
    }

    VkPhysicalDevicePerformanceQueryFeaturesKHR parse_VkPhysicalDevicePerformanceQueryFeaturesKHR_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPhysicalDevicePerformanceQueryFeaturesKHR s{};
        s.performanceCounterQueryPools =
            parse_VkBool32(json["performanceCounterQueryPools"], CreateScope("performanceCounterQueryPools"));
        s.performanceCounterMultipleQueryPools =
            parse_VkBool32(json["performanceCounterMultipleQueryPools"], CreateScope("performanceCounterMultipleQueryPools"));
        return s;
    }

    VkPhysicalDevicePipelineCreationCacheControlFeatures parse_VkPhysicalDevicePipelineCreationCacheControlFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDevicePipelineCreationCacheControlFeatures s{};
        s.pipelineCreationCacheControl =
            parse_VkBool32(json["pipelineCreationCacheControl"], CreateScope("pipelineCreationCacheControl"));
        return s;
    }

    VkPhysicalDevicePipelineProtectedAccessFeatures parse_VkPhysicalDevicePipelineProtectedAccessFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDevicePipelineProtectedAccessFeatures s{};
        s.pipelineProtectedAccess = parse_VkBool32(json["pipelineProtectedAccess"], CreateScope("pipelineProtectedAccess"));
        return s;
    }

    VkPhysicalDevicePipelineRobustnessFeatures parse_VkPhysicalDevicePipelineRobustnessFeatures_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPhysicalDevicePipelineRobustnessFeatures s{};
        s.pipelineRobustness = parse_VkBool32(json["pipelineRobustness"], CreateScope("pipelineRobustness"));
        return s;
    }

    VkPhysicalDevicePrivateDataFeatures parse_VkPhysicalDevicePrivateDataFeatures_contents(const Json::Value& json,
                                                                                           const LocationScope& l) {
        VkPhysicalDevicePrivateDataFeatures s{};
        s.privateData = parse_VkBool32(json["privateData"], CreateScope("privateData"));
        return s;
    }

    VkPhysicalDeviceProtectedMemoryFeatures parse_VkPhysicalDeviceProtectedMemoryFeatures_contents(const Json::Value& json,
                                                                                                   const LocationScope& l) {
        VkPhysicalDeviceProtectedMemoryFeatures s{};
        s.protectedMemory = parse_VkBool32(json["protectedMemory"], CreateScope("protectedMemory"));
        return s;
    }

    VkPhysicalDeviceRobustness2FeaturesKHR parse_VkPhysicalDeviceRobustness2FeaturesKHR_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPhysicalDeviceRobustness2FeaturesKHR s{};
        s.robustBufferAccess2 = parse_VkBool32(json["robustBufferAccess2"], CreateScope("robustBufferAccess2"));
        s.robustImageAccess2 = parse_VkBool32(json["robustImageAccess2"], CreateScope("robustImageAccess2"));
        s.nullDescriptor = parse_VkBool32(json["nullDescriptor"], CreateScope("nullDescriptor"));
        return s;
    }

    VkPhysicalDeviceSamplerYcbcrConversionFeatures parse_VkPhysicalDeviceSamplerYcbcrConversionFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceSamplerYcbcrConversionFeatures s{};
        s.samplerYcbcrConversion = parse_VkBool32(json["samplerYcbcrConversion"], CreateScope("samplerYcbcrConversion"));
        return s;
    }

    VkPhysicalDeviceScalarBlockLayoutFeatures parse_VkPhysicalDeviceScalarBlockLayoutFeatures_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceScalarBlockLayoutFeatures s{};
        s.scalarBlockLayout = parse_VkBool32(json["scalarBlockLayout"], CreateScope("scalarBlockLayout"));
        return s;
    }

    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures parse_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures s{};
        s.separateDepthStencilLayouts =
            parse_VkBool32(json["separateDepthStencilLayouts"], CreateScope("separateDepthStencilLayouts"));
        return s;
    }

    VkPhysicalDeviceShaderAtomicFloatFeaturesEXT parse_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderAtomicFloatFeaturesEXT s{};
        s.shaderBufferFloat32Atomics =
            parse_VkBool32(json["shaderBufferFloat32Atomics"], CreateScope("shaderBufferFloat32Atomics"));
        s.shaderBufferFloat32AtomicAdd =
            parse_VkBool32(json["shaderBufferFloat32AtomicAdd"], CreateScope("shaderBufferFloat32AtomicAdd"));
        s.shaderBufferFloat64Atomics =
            parse_VkBool32(json["shaderBufferFloat64Atomics"], CreateScope("shaderBufferFloat64Atomics"));
        s.shaderBufferFloat64AtomicAdd =
            parse_VkBool32(json["shaderBufferFloat64AtomicAdd"], CreateScope("shaderBufferFloat64AtomicAdd"));
        s.shaderSharedFloat32Atomics =
            parse_VkBool32(json["shaderSharedFloat32Atomics"], CreateScope("shaderSharedFloat32Atomics"));
        s.shaderSharedFloat32AtomicAdd =
            parse_VkBool32(json["shaderSharedFloat32AtomicAdd"], CreateScope("shaderSharedFloat32AtomicAdd"));
        s.shaderSharedFloat64Atomics =
            parse_VkBool32(json["shaderSharedFloat64Atomics"], CreateScope("shaderSharedFloat64Atomics"));
        s.shaderSharedFloat64AtomicAdd =
            parse_VkBool32(json["shaderSharedFloat64AtomicAdd"], CreateScope("shaderSharedFloat64AtomicAdd"));
        s.shaderImageFloat32Atomics = parse_VkBool32(json["shaderImageFloat32Atomics"], CreateScope("shaderImageFloat32Atomics"));
        s.shaderImageFloat32AtomicAdd =
            parse_VkBool32(json["shaderImageFloat32AtomicAdd"], CreateScope("shaderImageFloat32AtomicAdd"));
        s.sparseImageFloat32Atomics = parse_VkBool32(json["sparseImageFloat32Atomics"], CreateScope("sparseImageFloat32Atomics"));
        s.sparseImageFloat32AtomicAdd =
            parse_VkBool32(json["sparseImageFloat32AtomicAdd"], CreateScope("sparseImageFloat32AtomicAdd"));
        return s;
    }

    VkPhysicalDeviceShaderAtomicInt64Features parse_VkPhysicalDeviceShaderAtomicInt64Features_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceShaderAtomicInt64Features s{};
        s.shaderBufferInt64Atomics = parse_VkBool32(json["shaderBufferInt64Atomics"], CreateScope("shaderBufferInt64Atomics"));
        s.shaderSharedInt64Atomics = parse_VkBool32(json["shaderSharedInt64Atomics"], CreateScope("shaderSharedInt64Atomics"));
        return s;
    }

    VkPhysicalDeviceShaderClockFeaturesKHR parse_VkPhysicalDeviceShaderClockFeaturesKHR_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPhysicalDeviceShaderClockFeaturesKHR s{};
        s.shaderSubgroupClock = parse_VkBool32(json["shaderSubgroupClock"], CreateScope("shaderSubgroupClock"));
        s.shaderDeviceClock = parse_VkBool32(json["shaderDeviceClock"], CreateScope("shaderDeviceClock"));
        return s;
    }

    VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures parse_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures s{};
        s.shaderDemoteToHelperInvocation =
            parse_VkBool32(json["shaderDemoteToHelperInvocation"], CreateScope("shaderDemoteToHelperInvocation"));
        return s;
    }

    VkPhysicalDeviceShaderDrawParametersFeatures parse_VkPhysicalDeviceShaderDrawParametersFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderDrawParametersFeatures s{};
        s.shaderDrawParameters = parse_VkBool32(json["shaderDrawParameters"], CreateScope("shaderDrawParameters"));
        return s;
    }

    VkPhysicalDeviceShaderExpectAssumeFeatures parse_VkPhysicalDeviceShaderExpectAssumeFeatures_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPhysicalDeviceShaderExpectAssumeFeatures s{};
        s.shaderExpectAssume = parse_VkBool32(json["shaderExpectAssume"], CreateScope("shaderExpectAssume"));
        return s;
    }

    VkPhysicalDeviceShaderFloat16Int8Features parse_VkPhysicalDeviceShaderFloat16Int8Features_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceShaderFloat16Int8Features s{};
        s.shaderFloat16 = parse_VkBool32(json["shaderFloat16"], CreateScope("shaderFloat16"));
        s.shaderInt8 = parse_VkBool32(json["shaderInt8"], CreateScope("shaderInt8"));
        return s;
    }

    VkPhysicalDeviceShaderFloatControls2Features parse_VkPhysicalDeviceShaderFloatControls2Features_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderFloatControls2Features s{};
        s.shaderFloatControls2 = parse_VkBool32(json["shaderFloatControls2"], CreateScope("shaderFloatControls2"));
        return s;
    }

    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT parse_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT s{};
        s.shaderImageInt64Atomics = parse_VkBool32(json["shaderImageInt64Atomics"], CreateScope("shaderImageInt64Atomics"));
        s.sparseImageInt64Atomics = parse_VkBool32(json["sparseImageInt64Atomics"], CreateScope("sparseImageInt64Atomics"));
        return s;
    }

    VkPhysicalDeviceShaderIntegerDotProductFeatures parse_VkPhysicalDeviceShaderIntegerDotProductFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderIntegerDotProductFeatures s{};
        s.shaderIntegerDotProduct = parse_VkBool32(json["shaderIntegerDotProduct"], CreateScope("shaderIntegerDotProduct"));
        return s;
    }

    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures parse_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures s{};
        s.shaderSubgroupExtendedTypes =
            parse_VkBool32(json["shaderSubgroupExtendedTypes"], CreateScope("shaderSubgroupExtendedTypes"));
        return s;
    }

    VkPhysicalDeviceShaderSubgroupRotateFeatures parse_VkPhysicalDeviceShaderSubgroupRotateFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderSubgroupRotateFeatures s{};
        s.shaderSubgroupRotate = parse_VkBool32(json["shaderSubgroupRotate"], CreateScope("shaderSubgroupRotate"));
        s.shaderSubgroupRotateClustered =
            parse_VkBool32(json["shaderSubgroupRotateClustered"], CreateScope("shaderSubgroupRotateClustered"));
        return s;
    }

    VkPhysicalDeviceShaderTerminateInvocationFeatures parse_VkPhysicalDeviceShaderTerminateInvocationFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderTerminateInvocationFeatures s{};
        s.shaderTerminateInvocation = parse_VkBool32(json["shaderTerminateInvocation"], CreateScope("shaderTerminateInvocation"));
        return s;
    }

    VkPhysicalDeviceSubgroupSizeControlFeatures parse_VkPhysicalDeviceSubgroupSizeControlFeatures_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPhysicalDeviceSubgroupSizeControlFeatures s{};
        s.subgroupSizeControl = parse_VkBool32(json["subgroupSizeControl"], CreateScope("subgroupSizeControl"));
        s.computeFullSubgroups = parse_VkBool32(json["computeFullSubgroups"], CreateScope("computeFullSubgroups"));
        return s;
    }

    VkPhysicalDeviceSynchronization2Features parse_VkPhysicalDeviceSynchronization2Features_contents(const Json::Value& json,
                                                                                                     const LocationScope& l) {
        VkPhysicalDeviceSynchronization2Features s{};
        s.synchronization2 = parse_VkBool32(json["synchronization2"], CreateScope("synchronization2"));
        return s;
    }

    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT parse_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT s{};
        s.texelBufferAlignment = parse_VkBool32(json["texelBufferAlignment"], CreateScope("texelBufferAlignment"));
        return s;
    }

    VkPhysicalDeviceTextureCompressionASTCHDRFeatures parse_VkPhysicalDeviceTextureCompressionASTCHDRFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceTextureCompressionASTCHDRFeatures s{};
        s.textureCompressionASTC_HDR =
            parse_VkBool32(json["textureCompressionASTC_HDR"], CreateScope("textureCompressionASTC_HDR"));
        return s;
    }

    VkPhysicalDeviceTimelineSemaphoreFeatures parse_VkPhysicalDeviceTimelineSemaphoreFeatures_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceTimelineSemaphoreFeatures s{};
        s.timelineSemaphore = parse_VkBool32(json["timelineSemaphore"], CreateScope("timelineSemaphore"));
        return s;
    }

    VkPhysicalDeviceUniformBufferStandardLayoutFeatures parse_VkPhysicalDeviceUniformBufferStandardLayoutFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceUniformBufferStandardLayoutFeatures s{};
        s.uniformBufferStandardLayout =
            parse_VkBool32(json["uniformBufferStandardLayout"], CreateScope("uniformBufferStandardLayout"));
        return s;
    }

    VkPhysicalDeviceVariablePointersFeatures parse_VkPhysicalDeviceVariablePointersFeatures_contents(const Json::Value& json,
                                                                                                     const LocationScope& l) {
        VkPhysicalDeviceVariablePointersFeatures s{};
        s.variablePointersStorageBuffer =
            parse_VkBool32(json["variablePointersStorageBuffer"], CreateScope("variablePointersStorageBuffer"));
        s.variablePointers = parse_VkBool32(json["variablePointers"], CreateScope("variablePointers"));
        return s;
    }

    VkPhysicalDeviceVertexAttributeDivisorFeatures parse_VkPhysicalDeviceVertexAttributeDivisorFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceVertexAttributeDivisorFeatures s{};
        s.vertexAttributeInstanceRateDivisor =
            parse_VkBool32(json["vertexAttributeInstanceRateDivisor"], CreateScope("vertexAttributeInstanceRateDivisor"));
        s.vertexAttributeInstanceRateZeroDivisor =
            parse_VkBool32(json["vertexAttributeInstanceRateZeroDivisor"], CreateScope("vertexAttributeInstanceRateZeroDivisor"));
        return s;
    }

    VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT parse_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT s{};
        s.vertexInputDynamicState = parse_VkBool32(json["vertexInputDynamicState"], CreateScope("vertexInputDynamicState"));
        return s;
    }

    VkPhysicalDeviceVulkan11Features parse_VkPhysicalDeviceVulkan11Features_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkPhysicalDeviceVulkan11Features s{};
        s.storageBuffer16BitAccess = parse_VkBool32(json["storageBuffer16BitAccess"], CreateScope("storageBuffer16BitAccess"));
        s.uniformAndStorageBuffer16BitAccess =
            parse_VkBool32(json["uniformAndStorageBuffer16BitAccess"], CreateScope("uniformAndStorageBuffer16BitAccess"));
        s.storagePushConstant16 = parse_VkBool32(json["storagePushConstant16"], CreateScope("storagePushConstant16"));
        s.storageInputOutput16 = parse_VkBool32(json["storageInputOutput16"], CreateScope("storageInputOutput16"));
        s.multiview = parse_VkBool32(json["multiview"], CreateScope("multiview"));
        s.multiviewGeometryShader = parse_VkBool32(json["multiviewGeometryShader"], CreateScope("multiviewGeometryShader"));
        s.multiviewTessellationShader =
            parse_VkBool32(json["multiviewTessellationShader"], CreateScope("multiviewTessellationShader"));
        s.variablePointersStorageBuffer =
            parse_VkBool32(json["variablePointersStorageBuffer"], CreateScope("variablePointersStorageBuffer"));
        s.variablePointers = parse_VkBool32(json["variablePointers"], CreateScope("variablePointers"));
        s.protectedMemory = parse_VkBool32(json["protectedMemory"], CreateScope("protectedMemory"));
        s.samplerYcbcrConversion = parse_VkBool32(json["samplerYcbcrConversion"], CreateScope("samplerYcbcrConversion"));
        s.shaderDrawParameters = parse_VkBool32(json["shaderDrawParameters"], CreateScope("shaderDrawParameters"));
        return s;
    }

    VkPhysicalDeviceVulkan12Features parse_VkPhysicalDeviceVulkan12Features_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkPhysicalDeviceVulkan12Features s{};
        s.samplerMirrorClampToEdge = parse_VkBool32(json["samplerMirrorClampToEdge"], CreateScope("samplerMirrorClampToEdge"));
        s.drawIndirectCount = parse_VkBool32(json["drawIndirectCount"], CreateScope("drawIndirectCount"));
        s.storageBuffer8BitAccess = parse_VkBool32(json["storageBuffer8BitAccess"], CreateScope("storageBuffer8BitAccess"));
        s.uniformAndStorageBuffer8BitAccess =
            parse_VkBool32(json["uniformAndStorageBuffer8BitAccess"], CreateScope("uniformAndStorageBuffer8BitAccess"));
        s.storagePushConstant8 = parse_VkBool32(json["storagePushConstant8"], CreateScope("storagePushConstant8"));
        s.shaderBufferInt64Atomics = parse_VkBool32(json["shaderBufferInt64Atomics"], CreateScope("shaderBufferInt64Atomics"));
        s.shaderSharedInt64Atomics = parse_VkBool32(json["shaderSharedInt64Atomics"], CreateScope("shaderSharedInt64Atomics"));
        s.shaderFloat16 = parse_VkBool32(json["shaderFloat16"], CreateScope("shaderFloat16"));
        s.shaderInt8 = parse_VkBool32(json["shaderInt8"], CreateScope("shaderInt8"));
        s.descriptorIndexing = parse_VkBool32(json["descriptorIndexing"], CreateScope("descriptorIndexing"));
        s.shaderInputAttachmentArrayDynamicIndexing = parse_VkBool32(json["shaderInputAttachmentArrayDynamicIndexing"],
                                                                     CreateScope("shaderInputAttachmentArrayDynamicIndexing"));
        s.shaderUniformTexelBufferArrayDynamicIndexing = parse_VkBool32(
            json["shaderUniformTexelBufferArrayDynamicIndexing"], CreateScope("shaderUniformTexelBufferArrayDynamicIndexing"));
        s.shaderStorageTexelBufferArrayDynamicIndexing = parse_VkBool32(
            json["shaderStorageTexelBufferArrayDynamicIndexing"], CreateScope("shaderStorageTexelBufferArrayDynamicIndexing"));
        s.shaderUniformBufferArrayNonUniformIndexing = parse_VkBool32(json["shaderUniformBufferArrayNonUniformIndexing"],
                                                                      CreateScope("shaderUniformBufferArrayNonUniformIndexing"));
        s.shaderSampledImageArrayNonUniformIndexing = parse_VkBool32(json["shaderSampledImageArrayNonUniformIndexing"],
                                                                     CreateScope("shaderSampledImageArrayNonUniformIndexing"));
        s.shaderStorageBufferArrayNonUniformIndexing = parse_VkBool32(json["shaderStorageBufferArrayNonUniformIndexing"],
                                                                      CreateScope("shaderStorageBufferArrayNonUniformIndexing"));
        s.shaderStorageImageArrayNonUniformIndexing = parse_VkBool32(json["shaderStorageImageArrayNonUniformIndexing"],
                                                                     CreateScope("shaderStorageImageArrayNonUniformIndexing"));
        s.shaderInputAttachmentArrayNonUniformIndexing = parse_VkBool32(
            json["shaderInputAttachmentArrayNonUniformIndexing"], CreateScope("shaderInputAttachmentArrayNonUniformIndexing"));
        s.shaderUniformTexelBufferArrayNonUniformIndexing =
            parse_VkBool32(json["shaderUniformTexelBufferArrayNonUniformIndexing"],
                           CreateScope("shaderUniformTexelBufferArrayNonUniformIndexing"));
        s.shaderStorageTexelBufferArrayNonUniformIndexing =
            parse_VkBool32(json["shaderStorageTexelBufferArrayNonUniformIndexing"],
                           CreateScope("shaderStorageTexelBufferArrayNonUniformIndexing"));
        s.descriptorBindingUniformBufferUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingUniformBufferUpdateAfterBind"], CreateScope("descriptorBindingUniformBufferUpdateAfterBind"));
        s.descriptorBindingSampledImageUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingSampledImageUpdateAfterBind"], CreateScope("descriptorBindingSampledImageUpdateAfterBind"));
        s.descriptorBindingStorageImageUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingStorageImageUpdateAfterBind"], CreateScope("descriptorBindingStorageImageUpdateAfterBind"));
        s.descriptorBindingStorageBufferUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingStorageBufferUpdateAfterBind"], CreateScope("descriptorBindingStorageBufferUpdateAfterBind"));
        s.descriptorBindingUniformTexelBufferUpdateAfterBind =
            parse_VkBool32(json["descriptorBindingUniformTexelBufferUpdateAfterBind"],
                           CreateScope("descriptorBindingUniformTexelBufferUpdateAfterBind"));
        s.descriptorBindingStorageTexelBufferUpdateAfterBind =
            parse_VkBool32(json["descriptorBindingStorageTexelBufferUpdateAfterBind"],
                           CreateScope("descriptorBindingStorageTexelBufferUpdateAfterBind"));
        s.descriptorBindingUpdateUnusedWhilePending = parse_VkBool32(json["descriptorBindingUpdateUnusedWhilePending"],
                                                                     CreateScope("descriptorBindingUpdateUnusedWhilePending"));
        s.descriptorBindingPartiallyBound =
            parse_VkBool32(json["descriptorBindingPartiallyBound"], CreateScope("descriptorBindingPartiallyBound"));
        s.descriptorBindingVariableDescriptorCount = parse_VkBool32(json["descriptorBindingVariableDescriptorCount"],
                                                                    CreateScope("descriptorBindingVariableDescriptorCount"));
        s.runtimeDescriptorArray = parse_VkBool32(json["runtimeDescriptorArray"], CreateScope("runtimeDescriptorArray"));
        s.samplerFilterMinmax = parse_VkBool32(json["samplerFilterMinmax"], CreateScope("samplerFilterMinmax"));
        s.scalarBlockLayout = parse_VkBool32(json["scalarBlockLayout"], CreateScope("scalarBlockLayout"));
        s.imagelessFramebuffer = parse_VkBool32(json["imagelessFramebuffer"], CreateScope("imagelessFramebuffer"));
        s.uniformBufferStandardLayout =
            parse_VkBool32(json["uniformBufferStandardLayout"], CreateScope("uniformBufferStandardLayout"));
        s.shaderSubgroupExtendedTypes =
            parse_VkBool32(json["shaderSubgroupExtendedTypes"], CreateScope("shaderSubgroupExtendedTypes"));
        s.separateDepthStencilLayouts =
            parse_VkBool32(json["separateDepthStencilLayouts"], CreateScope("separateDepthStencilLayouts"));
        s.hostQueryReset = parse_VkBool32(json["hostQueryReset"], CreateScope("hostQueryReset"));
        s.timelineSemaphore = parse_VkBool32(json["timelineSemaphore"], CreateScope("timelineSemaphore"));
        s.bufferDeviceAddress = parse_VkBool32(json["bufferDeviceAddress"], CreateScope("bufferDeviceAddress"));
        s.bufferDeviceAddressCaptureReplay =
            parse_VkBool32(json["bufferDeviceAddressCaptureReplay"], CreateScope("bufferDeviceAddressCaptureReplay"));
        s.bufferDeviceAddressMultiDevice =
            parse_VkBool32(json["bufferDeviceAddressMultiDevice"], CreateScope("bufferDeviceAddressMultiDevice"));
        s.vulkanMemoryModel = parse_VkBool32(json["vulkanMemoryModel"], CreateScope("vulkanMemoryModel"));
        s.vulkanMemoryModelDeviceScope =
            parse_VkBool32(json["vulkanMemoryModelDeviceScope"], CreateScope("vulkanMemoryModelDeviceScope"));
        s.vulkanMemoryModelAvailabilityVisibilityChains = parse_VkBool32(
            json["vulkanMemoryModelAvailabilityVisibilityChains"], CreateScope("vulkanMemoryModelAvailabilityVisibilityChains"));
        s.shaderOutputViewportIndex = parse_VkBool32(json["shaderOutputViewportIndex"], CreateScope("shaderOutputViewportIndex"));
        s.shaderOutputLayer = parse_VkBool32(json["shaderOutputLayer"], CreateScope("shaderOutputLayer"));
        s.subgroupBroadcastDynamicId =
            parse_VkBool32(json["subgroupBroadcastDynamicId"], CreateScope("subgroupBroadcastDynamicId"));
        return s;
    }

    VkPhysicalDeviceVulkan13Features parse_VkPhysicalDeviceVulkan13Features_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkPhysicalDeviceVulkan13Features s{};
        s.robustImageAccess = parse_VkBool32(json["robustImageAccess"], CreateScope("robustImageAccess"));
        s.inlineUniformBlock = parse_VkBool32(json["inlineUniformBlock"], CreateScope("inlineUniformBlock"));
        s.descriptorBindingInlineUniformBlockUpdateAfterBind =
            parse_VkBool32(json["descriptorBindingInlineUniformBlockUpdateAfterBind"],
                           CreateScope("descriptorBindingInlineUniformBlockUpdateAfterBind"));
        s.pipelineCreationCacheControl =
            parse_VkBool32(json["pipelineCreationCacheControl"], CreateScope("pipelineCreationCacheControl"));
        s.privateData = parse_VkBool32(json["privateData"], CreateScope("privateData"));
        s.shaderDemoteToHelperInvocation =
            parse_VkBool32(json["shaderDemoteToHelperInvocation"], CreateScope("shaderDemoteToHelperInvocation"));
        s.shaderTerminateInvocation = parse_VkBool32(json["shaderTerminateInvocation"], CreateScope("shaderTerminateInvocation"));
        s.subgroupSizeControl = parse_VkBool32(json["subgroupSizeControl"], CreateScope("subgroupSizeControl"));
        s.computeFullSubgroups = parse_VkBool32(json["computeFullSubgroups"], CreateScope("computeFullSubgroups"));
        s.synchronization2 = parse_VkBool32(json["synchronization2"], CreateScope("synchronization2"));
        s.textureCompressionASTC_HDR =
            parse_VkBool32(json["textureCompressionASTC_HDR"], CreateScope("textureCompressionASTC_HDR"));
        s.shaderZeroInitializeWorkgroupMemory =
            parse_VkBool32(json["shaderZeroInitializeWorkgroupMemory"], CreateScope("shaderZeroInitializeWorkgroupMemory"));
        s.dynamicRendering = parse_VkBool32(json["dynamicRendering"], CreateScope("dynamicRendering"));
        s.shaderIntegerDotProduct = parse_VkBool32(json["shaderIntegerDotProduct"], CreateScope("shaderIntegerDotProduct"));
        s.maintenance4 = parse_VkBool32(json["maintenance4"], CreateScope("maintenance4"));
        return s;
    }

    VkPhysicalDeviceVulkan14Features parse_VkPhysicalDeviceVulkan14Features_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkPhysicalDeviceVulkan14Features s{};
        s.globalPriorityQuery = parse_VkBool32(json["globalPriorityQuery"], CreateScope("globalPriorityQuery"));
        s.shaderSubgroupRotate = parse_VkBool32(json["shaderSubgroupRotate"], CreateScope("shaderSubgroupRotate"));
        s.shaderSubgroupRotateClustered =
            parse_VkBool32(json["shaderSubgroupRotateClustered"], CreateScope("shaderSubgroupRotateClustered"));
        s.shaderFloatControls2 = parse_VkBool32(json["shaderFloatControls2"], CreateScope("shaderFloatControls2"));
        s.shaderExpectAssume = parse_VkBool32(json["shaderExpectAssume"], CreateScope("shaderExpectAssume"));
        s.rectangularLines = parse_VkBool32(json["rectangularLines"], CreateScope("rectangularLines"));
        s.bresenhamLines = parse_VkBool32(json["bresenhamLines"], CreateScope("bresenhamLines"));
        s.smoothLines = parse_VkBool32(json["smoothLines"], CreateScope("smoothLines"));
        s.stippledRectangularLines = parse_VkBool32(json["stippledRectangularLines"], CreateScope("stippledRectangularLines"));
        s.stippledBresenhamLines = parse_VkBool32(json["stippledBresenhamLines"], CreateScope("stippledBresenhamLines"));
        s.stippledSmoothLines = parse_VkBool32(json["stippledSmoothLines"], CreateScope("stippledSmoothLines"));
        s.vertexAttributeInstanceRateDivisor =
            parse_VkBool32(json["vertexAttributeInstanceRateDivisor"], CreateScope("vertexAttributeInstanceRateDivisor"));
        s.vertexAttributeInstanceRateZeroDivisor =
            parse_VkBool32(json["vertexAttributeInstanceRateZeroDivisor"], CreateScope("vertexAttributeInstanceRateZeroDivisor"));
        s.indexTypeUint8 = parse_VkBool32(json["indexTypeUint8"], CreateScope("indexTypeUint8"));
        s.dynamicRenderingLocalRead = parse_VkBool32(json["dynamicRenderingLocalRead"], CreateScope("dynamicRenderingLocalRead"));
        s.maintenance5 = parse_VkBool32(json["maintenance5"], CreateScope("maintenance5"));
        s.maintenance6 = parse_VkBool32(json["maintenance6"], CreateScope("maintenance6"));
        s.pipelineProtectedAccess = parse_VkBool32(json["pipelineProtectedAccess"], CreateScope("pipelineProtectedAccess"));
        s.pipelineRobustness = parse_VkBool32(json["pipelineRobustness"], CreateScope("pipelineRobustness"));
        s.hostImageCopy = parse_VkBool32(json["hostImageCopy"], CreateScope("hostImageCopy"));
        s.pushDescriptor = parse_VkBool32(json["pushDescriptor"], CreateScope("pushDescriptor"));
        return s;
    }

    VkPhysicalDeviceVulkanMemoryModelFeatures parse_VkPhysicalDeviceVulkanMemoryModelFeatures_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceVulkanMemoryModelFeatures s{};
        s.vulkanMemoryModel = parse_VkBool32(json["vulkanMemoryModel"], CreateScope("vulkanMemoryModel"));
        s.vulkanMemoryModelDeviceScope =
            parse_VkBool32(json["vulkanMemoryModelDeviceScope"], CreateScope("vulkanMemoryModelDeviceScope"));
        s.vulkanMemoryModelAvailabilityVisibilityChains = parse_VkBool32(
            json["vulkanMemoryModelAvailabilityVisibilityChains"], CreateScope("vulkanMemoryModelAvailabilityVisibilityChains"));
        return s;
    }

    VkPhysicalDeviceVulkanSC10Features parse_VkPhysicalDeviceVulkanSC10Features_contents(const Json::Value& json,
                                                                                         const LocationScope& l) {
        VkPhysicalDeviceVulkanSC10Features s{};
        s.shaderAtomicInstructions = parse_VkBool32(json["shaderAtomicInstructions"], CreateScope("shaderAtomicInstructions"));
        return s;
    }

    VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT parse_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT s{};
        s.ycbcr2plane444Formats = parse_VkBool32(json["ycbcr2plane444Formats"], CreateScope("ycbcr2plane444Formats"));
        return s;
    }

    VkPhysicalDeviceYcbcrImageArraysFeaturesEXT parse_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPhysicalDeviceYcbcrImageArraysFeaturesEXT s{};
        s.ycbcrImageArrays = parse_VkBool32(json["ycbcrImageArrays"], CreateScope("ycbcrImageArrays"));
        return s;
    }

    VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures parse_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures s{};
        s.shaderZeroInitializeWorkgroupMemory =
            parse_VkBool32(json["shaderZeroInitializeWorkgroupMemory"], CreateScope("shaderZeroInitializeWorkgroupMemory"));
        return s;
    }

    VkAttachmentDescription parse_VkAttachmentDescription_contents(const Json::Value& json, const LocationScope& l) {
        VkAttachmentDescription s{};
        s.flags = parse_VkAttachmentDescriptionFlags(json["flags"], CreateScope("flags"));
        s.format = parse_VkFormat(json["format"], CreateScope("format"));
        s.samples = parse_VkSampleCountFlagBits(json["samples"], CreateScope("samples"));
        s.loadOp = parse_VkAttachmentLoadOp(json["loadOp"], CreateScope("loadOp"));
        s.storeOp = parse_VkAttachmentStoreOp(json["storeOp"], CreateScope("storeOp"));
        s.stencilLoadOp = parse_VkAttachmentLoadOp(json["stencilLoadOp"], CreateScope("stencilLoadOp"));
        s.stencilStoreOp = parse_VkAttachmentStoreOp(json["stencilStoreOp"], CreateScope("stencilStoreOp"));
        s.initialLayout = parse_VkImageLayout(json["initialLayout"], CreateScope("initialLayout"));
        s.finalLayout = parse_VkImageLayout(json["finalLayout"], CreateScope("finalLayout"));
        return s;
    }

    VkAttachmentDescription* parse_VkAttachmentDescription_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkAttachmentDescription>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkAttachmentDescription_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkAttachmentReference parse_VkAttachmentReference_contents(const Json::Value& json, const LocationScope& l) {
        VkAttachmentReference s{};
        s.attachment = parse_uint32_t(json["attachment"], CreateScope("attachment"));
        s.layout = parse_VkImageLayout(json["layout"], CreateScope("layout"));
        return s;
    }

    VkAttachmentReference* parse_VkAttachmentReference_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkAttachmentReference>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkAttachmentReference_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkAttachmentReference* parse_VkAttachmentReference_pointer(const Json::Value& json, const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<VkAttachmentReference>(1);
        dst_buffer[0] = parse_VkAttachmentReference_contents(json, l);

        return dst_buffer;
    }

    VkSubpassDescription parse_VkSubpassDescription_contents(const Json::Value& json, const LocationScope& l) {
        VkSubpassDescription s{};
        s.flags = parse_VkSubpassDescriptionFlags(json["flags"], CreateScope("flags"));
        s.pipelineBindPoint = parse_VkPipelineBindPoint(json["pipelineBindPoint"], CreateScope("pipelineBindPoint"));
        s.inputAttachmentCount = parse_uint32_t(json["inputAttachmentCount"], CreateScope("inputAttachmentCount"));
        s.pInputAttachments = parse_VkAttachmentReference_array(json["pInputAttachments"], CreateScope("pInputAttachments"));
        s.colorAttachmentCount = parse_uint32_t(json["colorAttachmentCount"], CreateScope("colorAttachmentCount"));
        s.pColorAttachments = parse_VkAttachmentReference_array(json["pColorAttachments"], CreateScope("pColorAttachments"));
        s.pResolveAttachments = parse_VkAttachmentReference_array(json["pResolveAttachments"], CreateScope("pResolveAttachments"));
        s.pDepthStencilAttachment =
            parse_VkAttachmentReference_pointer(json["pDepthStencilAttachment"], CreateScope("pDepthStencilAttachment"));
        s.preserveAttachmentCount = parse_uint32_t(json["preserveAttachmentCount"], CreateScope("preserveAttachmentCount"));
        s.pPreserveAttachments = parse_uint32_t_array(json["pPreserveAttachments"], CreateScope("pPreserveAttachments"));
        return s;
    }

    VkSubpassDescription* parse_VkSubpassDescription_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkSubpassDescription>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkSubpassDescription_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkSubpassDependency parse_VkSubpassDependency_contents(const Json::Value& json, const LocationScope& l) {
        VkSubpassDependency s{};
        s.srcSubpass = parse_uint32_t(json["srcSubpass"], CreateScope("srcSubpass"));
        s.dstSubpass = parse_uint32_t(json["dstSubpass"], CreateScope("dstSubpass"));
        s.srcStageMask = parse_VkPipelineStageFlags(json["srcStageMask"], CreateScope("srcStageMask"));
        s.dstStageMask = parse_VkPipelineStageFlags(json["dstStageMask"], CreateScope("dstStageMask"));
        s.srcAccessMask = parse_VkAccessFlags(json["srcAccessMask"], CreateScope("srcAccessMask"));
        s.dstAccessMask = parse_VkAccessFlags(json["dstAccessMask"], CreateScope("dstAccessMask"));
        s.dependencyFlags = parse_VkDependencyFlags(json["dependencyFlags"], CreateScope("dependencyFlags"));
        return s;
    }

    VkSubpassDependency* parse_VkSubpassDependency_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkSubpassDependency>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkSubpassDependency_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkRenderPassCreateInfo parse_VkRenderPassCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkRenderPassCreateInfo s{};
        s.flags = parse_VkRenderPassCreateFlags(json["flags"], CreateScope("flags"));
        s.attachmentCount = parse_uint32_t(json["attachmentCount"], CreateScope("attachmentCount"));
        s.pAttachments = parse_VkAttachmentDescription_array(json["pAttachments"], CreateScope("pAttachments"));
        s.subpassCount = parse_uint32_t(json["subpassCount"], CreateScope("subpassCount"));
        s.pSubpasses = parse_VkSubpassDescription_array(json["pSubpasses"], CreateScope("pSubpasses"));
        s.dependencyCount = parse_uint32_t(json["dependencyCount"], CreateScope("dependencyCount"));
        s.pDependencies = parse_VkSubpassDependency_array(json["pDependencies"], CreateScope("pDependencies"));
        return s;
    }

    VkInputAttachmentAspectReference parse_VkInputAttachmentAspectReference_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkInputAttachmentAspectReference s{};
        s.subpass = parse_uint32_t(json["subpass"], CreateScope("subpass"));
        s.inputAttachmentIndex = parse_uint32_t(json["inputAttachmentIndex"], CreateScope("inputAttachmentIndex"));
        s.aspectMask = parse_VkImageAspectFlags(json["aspectMask"], CreateScope("aspectMask"));
        return s;
    }

    VkInputAttachmentAspectReference* parse_VkInputAttachmentAspectReference_array(const Json::Value& json,
                                                                                   const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkInputAttachmentAspectReference>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkInputAttachmentAspectReference_contents(json[i], l);
        }

        return dst_buffer;
    }

    VkRenderPassInputAttachmentAspectCreateInfo parse_VkRenderPassInputAttachmentAspectCreateInfo_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkRenderPassInputAttachmentAspectCreateInfo s{};
        s.aspectReferenceCount = parse_uint32_t(json["aspectReferenceCount"], CreateScope("aspectReferenceCount"));
        s.pAspectReferences =
            parse_VkInputAttachmentAspectReference_array(json["pAspectReferences"], CreateScope("pAspectReferences"));
        return s;
    }

    int32_t* parse_int32_t_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<int32_t>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_int32_t(json[i], l);
        }

        return dst_buffer;
    }

    VkRenderPassMultiviewCreateInfo parse_VkRenderPassMultiviewCreateInfo_contents(const Json::Value& json,
                                                                                   const LocationScope& l) {
        VkRenderPassMultiviewCreateInfo s{};
        s.subpassCount = parse_uint32_t(json["subpassCount"], CreateScope("subpassCount"));
        s.pViewMasks = parse_uint32_t_array(json["pViewMasks"], CreateScope("pViewMasks"));
        s.dependencyCount = parse_uint32_t(json["dependencyCount"], CreateScope("dependencyCount"));
        s.pViewOffsets = parse_int32_t_array(json["pViewOffsets"], CreateScope("pViewOffsets"));
        s.correlationMaskCount = parse_uint32_t(json["correlationMaskCount"], CreateScope("correlationMaskCount"));
        s.pCorrelationMasks = parse_uint32_t_array(json["pCorrelationMasks"], CreateScope("pCorrelationMasks"));
        return s;
    }

    VkAttachmentDescription2 parse_VkAttachmentDescription2_contents(const Json::Value& json, const LocationScope& l) {
        VkAttachmentDescription2 s{};
        s.flags = parse_VkAttachmentDescriptionFlags(json["flags"], CreateScope("flags"));
        s.format = parse_VkFormat(json["format"], CreateScope("format"));
        s.samples = parse_VkSampleCountFlagBits(json["samples"], CreateScope("samples"));
        s.loadOp = parse_VkAttachmentLoadOp(json["loadOp"], CreateScope("loadOp"));
        s.storeOp = parse_VkAttachmentStoreOp(json["storeOp"], CreateScope("storeOp"));
        s.stencilLoadOp = parse_VkAttachmentLoadOp(json["stencilLoadOp"], CreateScope("stencilLoadOp"));
        s.stencilStoreOp = parse_VkAttachmentStoreOp(json["stencilStoreOp"], CreateScope("stencilStoreOp"));
        s.initialLayout = parse_VkImageLayout(json["initialLayout"], CreateScope("initialLayout"));
        s.finalLayout = parse_VkImageLayout(json["finalLayout"], CreateScope("finalLayout"));
        return s;
    }

    VkAttachmentDescriptionStencilLayout parse_VkAttachmentDescriptionStencilLayout_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkAttachmentDescriptionStencilLayout s{};
        s.stencilInitialLayout = parse_VkImageLayout(json["stencilInitialLayout"], CreateScope("stencilInitialLayout"));
        s.stencilFinalLayout = parse_VkImageLayout(json["stencilFinalLayout"], CreateScope("stencilFinalLayout"));
        return s;
    }

    VkAttachmentDescription2* parse_VkAttachmentDescription2_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkAttachmentDescription2>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkAttachmentDescription2(json[i], l);
        }

        return dst_buffer;
    }

    VkAttachmentReference2 parse_VkAttachmentReference2_contents(const Json::Value& json, const LocationScope& l) {
        VkAttachmentReference2 s{};
        s.attachment = parse_uint32_t(json["attachment"], CreateScope("attachment"));
        s.layout = parse_VkImageLayout(json["layout"], CreateScope("layout"));
        s.aspectMask = parse_VkImageAspectFlags(json["aspectMask"], CreateScope("aspectMask"));
        return s;
    }

    VkAttachmentReferenceStencilLayout parse_VkAttachmentReferenceStencilLayout_contents(const Json::Value& json,
                                                                                         const LocationScope& l) {
        VkAttachmentReferenceStencilLayout s{};
        s.stencilLayout = parse_VkImageLayout(json["stencilLayout"], CreateScope("stencilLayout"));
        return s;
    }

    VkAttachmentReference2* parse_VkAttachmentReference2_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkAttachmentReference2>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkAttachmentReference2(json[i], l);
        }

        return dst_buffer;
    }

    VkAttachmentReference2* parse_VkAttachmentReference2_pointer(const Json::Value& json, const LocationScope& l) {
        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }

        auto dst_buffer = AllocMem<VkAttachmentReference2>(1);
        dst_buffer[0] = parse_VkAttachmentReference2(json, l);

        return dst_buffer;
    }

    VkSubpassDescription2 parse_VkSubpassDescription2_contents(const Json::Value& json, const LocationScope& l) {
        VkSubpassDescription2 s{};
        s.flags = parse_VkSubpassDescriptionFlags(json["flags"], CreateScope("flags"));
        s.pipelineBindPoint = parse_VkPipelineBindPoint(json["pipelineBindPoint"], CreateScope("pipelineBindPoint"));
        s.viewMask = parse_uint32_t(json["viewMask"], CreateScope("viewMask"));
        s.inputAttachmentCount = parse_uint32_t(json["inputAttachmentCount"], CreateScope("inputAttachmentCount"));
        s.pInputAttachments = parse_VkAttachmentReference2_array(json["pInputAttachments"], CreateScope("pInputAttachments"));
        s.colorAttachmentCount = parse_uint32_t(json["colorAttachmentCount"], CreateScope("colorAttachmentCount"));
        s.pColorAttachments = parse_VkAttachmentReference2_array(json["pColorAttachments"], CreateScope("pColorAttachments"));
        s.pResolveAttachments = parse_VkAttachmentReference2_array(json["pResolveAttachments"], CreateScope("pResolveAttachments"));
        s.pDepthStencilAttachment =
            parse_VkAttachmentReference2_pointer(json["pDepthStencilAttachment"], CreateScope("pDepthStencilAttachment"));
        s.preserveAttachmentCount = parse_uint32_t(json["preserveAttachmentCount"], CreateScope("preserveAttachmentCount"));
        s.pPreserveAttachments = parse_uint32_t_array(json["pPreserveAttachments"], CreateScope("pPreserveAttachments"));
        return s;
    }

    VkFragmentShadingRateAttachmentInfoKHR parse_VkFragmentShadingRateAttachmentInfoKHR_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkFragmentShadingRateAttachmentInfoKHR s{};
        s.pFragmentShadingRateAttachment = parse_VkAttachmentReference2_pointer(json["pFragmentShadingRateAttachment"],
                                                                                CreateScope("pFragmentShadingRateAttachment"));
        s.shadingRateAttachmentTexelSize =
            parse_VkExtent2D_contents(json["shadingRateAttachmentTexelSize"], CreateScope("shadingRateAttachmentTexelSize"));
        return s;
    }

    VkSubpassDescriptionDepthStencilResolve parse_VkSubpassDescriptionDepthStencilResolve_contents(const Json::Value& json,
                                                                                                   const LocationScope& l) {
        VkSubpassDescriptionDepthStencilResolve s{};
        s.depthResolveMode = parse_VkResolveModeFlagBits(json["depthResolveMode"], CreateScope("depthResolveMode"));
        s.stencilResolveMode = parse_VkResolveModeFlagBits(json["stencilResolveMode"], CreateScope("stencilResolveMode"));
        s.pDepthStencilResolveAttachment = parse_VkAttachmentReference2_pointer(json["pDepthStencilResolveAttachment"],
                                                                                CreateScope("pDepthStencilResolveAttachment"));
        return s;
    }

    VkSubpassDescription2* parse_VkSubpassDescription2_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkSubpassDescription2>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkSubpassDescription2(json[i], l);
        }

        return dst_buffer;
    }

    VkSubpassDependency2 parse_VkSubpassDependency2_contents(const Json::Value& json, const LocationScope& l) {
        VkSubpassDependency2 s{};
        s.srcSubpass = parse_uint32_t(json["srcSubpass"], CreateScope("srcSubpass"));
        s.dstSubpass = parse_uint32_t(json["dstSubpass"], CreateScope("dstSubpass"));
        s.srcStageMask = parse_VkPipelineStageFlags(json["srcStageMask"], CreateScope("srcStageMask"));
        s.dstStageMask = parse_VkPipelineStageFlags(json["dstStageMask"], CreateScope("dstStageMask"));
        s.srcAccessMask = parse_VkAccessFlags(json["srcAccessMask"], CreateScope("srcAccessMask"));
        s.dstAccessMask = parse_VkAccessFlags(json["dstAccessMask"], CreateScope("dstAccessMask"));
        s.dependencyFlags = parse_VkDependencyFlags(json["dependencyFlags"], CreateScope("dependencyFlags"));
        s.viewOffset = parse_int32_t(json["viewOffset"], CreateScope("viewOffset"));
        return s;
    }

    VkMemoryBarrier2 parse_VkMemoryBarrier2_contents(const Json::Value& json, const LocationScope& l) {
        VkMemoryBarrier2 s{};
        s.srcStageMask = parse_VkPipelineStageFlags2(json["srcStageMask"], CreateScope("srcStageMask"));
        s.srcAccessMask = parse_VkAccessFlags2(json["srcAccessMask"], CreateScope("srcAccessMask"));
        s.dstStageMask = parse_VkPipelineStageFlags2(json["dstStageMask"], CreateScope("dstStageMask"));
        s.dstAccessMask = parse_VkAccessFlags2(json["dstAccessMask"], CreateScope("dstAccessMask"));
        return s;
    }

    VkSubpassDependency2* parse_VkSubpassDependency2_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkSubpassDependency2>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkSubpassDependency2(json[i], l);
        }

        return dst_buffer;
    }

    VkRenderPassCreateInfo2 parse_VkRenderPassCreateInfo2_contents(const Json::Value& json, const LocationScope& l) {
        VkRenderPassCreateInfo2 s{};
        s.flags = parse_VkRenderPassCreateFlags(json["flags"], CreateScope("flags"));
        s.attachmentCount = parse_uint32_t(json["attachmentCount"], CreateScope("attachmentCount"));
        s.pAttachments = parse_VkAttachmentDescription2_array(json["pAttachments"], CreateScope("pAttachments"));
        s.subpassCount = parse_uint32_t(json["subpassCount"], CreateScope("subpassCount"));
        s.pSubpasses = parse_VkSubpassDescription2_array(json["pSubpasses"], CreateScope("pSubpasses"));
        s.dependencyCount = parse_uint32_t(json["dependencyCount"], CreateScope("dependencyCount"));
        s.pDependencies = parse_VkSubpassDependency2_array(json["pDependencies"], CreateScope("pDependencies"));
        s.correlatedViewMaskCount = parse_uint32_t(json["correlatedViewMaskCount"], CreateScope("correlatedViewMaskCount"));
        s.pCorrelatedViewMasks = parse_uint32_t_array(json["pCorrelatedViewMasks"], CreateScope("pCorrelatedViewMasks"));
        return s;
    }

    VkPipelineCacheCreateInfo parse_VkPipelineCacheCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelineCacheCreateInfo s{};
        s.flags = parse_VkPipelineCacheCreateFlags(json["flags"], CreateScope("flags"));
        s.initialDataSize = parse_size_t(json["initialDataSize"], CreateScope("initialDataSize"));
        s.pInitialData = parse_binary(json["pInitialData"], CreateScope("pInitialData"));
        return s;
    }

    VkPipelineCacheCreateInfo* parse_VkPipelineCacheCreateInfo_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkPipelineCacheCreateInfo>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkPipelineCacheCreateInfo(json[i], l);
        }

        return dst_buffer;
    }

    VkPipelinePoolSize parse_VkPipelinePoolSize_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelinePoolSize s{};
        s.poolEntrySize = parse_VkDeviceSize(json["poolEntrySize"], CreateScope("poolEntrySize"));
        s.poolEntryCount = parse_uint32_t(json["poolEntryCount"], CreateScope("poolEntryCount"));
        return s;
    }

    VkPipelinePoolSize* parse_VkPipelinePoolSize_array(const Json::Value& json, const LocationScope& l) {
        if (!json.isArray() && !(json.isString() && json.asString() == "NULL")) {
            Error() << "Not an array";
            return nullptr;
        }

        if (json.isString() && json.asString() == "NULL") {
            return nullptr;
        }
        auto count = json.size();
        auto dst_buffer = AllocMem<VkPipelinePoolSize>(count);
        for (Json::Value::ArrayIndex i = 0; i < count; ++i) {
            dst_buffer[i] = parse_VkPipelinePoolSize(json[i], l);
        }

        return dst_buffer;
    }

    VkDeviceObjectReservationCreateInfo parse_VkDeviceObjectReservationCreateInfo_contents(const Json::Value& json,
                                                                                           const LocationScope& l) {
        VkDeviceObjectReservationCreateInfo s{};
        s.pipelineCacheCreateInfoCount =
            parse_uint32_t(json["pipelineCacheCreateInfoCount"], CreateScope("pipelineCacheCreateInfoCount"));
        s.pPipelineCacheCreateInfos =
            parse_VkPipelineCacheCreateInfo_array(json["pPipelineCacheCreateInfos"], CreateScope("pPipelineCacheCreateInfos"));
        s.pipelinePoolSizeCount = parse_uint32_t(json["pipelinePoolSizeCount"], CreateScope("pipelinePoolSizeCount"));
        s.pPipelinePoolSizes = parse_VkPipelinePoolSize_array(json["pPipelinePoolSizes"], CreateScope("pPipelinePoolSizes"));
        s.semaphoreRequestCount = parse_uint32_t(json["semaphoreRequestCount"], CreateScope("semaphoreRequestCount"));
        s.commandBufferRequestCount = parse_uint32_t(json["commandBufferRequestCount"], CreateScope("commandBufferRequestCount"));
        s.fenceRequestCount = parse_uint32_t(json["fenceRequestCount"], CreateScope("fenceRequestCount"));
        s.deviceMemoryRequestCount = parse_uint32_t(json["deviceMemoryRequestCount"], CreateScope("deviceMemoryRequestCount"));
        s.bufferRequestCount = parse_uint32_t(json["bufferRequestCount"], CreateScope("bufferRequestCount"));
        s.imageRequestCount = parse_uint32_t(json["imageRequestCount"], CreateScope("imageRequestCount"));
        s.eventRequestCount = parse_uint32_t(json["eventRequestCount"], CreateScope("eventRequestCount"));
        s.queryPoolRequestCount = parse_uint32_t(json["queryPoolRequestCount"], CreateScope("queryPoolRequestCount"));
        s.bufferViewRequestCount = parse_uint32_t(json["bufferViewRequestCount"], CreateScope("bufferViewRequestCount"));
        s.imageViewRequestCount = parse_uint32_t(json["imageViewRequestCount"], CreateScope("imageViewRequestCount"));
        s.layeredImageViewRequestCount =
            parse_uint32_t(json["layeredImageViewRequestCount"], CreateScope("layeredImageViewRequestCount"));
        s.pipelineCacheRequestCount = parse_uint32_t(json["pipelineCacheRequestCount"], CreateScope("pipelineCacheRequestCount"));
        s.pipelineLayoutRequestCount =
            parse_uint32_t(json["pipelineLayoutRequestCount"], CreateScope("pipelineLayoutRequestCount"));
        s.renderPassRequestCount = parse_uint32_t(json["renderPassRequestCount"], CreateScope("renderPassRequestCount"));
        s.graphicsPipelineRequestCount =
            parse_uint32_t(json["graphicsPipelineRequestCount"], CreateScope("graphicsPipelineRequestCount"));
        s.computePipelineRequestCount =
            parse_uint32_t(json["computePipelineRequestCount"], CreateScope("computePipelineRequestCount"));
        s.descriptorSetLayoutRequestCount =
            parse_uint32_t(json["descriptorSetLayoutRequestCount"], CreateScope("descriptorSetLayoutRequestCount"));
        s.samplerRequestCount = parse_uint32_t(json["samplerRequestCount"], CreateScope("samplerRequestCount"));
        s.descriptorPoolRequestCount =
            parse_uint32_t(json["descriptorPoolRequestCount"], CreateScope("descriptorPoolRequestCount"));
        s.descriptorSetRequestCount = parse_uint32_t(json["descriptorSetRequestCount"], CreateScope("descriptorSetRequestCount"));
        s.framebufferRequestCount = parse_uint32_t(json["framebufferRequestCount"], CreateScope("framebufferRequestCount"));
        s.commandPoolRequestCount = parse_uint32_t(json["commandPoolRequestCount"], CreateScope("commandPoolRequestCount"));
        s.samplerYcbcrConversionRequestCount =
            parse_uint32_t(json["samplerYcbcrConversionRequestCount"], CreateScope("samplerYcbcrConversionRequestCount"));
        s.surfaceRequestCount = parse_uint32_t(json["surfaceRequestCount"], CreateScope("surfaceRequestCount"));
        s.swapchainRequestCount = parse_uint32_t(json["swapchainRequestCount"], CreateScope("swapchainRequestCount"));
        s.displayModeRequestCount = parse_uint32_t(json["displayModeRequestCount"], CreateScope("displayModeRequestCount"));
        s.subpassDescriptionRequestCount =
            parse_uint32_t(json["subpassDescriptionRequestCount"], CreateScope("subpassDescriptionRequestCount"));
        s.attachmentDescriptionRequestCount =
            parse_uint32_t(json["attachmentDescriptionRequestCount"], CreateScope("attachmentDescriptionRequestCount"));
        s.descriptorSetLayoutBindingRequestCount =
            parse_uint32_t(json["descriptorSetLayoutBindingRequestCount"], CreateScope("descriptorSetLayoutBindingRequestCount"));
        s.descriptorSetLayoutBindingLimit =
            parse_uint32_t(json["descriptorSetLayoutBindingLimit"], CreateScope("descriptorSetLayoutBindingLimit"));
        s.maxImageViewMipLevels = parse_uint32_t(json["maxImageViewMipLevels"], CreateScope("maxImageViewMipLevels"));
        s.maxImageViewArrayLayers = parse_uint32_t(json["maxImageViewArrayLayers"], CreateScope("maxImageViewArrayLayers"));
        s.maxLayeredImageViewMipLevels =
            parse_uint32_t(json["maxLayeredImageViewMipLevels"], CreateScope("maxLayeredImageViewMipLevels"));
        s.maxOcclusionQueriesPerPool =
            parse_uint32_t(json["maxOcclusionQueriesPerPool"], CreateScope("maxOcclusionQueriesPerPool"));
        s.maxPipelineStatisticsQueriesPerPool =
            parse_uint32_t(json["maxPipelineStatisticsQueriesPerPool"], CreateScope("maxPipelineStatisticsQueriesPerPool"));
        s.maxTimestampQueriesPerPool =
            parse_uint32_t(json["maxTimestampQueriesPerPool"], CreateScope("maxTimestampQueriesPerPool"));
        s.maxImmutableSamplersPerDescriptorSetLayout = parse_uint32_t(json["maxImmutableSamplersPerDescriptorSetLayout"],
                                                                      CreateScope("maxImmutableSamplersPerDescriptorSetLayout"));
        return s;
    }
};

}  // namespace pcjson
   // NOLINTEND
