#ifndef _VULKAN_JSON_DATA_HPP
#define _VULKAN_JSON_DATA_HPP

/*
 * Copyright 2021-2025 The Khronos Group Inc.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 *//*!
 * \file
 * \brief Defines JSON generators for Vulkan structures
 */

/********************************************************************************************/
/** This code is generated. To make changes, please modify the scripts or the relevant xml **/
/********************************************************************************************/

#include <iostream>
#include <map>
#include <bitset>
#include <functional>
#include <sstream>
#include <cassert>
#include <cmath>
#ifndef VULKAN_JSON_CTS
#include <vulkan/vulkan.h>
#endif

namespace vk_json {

static thread_local int s_num_spaces = 0;
static thread_local std::stringstream _string_stream;

static void dumpPNextChain(const void* pNext);

// By default, redirect to std::cout. Can stream it to a stringstream if needed.
//#define   _OUT std::cout
#define _OUT _string_stream

// Helper utility to do indentation in the generated json file.
#define PRINT_SPACE \
    for (int k = 0; k < s_num_spaces; k++) _OUT << " ";

#define INDENT(sz) s_num_spaces += (sz);

#define PRINT_VAL(c)                                       \
    PRINT_SPACE                                            \
    if (s != "") {                                         \
        _OUT << "\"" << s << "\""                          \
             << " : " << o << (c ? "," : "") << std::endl; \
    } else {                                               \
        _OUT << o << (c ? "," : "") << std::endl;          \
    }

#define PRINT_STR(c)                                              \
    PRINT_SPACE                                                   \
    if (s != "") {                                                \
        _OUT << "\"" << s << "\""                                 \
             << " : "                                             \
             << "\"" << o << "\"" << (c ? "," : "") << std::endl; \
    } else {                                                      \
        _OUT << "\"" << o << "\"" << (c ? "," : "") << std::endl; \
    }

// To make sure the generated data is consistent across platforms,
// we typecast to 32-bit and dump the data.
// The value is not expected to exceed the range.
static void print_size_t(const size_t* o, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "\"" << s << "\""
         << " : " << static_cast<uint32_t>(*o) << (commaNeeded ? "," : "") << std::endl;
}
static void print_size_t(size_t o, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "\"" << s << "\""
         << " : " << static_cast<uint32_t>(o) << (commaNeeded ? "," : "") << std::endl;
}

static void print_int32_t(int32_t o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_int32_t(const int32_t* o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_uint32_t(uint32_t o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_uint32_t(const uint32_t* o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_uint8_t(uint8_t o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_uint8_t(const uint8_t* o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_uint64_t(uint64_t o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_uint64_t(const uint64_t* o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_float(float o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_float(const float* o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_int(int o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_int(const int* o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_double(double o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_double(const double* o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_int64_t(int64_t o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_int64_t(const int64_t* o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_uint16_t(uint16_t o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_uint16_t(const uint16_t* o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_char(const char* const* o, const std::string& s, bool commaNeeded = true) { PRINT_STR(commaNeeded) }

static void print_char(char o, const std::string& s, bool commaNeeded = true) { PRINT_VAL(commaNeeded) }

static void print_char(const char* o, const std::string& s, bool commaNeeded = true) { PRINT_STR(commaNeeded) }

// Base 64 formatter class from executor/xeTestLogWriter.cpp

class Base64Formatter {
  public:
    const uint8_t* data;
    int numBytes;

    Base64Formatter(const uint8_t* data_, int numBytes_) : data(data_), numBytes(numBytes_) {}
};

std::ostream& operator<<(std::ostream& str, const Base64Formatter& fmt) {
    static const char s_base64Table[64] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
                                           'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
                                           'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
                                           'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};

    const uint8_t* data = fmt.data;
    int numBytes = fmt.numBytes;
    int srcNdx = 0;

    assert(data && (numBytes > 0));

    /* Loop all input chars. */
    while (srcNdx < numBytes) {
#undef min
        int numRead = std::min(3, numBytes - srcNdx);
        uint8_t s0 = data[srcNdx];
        uint8_t s1 = (numRead >= 2) ? data[srcNdx + 1] : 0;
        uint8_t s2 = (numRead >= 3) ? data[srcNdx + 2] : 0;
        char d[4];

        srcNdx += numRead;

        d[0] = s_base64Table[s0 >> 2];
        d[1] = s_base64Table[((s0 & 0x3) << 4) | (s1 >> 4)];
        d[2] = s_base64Table[((s1 & 0xF) << 2) | (s2 >> 6)];
        d[3] = s_base64Table[s2 & 0x3F];

        if (numRead < 3) d[3] = '=';
        if (numRead < 2) d[2] = '=';

        /* Write data. */
        str.write(&d[0], sizeof(d));
    }

    return str;
}

inline Base64Formatter toBase64(const uint8_t* bytes, int numBytes) { return Base64Formatter(bytes, numBytes); }

static void print_void_data(const void* o, int oSize, const std::string& s, bool commaNeeded = true) {
    if (o != NULL && oSize != 0) {
        PRINT_SPACE _OUT << "\"" << s << "\""
                         << " : "
                         << "\"" << toBase64((uint8_t*)o, oSize) << "\"" << (commaNeeded ? "," : "") << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"" << s << "\""
                         << " : "
                         << "\"NULL\"" << (commaNeeded ? "," : "") << std::endl;
    }
}

static void print_VkBool32(VkBool32 obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "\"" << str << "\""
         << " : "
         << "\"" << ((obj == 0) ? ("VK_FALSE") : ("VK_TRUE")) << "\"" << (commaNeeded ? "," : "") << std::endl;
}

static void print_VkDeviceAddress(VkDeviceAddress obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "\"" << str << "\""
         << " : "
         << "\"" << obj << "\"" << (commaNeeded ? "," : "") << std::endl;
}

static void print_VkDeviceSize(VkDeviceSize obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "\"" << str << "\""
         << " : "
         << "\"" << obj << "\"" << (commaNeeded ? "," : "") << std::endl;
}

static void print_VkFlags(VkFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "\"" << str << "\""
         << " : "
         << "\"" << obj << "\"" << (commaNeeded ? "," : "") << std::endl;
}

static void print_VkSampleMask(VkSampleMask obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "\"" << str << "\""
         << " : "
         << "\"" << obj << "\"" << (commaNeeded ? "," : "") << std::endl;
}

static void print_VkBuffer(VkBuffer obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkImage(VkImage obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkInstance(VkInstance obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkPhysicalDevice(VkPhysicalDevice obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkDevice(VkDevice obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkQueue(VkQueue obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkSemaphore(VkSemaphore obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkCommandBuffer(VkCommandBuffer obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkFence(VkFence obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkDeviceMemory(VkDeviceMemory obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkEvent(VkEvent obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkQueryPool(VkQueryPool obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkBufferView(VkBufferView obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkImageView(VkImageView obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkShaderModule(VkShaderModule obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkPipelineCache(VkPipelineCache obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkPipelineLayout(VkPipelineLayout obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkPipeline(VkPipeline obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkRenderPass(VkRenderPass obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkDescriptorSetLayout(VkDescriptorSetLayout obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkSampler(VkSampler obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkDescriptorSet(VkDescriptorSet obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkDescriptorPool(VkDescriptorPool obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkFramebuffer(VkFramebuffer obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkCommandPool(VkCommandPool obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkResult_map = {
    std::make_pair(0, "VK_SUCCESS"),
    std::make_pair(1, "VK_NOT_READY"),
    std::make_pair(2, "VK_TIMEOUT"),
    std::make_pair(3, "VK_EVENT_SET"),
    std::make_pair(4, "VK_EVENT_RESET"),
    std::make_pair(5, "VK_INCOMPLETE"),
    std::make_pair(-1, "VK_ERROR_OUT_OF_HOST_MEMORY"),
    std::make_pair(-2, "VK_ERROR_OUT_OF_DEVICE_MEMORY"),
    std::make_pair(-3, "VK_ERROR_INITIALIZATION_FAILED"),
    std::make_pair(-4, "VK_ERROR_DEVICE_LOST"),
    std::make_pair(-5, "VK_ERROR_MEMORY_MAP_FAILED"),
    std::make_pair(-6, "VK_ERROR_LAYER_NOT_PRESENT"),
    std::make_pair(-7, "VK_ERROR_EXTENSION_NOT_PRESENT"),
    std::make_pair(-8, "VK_ERROR_FEATURE_NOT_PRESENT"),
    std::make_pair(-9, "VK_ERROR_INCOMPATIBLE_DRIVER"),
    std::make_pair(-10, "VK_ERROR_TOO_MANY_OBJECTS"),
    std::make_pair(-11, "VK_ERROR_FORMAT_NOT_SUPPORTED"),
    std::make_pair(-12, "VK_ERROR_FRAGMENTED_POOL"),
    std::make_pair(-13, "VK_ERROR_UNKNOWN"),
    std::make_pair(-1000069000, "VK_ERROR_OUT_OF_POOL_MEMORY"),
    std::make_pair(-1000072003, "VK_ERROR_INVALID_EXTERNAL_HANDLE"),
    std::make_pair(-1000161000, "VK_ERROR_FRAGMENTATION"),
    std::make_pair(-1000257000, "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS"),
    std::make_pair(1000297000, "VK_PIPELINE_COMPILE_REQUIRED"),
    std::make_pair(-1000174001, "VK_ERROR_NOT_PERMITTED"),
    std::make_pair(-1000000000, "VK_ERROR_SURFACE_LOST_KHR"),
    std::make_pair(-1000000001, "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"),
    std::make_pair(1000001003, "VK_SUBOPTIMAL_KHR"),
    std::make_pair(-1000001004, "VK_ERROR_OUT_OF_DATE_KHR"),
    std::make_pair(-1000003001, "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"),
    std::make_pair(-1000011001, "VK_ERROR_VALIDATION_FAILED_EXT"),
    std::make_pair(-1000012000, "VK_ERROR_INVALID_SHADER_NV"),
    std::make_pair(-1000023000, "VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR"),
    std::make_pair(-1000023001, "VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR"),
    std::make_pair(-1000023002, "VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR"),
    std::make_pair(-1000023003, "VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR"),
    std::make_pair(-1000023004, "VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR"),
    std::make_pair(-1000023005, "VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR"),
    std::make_pair(-1000158000, "VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT"),
    std::make_pair(-1000255000, "VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT"),
    std::make_pair(1000268000, "VK_THREAD_IDLE_KHR"),
    std::make_pair(1000268001, "VK_THREAD_DONE_KHR"),
    std::make_pair(1000268002, "VK_OPERATION_DEFERRED_KHR"),
    std::make_pair(1000268003, "VK_OPERATION_NOT_DEFERRED_KHR"),
    std::make_pair(-1000299000, "VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR"),
    std::make_pair(-1000338000, "VK_ERROR_COMPRESSION_EXHAUSTED_EXT"),
    std::make_pair(1000482000, "VK_INCOMPATIBLE_SHADER_BINARY_EXT"),
    std::make_pair(1000483000, "VK_PIPELINE_BINARY_MISSING_KHR"),
    std::make_pair(-1000483000, "VK_ERROR_NOT_ENOUGH_SPACE_KHR"),
};
static void print_VkResult(VkResult obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkResult_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkResult_map[obj] << "\"" << std::endl;
}
static void print_VkResult(const VkResult* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkResult_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkResult_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkStructureType_map = {
    std::make_pair(0, "VK_STRUCTURE_TYPE_APPLICATION_INFO"),
    std::make_pair(1, "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"),
    std::make_pair(2, "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"),
    std::make_pair(3, "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"),
    std::make_pair(4, "VK_STRUCTURE_TYPE_SUBMIT_INFO"),
    std::make_pair(5, "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"),
    std::make_pair(6, "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"),
    std::make_pair(7, "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"),
    std::make_pair(8, "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"),
    std::make_pair(9, "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"),
    std::make_pair(10, "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"),
    std::make_pair(11, "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"),
    std::make_pair(12, "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"),
    std::make_pair(13, "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"),
    std::make_pair(14, "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"),
    std::make_pair(15, "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"),
    std::make_pair(16, "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"),
    std::make_pair(17, "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"),
    std::make_pair(18, "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"),
    std::make_pair(19, "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"),
    std::make_pair(20, "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"),
    std::make_pair(21, "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"),
    std::make_pair(22, "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"),
    std::make_pair(23, "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"),
    std::make_pair(24, "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"),
    std::make_pair(25, "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"),
    std::make_pair(26, "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"),
    std::make_pair(27, "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"),
    std::make_pair(28, "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"),
    std::make_pair(29, "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"),
    std::make_pair(30, "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"),
    std::make_pair(31, "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"),
    std::make_pair(32, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"),
    std::make_pair(33, "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"),
    std::make_pair(34, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"),
    std::make_pair(35, "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"),
    std::make_pair(36, "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"),
    std::make_pair(37, "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"),
    std::make_pair(38, "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"),
    std::make_pair(39, "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"),
    std::make_pair(40, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"),
    std::make_pair(41, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"),
    std::make_pair(42, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"),
    std::make_pair(43, "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"),
    std::make_pair(44, "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"),
    std::make_pair(45, "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"),
    std::make_pair(46, "VK_STRUCTURE_TYPE_MEMORY_BARRIER"),
    std::make_pair(47, "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"),
    std::make_pair(48, "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"),
    std::make_pair(1000094000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"),
    std::make_pair(1000157000, "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"),
    std::make_pair(1000157001, "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"),
    std::make_pair(1000083000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"),
    std::make_pair(1000127000, "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"),
    std::make_pair(1000127001, "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"),
    std::make_pair(1000060000, "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"),
    std::make_pair(1000060003, "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"),
    std::make_pair(1000060004, "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"),
    std::make_pair(1000060005, "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"),
    std::make_pair(1000060006, "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"),
    std::make_pair(1000060013, "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"),
    std::make_pair(1000060014, "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"),
    std::make_pair(1000070000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"),
    std::make_pair(1000070001, "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"),
    std::make_pair(1000146000, "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"),
    std::make_pair(1000146001, "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"),
    std::make_pair(1000146002, "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"),
    std::make_pair(1000146003, "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"),
    std::make_pair(1000146004, "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"),
    std::make_pair(1000059000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"),
    std::make_pair(1000059001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"),
    std::make_pair(1000059002, "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"),
    std::make_pair(1000059003, "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"),
    std::make_pair(1000059004, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"),
    std::make_pair(1000059005, "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"),
    std::make_pair(1000059006, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"),
    std::make_pair(1000059007, "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"),
    std::make_pair(1000059008, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"),
    std::make_pair(1000117000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"),
    std::make_pair(1000117001, "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"),
    std::make_pair(1000117002, "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"),
    std::make_pair(1000117003, "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"),
    std::make_pair(1000053000, "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"),
    std::make_pair(1000053001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"),
    std::make_pair(1000053002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"),
    std::make_pair(1000120000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"),
    std::make_pair(1000145000, "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO"),
    std::make_pair(1000145001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"),
    std::make_pair(1000145002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"),
    std::make_pair(1000145003, "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2"),
    std::make_pair(1000156000, "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"),
    std::make_pair(1000156001, "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"),
    std::make_pair(1000156002, "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"),
    std::make_pair(1000156003, "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"),
    std::make_pair(1000156004, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"),
    std::make_pair(1000156005, "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"),
    std::make_pair(1000085000, "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"),
    std::make_pair(1000071000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"),
    std::make_pair(1000071001, "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"),
    std::make_pair(1000071002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"),
    std::make_pair(1000071003, "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"),
    std::make_pair(1000071004, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"),
    std::make_pair(1000072000, "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"),
    std::make_pair(1000072001, "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"),
    std::make_pair(1000072002, "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"),
    std::make_pair(1000112000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"),
    std::make_pair(1000112001, "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"),
    std::make_pair(1000113000, "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"),
    std::make_pair(1000077000, "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"),
    std::make_pair(1000076000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"),
    std::make_pair(1000076001, "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"),
    std::make_pair(1000168000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"),
    std::make_pair(1000168001, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"),
    std::make_pair(1000063000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"),
    std::make_pair(49, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES"),
    std::make_pair(50, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES"),
    std::make_pair(51, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES"),
    std::make_pair(52, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES"),
    std::make_pair(1000147000, "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO"),
    std::make_pair(1000109000, "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2"),
    std::make_pair(1000109001, "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2"),
    std::make_pair(1000109002, "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2"),
    std::make_pair(1000109003, "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2"),
    std::make_pair(1000109004, "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2"),
    std::make_pair(1000109005, "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO"),
    std::make_pair(1000109006, "VK_STRUCTURE_TYPE_SUBPASS_END_INFO"),
    std::make_pair(1000177000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"),
    std::make_pair(1000196000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"),
    std::make_pair(1000180000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"),
    std::make_pair(1000082000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"),
    std::make_pair(1000197000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"),
    std::make_pair(1000161000, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO"),
    std::make_pair(1000161001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"),
    std::make_pair(1000161002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"),
    std::make_pair(1000161003, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO"),
    std::make_pair(1000161004, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT"),
    std::make_pair(1000199000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"),
    std::make_pair(1000199001, "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE"),
    std::make_pair(1000221000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"),
    std::make_pair(1000246000, "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO"),
    std::make_pair(1000130000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"),
    std::make_pair(1000130001, "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO"),
    std::make_pair(1000211000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"),
    std::make_pair(1000108000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"),
    std::make_pair(1000108001, "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO"),
    std::make_pair(1000108002, "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO"),
    std::make_pair(1000108003, "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO"),
    std::make_pair(1000253000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"),
    std::make_pair(1000175000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"),
    std::make_pair(1000241000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"),
    std::make_pair(1000241001, "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT"),
    std::make_pair(1000241002, "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT"),
    std::make_pair(1000261000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"),
    std::make_pair(1000207000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"),
    std::make_pair(1000207001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"),
    std::make_pair(1000207002, "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO"),
    std::make_pair(1000207003, "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO"),
    std::make_pair(1000207004, "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO"),
    std::make_pair(1000207005, "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO"),
    std::make_pair(1000257000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"),
    std::make_pair(1000244001, "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"),
    std::make_pair(1000257002, "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO"),
    std::make_pair(1000257003, "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO"),
    std::make_pair(1000257004, "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO"),
    std::make_pair(53, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES"),
    std::make_pair(54, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES"),
    std::make_pair(1000192000, "VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO"),
    std::make_pair(1000215000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES"),
    std::make_pair(1000245000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES"),
    std::make_pair(1000276000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES"),
    std::make_pair(1000295000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES"),
    std::make_pair(1000295001, "VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO"),
    std::make_pair(1000295002, "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO"),
    std::make_pair(1000297000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES"),
    std::make_pair(1000314000, "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2"),
    std::make_pair(1000314001, "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2"),
    std::make_pair(1000314002, "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2"),
    std::make_pair(1000314003, "VK_STRUCTURE_TYPE_DEPENDENCY_INFO"),
    std::make_pair(1000314004, "VK_STRUCTURE_TYPE_SUBMIT_INFO_2"),
    std::make_pair(1000314005, "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO"),
    std::make_pair(1000314006, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO"),
    std::make_pair(1000314007, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES"),
    std::make_pair(1000325000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES"),
    std::make_pair(1000335000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES"),
    std::make_pair(1000337000, "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2"),
    std::make_pair(1000337001, "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2"),
    std::make_pair(1000337002, "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2"),
    std::make_pair(1000337003, "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2"),
    std::make_pair(1000337004, "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2"),
    std::make_pair(1000337005, "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2"),
    std::make_pair(1000337006, "VK_STRUCTURE_TYPE_BUFFER_COPY_2"),
    std::make_pair(1000337007, "VK_STRUCTURE_TYPE_IMAGE_COPY_2"),
    std::make_pair(1000337008, "VK_STRUCTURE_TYPE_IMAGE_BLIT_2"),
    std::make_pair(1000337009, "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2"),
    std::make_pair(1000337010, "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2"),
    std::make_pair(1000225000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES"),
    std::make_pair(1000225001, "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO"),
    std::make_pair(1000225002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES"),
    std::make_pair(1000138000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES"),
    std::make_pair(1000138001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES"),
    std::make_pair(1000138002, "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK"),
    std::make_pair(1000138003, "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO"),
    std::make_pair(1000066000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES"),
    std::make_pair(1000044000, "VK_STRUCTURE_TYPE_RENDERING_INFO"),
    std::make_pair(1000044001, "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO"),
    std::make_pair(1000044002, "VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO"),
    std::make_pair(1000044003, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES"),
    std::make_pair(1000044004, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO"),
    std::make_pair(1000280000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES"),
    std::make_pair(1000280001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES"),
    std::make_pair(1000281001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES"),
    std::make_pair(1000360000, "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3"),
    std::make_pair(1000413000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES"),
    std::make_pair(1000413001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES"),
    std::make_pair(1000413002, "VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS"),
    std::make_pair(1000413003, "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS"),
    std::make_pair(55, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES"),
    std::make_pair(56, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES"),
    std::make_pair(1000174000, "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO"),
    std::make_pair(1000388000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES"),
    std::make_pair(1000388001, "VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES"),
    std::make_pair(1000416000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES"),
    std::make_pair(1000528000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES"),
    std::make_pair(1000544000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES"),
    std::make_pair(1000259000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES"),
    std::make_pair(1000259001, "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO"),
    std::make_pair(1000259002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES"),
    std::make_pair(1000525000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES"),
    std::make_pair(1000190001, "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO"),
    std::make_pair(1000190002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES"),
    std::make_pair(1000265000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES"),
    std::make_pair(1000271000, "VK_STRUCTURE_TYPE_MEMORY_MAP_INFO"),
    std::make_pair(1000271001, "VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO"),
    std::make_pair(1000470000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES"),
    std::make_pair(1000470001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES"),
    std::make_pair(1000470003, "VK_STRUCTURE_TYPE_RENDERING_AREA_INFO"),
    std::make_pair(1000470004, "VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO"),
    std::make_pair(1000338002, "VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2"),
    std::make_pair(1000338003, "VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2"),
    std::make_pair(1000470005, "VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO"),
    std::make_pair(1000470006, "VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO"),
    std::make_pair(1000080000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES"),
    std::make_pair(1000232000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES"),
    std::make_pair(1000232001, "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO"),
    std::make_pair(1000232002, "VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO"),
    std::make_pair(1000545000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES"),
    std::make_pair(1000545001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES"),
    std::make_pair(1000545002, "VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS"),
    std::make_pair(1000545003, "VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO"),
    std::make_pair(1000545004, "VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO"),
    std::make_pair(1000545005, "VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO"),
    std::make_pair(1000545006, "VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO"),
    std::make_pair(1000466000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES"),
    std::make_pair(1000068000, "VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO"),
    std::make_pair(1000068001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES"),
    std::make_pair(1000068002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES"),
    std::make_pair(1000270000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES"),
    std::make_pair(1000270001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES"),
    std::make_pair(1000270002, "VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY"),
    std::make_pair(1000270003, "VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY"),
    std::make_pair(1000270004, "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO"),
    std::make_pair(1000270005, "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO"),
    std::make_pair(1000270006, "VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO"),
    std::make_pair(1000270007, "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO"),
    std::make_pair(1000270008, "VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE"),
    std::make_pair(1000270009, "VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY"),
    std::make_pair(1000001000, "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"),
    std::make_pair(1000001001, "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"),
    std::make_pair(1000060007, "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"),
    std::make_pair(1000060008, "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"),
    std::make_pair(1000060009, "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"),
    std::make_pair(1000060010, "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"),
    std::make_pair(1000060011, "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"),
    std::make_pair(1000060012, "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"),
    std::make_pair(1000002000, "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"),
    std::make_pair(1000002001, "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"),
    std::make_pair(1000003000, "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"),
    std::make_pair(1000004000, "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"),
    std::make_pair(1000005000, "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"),
    std::make_pair(1000006000, "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"),
    std::make_pair(1000008000, "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"),
    std::make_pair(1000009000, "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"),
    std::make_pair(1000010000, "VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID"),
    std::make_pair(1000010001, "VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID"),
    std::make_pair(1000010002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID"),
    std::make_pair(1000011000, "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"),
    std::make_pair(1000018000, "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"),
    std::make_pair(1000022000, "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"),
    std::make_pair(1000022001, "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"),
    std::make_pair(1000022002, "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"),
    std::make_pair(1000023000, "VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR"),
    std::make_pair(1000023001, "VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR"),
    std::make_pair(1000023002, "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR"),
    std::make_pair(1000023003, "VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR"),
    std::make_pair(1000023004, "VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR"),
    std::make_pair(1000023005, "VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR"),
    std::make_pair(1000023006, "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR"),
    std::make_pair(1000023007, "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR"),
    std::make_pair(1000023008, "VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR"),
    std::make_pair(1000023009, "VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR"),
    std::make_pair(1000023010, "VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR"),
    std::make_pair(1000023011, "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR"),
    std::make_pair(1000023012, "VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR"),
    std::make_pair(1000023013, "VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR"),
    std::make_pair(1000023014, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR"),
    std::make_pair(1000023015, "VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR"),
    std::make_pair(1000023016, "VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR"),
    std::make_pair(1000024000, "VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR"),
    std::make_pair(1000024001, "VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR"),
    std::make_pair(1000024002, "VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR"),
    std::make_pair(1000026000, "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"),
    std::make_pair(1000026001, "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"),
    std::make_pair(1000026002, "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"),
    std::make_pair(1000028000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"),
    std::make_pair(1000028001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT"),
    std::make_pair(1000028002, "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT"),
    std::make_pair(1000029000, "VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX"),
    std::make_pair(1000029001, "VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX"),
    std::make_pair(1000029002, "VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX"),
    std::make_pair(1000029004, "VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX"),
    std::make_pair(1000030000, "VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX"),
    std::make_pair(1000030001, "VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX"),
    std::make_pair(1000038000, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR"),
    std::make_pair(1000038001, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR"),
    std::make_pair(1000038002, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR"),
    std::make_pair(1000038003, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR"),
    std::make_pair(1000038004, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR"),
    std::make_pair(1000038005, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR"),
    std::make_pair(1000038006, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR"),
    std::make_pair(1000038007, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR"),
    std::make_pair(1000038008, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR"),
    std::make_pair(1000038009, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR"),
    std::make_pair(1000038010, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR"),
    std::make_pair(1000038011, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR"),
    std::make_pair(1000038012, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR"),
    std::make_pair(1000038013, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR"),
    std::make_pair(1000039000, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR"),
    std::make_pair(1000039001, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR"),
    std::make_pair(1000039002, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR"),
    std::make_pair(1000039003, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR"),
    std::make_pair(1000039004, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR"),
    std::make_pair(1000039005, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR"),
    std::make_pair(1000039006, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR"),
    std::make_pair(1000039007, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR"),
    std::make_pair(1000039009, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR"),
    std::make_pair(1000039010, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR"),
    std::make_pair(1000039011, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR"),
    std::make_pair(1000039012, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR"),
    std::make_pair(1000039013, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR"),
    std::make_pair(1000039014, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR"),
    std::make_pair(1000040000, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR"),
    std::make_pair(1000040001, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR"),
    std::make_pair(1000040003, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR"),
    std::make_pair(1000040004, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR"),
    std::make_pair(1000040005, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR"),
    std::make_pair(1000040006, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR"),
    std::make_pair(1000041000, "VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"),
    std::make_pair(1000049000, "VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP"),
    std::make_pair(1000050000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV"),
    std::make_pair(1000051000, "VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV"),
    std::make_pair(1000056000, "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"),
    std::make_pair(1000056001, "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"),
    std::make_pair(1000057000, "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
    std::make_pair(1000057001, "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
    std::make_pair(1000058000, "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"),
    std::make_pair(1000060007, "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"),
    std::make_pair(1000060008, "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"),
    std::make_pair(1000060009, "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"),
    std::make_pair(1000060010, "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"),
    std::make_pair(1000060011, "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"),
    std::make_pair(1000060012, "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"),
    std::make_pair(1000061000, "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"),
    std::make_pair(1000062000, "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"),
    std::make_pair(1000067000, "VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT"),
    std::make_pair(1000067001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT"),
    std::make_pair(1000073000, "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
    std::make_pair(1000073001, "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
    std::make_pair(1000073002, "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"),
    std::make_pair(1000073003, "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"),
    std::make_pair(1000074000, "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"),
    std::make_pair(1000074001, "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"),
    std::make_pair(1000074002, "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"),
    std::make_pair(1000075000, "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"),
    std::make_pair(1000078000, "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"),
    std::make_pair(1000078001, "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"),
    std::make_pair(1000078002, "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"),
    std::make_pair(1000078003, "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"),
    std::make_pair(1000079000, "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"),
    std::make_pair(1000079001, "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"),
    std::make_pair(1000081000, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT"),
    std::make_pair(1000081001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT"),
    std::make_pair(1000081002, "VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT"),
    std::make_pair(1000084000, "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"),
    std::make_pair(1000087000, "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"),
    std::make_pair(1000090000, "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT"),
    std::make_pair(1000091000, "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"),
    std::make_pair(1000091001, "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"),
    std::make_pair(1000091002, "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"),
    std::make_pair(1000091003, "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"),
    std::make_pair(1000092000, "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"),
    std::make_pair(1000097000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"),
    std::make_pair(1000044009, "VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX"),
    std::make_pair(1000098000, "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"),
    std::make_pair(1000099000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"),
    std::make_pair(1000099001, "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"),
    std::make_pair(1000101000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"),
    std::make_pair(1000101001, "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"),
    std::make_pair(1000102000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT"),
    std::make_pair(1000102001, "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT"),
    std::make_pair(1000105000, "VK_STRUCTURE_TYPE_HDR_METADATA_EXT"),
    std::make_pair(1000110000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG"),
    std::make_pair(1000111000, "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"),
    std::make_pair(1000114000, "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
    std::make_pair(1000114001, "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
    std::make_pair(1000114002, "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"),
    std::make_pair(1000115000, "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"),
    std::make_pair(1000115001, "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"),
    std::make_pair(1000116000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR"),
    std::make_pair(1000116001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR"),
    std::make_pair(1000116002, "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR"),
    std::make_pair(1000116003, "VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR"),
    std::make_pair(1000116004, "VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR"),
    std::make_pair(1000116005, "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR"),
    std::make_pair(1000116006, "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR"),
    std::make_pair(1000119000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"),
    std::make_pair(1000119001, "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"),
    std::make_pair(1000119002, "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"),
    std::make_pair(1000121000, "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR"),
    std::make_pair(1000121001, "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR"),
    std::make_pair(1000121002, "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR"),
    std::make_pair(1000121003, "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR"),
    std::make_pair(1000121004, "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR"),
    std::make_pair(1000122000, "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"),
    std::make_pair(1000123000, "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"),
    std::make_pair(1000128000, "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"),
    std::make_pair(1000128001, "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT"),
    std::make_pair(1000128002, "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT"),
    std::make_pair(1000128003, "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"),
    std::make_pair(1000128004, "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"),
    std::make_pair(1000129000, "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"),
    std::make_pair(1000129001, "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"),
    std::make_pair(1000129002, "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"),
    std::make_pair(1000129003, "VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"),
    std::make_pair(1000129004, "VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"),
    std::make_pair(1000129005, "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID"),
    std::make_pair(1000129006, "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID"),
    std::make_pair(1000134000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX"),
    std::make_pair(1000134001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX"),
    std::make_pair(1000134002, "VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX"),
    std::make_pair(1000134003, "VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX"),
    std::make_pair(1000134004, "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX"),
    std::make_pair(1000044008, "VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD"),
    std::make_pair(1000143000, "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT"),
    std::make_pair(1000143001, "VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"),
    std::make_pair(1000143002, "VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"),
    std::make_pair(1000143003, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"),
    std::make_pair(1000143004, "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT"),
    std::make_pair(1000148000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"),
    std::make_pair(1000148001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"),
    std::make_pair(1000148002, "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"),
    std::make_pair(1000149000, "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"),
    std::make_pair(1000150007, "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR"),
    std::make_pair(1000150000, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR"),
    std::make_pair(1000150002, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR"),
    std::make_pair(1000150003, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR"),
    std::make_pair(1000150004, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR"),
    std::make_pair(1000150005, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR"),
    std::make_pair(1000150006, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR"),
    std::make_pair(1000150009, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR"),
    std::make_pair(1000150010, "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR"),
    std::make_pair(1000150011, "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR"),
    std::make_pair(1000150012, "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR"),
    std::make_pair(1000150013, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR"),
    std::make_pair(1000150014, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR"),
    std::make_pair(1000150017, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR"),
    std::make_pair(1000150020, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR"),
    std::make_pair(1000347000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR"),
    std::make_pair(1000347001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR"),
    std::make_pair(1000150015, "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR"),
    std::make_pair(1000150016, "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR"),
    std::make_pair(1000150018, "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR"),
    std::make_pair(1000348013, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR"),
    std::make_pair(1000152000, "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"),
    std::make_pair(1000154000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV"),
    std::make_pair(1000154001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV"),
    std::make_pair(1000158000, "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT"),
    std::make_pair(1000158002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT"),
    std::make_pair(1000158003, "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT"),
    std::make_pair(1000158004, "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT"),
    std::make_pair(1000158005, "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT"),
    std::make_pair(1000158006, "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT"),
    std::make_pair(1000160000, "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT"),
    std::make_pair(1000160001, "VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"),
    std::make_pair(1000163000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR"),
    std::make_pair(1000163001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR"),
    std::make_pair(1000164000, "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV"),
    std::make_pair(1000164001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV"),
    std::make_pair(1000164002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV"),
    std::make_pair(1000164005, "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV"),
    std::make_pair(1000165000, "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV"),
    std::make_pair(1000165001, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV"),
    std::make_pair(1000165003, "VK_STRUCTURE_TYPE_GEOMETRY_NV"),
    std::make_pair(1000165004, "VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV"),
    std::make_pair(1000165005, "VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV"),
    std::make_pair(1000165006, "VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV"),
    std::make_pair(1000165007, "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV"),
    std::make_pair(1000165008, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV"),
    std::make_pair(1000165009, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV"),
    std::make_pair(1000165011, "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV"),
    std::make_pair(1000165012, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV"),
    std::make_pair(1000166000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV"),
    std::make_pair(1000166001, "VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV"),
    std::make_pair(1000170000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT"),
    std::make_pair(1000170001, "VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT"),
    std::make_pair(1000178000, "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT"),
    std::make_pair(1000178001, "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT"),
    std::make_pair(1000178002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"),
    std::make_pair(1000181000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR"),
    std::make_pair(1000183000, "VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD"),
    std::make_pair(1000185000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"),
    std::make_pair(1000187000, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR"),
    std::make_pair(1000187001, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR"),
    std::make_pair(1000187002, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR"),
    std::make_pair(1000187003, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR"),
    std::make_pair(1000187004, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR"),
    std::make_pair(1000187005, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR"),
    std::make_pair(1000189000, "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD"),
    std::make_pair(1000190000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"),
    std::make_pair(1000191000, "VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP"),
    std::make_pair(1000202000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV"),
    std::make_pair(1000202001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV"),
    std::make_pair(1000204000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV"),
    std::make_pair(1000205000, "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV"),
    std::make_pair(1000205002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV"),
    std::make_pair(1000206000, "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV"),
    std::make_pair(1000206001, "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV"),
    std::make_pair(1000314008, "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV"),
    std::make_pair(1000314009, "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV"),
    std::make_pair(1000209000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL"),
    std::make_pair(1000210000, "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL"),
    std::make_pair(1000210001, "VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL"),
    std::make_pair(1000210002, "VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL"),
    std::make_pair(1000210003, "VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL"),
    std::make_pair(1000210004, "VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL"),
    std::make_pair(1000210005, "VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL"),
    std::make_pair(1000212000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT"),
    std::make_pair(1000213000, "VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD"),
    std::make_pair(1000213001, "VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD"),
    std::make_pair(1000214000, "VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA"),
    std::make_pair(1000217000, "VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT"),
    std::make_pair(1000218000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT"),
    std::make_pair(1000218001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT"),
    std::make_pair(1000218002, "VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT"),
    std::make_pair(1000044007, "VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT"),
    std::make_pair(1000226000, "VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"),
    std::make_pair(1000226001, "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR"),
    std::make_pair(1000226002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR"),
    std::make_pair(1000226003, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR"),
    std::make_pair(1000226004, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR"),
    std::make_pair(1000044006, "VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"),
    std::make_pair(1000227000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD"),
    std::make_pair(1000229000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD"),
    std::make_pair(1000234000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT"),
    std::make_pair(1000235000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR"),
    std::make_pair(1000237000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT"),
    std::make_pair(1000238000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT"),
    std::make_pair(1000238001, "VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT"),
    std::make_pair(1000239000, "VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR"),
    std::make_pair(1000240000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"),
    std::make_pair(1000244000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"),
    std::make_pair(1000244002, "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT"),
    std::make_pair(1000247000, "VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT"),
    std::make_pair(1000248000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR"),
    std::make_pair(1000249000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV"),
    std::make_pair(1000249001, "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV"),
    std::make_pair(1000249002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV"),
    std::make_pair(1000250000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV"),
    std::make_pair(1000250001, "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV"),
    std::make_pair(1000250002, "VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV"),
    std::make_pair(1000251000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT"),
    std::make_pair(1000252000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT"),
    std::make_pair(1000254000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT"),
    std::make_pair(1000254001, "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT"),
    std::make_pair(1000254002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT"),
    std::make_pair(1000255000, "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT"),
    std::make_pair(1000255002, "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT"),
    std::make_pair(1000255001, "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT"),
    std::make_pair(1000256000, "VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT"),
    std::make_pair(1000260000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT"),
    std::make_pair(1000267000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT"),
    std::make_pair(1000269000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR"),
    std::make_pair(1000269001, "VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR"),
    std::make_pair(1000269002, "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR"),
    std::make_pair(1000269003, "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR"),
    std::make_pair(1000269004, "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR"),
    std::make_pair(1000269005, "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR"),
    std::make_pair(1000272000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT"),
    std::make_pair(1000272001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT"),
    std::make_pair(1000272002, "VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT"),
    std::make_pair(1000273000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT"),
    std::make_pair(1000274000, "VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT"),
    std::make_pair(1000274001, "VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT"),
    std::make_pair(1000274002, "VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT"),
    std::make_pair(1000275000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT"),
    std::make_pair(1000275001, "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT"),
    std::make_pair(1000275002, "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT"),
    std::make_pair(1000275003, "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT"),
    std::make_pair(1000275004, "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT"),
    std::make_pair(1000275005, "VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT"),
    std::make_pair(1000277000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV"),
    std::make_pair(1000277001, "VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV"),
    std::make_pair(1000277002, "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV"),
    std::make_pair(1000277003, "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV"),
    std::make_pair(1000277004, "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV"),
    std::make_pair(1000277005, "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV"),
    std::make_pair(1000277006, "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV"),
    std::make_pair(1000277007, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV"),
    std::make_pair(1000278000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV"),
    std::make_pair(1000278001, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV"),
    std::make_pair(1000281000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT"),
    std::make_pair(1000282000, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM"),
    std::make_pair(1000282001, "VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM"),
    std::make_pair(1000283000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT"),
    std::make_pair(1000283001, "VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT"),
    std::make_pair(1000283002, "VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT"),
    std::make_pair(1000284000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT"),
    std::make_pair(1000284001, "VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT"),
    std::make_pair(1000284002, "VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT"),
    std::make_pair(1000286000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT"),
    std::make_pair(1000286001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT"),
    std::make_pair(1000287000, "VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT"),
    std::make_pair(1000287001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT"),
    std::make_pair(1000287002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT"),
    std::make_pair(1000290000, "VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR"),
    std::make_pair(1000292000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV"),
    std::make_pair(1000292001, "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV"),
    std::make_pair(1000292002, "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV"),
    std::make_pair(1000294000, "VK_STRUCTURE_TYPE_PRESENT_ID_KHR"),
    std::make_pair(1000294001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR"),
    std::make_pair(1000299000, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR"),
    std::make_pair(1000299001, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR"),
    std::make_pair(1000299002, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR"),
    std::make_pair(1000299003, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR"),
    std::make_pair(1000299004, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR"),
    std::make_pair(1000299005, "VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR"),
    std::make_pair(1000299006, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR"),
    std::make_pair(1000299007, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR"),
    std::make_pair(1000299008, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR"),
    std::make_pair(1000299009, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR"),
    std::make_pair(1000299010, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR"),
    std::make_pair(1000300000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV"),
    std::make_pair(1000300001, "VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV"),
    std::make_pair(1000307000, "VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV"),
    std::make_pair(1000307001, "VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV"),
    std::make_pair(1000307002, "VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV"),
    std::make_pair(1000307003, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV"),
    std::make_pair(1000307004, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV"),
    std::make_pair(1000308000, "VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR"),
    std::make_pair(1000310000, "VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV"),
    std::make_pair(1000311000, "VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT"),
    std::make_pair(1000311001, "VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT"),
    std::make_pair(1000311002, "VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT"),
    std::make_pair(1000311003, "VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT"),
    std::make_pair(1000311004, "VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT"),
    std::make_pair(1000311005, "VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT"),
    std::make_pair(1000311006, "VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT"),
    std::make_pair(1000311007, "VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT"),
    std::make_pair(1000311008, "VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT"),
    std::make_pair(1000311009, "VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT"),
    std::make_pair(1000311010, "VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT"),
    std::make_pair(1000311011, "VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT"),
    std::make_pair(1000316000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT"),
    std::make_pair(1000316001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT"),
    std::make_pair(1000316002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT"),
    std::make_pair(1000316003, "VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT"),
    std::make_pair(1000316004, "VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT"),
    std::make_pair(1000316005, "VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"),
    std::make_pair(1000316006, "VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"),
    std::make_pair(1000316007, "VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"),
    std::make_pair(1000316008, "VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"),
    std::make_pair(1000316010, "VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT"),
    std::make_pair(1000316011, "VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT"),
    std::make_pair(1000316012, "VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT"),
    std::make_pair(1000316009, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"),
    std::make_pair(1000320000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT"),
    std::make_pair(1000320001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT"),
    std::make_pair(1000320002, "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT"),
    std::make_pair(1000321000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD"),
    std::make_pair(1000203000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR"),
    std::make_pair(1000322000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR"),
    std::make_pair(1000323000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR"),
    std::make_pair(1000326000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV"),
    std::make_pair(1000326001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV"),
    std::make_pair(1000326002, "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV"),
    std::make_pair(1000327000, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV"),
    std::make_pair(1000327001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV"),
    std::make_pair(1000327002, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV"),
    std::make_pair(1000328000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT"),
    std::make_pair(1000328001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT"),
    std::make_pair(1000330000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT"),
    std::make_pair(1000332000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT"),
    std::make_pair(1000332001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT"),
    std::make_pair(1000333000, "VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM"),
    std::make_pair(1000336000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR"),
    std::make_pair(1000338000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT"),
    std::make_pair(1000338001, "VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT"),
    std::make_pair(1000338004, "VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT"),
    std::make_pair(1000339000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT"),
    std::make_pair(1000340000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT"),
    std::make_pair(1000341000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT"),
    std::make_pair(1000341001, "VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT"),
    std::make_pair(1000341002, "VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT"),
    std::make_pair(1000344000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT"),
    std::make_pair(1000346000, "VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT"),
    std::make_pair(1000352000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT"),
    std::make_pair(1000352001, "VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT"),
    std::make_pair(1000352002, "VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT"),
    std::make_pair(1000353000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT"),
    std::make_pair(1000354000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT"),
    std::make_pair(1000354001, "VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT"),
    std::make_pair(1000355000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT"),
    std::make_pair(1000355001, "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT"),
    std::make_pair(1000356000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT"),
    std::make_pair(1000361000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT"),
    std::make_pair(1000364000, "VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA"),
    std::make_pair(1000364001, "VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA"),
    std::make_pair(1000364002, "VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA"),
    std::make_pair(1000365000, "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA"),
    std::make_pair(1000365001, "VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA"),
    std::make_pair(1000366000, "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA"),
    std::make_pair(1000366001, "VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA"),
    std::make_pair(1000366002, "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA"),
    std::make_pair(1000366003, "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA"),
    std::make_pair(1000366004, "VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA"),
    std::make_pair(1000366005, "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA"),
    std::make_pair(1000366006, "VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA"),
    std::make_pair(1000366007, "VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA"),
    std::make_pair(1000366008, "VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA"),
    std::make_pair(1000366009, "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA"),
    std::make_pair(1000369000, "VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI"),
    std::make_pair(1000369001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI"),
    std::make_pair(1000369002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI"),
    std::make_pair(1000370000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI"),
    std::make_pair(1000371000, "VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV"),
    std::make_pair(1000371001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV"),
    std::make_pair(1000372000, "VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT"),
    std::make_pair(1000372001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT"),
    std::make_pair(1000373000, "VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV"),
    std::make_pair(1000373001, "VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV"),
    std::make_pair(1000373002, "VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV"),
    std::make_pair(1000373003, "VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV"),
    std::make_pair(1000373004, "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV"),
    std::make_pair(1000373005, "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV"),
    std::make_pair(1000373006, "VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV"),
    std::make_pair(1000373007, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV"),
    std::make_pair(1000374000, "VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV"),
    std::make_pair(1000374001, "VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV"),
    std::make_pair(1000374002, "VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV"),
    std::make_pair(1000374003, "VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV"),
    std::make_pair(1000374004, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV"),
    std::make_pair(1000375000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT"),
    std::make_pair(1000375001, "VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT"),
    std::make_pair(1000376000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT"),
    std::make_pair(1000376001, "VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT"),
    std::make_pair(1000376002, "VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT"),
    std::make_pair(1000377000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT"),
    std::make_pair(1000378000, "VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX"),
    std::make_pair(1000381000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT"),
    std::make_pair(1000381001, "VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT"),
    std::make_pair(1000382000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT"),
    std::make_pair(1000386000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR"),
    std::make_pair(1000391000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT"),
    std::make_pair(1000391001, "VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT"),
    std::make_pair(1000392000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT"),
    std::make_pair(1000392001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT"),
    std::make_pair(1000393000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT"),
    std::make_pair(1000395000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT"),
    std::make_pair(1000395001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT"),
    std::make_pair(1000396000, "VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT"),
    std::make_pair(1000396001, "VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT"),
    std::make_pair(1000396002, "VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT"),
    std::make_pair(1000396003, "VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT"),
    std::make_pair(1000396004, "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT"),
    std::make_pair(1000396005, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT"),
    std::make_pair(1000396006, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT"),
    std::make_pair(1000396007, "VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT"),
    std::make_pair(1000396008, "VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT"),
    std::make_pair(1000396009, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT"),
    std::make_pair(1000397000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV"),
    std::make_pair(1000397001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV"),
    std::make_pair(1000397002, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV"),
    std::make_pair(1000404000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI"),
    std::make_pair(1000404001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI"),
    std::make_pair(1000404002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI"),
    std::make_pair(1000411000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT"),
    std::make_pair(1000411001, "VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT"),
    std::make_pair(1000412000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT"),
    std::make_pair(1000415000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM"),
    std::make_pair(1000417000, "VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM"),
    std::make_pair(1000417001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM"),
    std::make_pair(1000417002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM"),
    std::make_pair(1000418000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT"),
    std::make_pair(1000418001, "VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT"),
    std::make_pair(1000420000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE"),
    std::make_pair(1000420001, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE"),
    std::make_pair(1000420002, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE"),
    std::make_pair(1000422000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT"),
    std::make_pair(1000424000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM"),
    std::make_pair(1000424001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM"),
    std::make_pair(1000424002, "VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM"),
    std::make_pair(1000424003, "VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM"),
    std::make_pair(1000424004, "VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM"),
    std::make_pair(1000425000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM"),
    std::make_pair(1000425001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM"),
    std::make_pair(1000425002, "VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM"),
    std::make_pair(1000426000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV"),
    std::make_pair(1000426001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV"),
    std::make_pair(1000427000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV"),
    std::make_pair(1000427001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV"),
    std::make_pair(1000428000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV"),
    std::make_pair(1000428001, "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV"),
    std::make_pair(1000428002, "VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV"),
    std::make_pair(1000429008, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV"),
    std::make_pair(1000429009, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV"),
    std::make_pair(1000429010, "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV"),
    std::make_pair(1000430000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV"),
    std::make_pair(1000434000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR"),
    std::make_pair(1000435000, "VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT"),
    std::make_pair(1000437000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT"),
    std::make_pair(1000440000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM"),
    std::make_pair(1000440001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM"),
    std::make_pair(1000440002, "VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM"),
    std::make_pair(1000451000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT"),
    std::make_pair(1000451001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT"),
    std::make_pair(1000453000, "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT"),
    std::make_pair(1000455000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT"),
    std::make_pair(1000455001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT"),
    std::make_pair(1000458000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT"),
    std::make_pair(1000458001, "VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT"),
    std::make_pair(1000458002, "VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT"),
    std::make_pair(1000458003, "VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT"),
    std::make_pair(1000459000, "VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG"),
    std::make_pair(1000459001, "VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG"),
    std::make_pair(1000462000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT"),
    std::make_pair(1000462001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT"),
    std::make_pair(1000462002, "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT"),
    std::make_pair(1000462003, "VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT"),
    std::make_pair(1000342000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT"),
    std::make_pair(1000464000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV"),
    std::make_pair(1000464001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV"),
    std::make_pair(1000464002, "VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV"),
    std::make_pair(1000464003, "VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV"),
    std::make_pair(1000464004, "VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV"),
    std::make_pair(1000464005, "VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV"),
    std::make_pair(1000464010, "VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV"),
    std::make_pair(1000465000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT"),
    std::make_pair(1000468000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID"),
    std::make_pair(1000468001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID"),
    std::make_pair(1000468002, "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID"),
    std::make_pair(1000476000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD"),
    std::make_pair(1000476001, "VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD"),
    std::make_pair(1000476002, "VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD"),
    std::make_pair(1000481000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR"),
    std::make_pair(1000482000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT"),
    std::make_pair(1000482001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT"),
    std::make_pair(1000482002, "VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT"),
    std::make_pair(1000352001, "VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT"),
    std::make_pair(1000352002, "VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT"),
    std::make_pair(1000483000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR"),
    std::make_pair(1000483001, "VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR"),
    std::make_pair(1000483002, "VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR"),
    std::make_pair(1000483003, "VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR"),
    std::make_pair(1000483004, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR"),
    std::make_pair(1000483005, "VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR"),
    std::make_pair(1000483006, "VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR"),
    std::make_pair(1000483007, "VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR"),
    std::make_pair(1000483008, "VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR"),
    std::make_pair(1000483009, "VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR"),
    std::make_pair(1000484000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM"),
    std::make_pair(1000484001, "VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM"),
    std::make_pair(1000485000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC"),
    std::make_pair(1000485001, "VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC"),
    std::make_pair(1000488000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM"),
    std::make_pair(1000489000, "VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV"),
    std::make_pair(1000489001, "VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV"),
    std::make_pair(1000489002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV"),
    std::make_pair(1000373000, "VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV"),
    std::make_pair(1000373001, "VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV"),
    std::make_pair(1000373002, "VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV"),
    std::make_pair(1000373003, "VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV"),
    std::make_pair(1000490000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV"),
    std::make_pair(1000490001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV"),
    std::make_pair(1000491000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV"),
    std::make_pair(1000491001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV"),
    std::make_pair(1000491002, "VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV"),
    std::make_pair(1000491004, "VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV"),
    std::make_pair(1000492000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV"),
    std::make_pair(1000492001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV"),
    std::make_pair(1000351000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT"),
    std::make_pair(1000351002, "VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT"),
    std::make_pair(1000495000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT"),
    std::make_pair(1000495001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT"),
    std::make_pair(1000496000, "VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT"),
    std::make_pair(1000497000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM"),
    std::make_pair(1000497001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM"),
    std::make_pair(1000498000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT"),
    std::make_pair(1000499000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT"),
    std::make_pair(1000505000, "VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV"),
    std::make_pair(1000505001, "VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV"),
    std::make_pair(1000505002, "VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV"),
    std::make_pair(1000505003, "VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV"),
    std::make_pair(1000505004, "VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV"),
    std::make_pair(1000505005, "VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV"),
    std::make_pair(1000505006, "VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV"),
    std::make_pair(1000505007, "VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV"),
    std::make_pair(1000505008, "VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV"),
    std::make_pair(1000506000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR"),
    std::make_pair(1000506001, "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR"),
    std::make_pair(1000506002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR"),
    std::make_pair(1000510000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM"),
    std::make_pair(1000510001, "VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM"),
    std::make_pair(1000201000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR"),
    std::make_pair(1000511000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR"),
    std::make_pair(1000512000, "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR"),
    std::make_pair(1000512001, "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR"),
    std::make_pair(1000512003, "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR"),
    std::make_pair(1000512004, "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR"),
    std::make_pair(1000512005, "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR"),
    std::make_pair(1000513000, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR"),
    std::make_pair(1000513001, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR"),
    std::make_pair(1000513002, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR"),
    std::make_pair(1000513003, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR"),
    std::make_pair(1000513004, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR"),
    std::make_pair(1000513005, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR"),
    std::make_pair(1000513006, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR"),
    std::make_pair(1000513007, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR"),
    std::make_pair(1000513008, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR"),
    std::make_pair(1000513009, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR"),
    std::make_pair(1000513010, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR"),
    std::make_pair(1000515000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR"),
    std::make_pair(1000515001, "VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR"),
    std::make_pair(1000516000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV"),
    std::make_pair(1000518000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM"),
    std::make_pair(1000518001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM"),
    std::make_pair(1000518002, "VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM"),
    std::make_pair(1000519000, "VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM"),
    std::make_pair(1000519001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM"),
    std::make_pair(1000519002, "VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM"),
    std::make_pair(1000520000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM"),
    std::make_pair(1000520001, "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM"),
    std::make_pair(1000521000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM"),
    std::make_pair(1000524000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT"),
    std::make_pair(1000529000, "VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX"),
    std::make_pair(1000529001, "VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX"),
    std::make_pair(1000529002, "VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX"),
    std::make_pair(1000529003, "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX"),
    std::make_pair(1000529004, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX"),
    std::make_pair(1000530000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT"),
    std::make_pair(1000184000, "VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR"),
    std::make_pair(1000545007, "VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT"),
    std::make_pair(1000545008, "VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT"),
    std::make_pair(1000546000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV"),
    std::make_pair(1000551000, "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV"),
    std::make_pair(1000551001, "VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV"),
    std::make_pair(1000553000, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR"),
    std::make_pair(1000553001, "VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR"),
    std::make_pair(1000553002, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR"),
    std::make_pair(1000553005, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR"),
    std::make_pair(1000553009, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR"),
    std::make_pair(1000553003, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR"),
    std::make_pair(1000553004, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR"),
    std::make_pair(1000553006, "VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR"),
    std::make_pair(1000553007, "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR"),
    std::make_pair(1000553008, "VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR"),
    std::make_pair(1000555000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV"),
    std::make_pair(1000558000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR"),
    std::make_pair(1000559000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV"),
    std::make_pair(1000562000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR"),
    std::make_pair(1000562001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR"),
    std::make_pair(1000562002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR"),
    std::make_pair(1000562003, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR"),
    std::make_pair(1000562004, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR"),
    std::make_pair(1000563000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV"),
    std::make_pair(1000564000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT"),
    std::make_pair(1000568000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV"),
    std::make_pair(1000569000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV"),
    std::make_pair(1000569001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV"),
    std::make_pair(1000569002, "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV"),
    std::make_pair(1000569003, "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV"),
    std::make_pair(1000569004, "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV"),
    std::make_pair(1000569005, "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV"),
    std::make_pair(1000569006, "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV"),
    std::make_pair(1000569007, "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV"),
    std::make_pair(1000570000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV"),
    std::make_pair(1000570001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV"),
    std::make_pair(1000570002, "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV"),
    std::make_pair(1000570003, "VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV"),
    std::make_pair(1000570004, "VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV"),
    std::make_pair(1000570005, "VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV"),
    std::make_pair(1000572000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT"),
    std::make_pair(1000572001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT"),
    std::make_pair(1000572002, "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT"),
    std::make_pair(1000572003, "VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT"),
    std::make_pair(1000572004, "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT"),
    std::make_pair(1000572006, "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT"),
    std::make_pair(1000572007, "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT"),
    std::make_pair(1000572008, "VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT"),
    std::make_pair(1000572009, "VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT"),
    std::make_pair(1000572010, "VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT"),
    std::make_pair(1000572011, "VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT"),
    std::make_pair(1000572012, "VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT"),
    std::make_pair(1000572013, "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT"),
    std::make_pair(1000572014, "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT"),
    std::make_pair(1000574000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR"),
    std::make_pair(1000574002, "VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR"),
    std::make_pair(1000575000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA"),
    std::make_pair(1000575001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA"),
    std::make_pair(1000575002, "VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA"),
    std::make_pair(1000582000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT"),
    std::make_pair(1000582001, "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT"),
    std::make_pair(1000586000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR"),
    std::make_pair(1000586001, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR"),
    std::make_pair(1000586002, "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR"),
    std::make_pair(1000586003, "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR"),
    std::make_pair(1000590000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI"),
    std::make_pair(1000590001, "VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI"),
    std::make_pair(1000593000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV"),
    std::make_pair(1000593001, "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV"),
    std::make_pair(1000593002, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV"),
    std::make_pair(1000596000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM"),
    std::make_pair(1000602000, "VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT"),
    std::make_pair(1000602001, "VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT"),
    std::make_pair(1000602002, "VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT"),
    std::make_pair(1000421000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR"),
    std::make_pair(1000608000, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT"),
    std::make_pair(1000613000, "VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV"),
    std::make_pair(1000613001, "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV"),
};
static void print_VkStructureType(VkStructureType obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkStructureType_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkStructureType_map[obj] << "\"" << std::endl;
}
static void print_VkStructureType(const VkStructureType* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkStructureType_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkStructureType_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineCacheHeaderVersion_map = {
    std::make_pair(1, "VK_PIPELINE_CACHE_HEADER_VERSION_ONE"),
};
static void print_VkPipelineCacheHeaderVersion(VkPipelineCacheHeaderVersion obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCacheHeaderVersion_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCacheHeaderVersion_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineCacheHeaderVersion(const VkPipelineCacheHeaderVersion* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCacheHeaderVersion_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCacheHeaderVersion_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAccessFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_ACCESS_INDIRECT_COMMAND_READ_BIT"),
    std::make_pair(1ULL << 1, "VK_ACCESS_INDEX_READ_BIT"),
    std::make_pair(1ULL << 2, "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"),
    std::make_pair(1ULL << 3, "VK_ACCESS_UNIFORM_READ_BIT"),
    std::make_pair(1ULL << 4, "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"),
    std::make_pair(1ULL << 5, "VK_ACCESS_SHADER_READ_BIT"),
    std::make_pair(1ULL << 6, "VK_ACCESS_SHADER_WRITE_BIT"),
    std::make_pair(1ULL << 7, "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"),
    std::make_pair(1ULL << 8, "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"),
    std::make_pair(1ULL << 9, "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"),
    std::make_pair(1ULL << 10, "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"),
    std::make_pair(1ULL << 11, "VK_ACCESS_TRANSFER_READ_BIT"),
    std::make_pair(1ULL << 12, "VK_ACCESS_TRANSFER_WRITE_BIT"),
    std::make_pair(1ULL << 13, "VK_ACCESS_HOST_READ_BIT"),
    std::make_pair(1ULL << 14, "VK_ACCESS_HOST_WRITE_BIT"),
    std::make_pair(1ULL << 15, "VK_ACCESS_MEMORY_READ_BIT"),
    std::make_pair(1ULL << 16, "VK_ACCESS_MEMORY_WRITE_BIT"),
    std::make_pair(0, "VK_ACCESS_NONE"),
    std::make_pair(1ULL << 25, "VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT"),
    std::make_pair(1ULL << 26, "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT"),
    std::make_pair(1ULL << 27, "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT"),
    std::make_pair(1ULL << 20, "VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT"),
    std::make_pair(1ULL << 19, "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"),
    std::make_pair(1ULL << 21, "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR"),
    std::make_pair(1ULL << 22, "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"),
    std::make_pair(1ULL << 24, "VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT"),
    std::make_pair(1ULL << 23, "VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"),
    std::make_pair(1ULL << 17, "VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT"),
    std::make_pair(1ULL << 18, "VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT"),
};
static void print_VkAccessFlagBits(VkAccessFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccessFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccessFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkAccessFlagBits(const VkAccessFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccessFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccessFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkImageLayout_map = {
    std::make_pair(0, "VK_IMAGE_LAYOUT_UNDEFINED"),
    std::make_pair(1, "VK_IMAGE_LAYOUT_GENERAL"),
    std::make_pair(2, "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"),
    std::make_pair(3, "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"),
    std::make_pair(4, "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"),
    std::make_pair(5, "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"),
    std::make_pair(6, "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"),
    std::make_pair(7, "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),
    std::make_pair(8, "VK_IMAGE_LAYOUT_PREINITIALIZED"),
    std::make_pair(1000117000, "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL"),
    std::make_pair(1000117001, "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL"),
    std::make_pair(1000241000, "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL"),
    std::make_pair(1000241001, "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL"),
    std::make_pair(1000241002, "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL"),
    std::make_pair(1000241003, "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL"),
    std::make_pair(1000314000, "VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL"),
    std::make_pair(1000314001, "VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL"),
    std::make_pair(1000232000, "VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ"),
    std::make_pair(1000001002, "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"),
    std::make_pair(1000024000, "VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR"),
    std::make_pair(1000024001, "VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR"),
    std::make_pair(1000024002, "VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR"),
    std::make_pair(1000111000, "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"),
    std::make_pair(1000218000, "VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT"),
    std::make_pair(1000164003, "VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR"),
    std::make_pair(1000299000, "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR"),
    std::make_pair(1000299001, "VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR"),
    std::make_pair(1000299002, "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR"),
    std::make_pair(1000339000, "VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT"),
    std::make_pair(1000553000, "VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR"),
};
static void print_VkImageLayout(VkImageLayout obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageLayout_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageLayout_map[obj] << "\"" << std::endl;
}
static void print_VkImageLayout(const VkImageLayout* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageLayout_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageLayout_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkImageAspectFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_IMAGE_ASPECT_COLOR_BIT"),
    std::make_pair(1ULL << 1, "VK_IMAGE_ASPECT_DEPTH_BIT"),
    std::make_pair(1ULL << 2, "VK_IMAGE_ASPECT_STENCIL_BIT"),
    std::make_pair(1ULL << 3, "VK_IMAGE_ASPECT_METADATA_BIT"),
    std::make_pair(1ULL << 4, "VK_IMAGE_ASPECT_PLANE_0_BIT"),
    std::make_pair(1ULL << 5, "VK_IMAGE_ASPECT_PLANE_1_BIT"),
    std::make_pair(1ULL << 6, "VK_IMAGE_ASPECT_PLANE_2_BIT"),
    std::make_pair(0, "VK_IMAGE_ASPECT_NONE"),
    std::make_pair(1ULL << 7, "VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT"),
    std::make_pair(1ULL << 8, "VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT"),
    std::make_pair(1ULL << 9, "VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT"),
    std::make_pair(1ULL << 10, "VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT"),
};
static void print_VkImageAspectFlagBits(VkImageAspectFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageAspectFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageAspectFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkImageAspectFlagBits(const VkImageAspectFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageAspectFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageAspectFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkObjectType_map = {
    std::make_pair(0, "VK_OBJECT_TYPE_UNKNOWN"),
    std::make_pair(1, "VK_OBJECT_TYPE_INSTANCE"),
    std::make_pair(2, "VK_OBJECT_TYPE_PHYSICAL_DEVICE"),
    std::make_pair(3, "VK_OBJECT_TYPE_DEVICE"),
    std::make_pair(4, "VK_OBJECT_TYPE_QUEUE"),
    std::make_pair(5, "VK_OBJECT_TYPE_SEMAPHORE"),
    std::make_pair(6, "VK_OBJECT_TYPE_COMMAND_BUFFER"),
    std::make_pair(7, "VK_OBJECT_TYPE_FENCE"),
    std::make_pair(8, "VK_OBJECT_TYPE_DEVICE_MEMORY"),
    std::make_pair(9, "VK_OBJECT_TYPE_BUFFER"),
    std::make_pair(10, "VK_OBJECT_TYPE_IMAGE"),
    std::make_pair(11, "VK_OBJECT_TYPE_EVENT"),
    std::make_pair(12, "VK_OBJECT_TYPE_QUERY_POOL"),
    std::make_pair(13, "VK_OBJECT_TYPE_BUFFER_VIEW"),
    std::make_pair(14, "VK_OBJECT_TYPE_IMAGE_VIEW"),
    std::make_pair(15, "VK_OBJECT_TYPE_SHADER_MODULE"),
    std::make_pair(16, "VK_OBJECT_TYPE_PIPELINE_CACHE"),
    std::make_pair(17, "VK_OBJECT_TYPE_PIPELINE_LAYOUT"),
    std::make_pair(18, "VK_OBJECT_TYPE_RENDER_PASS"),
    std::make_pair(19, "VK_OBJECT_TYPE_PIPELINE"),
    std::make_pair(20, "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"),
    std::make_pair(21, "VK_OBJECT_TYPE_SAMPLER"),
    std::make_pair(22, "VK_OBJECT_TYPE_DESCRIPTOR_POOL"),
    std::make_pair(23, "VK_OBJECT_TYPE_DESCRIPTOR_SET"),
    std::make_pair(24, "VK_OBJECT_TYPE_FRAMEBUFFER"),
    std::make_pair(25, "VK_OBJECT_TYPE_COMMAND_POOL"),
    std::make_pair(1000156000, "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"),
    std::make_pair(1000085000, "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"),
    std::make_pair(1000295000, "VK_OBJECT_TYPE_PRIVATE_DATA_SLOT"),
    std::make_pair(1000000000, "VK_OBJECT_TYPE_SURFACE_KHR"),
    std::make_pair(1000001000, "VK_OBJECT_TYPE_SWAPCHAIN_KHR"),
    std::make_pair(1000002000, "VK_OBJECT_TYPE_DISPLAY_KHR"),
    std::make_pair(1000002001, "VK_OBJECT_TYPE_DISPLAY_MODE_KHR"),
    std::make_pair(1000011000, "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT"),
    std::make_pair(1000023000, "VK_OBJECT_TYPE_VIDEO_SESSION_KHR"),
    std::make_pair(1000023001, "VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR"),
    std::make_pair(1000029000, "VK_OBJECT_TYPE_CU_MODULE_NVX"),
    std::make_pair(1000029001, "VK_OBJECT_TYPE_CU_FUNCTION_NVX"),
    std::make_pair(1000128000, "VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT"),
    std::make_pair(1000150000, "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR"),
    std::make_pair(1000160000, "VK_OBJECT_TYPE_VALIDATION_CACHE_EXT"),
    std::make_pair(1000165000, "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV"),
    std::make_pair(1000210000, "VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL"),
    std::make_pair(1000268000, "VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR"),
    std::make_pair(1000277000, "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV"),
    std::make_pair(1000307000, "VK_OBJECT_TYPE_CUDA_MODULE_NV"),
    std::make_pair(1000307001, "VK_OBJECT_TYPE_CUDA_FUNCTION_NV"),
    std::make_pair(1000366000, "VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA"),
    std::make_pair(1000396000, "VK_OBJECT_TYPE_MICROMAP_EXT"),
    std::make_pair(1000464000, "VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV"),
    std::make_pair(1000482000, "VK_OBJECT_TYPE_SHADER_EXT"),
    std::make_pair(1000483000, "VK_OBJECT_TYPE_PIPELINE_BINARY_KHR"),
    std::make_pair(1000489000, "VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV"),
    std::make_pair(1000572000, "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT"),
    std::make_pair(1000572001, "VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT"),
};
static void print_VkObjectType(VkObjectType obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkObjectType_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkObjectType_map[obj] << "\"" << std::endl;
}
static void print_VkObjectType(const VkObjectType* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkObjectType_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkObjectType_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVendorId_map = {
    std::make_pair(0x10000, "VK_VENDOR_ID_KHRONOS"),  std::make_pair(0x10001, "VK_VENDOR_ID_VIV"),
    std::make_pair(0x10002, "VK_VENDOR_ID_VSI"),      std::make_pair(0x10003, "VK_VENDOR_ID_KAZAN"),
    std::make_pair(0x10004, "VK_VENDOR_ID_CODEPLAY"), std::make_pair(0x10005, "VK_VENDOR_ID_MESA"),
    std::make_pair(0x10006, "VK_VENDOR_ID_POCL"),     std::make_pair(0x10007, "VK_VENDOR_ID_MOBILEYE"),
};
static void print_VkVendorId(VkVendorId obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVendorId_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVendorId_map[obj] << "\"" << std::endl;
}
static void print_VkVendorId(const VkVendorId* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVendorId_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVendorId_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSystemAllocationScope_map = {
    std::make_pair(0, "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"),  std::make_pair(1, "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"),
    std::make_pair(2, "VK_SYSTEM_ALLOCATION_SCOPE_CACHE"),    std::make_pair(3, "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"),
    std::make_pair(4, "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"),
};
static void print_VkSystemAllocationScope(VkSystemAllocationScope obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSystemAllocationScope_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSystemAllocationScope_map[obj] << "\"" << std::endl;
}
static void print_VkSystemAllocationScope(const VkSystemAllocationScope* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSystemAllocationScope_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSystemAllocationScope_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkInternalAllocationType_map = {
    std::make_pair(0, "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"),
};
static void print_VkInternalAllocationType(VkInternalAllocationType obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkInternalAllocationType_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkInternalAllocationType_map[obj] << "\"" << std::endl;
}
static void print_VkInternalAllocationType(const VkInternalAllocationType* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkInternalAllocationType_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkInternalAllocationType_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkFormat_map = {
    std::make_pair(0, "VK_FORMAT_UNDEFINED"),
    std::make_pair(1, "VK_FORMAT_R4G4_UNORM_PACK8"),
    std::make_pair(2, "VK_FORMAT_R4G4B4A4_UNORM_PACK16"),
    std::make_pair(3, "VK_FORMAT_B4G4R4A4_UNORM_PACK16"),
    std::make_pair(4, "VK_FORMAT_R5G6B5_UNORM_PACK16"),
    std::make_pair(5, "VK_FORMAT_B5G6R5_UNORM_PACK16"),
    std::make_pair(6, "VK_FORMAT_R5G5B5A1_UNORM_PACK16"),
    std::make_pair(7, "VK_FORMAT_B5G5R5A1_UNORM_PACK16"),
    std::make_pair(8, "VK_FORMAT_A1R5G5B5_UNORM_PACK16"),
    std::make_pair(9, "VK_FORMAT_R8_UNORM"),
    std::make_pair(10, "VK_FORMAT_R8_SNORM"),
    std::make_pair(11, "VK_FORMAT_R8_USCALED"),
    std::make_pair(12, "VK_FORMAT_R8_SSCALED"),
    std::make_pair(13, "VK_FORMAT_R8_UINT"),
    std::make_pair(14, "VK_FORMAT_R8_SINT"),
    std::make_pair(15, "VK_FORMAT_R8_SRGB"),
    std::make_pair(16, "VK_FORMAT_R8G8_UNORM"),
    std::make_pair(17, "VK_FORMAT_R8G8_SNORM"),
    std::make_pair(18, "VK_FORMAT_R8G8_USCALED"),
    std::make_pair(19, "VK_FORMAT_R8G8_SSCALED"),
    std::make_pair(20, "VK_FORMAT_R8G8_UINT"),
    std::make_pair(21, "VK_FORMAT_R8G8_SINT"),
    std::make_pair(22, "VK_FORMAT_R8G8_SRGB"),
    std::make_pair(23, "VK_FORMAT_R8G8B8_UNORM"),
    std::make_pair(24, "VK_FORMAT_R8G8B8_SNORM"),
    std::make_pair(25, "VK_FORMAT_R8G8B8_USCALED"),
    std::make_pair(26, "VK_FORMAT_R8G8B8_SSCALED"),
    std::make_pair(27, "VK_FORMAT_R8G8B8_UINT"),
    std::make_pair(28, "VK_FORMAT_R8G8B8_SINT"),
    std::make_pair(29, "VK_FORMAT_R8G8B8_SRGB"),
    std::make_pair(30, "VK_FORMAT_B8G8R8_UNORM"),
    std::make_pair(31, "VK_FORMAT_B8G8R8_SNORM"),
    std::make_pair(32, "VK_FORMAT_B8G8R8_USCALED"),
    std::make_pair(33, "VK_FORMAT_B8G8R8_SSCALED"),
    std::make_pair(34, "VK_FORMAT_B8G8R8_UINT"),
    std::make_pair(35, "VK_FORMAT_B8G8R8_SINT"),
    std::make_pair(36, "VK_FORMAT_B8G8R8_SRGB"),
    std::make_pair(37, "VK_FORMAT_R8G8B8A8_UNORM"),
    std::make_pair(38, "VK_FORMAT_R8G8B8A8_SNORM"),
    std::make_pair(39, "VK_FORMAT_R8G8B8A8_USCALED"),
    std::make_pair(40, "VK_FORMAT_R8G8B8A8_SSCALED"),
    std::make_pair(41, "VK_FORMAT_R8G8B8A8_UINT"),
    std::make_pair(42, "VK_FORMAT_R8G8B8A8_SINT"),
    std::make_pair(43, "VK_FORMAT_R8G8B8A8_SRGB"),
    std::make_pair(44, "VK_FORMAT_B8G8R8A8_UNORM"),
    std::make_pair(45, "VK_FORMAT_B8G8R8A8_SNORM"),
    std::make_pair(46, "VK_FORMAT_B8G8R8A8_USCALED"),
    std::make_pair(47, "VK_FORMAT_B8G8R8A8_SSCALED"),
    std::make_pair(48, "VK_FORMAT_B8G8R8A8_UINT"),
    std::make_pair(49, "VK_FORMAT_B8G8R8A8_SINT"),
    std::make_pair(50, "VK_FORMAT_B8G8R8A8_SRGB"),
    std::make_pair(51, "VK_FORMAT_A8B8G8R8_UNORM_PACK32"),
    std::make_pair(52, "VK_FORMAT_A8B8G8R8_SNORM_PACK32"),
    std::make_pair(53, "VK_FORMAT_A8B8G8R8_USCALED_PACK32"),
    std::make_pair(54, "VK_FORMAT_A8B8G8R8_SSCALED_PACK32"),
    std::make_pair(55, "VK_FORMAT_A8B8G8R8_UINT_PACK32"),
    std::make_pair(56, "VK_FORMAT_A8B8G8R8_SINT_PACK32"),
    std::make_pair(57, "VK_FORMAT_A8B8G8R8_SRGB_PACK32"),
    std::make_pair(58, "VK_FORMAT_A2R10G10B10_UNORM_PACK32"),
    std::make_pair(59, "VK_FORMAT_A2R10G10B10_SNORM_PACK32"),
    std::make_pair(60, "VK_FORMAT_A2R10G10B10_USCALED_PACK32"),
    std::make_pair(61, "VK_FORMAT_A2R10G10B10_SSCALED_PACK32"),
    std::make_pair(62, "VK_FORMAT_A2R10G10B10_UINT_PACK32"),
    std::make_pair(63, "VK_FORMAT_A2R10G10B10_SINT_PACK32"),
    std::make_pair(64, "VK_FORMAT_A2B10G10R10_UNORM_PACK32"),
    std::make_pair(65, "VK_FORMAT_A2B10G10R10_SNORM_PACK32"),
    std::make_pair(66, "VK_FORMAT_A2B10G10R10_USCALED_PACK32"),
    std::make_pair(67, "VK_FORMAT_A2B10G10R10_SSCALED_PACK32"),
    std::make_pair(68, "VK_FORMAT_A2B10G10R10_UINT_PACK32"),
    std::make_pair(69, "VK_FORMAT_A2B10G10R10_SINT_PACK32"),
    std::make_pair(70, "VK_FORMAT_R16_UNORM"),
    std::make_pair(71, "VK_FORMAT_R16_SNORM"),
    std::make_pair(72, "VK_FORMAT_R16_USCALED"),
    std::make_pair(73, "VK_FORMAT_R16_SSCALED"),
    std::make_pair(74, "VK_FORMAT_R16_UINT"),
    std::make_pair(75, "VK_FORMAT_R16_SINT"),
    std::make_pair(76, "VK_FORMAT_R16_SFLOAT"),
    std::make_pair(77, "VK_FORMAT_R16G16_UNORM"),
    std::make_pair(78, "VK_FORMAT_R16G16_SNORM"),
    std::make_pair(79, "VK_FORMAT_R16G16_USCALED"),
    std::make_pair(80, "VK_FORMAT_R16G16_SSCALED"),
    std::make_pair(81, "VK_FORMAT_R16G16_UINT"),
    std::make_pair(82, "VK_FORMAT_R16G16_SINT"),
    std::make_pair(83, "VK_FORMAT_R16G16_SFLOAT"),
    std::make_pair(84, "VK_FORMAT_R16G16B16_UNORM"),
    std::make_pair(85, "VK_FORMAT_R16G16B16_SNORM"),
    std::make_pair(86, "VK_FORMAT_R16G16B16_USCALED"),
    std::make_pair(87, "VK_FORMAT_R16G16B16_SSCALED"),
    std::make_pair(88, "VK_FORMAT_R16G16B16_UINT"),
    std::make_pair(89, "VK_FORMAT_R16G16B16_SINT"),
    std::make_pair(90, "VK_FORMAT_R16G16B16_SFLOAT"),
    std::make_pair(91, "VK_FORMAT_R16G16B16A16_UNORM"),
    std::make_pair(92, "VK_FORMAT_R16G16B16A16_SNORM"),
    std::make_pair(93, "VK_FORMAT_R16G16B16A16_USCALED"),
    std::make_pair(94, "VK_FORMAT_R16G16B16A16_SSCALED"),
    std::make_pair(95, "VK_FORMAT_R16G16B16A16_UINT"),
    std::make_pair(96, "VK_FORMAT_R16G16B16A16_SINT"),
    std::make_pair(97, "VK_FORMAT_R16G16B16A16_SFLOAT"),
    std::make_pair(98, "VK_FORMAT_R32_UINT"),
    std::make_pair(99, "VK_FORMAT_R32_SINT"),
    std::make_pair(100, "VK_FORMAT_R32_SFLOAT"),
    std::make_pair(101, "VK_FORMAT_R32G32_UINT"),
    std::make_pair(102, "VK_FORMAT_R32G32_SINT"),
    std::make_pair(103, "VK_FORMAT_R32G32_SFLOAT"),
    std::make_pair(104, "VK_FORMAT_R32G32B32_UINT"),
    std::make_pair(105, "VK_FORMAT_R32G32B32_SINT"),
    std::make_pair(106, "VK_FORMAT_R32G32B32_SFLOAT"),
    std::make_pair(107, "VK_FORMAT_R32G32B32A32_UINT"),
    std::make_pair(108, "VK_FORMAT_R32G32B32A32_SINT"),
    std::make_pair(109, "VK_FORMAT_R32G32B32A32_SFLOAT"),
    std::make_pair(110, "VK_FORMAT_R64_UINT"),
    std::make_pair(111, "VK_FORMAT_R64_SINT"),
    std::make_pair(112, "VK_FORMAT_R64_SFLOAT"),
    std::make_pair(113, "VK_FORMAT_R64G64_UINT"),
    std::make_pair(114, "VK_FORMAT_R64G64_SINT"),
    std::make_pair(115, "VK_FORMAT_R64G64_SFLOAT"),
    std::make_pair(116, "VK_FORMAT_R64G64B64_UINT"),
    std::make_pair(117, "VK_FORMAT_R64G64B64_SINT"),
    std::make_pair(118, "VK_FORMAT_R64G64B64_SFLOAT"),
    std::make_pair(119, "VK_FORMAT_R64G64B64A64_UINT"),
    std::make_pair(120, "VK_FORMAT_R64G64B64A64_SINT"),
    std::make_pair(121, "VK_FORMAT_R64G64B64A64_SFLOAT"),
    std::make_pair(122, "VK_FORMAT_B10G11R11_UFLOAT_PACK32"),
    std::make_pair(123, "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"),
    std::make_pair(124, "VK_FORMAT_D16_UNORM"),
    std::make_pair(125, "VK_FORMAT_X8_D24_UNORM_PACK32"),
    std::make_pair(126, "VK_FORMAT_D32_SFLOAT"),
    std::make_pair(127, "VK_FORMAT_S8_UINT"),
    std::make_pair(128, "VK_FORMAT_D16_UNORM_S8_UINT"),
    std::make_pair(129, "VK_FORMAT_D24_UNORM_S8_UINT"),
    std::make_pair(130, "VK_FORMAT_D32_SFLOAT_S8_UINT"),
    std::make_pair(131, "VK_FORMAT_BC1_RGB_UNORM_BLOCK"),
    std::make_pair(132, "VK_FORMAT_BC1_RGB_SRGB_BLOCK"),
    std::make_pair(133, "VK_FORMAT_BC1_RGBA_UNORM_BLOCK"),
    std::make_pair(134, "VK_FORMAT_BC1_RGBA_SRGB_BLOCK"),
    std::make_pair(135, "VK_FORMAT_BC2_UNORM_BLOCK"),
    std::make_pair(136, "VK_FORMAT_BC2_SRGB_BLOCK"),
    std::make_pair(137, "VK_FORMAT_BC3_UNORM_BLOCK"),
    std::make_pair(138, "VK_FORMAT_BC3_SRGB_BLOCK"),
    std::make_pair(139, "VK_FORMAT_BC4_UNORM_BLOCK"),
    std::make_pair(140, "VK_FORMAT_BC4_SNORM_BLOCK"),
    std::make_pair(141, "VK_FORMAT_BC5_UNORM_BLOCK"),
    std::make_pair(142, "VK_FORMAT_BC5_SNORM_BLOCK"),
    std::make_pair(143, "VK_FORMAT_BC6H_UFLOAT_BLOCK"),
    std::make_pair(144, "VK_FORMAT_BC6H_SFLOAT_BLOCK"),
    std::make_pair(145, "VK_FORMAT_BC7_UNORM_BLOCK"),
    std::make_pair(146, "VK_FORMAT_BC7_SRGB_BLOCK"),
    std::make_pair(147, "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"),
    std::make_pair(148, "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"),
    std::make_pair(149, "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"),
    std::make_pair(150, "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"),
    std::make_pair(151, "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"),
    std::make_pair(152, "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"),
    std::make_pair(153, "VK_FORMAT_EAC_R11_UNORM_BLOCK"),
    std::make_pair(154, "VK_FORMAT_EAC_R11_SNORM_BLOCK"),
    std::make_pair(155, "VK_FORMAT_EAC_R11G11_UNORM_BLOCK"),
    std::make_pair(156, "VK_FORMAT_EAC_R11G11_SNORM_BLOCK"),
    std::make_pair(157, "VK_FORMAT_ASTC_4x4_UNORM_BLOCK"),
    std::make_pair(158, "VK_FORMAT_ASTC_4x4_SRGB_BLOCK"),
    std::make_pair(159, "VK_FORMAT_ASTC_5x4_UNORM_BLOCK"),
    std::make_pair(160, "VK_FORMAT_ASTC_5x4_SRGB_BLOCK"),
    std::make_pair(161, "VK_FORMAT_ASTC_5x5_UNORM_BLOCK"),
    std::make_pair(162, "VK_FORMAT_ASTC_5x5_SRGB_BLOCK"),
    std::make_pair(163, "VK_FORMAT_ASTC_6x5_UNORM_BLOCK"),
    std::make_pair(164, "VK_FORMAT_ASTC_6x5_SRGB_BLOCK"),
    std::make_pair(165, "VK_FORMAT_ASTC_6x6_UNORM_BLOCK"),
    std::make_pair(166, "VK_FORMAT_ASTC_6x6_SRGB_BLOCK"),
    std::make_pair(167, "VK_FORMAT_ASTC_8x5_UNORM_BLOCK"),
    std::make_pair(168, "VK_FORMAT_ASTC_8x5_SRGB_BLOCK"),
    std::make_pair(169, "VK_FORMAT_ASTC_8x6_UNORM_BLOCK"),
    std::make_pair(170, "VK_FORMAT_ASTC_8x6_SRGB_BLOCK"),
    std::make_pair(171, "VK_FORMAT_ASTC_8x8_UNORM_BLOCK"),
    std::make_pair(172, "VK_FORMAT_ASTC_8x8_SRGB_BLOCK"),
    std::make_pair(173, "VK_FORMAT_ASTC_10x5_UNORM_BLOCK"),
    std::make_pair(174, "VK_FORMAT_ASTC_10x5_SRGB_BLOCK"),
    std::make_pair(175, "VK_FORMAT_ASTC_10x6_UNORM_BLOCK"),
    std::make_pair(176, "VK_FORMAT_ASTC_10x6_SRGB_BLOCK"),
    std::make_pair(177, "VK_FORMAT_ASTC_10x8_UNORM_BLOCK"),
    std::make_pair(178, "VK_FORMAT_ASTC_10x8_SRGB_BLOCK"),
    std::make_pair(179, "VK_FORMAT_ASTC_10x10_UNORM_BLOCK"),
    std::make_pair(180, "VK_FORMAT_ASTC_10x10_SRGB_BLOCK"),
    std::make_pair(181, "VK_FORMAT_ASTC_12x10_UNORM_BLOCK"),
    std::make_pair(182, "VK_FORMAT_ASTC_12x10_SRGB_BLOCK"),
    std::make_pair(183, "VK_FORMAT_ASTC_12x12_UNORM_BLOCK"),
    std::make_pair(184, "VK_FORMAT_ASTC_12x12_SRGB_BLOCK"),
    std::make_pair(1000156000, "VK_FORMAT_G8B8G8R8_422_UNORM"),
    std::make_pair(1000156001, "VK_FORMAT_B8G8R8G8_422_UNORM"),
    std::make_pair(1000156002, "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM"),
    std::make_pair(1000156003, "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM"),
    std::make_pair(1000156004, "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM"),
    std::make_pair(1000156005, "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM"),
    std::make_pair(1000156006, "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM"),
    std::make_pair(1000156007, "VK_FORMAT_R10X6_UNORM_PACK16"),
    std::make_pair(1000156008, "VK_FORMAT_R10X6G10X6_UNORM_2PACK16"),
    std::make_pair(1000156009, "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16"),
    std::make_pair(1000156010, "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16"),
    std::make_pair(1000156011, "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16"),
    std::make_pair(1000156012, "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16"),
    std::make_pair(1000156013, "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16"),
    std::make_pair(1000156014, "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16"),
    std::make_pair(1000156015, "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16"),
    std::make_pair(1000156016, "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16"),
    std::make_pair(1000156017, "VK_FORMAT_R12X4_UNORM_PACK16"),
    std::make_pair(1000156018, "VK_FORMAT_R12X4G12X4_UNORM_2PACK16"),
    std::make_pair(1000156019, "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16"),
    std::make_pair(1000156020, "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16"),
    std::make_pair(1000156021, "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16"),
    std::make_pair(1000156022, "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16"),
    std::make_pair(1000156023, "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16"),
    std::make_pair(1000156024, "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16"),
    std::make_pair(1000156025, "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16"),
    std::make_pair(1000156026, "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16"),
    std::make_pair(1000156027, "VK_FORMAT_G16B16G16R16_422_UNORM"),
    std::make_pair(1000156028, "VK_FORMAT_B16G16R16G16_422_UNORM"),
    std::make_pair(1000156029, "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM"),
    std::make_pair(1000156030, "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM"),
    std::make_pair(1000156031, "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM"),
    std::make_pair(1000156032, "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM"),
    std::make_pair(1000156033, "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM"),
    std::make_pair(1000330000, "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM"),
    std::make_pair(1000330001, "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16"),
    std::make_pair(1000330002, "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16"),
    std::make_pair(1000330003, "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM"),
    std::make_pair(1000340000, "VK_FORMAT_A4R4G4B4_UNORM_PACK16"),
    std::make_pair(1000340001, "VK_FORMAT_A4B4G4R4_UNORM_PACK16"),
    std::make_pair(1000066000, "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK"),
    std::make_pair(1000066001, "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK"),
    std::make_pair(1000066002, "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK"),
    std::make_pair(1000066003, "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK"),
    std::make_pair(1000066004, "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK"),
    std::make_pair(1000066005, "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK"),
    std::make_pair(1000066006, "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK"),
    std::make_pair(1000066007, "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK"),
    std::make_pair(1000066008, "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK"),
    std::make_pair(1000066009, "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK"),
    std::make_pair(1000066010, "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK"),
    std::make_pair(1000066011, "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK"),
    std::make_pair(1000066012, "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK"),
    std::make_pair(1000066013, "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK"),
    std::make_pair(1000470000, "VK_FORMAT_A1B5G5R5_UNORM_PACK16"),
    std::make_pair(1000470001, "VK_FORMAT_A8_UNORM"),
    std::make_pair(1000054000, "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG"),
    std::make_pair(1000054001, "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG"),
    std::make_pair(1000054002, "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG"),
    std::make_pair(1000054003, "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG"),
    std::make_pair(1000054004, "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG"),
    std::make_pair(1000054005, "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG"),
    std::make_pair(1000054006, "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG"),
    std::make_pair(1000054007, "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG"),
    std::make_pair(1000288000, "VK_FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT"),
    std::make_pair(1000288001, "VK_FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT"),
    std::make_pair(1000288002, "VK_FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT"),
    std::make_pair(1000288003, "VK_FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT"),
    std::make_pair(1000288004, "VK_FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT"),
    std::make_pair(1000288005, "VK_FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT"),
    std::make_pair(1000288006, "VK_FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT"),
    std::make_pair(1000288007, "VK_FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT"),
    std::make_pair(1000288008, "VK_FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT"),
    std::make_pair(1000288009, "VK_FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT"),
    std::make_pair(1000288010, "VK_FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT"),
    std::make_pair(1000288011, "VK_FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT"),
    std::make_pair(1000288012, "VK_FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT"),
    std::make_pair(1000288013, "VK_FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT"),
    std::make_pair(1000288014, "VK_FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT"),
    std::make_pair(1000288015, "VK_FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT"),
    std::make_pair(1000288016, "VK_FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT"),
    std::make_pair(1000288017, "VK_FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT"),
    std::make_pair(1000288018, "VK_FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT"),
    std::make_pair(1000288019, "VK_FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT"),
    std::make_pair(1000288020, "VK_FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT"),
    std::make_pair(1000288021, "VK_FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT"),
    std::make_pair(1000288022, "VK_FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT"),
    std::make_pair(1000288023, "VK_FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT"),
    std::make_pair(1000288024, "VK_FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT"),
    std::make_pair(1000288025, "VK_FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT"),
    std::make_pair(1000288026, "VK_FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT"),
    std::make_pair(1000288027, "VK_FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT"),
    std::make_pair(1000288028, "VK_FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT"),
    std::make_pair(1000288029, "VK_FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT"),
    std::make_pair(1000464000, "VK_FORMAT_R16G16_SFIXED5_NV"),
};
static void print_VkFormat(VkFormat obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFormat_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFormat_map[obj] << "\"" << std::endl;
}
static void print_VkFormat(const VkFormat* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFormat_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFormat_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkFormatFeatureFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"),
    std::make_pair(1ULL << 1, "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"),
    std::make_pair(1ULL << 2, "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"),
    std::make_pair(1ULL << 3, "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"),
    std::make_pair(1ULL << 4, "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"),
    std::make_pair(1ULL << 5, "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"),
    std::make_pair(1ULL << 6, "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"),
    std::make_pair(1ULL << 7, "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"),
    std::make_pair(1ULL << 8, "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"),
    std::make_pair(1ULL << 9, "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"),
    std::make_pair(1ULL << 10, "VK_FORMAT_FEATURE_BLIT_SRC_BIT"),
    std::make_pair(1ULL << 11, "VK_FORMAT_FEATURE_BLIT_DST_BIT"),
    std::make_pair(1ULL << 12, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT"),
    std::make_pair(1ULL << 14, "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT"),
    std::make_pair(1ULL << 15, "VK_FORMAT_FEATURE_TRANSFER_DST_BIT"),
    std::make_pair(1ULL << 17, "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT"),
    std::make_pair(1ULL << 18, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"),
    std::make_pair(1ULL << 19, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"),
    std::make_pair(1ULL << 20, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"),
    std::make_pair(1ULL << 21, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"),
    std::make_pair(1ULL << 22, "VK_FORMAT_FEATURE_DISJOINT_BIT"),
    std::make_pair(1ULL << 23, "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT"),
    std::make_pair(1ULL << 16, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT"),
    std::make_pair(1ULL << 25, "VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR"),
    std::make_pair(1ULL << 26, "VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR"),
    std::make_pair(1ULL << 29, "VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR"),
    std::make_pair(1ULL << 13, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT"),
    std::make_pair(1ULL << 24, "VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT"),
    std::make_pair(1ULL << 30, "VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
    std::make_pair(1ULL << 27, "VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR"),
    std::make_pair(1ULL << 28, "VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR"),
};
static void print_VkFormatFeatureFlagBits(VkFormatFeatureFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFormatFeatureFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFormatFeatureFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkFormatFeatureFlagBits(const VkFormatFeatureFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFormatFeatureFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFormatFeatureFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkImageCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_IMAGE_CREATE_SPARSE_BINDING_BIT"),
    std::make_pair(1ULL << 1, "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"),
    std::make_pair(1ULL << 2, "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"),
    std::make_pair(1ULL << 3, "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"),
    std::make_pair(1ULL << 4, "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"),
    std::make_pair(1ULL << 10, "VK_IMAGE_CREATE_ALIAS_BIT"),
    std::make_pair(1ULL << 6, "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"),
    std::make_pair(1ULL << 5, "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT"),
    std::make_pair(1ULL << 7, "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT"),
    std::make_pair(1ULL << 8, "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT"),
    std::make_pair(1ULL << 11, "VK_IMAGE_CREATE_PROTECTED_BIT"),
    std::make_pair(1ULL << 9, "VK_IMAGE_CREATE_DISJOINT_BIT"),
    std::make_pair(1ULL << 13, "VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV"),
    std::make_pair(1ULL << 12, "VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT"),
    std::make_pair(1ULL << 14, "VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT"),
    std::make_pair(1ULL << 19, "VK_IMAGE_CREATE_RESERVED_19_BIT_EXT"),
    std::make_pair(1ULL << 16, "VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"),
    std::make_pair(1ULL << 18, "VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT"),
    std::make_pair(1ULL << 17, "VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT"),
    std::make_pair(1ULL << 15, "VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM"),
    std::make_pair(1ULL << 20, "VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR"),
};
static void print_VkImageCreateFlagBits(VkImageCreateFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkImageCreateFlagBits(const VkImageCreateFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSampleCountFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_SAMPLE_COUNT_1_BIT"),  std::make_pair(1ULL << 1, "VK_SAMPLE_COUNT_2_BIT"),
    std::make_pair(1ULL << 2, "VK_SAMPLE_COUNT_4_BIT"),  std::make_pair(1ULL << 3, "VK_SAMPLE_COUNT_8_BIT"),
    std::make_pair(1ULL << 4, "VK_SAMPLE_COUNT_16_BIT"), std::make_pair(1ULL << 5, "VK_SAMPLE_COUNT_32_BIT"),
    std::make_pair(1ULL << 6, "VK_SAMPLE_COUNT_64_BIT"),
};
static void print_VkSampleCountFlagBits(VkSampleCountFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSampleCountFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSampleCountFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkSampleCountFlagBits(const VkSampleCountFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSampleCountFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSampleCountFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkImageTiling_map = {
    std::make_pair(0, "VK_IMAGE_TILING_OPTIMAL"),
    std::make_pair(1, "VK_IMAGE_TILING_LINEAR"),
    std::make_pair(1000158000, "VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT"),
};
static void print_VkImageTiling(VkImageTiling obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageTiling_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageTiling_map[obj] << "\"" << std::endl;
}
static void print_VkImageTiling(const VkImageTiling* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageTiling_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageTiling_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkImageType_map = {
    std::make_pair(0, "VK_IMAGE_TYPE_1D"),
    std::make_pair(1, "VK_IMAGE_TYPE_2D"),
    std::make_pair(2, "VK_IMAGE_TYPE_3D"),
};
static void print_VkImageType(VkImageType obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageType_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageType_map[obj] << "\"" << std::endl;
}
static void print_VkImageType(const VkImageType* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageType_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageType_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkImageUsageFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_IMAGE_USAGE_TRANSFER_SRC_BIT"),
    std::make_pair(1ULL << 1, "VK_IMAGE_USAGE_TRANSFER_DST_BIT"),
    std::make_pair(1ULL << 2, "VK_IMAGE_USAGE_SAMPLED_BIT"),
    std::make_pair(1ULL << 3, "VK_IMAGE_USAGE_STORAGE_BIT"),
    std::make_pair(1ULL << 4, "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"),
    std::make_pair(1ULL << 5, "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"),
    std::make_pair(1ULL << 6, "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"),
    std::make_pair(1ULL << 7, "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"),
    std::make_pair(1ULL << 22, "VK_IMAGE_USAGE_HOST_TRANSFER_BIT"),
    std::make_pair(1ULL << 10, "VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR"),
    std::make_pair(1ULL << 11, "VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR"),
    std::make_pair(1ULL << 12, "VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR"),
    std::make_pair(1ULL << 9, "VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT"),
    std::make_pair(1ULL << 8, "VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
    std::make_pair(1ULL << 13, "VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR"),
    std::make_pair(1ULL << 14, "VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR"),
    std::make_pair(1ULL << 15, "VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR"),
    std::make_pair(1ULL << 19, "VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"),
    std::make_pair(1ULL << 18, "VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI"),
    std::make_pair(1ULL << 20, "VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM"),
    std::make_pair(1ULL << 21, "VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM"),
    std::make_pair(1ULL << 24, "VK_IMAGE_USAGE_RESERVED_24_BIT_COREAVI"),
    std::make_pair(1ULL << 23, "VK_IMAGE_USAGE_RESERVED_23_BIT_EXT"),
    std::make_pair(1ULL << 27, "VK_IMAGE_USAGE_RESERVED_27_QCOM"),
    std::make_pair(1ULL << 25, "VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR"),
    std::make_pair(1ULL << 26, "VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR"),
};
static void print_VkImageUsageFlagBits(VkImageUsageFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageUsageFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageUsageFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkImageUsageFlagBits(const VkImageUsageFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageUsageFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageUsageFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkInstanceCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR"),
};
static void print_VkInstanceCreateFlagBits(VkInstanceCreateFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkInstanceCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkInstanceCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkInstanceCreateFlagBits(const VkInstanceCreateFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkInstanceCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkInstanceCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkMemoryHeapFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"),
    std::make_pair(1ULL << 1, "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT"),
    std::make_pair(1ULL << 3, "VK_MEMORY_HEAP_RESERVED_3_QCOM"),
};
static void print_VkMemoryHeapFlagBits(VkMemoryHeapFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryHeapFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryHeapFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkMemoryHeapFlagBits(const VkMemoryHeapFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryHeapFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryHeapFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkMemoryPropertyFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"),
    std::make_pair(1ULL << 1, "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"),
    std::make_pair(1ULL << 2, "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),
    std::make_pair(1ULL << 3, "VK_MEMORY_PROPERTY_HOST_CACHED_BIT"),
    std::make_pair(1ULL << 4, "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"),
    std::make_pair(1ULL << 5, "VK_MEMORY_PROPERTY_PROTECTED_BIT"),
    std::make_pair(1ULL << 6, "VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD"),
    std::make_pair(1ULL << 7, "VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD"),
    std::make_pair(1ULL << 8, "VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV"),
};
static void print_VkMemoryPropertyFlagBits(VkMemoryPropertyFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryPropertyFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryPropertyFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkMemoryPropertyFlagBits(const VkMemoryPropertyFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryPropertyFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryPropertyFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPhysicalDeviceType_map = {
    std::make_pair(0, "VK_PHYSICAL_DEVICE_TYPE_OTHER"),        std::make_pair(1, "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"),
    std::make_pair(2, "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"), std::make_pair(3, "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"),
    std::make_pair(4, "VK_PHYSICAL_DEVICE_TYPE_CPU"),
};
static void print_VkPhysicalDeviceType(VkPhysicalDeviceType obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPhysicalDeviceType_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPhysicalDeviceType_map[obj] << "\"" << std::endl;
}
static void print_VkPhysicalDeviceType(const VkPhysicalDeviceType* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPhysicalDeviceType_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPhysicalDeviceType_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkQueueFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_QUEUE_GRAPHICS_BIT"),        std::make_pair(1ULL << 1, "VK_QUEUE_COMPUTE_BIT"),
    std::make_pair(1ULL << 2, "VK_QUEUE_TRANSFER_BIT"),        std::make_pair(1ULL << 3, "VK_QUEUE_SPARSE_BINDING_BIT"),
    std::make_pair(1ULL << 4, "VK_QUEUE_PROTECTED_BIT"),       std::make_pair(1ULL << 5, "VK_QUEUE_VIDEO_DECODE_BIT_KHR"),
    std::make_pair(1ULL << 9, "VK_QUEUE_RESERVED_9_BIT_EXT"),  std::make_pair(1ULL << 6, "VK_QUEUE_VIDEO_ENCODE_BIT_KHR"),
    std::make_pair(1ULL << 7, "VK_QUEUE_RESERVED_7_BIT_QCOM"), std::make_pair(1ULL << 11, "VK_QUEUE_RESERVED_11_BIT_ARM"),
    std::make_pair(1ULL << 8, "VK_QUEUE_OPTICAL_FLOW_BIT_NV"), std::make_pair(1ULL << 10, "VK_QUEUE_RESERVED_10_BIT_EXT"),
};
static void print_VkQueueFlagBits(VkQueueFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueueFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueueFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkQueueFlagBits(const VkQueueFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueueFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueueFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDeviceQueueCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT"),
    std::make_pair(1ULL << 1, "VK_DEVICE_QUEUE_CREATE_RESERVED_1_BIT_QCOM"),
    std::make_pair(1ULL << 2, "VK_DEVICE_QUEUE_CREATE_RESERVED_2_BIT_EXT"),
};
static void print_VkDeviceQueueCreateFlagBits(VkDeviceQueueCreateFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceQueueCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceQueueCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkDeviceQueueCreateFlagBits(const VkDeviceQueueCreateFlagBits* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceQueueCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceQueueCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineStageFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"),
    std::make_pair(1ULL << 1, "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"),
    std::make_pair(1ULL << 2, "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"),
    std::make_pair(1ULL << 3, "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"),
    std::make_pair(1ULL << 4, "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT"),
    std::make_pair(1ULL << 5, "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"),
    std::make_pair(1ULL << 6, "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"),
    std::make_pair(1ULL << 7, "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"),
    std::make_pair(1ULL << 8, "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"),
    std::make_pair(1ULL << 9, "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"),
    std::make_pair(1ULL << 10, "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"),
    std::make_pair(1ULL << 11, "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"),
    std::make_pair(1ULL << 12, "VK_PIPELINE_STAGE_TRANSFER_BIT"),
    std::make_pair(1ULL << 13, "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"),
    std::make_pair(1ULL << 14, "VK_PIPELINE_STAGE_HOST_BIT"),
    std::make_pair(1ULL << 15, "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"),
    std::make_pair(1ULL << 16, "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"),
    std::make_pair(0, "VK_PIPELINE_STAGE_NONE"),
    std::make_pair(1ULL << 24, "VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT"),
    std::make_pair(1ULL << 18, "VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT"),
    std::make_pair(1ULL << 25, "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"),
    std::make_pair(1ULL << 21, "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR"),
    std::make_pair(1ULL << 23, "VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT"),
    std::make_pair(1ULL << 22, "VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
    std::make_pair(1ULL << 19, "VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT"),
    std::make_pair(1ULL << 20, "VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT"),
    std::make_pair(1ULL << 17, "VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT"),
};
static void print_VkPipelineStageFlagBits(VkPipelineStageFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineStageFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineStageFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineStageFlagBits(const VkPipelineStageFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineStageFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineStageFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkMemoryMapFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_MEMORY_MAP_PLACED_BIT_EXT"),
};
static void print_VkMemoryMapFlagBits(VkMemoryMapFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryMapFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryMapFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkMemoryMapFlagBits(const VkMemoryMapFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryMapFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryMapFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSparseMemoryBindFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_SPARSE_MEMORY_BIND_METADATA_BIT"),
};
static void print_VkSparseMemoryBindFlagBits(VkSparseMemoryBindFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSparseMemoryBindFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSparseMemoryBindFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkSparseMemoryBindFlagBits(const VkSparseMemoryBindFlagBits* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSparseMemoryBindFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSparseMemoryBindFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSparseImageFormatFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"),
    std::make_pair(1ULL << 1, "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"),
    std::make_pair(1ULL << 2, "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT"),
};
static void print_VkSparseImageFormatFlagBits(VkSparseImageFormatFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSparseImageFormatFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSparseImageFormatFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkSparseImageFormatFlagBits(const VkSparseImageFormatFlagBits* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSparseImageFormatFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSparseImageFormatFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkFenceCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_FENCE_CREATE_SIGNALED_BIT"),
};
static void print_VkFenceCreateFlagBits(VkFenceCreateFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFenceCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFenceCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkFenceCreateFlagBits(const VkFenceCreateFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFenceCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFenceCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkEventCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_EVENT_CREATE_DEVICE_ONLY_BIT"),
};
static void print_VkEventCreateFlagBits(VkEventCreateFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkEventCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkEventCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkEventCreateFlagBits(const VkEventCreateFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkEventCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkEventCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkQueryPipelineStatisticFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"),
    std::make_pair(1ULL << 1, "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"),
    std::make_pair(1ULL << 2, "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"),
    std::make_pair(1ULL << 3, "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"),
    std::make_pair(1ULL << 4, "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"),
    std::make_pair(1ULL << 5, "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"),
    std::make_pair(1ULL << 6, "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"),
    std::make_pair(1ULL << 7, "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"),
    std::make_pair(1ULL << 8, "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"),
    std::make_pair(1ULL << 9, "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT"),
    std::make_pair(1ULL << 10, "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"),
    std::make_pair(1ULL << 11, "VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT"),
    std::make_pair(1ULL << 12, "VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT"),
    std::make_pair(1ULL << 13, "VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI"),
};
static void print_VkQueryPipelineStatisticFlagBits(VkQueryPipelineStatisticFlagBits obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueryPipelineStatisticFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueryPipelineStatisticFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkQueryPipelineStatisticFlagBits(const VkQueryPipelineStatisticFlagBits* obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueryPipelineStatisticFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueryPipelineStatisticFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkQueryType_map = {
    std::make_pair(0, "VK_QUERY_TYPE_OCCLUSION"),
    std::make_pair(1, "VK_QUERY_TYPE_PIPELINE_STATISTICS"),
    std::make_pair(2, "VK_QUERY_TYPE_TIMESTAMP"),
    std::make_pair(1000023000, "VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR"),
    std::make_pair(1000028004, "VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT"),
    std::make_pair(1000116000, "VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR"),
    std::make_pair(1000150000, "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR"),
    std::make_pair(1000150001, "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR"),
    std::make_pair(1000165000, "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV"),
    std::make_pair(1000210000, "VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL"),
    std::make_pair(1000299000, "VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR"),
    std::make_pair(1000328000, "VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT"),
    std::make_pair(1000382000, "VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT"),
    std::make_pair(1000386000, "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR"),
    std::make_pair(1000386001, "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR"),
    std::make_pair(1000396000, "VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT"),
    std::make_pair(1000396001, "VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT"),
};
static void print_VkQueryType(VkQueryType obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueryType_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueryType_map[obj] << "\"" << std::endl;
}
static void print_VkQueryType(const VkQueryType* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueryType_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueryType_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkQueryResultFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_QUERY_RESULT_64_BIT"),
    std::make_pair(1ULL << 1, "VK_QUERY_RESULT_WAIT_BIT"),
    std::make_pair(1ULL << 2, "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"),
    std::make_pair(1ULL << 3, "VK_QUERY_RESULT_PARTIAL_BIT"),
    std::make_pair(1ULL << 4, "VK_QUERY_RESULT_WITH_STATUS_BIT_KHR"),
};
static void print_VkQueryResultFlagBits(VkQueryResultFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueryResultFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueryResultFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkQueryResultFlagBits(const VkQueryResultFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueryResultFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueryResultFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkBufferCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_BUFFER_CREATE_SPARSE_BINDING_BIT"),
    std::make_pair(1ULL << 1, "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"),
    std::make_pair(1ULL << 2, "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"),
    std::make_pair(1ULL << 3, "VK_BUFFER_CREATE_PROTECTED_BIT"),
    std::make_pair(1ULL << 4, "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"),
    std::make_pair(1ULL << 5, "VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"),
    std::make_pair(1ULL << 6, "VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR"),
};
static void print_VkBufferCreateFlagBits(VkBufferCreateFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBufferCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBufferCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkBufferCreateFlagBits(const VkBufferCreateFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBufferCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBufferCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkBufferUsageFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_BUFFER_USAGE_TRANSFER_SRC_BIT"),
    std::make_pair(1ULL << 1, "VK_BUFFER_USAGE_TRANSFER_DST_BIT"),
    std::make_pair(1ULL << 2, "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"),
    std::make_pair(1ULL << 3, "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"),
    std::make_pair(1ULL << 4, "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"),
    std::make_pair(1ULL << 5, "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"),
    std::make_pair(1ULL << 6, "VK_BUFFER_USAGE_INDEX_BUFFER_BIT"),
    std::make_pair(1ULL << 7, "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"),
    std::make_pair(1ULL << 8, "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"),
    std::make_pair(1ULL << 17, "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT"),
    std::make_pair(1ULL << 13, "VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR"),
    std::make_pair(1ULL << 14, "VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR"),
    std::make_pair(1ULL << 11, "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 12, "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 9, "VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT"),
    std::make_pair(1ULL << 25, "VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX"),
    std::make_pair(1ULL << 28, "VK_BUFFER_USAGE_RESERVED_28_BIT_KHR"),
    std::make_pair(1ULL << 19, "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR"),
    std::make_pair(1ULL << 20, "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR"),
    std::make_pair(1ULL << 10, "VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR"),
    std::make_pair(1ULL << 15, "VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR"),
    std::make_pair(1ULL << 16, "VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR"),
    std::make_pair(1ULL << 21, "VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 22, "VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 26, "VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 23, "VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT"),
    std::make_pair(1ULL << 24, "VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT"),
    std::make_pair(1ULL << 27, "VK_BUFFER_USAGE_RESERVED_27_BIT_QCOM"),
};
static void print_VkBufferUsageFlagBits(VkBufferUsageFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBufferUsageFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBufferUsageFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkBufferUsageFlagBits(const VkBufferUsageFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBufferUsageFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBufferUsageFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSharingMode_map = {
    std::make_pair(0, "VK_SHARING_MODE_EXCLUSIVE"),
    std::make_pair(1, "VK_SHARING_MODE_CONCURRENT"),
};
static void print_VkSharingMode(VkSharingMode obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSharingMode_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSharingMode_map[obj] << "\"" << std::endl;
}
static void print_VkSharingMode(const VkSharingMode* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSharingMode_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSharingMode_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkComponentSwizzle_map = {
    std::make_pair(0, "VK_COMPONENT_SWIZZLE_IDENTITY"), std::make_pair(1, "VK_COMPONENT_SWIZZLE_ZERO"),
    std::make_pair(2, "VK_COMPONENT_SWIZZLE_ONE"),      std::make_pair(3, "VK_COMPONENT_SWIZZLE_R"),
    std::make_pair(4, "VK_COMPONENT_SWIZZLE_G"),        std::make_pair(5, "VK_COMPONENT_SWIZZLE_B"),
    std::make_pair(6, "VK_COMPONENT_SWIZZLE_A"),
};
static void print_VkComponentSwizzle(VkComponentSwizzle obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkComponentSwizzle_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkComponentSwizzle_map[obj] << "\"" << std::endl;
}
static void print_VkComponentSwizzle(const VkComponentSwizzle* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkComponentSwizzle_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkComponentSwizzle_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkImageViewCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT"),
    std::make_pair(1ULL << 2, "VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"),
    std::make_pair(1ULL << 1, "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT"),
};
static void print_VkImageViewCreateFlagBits(VkImageViewCreateFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageViewCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageViewCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkImageViewCreateFlagBits(const VkImageViewCreateFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageViewCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageViewCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkImageViewType_map = {
    std::make_pair(0, "VK_IMAGE_VIEW_TYPE_1D"),         std::make_pair(1, "VK_IMAGE_VIEW_TYPE_2D"),
    std::make_pair(2, "VK_IMAGE_VIEW_TYPE_3D"),         std::make_pair(3, "VK_IMAGE_VIEW_TYPE_CUBE"),
    std::make_pair(4, "VK_IMAGE_VIEW_TYPE_1D_ARRAY"),   std::make_pair(5, "VK_IMAGE_VIEW_TYPE_2D_ARRAY"),
    std::make_pair(6, "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"),
};
static void print_VkImageViewType(VkImageViewType obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageViewType_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageViewType_map[obj] << "\"" << std::endl;
}
static void print_VkImageViewType(const VkImageViewType* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageViewType_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageViewType_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineCacheCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"),
    std::make_pair(1ULL << 3, "VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR"),
};
static void print_VkPipelineCacheCreateFlagBits(VkPipelineCacheCreateFlagBits obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCacheCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCacheCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineCacheCreateFlagBits(const VkPipelineCacheCreateFlagBits* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCacheCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCacheCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkBlendFactor_map = {
    std::make_pair(0, "VK_BLEND_FACTOR_ZERO"),
    std::make_pair(1, "VK_BLEND_FACTOR_ONE"),
    std::make_pair(2, "VK_BLEND_FACTOR_SRC_COLOR"),
    std::make_pair(3, "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"),
    std::make_pair(4, "VK_BLEND_FACTOR_DST_COLOR"),
    std::make_pair(5, "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"),
    std::make_pair(6, "VK_BLEND_FACTOR_SRC_ALPHA"),
    std::make_pair(7, "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"),
    std::make_pair(8, "VK_BLEND_FACTOR_DST_ALPHA"),
    std::make_pair(9, "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"),
    std::make_pair(10, "VK_BLEND_FACTOR_CONSTANT_COLOR"),
    std::make_pair(11, "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"),
    std::make_pair(12, "VK_BLEND_FACTOR_CONSTANT_ALPHA"),
    std::make_pair(13, "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"),
    std::make_pair(14, "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"),
    std::make_pair(15, "VK_BLEND_FACTOR_SRC1_COLOR"),
    std::make_pair(16, "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"),
    std::make_pair(17, "VK_BLEND_FACTOR_SRC1_ALPHA"),
    std::make_pair(18, "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"),
};
static void print_VkBlendFactor(VkBlendFactor obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBlendFactor_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBlendFactor_map[obj] << "\"" << std::endl;
}
static void print_VkBlendFactor(const VkBlendFactor* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBlendFactor_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBlendFactor_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkBlendOp_map = {
    std::make_pair(0, "VK_BLEND_OP_ADD"),
    std::make_pair(1, "VK_BLEND_OP_SUBTRACT"),
    std::make_pair(2, "VK_BLEND_OP_REVERSE_SUBTRACT"),
    std::make_pair(3, "VK_BLEND_OP_MIN"),
    std::make_pair(4, "VK_BLEND_OP_MAX"),
    std::make_pair(1000148000, "VK_BLEND_OP_ZERO_EXT"),
    std::make_pair(1000148001, "VK_BLEND_OP_SRC_EXT"),
    std::make_pair(1000148002, "VK_BLEND_OP_DST_EXT"),
    std::make_pair(1000148003, "VK_BLEND_OP_SRC_OVER_EXT"),
    std::make_pair(1000148004, "VK_BLEND_OP_DST_OVER_EXT"),
    std::make_pair(1000148005, "VK_BLEND_OP_SRC_IN_EXT"),
    std::make_pair(1000148006, "VK_BLEND_OP_DST_IN_EXT"),
    std::make_pair(1000148007, "VK_BLEND_OP_SRC_OUT_EXT"),
    std::make_pair(1000148008, "VK_BLEND_OP_DST_OUT_EXT"),
    std::make_pair(1000148009, "VK_BLEND_OP_SRC_ATOP_EXT"),
    std::make_pair(1000148010, "VK_BLEND_OP_DST_ATOP_EXT"),
    std::make_pair(1000148011, "VK_BLEND_OP_XOR_EXT"),
    std::make_pair(1000148012, "VK_BLEND_OP_MULTIPLY_EXT"),
    std::make_pair(1000148013, "VK_BLEND_OP_SCREEN_EXT"),
    std::make_pair(1000148014, "VK_BLEND_OP_OVERLAY_EXT"),
    std::make_pair(1000148015, "VK_BLEND_OP_DARKEN_EXT"),
    std::make_pair(1000148016, "VK_BLEND_OP_LIGHTEN_EXT"),
    std::make_pair(1000148017, "VK_BLEND_OP_COLORDODGE_EXT"),
    std::make_pair(1000148018, "VK_BLEND_OP_COLORBURN_EXT"),
    std::make_pair(1000148019, "VK_BLEND_OP_HARDLIGHT_EXT"),
    std::make_pair(1000148020, "VK_BLEND_OP_SOFTLIGHT_EXT"),
    std::make_pair(1000148021, "VK_BLEND_OP_DIFFERENCE_EXT"),
    std::make_pair(1000148022, "VK_BLEND_OP_EXCLUSION_EXT"),
    std::make_pair(1000148023, "VK_BLEND_OP_INVERT_EXT"),
    std::make_pair(1000148024, "VK_BLEND_OP_INVERT_RGB_EXT"),
    std::make_pair(1000148025, "VK_BLEND_OP_LINEARDODGE_EXT"),
    std::make_pair(1000148026, "VK_BLEND_OP_LINEARBURN_EXT"),
    std::make_pair(1000148027, "VK_BLEND_OP_VIVIDLIGHT_EXT"),
    std::make_pair(1000148028, "VK_BLEND_OP_LINEARLIGHT_EXT"),
    std::make_pair(1000148029, "VK_BLEND_OP_PINLIGHT_EXT"),
    std::make_pair(1000148030, "VK_BLEND_OP_HARDMIX_EXT"),
    std::make_pair(1000148031, "VK_BLEND_OP_HSL_HUE_EXT"),
    std::make_pair(1000148032, "VK_BLEND_OP_HSL_SATURATION_EXT"),
    std::make_pair(1000148033, "VK_BLEND_OP_HSL_COLOR_EXT"),
    std::make_pair(1000148034, "VK_BLEND_OP_HSL_LUMINOSITY_EXT"),
    std::make_pair(1000148035, "VK_BLEND_OP_PLUS_EXT"),
    std::make_pair(1000148036, "VK_BLEND_OP_PLUS_CLAMPED_EXT"),
    std::make_pair(1000148037, "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT"),
    std::make_pair(1000148038, "VK_BLEND_OP_PLUS_DARKER_EXT"),
    std::make_pair(1000148039, "VK_BLEND_OP_MINUS_EXT"),
    std::make_pair(1000148040, "VK_BLEND_OP_MINUS_CLAMPED_EXT"),
    std::make_pair(1000148041, "VK_BLEND_OP_CONTRAST_EXT"),
    std::make_pair(1000148042, "VK_BLEND_OP_INVERT_OVG_EXT"),
    std::make_pair(1000148043, "VK_BLEND_OP_RED_EXT"),
    std::make_pair(1000148044, "VK_BLEND_OP_GREEN_EXT"),
    std::make_pair(1000148045, "VK_BLEND_OP_BLUE_EXT"),
};
static void print_VkBlendOp(VkBlendOp obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBlendOp_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBlendOp_map[obj] << "\"" << std::endl;
}
static void print_VkBlendOp(const VkBlendOp* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBlendOp_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBlendOp_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkColorComponentFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_COLOR_COMPONENT_R_BIT"),
    std::make_pair(1ULL << 1, "VK_COLOR_COMPONENT_G_BIT"),
    std::make_pair(1ULL << 2, "VK_COLOR_COMPONENT_B_BIT"),
    std::make_pair(1ULL << 3, "VK_COLOR_COMPONENT_A_BIT"),
};
static void print_VkColorComponentFlagBits(VkColorComponentFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkColorComponentFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkColorComponentFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkColorComponentFlagBits(const VkColorComponentFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkColorComponentFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkColorComponentFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkCompareOp_map = {
    std::make_pair(0, "VK_COMPARE_OP_NEVER"),
    std::make_pair(1, "VK_COMPARE_OP_LESS"),
    std::make_pair(2, "VK_COMPARE_OP_EQUAL"),
    std::make_pair(3, "VK_COMPARE_OP_LESS_OR_EQUAL"),
    std::make_pair(4, "VK_COMPARE_OP_GREATER"),
    std::make_pair(5, "VK_COMPARE_OP_NOT_EQUAL"),
    std::make_pair(6, "VK_COMPARE_OP_GREATER_OR_EQUAL"),
    std::make_pair(7, "VK_COMPARE_OP_ALWAYS"),
};
static void print_VkCompareOp(VkCompareOp obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCompareOp_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCompareOp_map[obj] << "\"" << std::endl;
}
static void print_VkCompareOp(const VkCompareOp* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCompareOp_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCompareOp_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"),
    std::make_pair(1ULL << 1, "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"),
    std::make_pair(1ULL << 2, "VK_PIPELINE_CREATE_DERIVATIVE_BIT"),
    std::make_pair(1ULL << 3, "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"),
    std::make_pair(1ULL << 4, "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT"),
    std::make_pair(1ULL << 8, "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT"),
    std::make_pair(1ULL << 9, "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT"),
    std::make_pair(1ULL << 27, "VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT"),
    std::make_pair(1ULL << 30, "VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT"),
    std::make_pair(1ULL << 14, "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR"),
    std::make_pair(1ULL << 15, "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR"),
    std::make_pair(1ULL << 16, "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR"),
    std::make_pair(1ULL << 17, "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR"),
    std::make_pair(1ULL << 12, "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR"),
    std::make_pair(1ULL << 13, "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR"),
    std::make_pair(1ULL << 19, "VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR"),
    std::make_pair(1ULL << 5, "VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV"),
    std::make_pair(1ULL << 22, "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"),
    std::make_pair(1ULL << 21, "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
    std::make_pair(1ULL << 6, "VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR"),
    std::make_pair(1ULL << 7, "VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR"),
    std::make_pair(1ULL << 18, "VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV"),
    std::make_pair(1ULL << 11, "VK_PIPELINE_CREATE_LIBRARY_BIT_KHR"),
    std::make_pair(1ULL << 29, "VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 23, "VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT"),
    std::make_pair(1ULL << 10, "VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT"),
    std::make_pair(1ULL << 20, "VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV"),
    std::make_pair(1ULL << 25, "VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"),
    std::make_pair(1ULL << 26, "VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"),
    std::make_pair(1ULL << 24, "VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT"),
    std::make_pair(1ULL << 28, "VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV"),
};
static void print_VkPipelineCreateFlagBits(VkPipelineCreateFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineCreateFlagBits(const VkPipelineCreateFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineShaderStageCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT"),
    std::make_pair(1ULL << 1, "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT"),
    std::make_pair(1ULL << 3, "VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_3_BIT_KHR"),
};
static void print_VkPipelineShaderStageCreateFlagBits(VkPipelineShaderStageCreateFlagBits obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineShaderStageCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineShaderStageCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineShaderStageCreateFlagBits(const VkPipelineShaderStageCreateFlagBits* obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineShaderStageCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineShaderStageCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkShaderStageFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_SHADER_STAGE_VERTEX_BIT"),
    std::make_pair(1ULL << 1, "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"),
    std::make_pair(1ULL << 2, "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"),
    std::make_pair(1ULL << 3, "VK_SHADER_STAGE_GEOMETRY_BIT"),
    std::make_pair(1ULL << 4, "VK_SHADER_STAGE_FRAGMENT_BIT"),
    std::make_pair(1ULL << 5, "VK_SHADER_STAGE_COMPUTE_BIT"),
    std::make_pair(0x0000001F, "VK_SHADER_STAGE_ALL_GRAPHICS"),
    std::make_pair(0x7FFFFFFF, "VK_SHADER_STAGE_ALL"),
    std::make_pair(1ULL << 8, "VK_SHADER_STAGE_RAYGEN_BIT_KHR"),
    std::make_pair(1ULL << 9, "VK_SHADER_STAGE_ANY_HIT_BIT_KHR"),
    std::make_pair(1ULL << 10, "VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR"),
    std::make_pair(1ULL << 11, "VK_SHADER_STAGE_MISS_BIT_KHR"),
    std::make_pair(1ULL << 12, "VK_SHADER_STAGE_INTERSECTION_BIT_KHR"),
    std::make_pair(1ULL << 13, "VK_SHADER_STAGE_CALLABLE_BIT_KHR"),
    std::make_pair(1ULL << 6, "VK_SHADER_STAGE_TASK_BIT_EXT"),
    std::make_pair(1ULL << 7, "VK_SHADER_STAGE_MESH_BIT_EXT"),
    std::make_pair(1ULL << 14, "VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI"),
    std::make_pair(1ULL << 19, "VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI"),
    std::make_pair(1ULL << 15, "VK_SHADER_STAGE_RESERVED_15_BIT_NV"),
};
static void print_VkShaderStageFlagBits(VkShaderStageFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderStageFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderStageFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkShaderStageFlagBits(const VkShaderStageFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderStageFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderStageFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkCullModeFlagBits_map = {
    std::make_pair(0, "VK_CULL_MODE_NONE"),
    std::make_pair(1ULL << 0, "VK_CULL_MODE_FRONT_BIT"),
    std::make_pair(1ULL << 1, "VK_CULL_MODE_BACK_BIT"),
    std::make_pair(0x00000003, "VK_CULL_MODE_FRONT_AND_BACK"),
};
static void print_VkCullModeFlagBits(VkCullModeFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCullModeFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCullModeFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkCullModeFlagBits(const VkCullModeFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCullModeFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCullModeFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDynamicState_map = {
    std::make_pair(0, "VK_DYNAMIC_STATE_VIEWPORT"),
    std::make_pair(1, "VK_DYNAMIC_STATE_SCISSOR"),
    std::make_pair(2, "VK_DYNAMIC_STATE_LINE_WIDTH"),
    std::make_pair(3, "VK_DYNAMIC_STATE_DEPTH_BIAS"),
    std::make_pair(4, "VK_DYNAMIC_STATE_BLEND_CONSTANTS"),
    std::make_pair(5, "VK_DYNAMIC_STATE_DEPTH_BOUNDS"),
    std::make_pair(6, "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"),
    std::make_pair(7, "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"),
    std::make_pair(8, "VK_DYNAMIC_STATE_STENCIL_REFERENCE"),
    std::make_pair(1000267000, "VK_DYNAMIC_STATE_CULL_MODE"),
    std::make_pair(1000267001, "VK_DYNAMIC_STATE_FRONT_FACE"),
    std::make_pair(1000267002, "VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY"),
    std::make_pair(1000267003, "VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT"),
    std::make_pair(1000267004, "VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT"),
    std::make_pair(1000267005, "VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE"),
    std::make_pair(1000267006, "VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE"),
    std::make_pair(1000267007, "VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE"),
    std::make_pair(1000267008, "VK_DYNAMIC_STATE_DEPTH_COMPARE_OP"),
    std::make_pair(1000267009, "VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE"),
    std::make_pair(1000267010, "VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE"),
    std::make_pair(1000267011, "VK_DYNAMIC_STATE_STENCIL_OP"),
    std::make_pair(1000377001, "VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE"),
    std::make_pair(1000377002, "VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE"),
    std::make_pair(1000377004, "VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE"),
    std::make_pair(1000259000, "VK_DYNAMIC_STATE_LINE_STIPPLE"),
    std::make_pair(1000087000, "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV"),
    std::make_pair(1000099000, "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT"),
    std::make_pair(1000099001, "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT"),
    std::make_pair(1000099002, "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT"),
    std::make_pair(1000143000, "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT"),
    std::make_pair(1000347000, "VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR"),
    std::make_pair(1000164004, "VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV"),
    std::make_pair(1000164006, "VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV"),
    std::make_pair(1000205000, "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV"),
    std::make_pair(1000205001, "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV"),
    std::make_pair(1000226000, "VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR"),
    std::make_pair(1000352000, "VK_DYNAMIC_STATE_VERTEX_INPUT_EXT"),
    std::make_pair(1000377000, "VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT"),
    std::make_pair(1000377003, "VK_DYNAMIC_STATE_LOGIC_OP_EXT"),
    std::make_pair(1000381000, "VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT"),
    std::make_pair(1000455003, "VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT"),
    std::make_pair(1000455004, "VK_DYNAMIC_STATE_POLYGON_MODE_EXT"),
    std::make_pair(1000455005, "VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT"),
    std::make_pair(1000455006, "VK_DYNAMIC_STATE_SAMPLE_MASK_EXT"),
    std::make_pair(1000455007, "VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT"),
    std::make_pair(1000455008, "VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT"),
    std::make_pair(1000455009, "VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT"),
    std::make_pair(1000455010, "VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT"),
    std::make_pair(1000455011, "VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT"),
    std::make_pair(1000455012, "VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT"),
    std::make_pair(1000455002, "VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT"),
    std::make_pair(1000455013, "VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT"),
    std::make_pair(1000455014, "VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT"),
    std::make_pair(1000455015, "VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT"),
    std::make_pair(1000455016, "VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT"),
    std::make_pair(1000455017, "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT"),
    std::make_pair(1000455018, "VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT"),
    std::make_pair(1000455019, "VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT"),
    std::make_pair(1000455020, "VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT"),
    std::make_pair(1000455021, "VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT"),
    std::make_pair(1000455022, "VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT"),
    std::make_pair(1000455023, "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV"),
    std::make_pair(1000455024, "VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV"),
    std::make_pair(1000455025, "VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV"),
    std::make_pair(1000455026, "VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV"),
    std::make_pair(1000455027, "VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV"),
    std::make_pair(1000455028, "VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV"),
    std::make_pair(1000455029, "VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV"),
    std::make_pair(1000455030, "VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV"),
    std::make_pair(1000455031, "VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV"),
    std::make_pair(1000455032, "VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV"),
    std::make_pair(1000524000, "VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT"),
    std::make_pair(1000582000, "VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT"),
};
static void print_VkDynamicState(VkDynamicState obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDynamicState_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDynamicState_map[obj] << "\"" << std::endl;
}
static void print_VkDynamicState(const VkDynamicState* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDynamicState_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDynamicState_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkFrontFace_map = {
    std::make_pair(0, "VK_FRONT_FACE_COUNTER_CLOCKWISE"),
    std::make_pair(1, "VK_FRONT_FACE_CLOCKWISE"),
};
static void print_VkFrontFace(VkFrontFace obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFrontFace_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFrontFace_map[obj] << "\"" << std::endl;
}
static void print_VkFrontFace(const VkFrontFace* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFrontFace_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFrontFace_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVertexInputRate_map = {
    std::make_pair(0, "VK_VERTEX_INPUT_RATE_VERTEX"),
    std::make_pair(1, "VK_VERTEX_INPUT_RATE_INSTANCE"),
};
static void print_VkVertexInputRate(VkVertexInputRate obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVertexInputRate_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVertexInputRate_map[obj] << "\"" << std::endl;
}
static void print_VkVertexInputRate(const VkVertexInputRate* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVertexInputRate_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVertexInputRate_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPrimitiveTopology_map = {
    std::make_pair(0, "VK_PRIMITIVE_TOPOLOGY_POINT_LIST"),
    std::make_pair(1, "VK_PRIMITIVE_TOPOLOGY_LINE_LIST"),
    std::make_pair(2, "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"),
    std::make_pair(3, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"),
    std::make_pair(4, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"),
    std::make_pair(5, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"),
    std::make_pair(6, "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"),
    std::make_pair(7, "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"),
    std::make_pair(8, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"),
    std::make_pair(9, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"),
    std::make_pair(10, "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"),
};
static void print_VkPrimitiveTopology(VkPrimitiveTopology obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPrimitiveTopology_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPrimitiveTopology_map[obj] << "\"" << std::endl;
}
static void print_VkPrimitiveTopology(const VkPrimitiveTopology* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPrimitiveTopology_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPrimitiveTopology_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPolygonMode_map = {
    std::make_pair(0, "VK_POLYGON_MODE_FILL"),
    std::make_pair(1, "VK_POLYGON_MODE_LINE"),
    std::make_pair(2, "VK_POLYGON_MODE_POINT"),
    std::make_pair(1000153000, "VK_POLYGON_MODE_FILL_RECTANGLE_NV"),
};
static void print_VkPolygonMode(VkPolygonMode obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPolygonMode_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPolygonMode_map[obj] << "\"" << std::endl;
}
static void print_VkPolygonMode(const VkPolygonMode* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPolygonMode_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPolygonMode_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineDepthStencilStateCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"),
    std::make_pair(1ULL << 1, "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"),
};
static void print_VkPipelineDepthStencilStateCreateFlagBits(VkPipelineDepthStencilStateCreateFlagBits obj, const std::string& str,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineDepthStencilStateCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineDepthStencilStateCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineDepthStencilStateCreateFlagBits(const VkPipelineDepthStencilStateCreateFlagBits* obj,
                                                            const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineDepthStencilStateCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineDepthStencilStateCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkStencilOp_map = {
    std::make_pair(0, "VK_STENCIL_OP_KEEP"),
    std::make_pair(1, "VK_STENCIL_OP_ZERO"),
    std::make_pair(2, "VK_STENCIL_OP_REPLACE"),
    std::make_pair(3, "VK_STENCIL_OP_INCREMENT_AND_CLAMP"),
    std::make_pair(4, "VK_STENCIL_OP_DECREMENT_AND_CLAMP"),
    std::make_pair(5, "VK_STENCIL_OP_INVERT"),
    std::make_pair(6, "VK_STENCIL_OP_INCREMENT_AND_WRAP"),
    std::make_pair(7, "VK_STENCIL_OP_DECREMENT_AND_WRAP"),
};
static void print_VkStencilOp(VkStencilOp obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkStencilOp_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkStencilOp_map[obj] << "\"" << std::endl;
}
static void print_VkStencilOp(const VkStencilOp* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkStencilOp_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkStencilOp_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineColorBlendStateCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT"),
};
static void print_VkPipelineColorBlendStateCreateFlagBits(VkPipelineColorBlendStateCreateFlagBits obj, const std::string& str,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineColorBlendStateCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineColorBlendStateCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineColorBlendStateCreateFlagBits(const VkPipelineColorBlendStateCreateFlagBits* obj,
                                                          const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineColorBlendStateCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineColorBlendStateCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkLogicOp_map = {
    std::make_pair(0, "VK_LOGIC_OP_CLEAR"),
    std::make_pair(1, "VK_LOGIC_OP_AND"),
    std::make_pair(2, "VK_LOGIC_OP_AND_REVERSE"),
    std::make_pair(3, "VK_LOGIC_OP_COPY"),
    std::make_pair(4, "VK_LOGIC_OP_AND_INVERTED"),
    std::make_pair(5, "VK_LOGIC_OP_NO_OP"),
    std::make_pair(6, "VK_LOGIC_OP_XOR"),
    std::make_pair(7, "VK_LOGIC_OP_OR"),
    std::make_pair(8, "VK_LOGIC_OP_NOR"),
    std::make_pair(9, "VK_LOGIC_OP_EQUIVALENT"),
    std::make_pair(10, "VK_LOGIC_OP_INVERT"),
    std::make_pair(11, "VK_LOGIC_OP_OR_REVERSE"),
    std::make_pair(12, "VK_LOGIC_OP_COPY_INVERTED"),
    std::make_pair(13, "VK_LOGIC_OP_OR_INVERTED"),
    std::make_pair(14, "VK_LOGIC_OP_NAND"),
    std::make_pair(15, "VK_LOGIC_OP_SET"),
};
static void print_VkLogicOp(VkLogicOp obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLogicOp_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLogicOp_map[obj] << "\"" << std::endl;
}
static void print_VkLogicOp(const VkLogicOp* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLogicOp_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLogicOp_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineLayoutCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_PIPELINE_LAYOUT_CREATE_RESERVED_0_BIT_AMD"),
    std::make_pair(1ULL << 1, "VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT"),
};
static void print_VkPipelineLayoutCreateFlagBits(VkPipelineLayoutCreateFlagBits obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineLayoutCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineLayoutCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineLayoutCreateFlagBits(const VkPipelineLayoutCreateFlagBits* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineLayoutCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineLayoutCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkBorderColor_map = {
    std::make_pair(0, "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"),   std::make_pair(1, "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"),
    std::make_pair(2, "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"),        std::make_pair(3, "VK_BORDER_COLOR_INT_OPAQUE_BLACK"),
    std::make_pair(4, "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"),        std::make_pair(5, "VK_BORDER_COLOR_INT_OPAQUE_WHITE"),
    std::make_pair(1000287003, "VK_BORDER_COLOR_FLOAT_CUSTOM_EXT"), std::make_pair(1000287004, "VK_BORDER_COLOR_INT_CUSTOM_EXT"),
};
static void print_VkBorderColor(VkBorderColor obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBorderColor_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBorderColor_map[obj] << "\"" << std::endl;
}
static void print_VkBorderColor(const VkBorderColor* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBorderColor_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBorderColor_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkFilter_map = {
    std::make_pair(0, "VK_FILTER_NEAREST"),
    std::make_pair(1, "VK_FILTER_LINEAR"),
    std::make_pair(1000015000, "VK_FILTER_CUBIC_EXT"),
};
static void print_VkFilter(VkFilter obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFilter_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFilter_map[obj] << "\"" << std::endl;
}
static void print_VkFilter(const VkFilter* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFilter_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFilter_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSamplerAddressMode_map = {
    std::make_pair(0, "VK_SAMPLER_ADDRESS_MODE_REPEAT"),
    std::make_pair(1, "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"),
    std::make_pair(2, "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"),
    std::make_pair(3, "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),
    std::make_pair(4, "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE"),
    std::make_pair(4, "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE"),
};
static void print_VkSamplerAddressMode(VkSamplerAddressMode obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerAddressMode_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerAddressMode_map[obj] << "\"" << std::endl;
}
static void print_VkSamplerAddressMode(const VkSamplerAddressMode* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerAddressMode_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerAddressMode_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSamplerCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT"),
    std::make_pair(1ULL << 1, "VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT"),
    std::make_pair(1ULL << 3, "VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"),
    std::make_pair(1ULL << 2, "VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT"),
    std::make_pair(1ULL << 4, "VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM"),
};
static void print_VkSamplerCreateFlagBits(VkSamplerCreateFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkSamplerCreateFlagBits(const VkSamplerCreateFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSamplerMipmapMode_map = {
    std::make_pair(0, "VK_SAMPLER_MIPMAP_MODE_NEAREST"),
    std::make_pair(1, "VK_SAMPLER_MIPMAP_MODE_LINEAR"),
};
static void print_VkSamplerMipmapMode(VkSamplerMipmapMode obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerMipmapMode_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerMipmapMode_map[obj] << "\"" << std::endl;
}
static void print_VkSamplerMipmapMode(const VkSamplerMipmapMode* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerMipmapMode_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerMipmapMode_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDescriptorPoolCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),
    std::make_pair(1ULL << 1, "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT"),
    std::make_pair(1ULL << 2, "VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT"),
    std::make_pair(1ULL << 3, "VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV"),
    std::make_pair(1ULL << 4, "VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV"),
};
static void print_VkDescriptorPoolCreateFlagBits(VkDescriptorPoolCreateFlagBits obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorPoolCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorPoolCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkDescriptorPoolCreateFlagBits(const VkDescriptorPoolCreateFlagBits* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorPoolCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorPoolCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDescriptorType_map = {
    std::make_pair(0, "VK_DESCRIPTOR_TYPE_SAMPLER"),
    std::make_pair(1, "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),
    std::make_pair(2, "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"),
    std::make_pair(3, "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"),
    std::make_pair(4, "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"),
    std::make_pair(5, "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"),
    std::make_pair(6, "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"),
    std::make_pair(7, "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"),
    std::make_pair(8, "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"),
    std::make_pair(9, "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"),
    std::make_pair(10, "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"),
    std::make_pair(1000138000, "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK"),
    std::make_pair(1000150000, "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR"),
    std::make_pair(1000165000, "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV"),
    std::make_pair(1000440000, "VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM"),
    std::make_pair(1000440001, "VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM"),
    std::make_pair(1000351000, "VK_DESCRIPTOR_TYPE_MUTABLE_EXT"),
    std::make_pair(1000570000, "VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV"),
};
static void print_VkDescriptorType(VkDescriptorType obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorType_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorType_map[obj] << "\"" << std::endl;
}
static void print_VkDescriptorType(const VkDescriptorType* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorType_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorType_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDescriptorSetLayoutCreateFlagBits_map = {
    std::make_pair(1ULL << 1, "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT"),
    std::make_pair(1ULL << 0, "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT"),
    std::make_pair(1ULL << 4, "VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 5, "VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT"),
    std::make_pair(1ULL << 3, "VK_DESCRIPTOR_SET_LAYOUT_CREATE_RESERVED_3_BIT_AMD"),
    std::make_pair(1ULL << 7, "VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV"),
    std::make_pair(1ULL << 2, "VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT"),
    std::make_pair(1ULL << 6, "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV"),
};
static void print_VkDescriptorSetLayoutCreateFlagBits(VkDescriptorSetLayoutCreateFlagBits obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorSetLayoutCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorSetLayoutCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkDescriptorSetLayoutCreateFlagBits(const VkDescriptorSetLayoutCreateFlagBits* obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorSetLayoutCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorSetLayoutCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAttachmentDescriptionFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"),
};
static void print_VkAttachmentDescriptionFlagBits(VkAttachmentDescriptionFlagBits obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAttachmentDescriptionFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAttachmentDescriptionFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkAttachmentDescriptionFlagBits(const VkAttachmentDescriptionFlagBits* obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAttachmentDescriptionFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAttachmentDescriptionFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAttachmentLoadOp_map = {
    std::make_pair(0, "VK_ATTACHMENT_LOAD_OP_LOAD"),
    std::make_pair(1, "VK_ATTACHMENT_LOAD_OP_CLEAR"),
    std::make_pair(2, "VK_ATTACHMENT_LOAD_OP_DONT_CARE"),
    std::make_pair(1000400000, "VK_ATTACHMENT_LOAD_OP_NONE"),
};
static void print_VkAttachmentLoadOp(VkAttachmentLoadOp obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAttachmentLoadOp_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAttachmentLoadOp_map[obj] << "\"" << std::endl;
}
static void print_VkAttachmentLoadOp(const VkAttachmentLoadOp* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAttachmentLoadOp_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAttachmentLoadOp_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAttachmentStoreOp_map = {
    std::make_pair(0, "VK_ATTACHMENT_STORE_OP_STORE"),
    std::make_pair(1, "VK_ATTACHMENT_STORE_OP_DONT_CARE"),
    std::make_pair(1000301000, "VK_ATTACHMENT_STORE_OP_NONE"),
};
static void print_VkAttachmentStoreOp(VkAttachmentStoreOp obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAttachmentStoreOp_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAttachmentStoreOp_map[obj] << "\"" << std::endl;
}
static void print_VkAttachmentStoreOp(const VkAttachmentStoreOp* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAttachmentStoreOp_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAttachmentStoreOp_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDependencyFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_DEPENDENCY_BY_REGION_BIT"),
    std::make_pair(1ULL << 2, "VK_DEPENDENCY_DEVICE_GROUP_BIT"),
    std::make_pair(1ULL << 1, "VK_DEPENDENCY_VIEW_LOCAL_BIT"),
    std::make_pair(1ULL << 3, "VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT"),
    std::make_pair(1ULL << 5, "VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR"),
    std::make_pair(1ULL << 6, "VK_DEPENDENCY_EXTENSION_585_BIT_EXT"),
    std::make_pair(1ULL << 4, "VK_DEPENDENCY_EXTENSION_586_BIT_IMG"),
};
static void print_VkDependencyFlagBits(VkDependencyFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDependencyFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDependencyFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkDependencyFlagBits(const VkDependencyFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDependencyFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDependencyFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkFramebufferCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT"),
};
static void print_VkFramebufferCreateFlagBits(VkFramebufferCreateFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFramebufferCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFramebufferCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkFramebufferCreateFlagBits(const VkFramebufferCreateFlagBits* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFramebufferCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFramebufferCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineBindPoint_map = {
    std::make_pair(0, "VK_PIPELINE_BIND_POINT_GRAPHICS"),
    std::make_pair(1, "VK_PIPELINE_BIND_POINT_COMPUTE"),
    std::make_pair(1000134000, "VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX"),
    std::make_pair(1000165000, "VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR"),
    std::make_pair(1000369003, "VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI"),
};
static void print_VkPipelineBindPoint(VkPipelineBindPoint obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineBindPoint_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineBindPoint_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineBindPoint(const VkPipelineBindPoint* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineBindPoint_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineBindPoint_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkRenderPassCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM"),
};
static void print_VkRenderPassCreateFlagBits(VkRenderPassCreateFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRenderPassCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRenderPassCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkRenderPassCreateFlagBits(const VkRenderPassCreateFlagBits* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRenderPassCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRenderPassCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSubpassDescriptionFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX"),
    std::make_pair(1ULL << 1, "VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX"),
    std::make_pair(1ULL << 2, "VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM"),
    std::make_pair(1ULL << 3, "VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM"),
    std::make_pair(1ULL << 4, "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT"),
    std::make_pair(1ULL << 5, "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"),
    std::make_pair(1ULL << 6, "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"),
    std::make_pair(1ULL << 7, "VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT"),
};
static void print_VkSubpassDescriptionFlagBits(VkSubpassDescriptionFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSubpassDescriptionFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSubpassDescriptionFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkSubpassDescriptionFlagBits(const VkSubpassDescriptionFlagBits* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSubpassDescriptionFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSubpassDescriptionFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkCommandPoolCreateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"),
    std::make_pair(1ULL << 1, "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),
    std::make_pair(1ULL << 2, "VK_COMMAND_POOL_CREATE_PROTECTED_BIT"),
};
static void print_VkCommandPoolCreateFlagBits(VkCommandPoolCreateFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCommandPoolCreateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCommandPoolCreateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkCommandPoolCreateFlagBits(const VkCommandPoolCreateFlagBits* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCommandPoolCreateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCommandPoolCreateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkCommandPoolResetFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"),
    std::make_pair(1ULL << 1, "VK_COMMAND_POOL_RESET_RESERVED_1_BIT_COREAVI"),
};
static void print_VkCommandPoolResetFlagBits(VkCommandPoolResetFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCommandPoolResetFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCommandPoolResetFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkCommandPoolResetFlagBits(const VkCommandPoolResetFlagBits* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCommandPoolResetFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCommandPoolResetFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkCommandBufferLevel_map = {
    std::make_pair(0, "VK_COMMAND_BUFFER_LEVEL_PRIMARY"),
    std::make_pair(1, "VK_COMMAND_BUFFER_LEVEL_SECONDARY"),
};
static void print_VkCommandBufferLevel(VkCommandBufferLevel obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCommandBufferLevel_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCommandBufferLevel_map[obj] << "\"" << std::endl;
}
static void print_VkCommandBufferLevel(const VkCommandBufferLevel* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCommandBufferLevel_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCommandBufferLevel_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkCommandBufferUsageFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"),
    std::make_pair(1ULL << 1, "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"),
    std::make_pair(1ULL << 2, "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"),
};
static void print_VkCommandBufferUsageFlagBits(VkCommandBufferUsageFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCommandBufferUsageFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCommandBufferUsageFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkCommandBufferUsageFlagBits(const VkCommandBufferUsageFlagBits* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCommandBufferUsageFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCommandBufferUsageFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkQueryControlFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_QUERY_CONTROL_PRECISE_BIT"),
};
static void print_VkQueryControlFlagBits(VkQueryControlFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueryControlFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueryControlFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkQueryControlFlagBits(const VkQueryControlFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueryControlFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueryControlFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkCommandBufferResetFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"),
};
static void print_VkCommandBufferResetFlagBits(VkCommandBufferResetFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCommandBufferResetFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCommandBufferResetFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkCommandBufferResetFlagBits(const VkCommandBufferResetFlagBits* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCommandBufferResetFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCommandBufferResetFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkIndexType_map = {
    std::make_pair(0, "VK_INDEX_TYPE_UINT16"),
    std::make_pair(1, "VK_INDEX_TYPE_UINT32"),
    std::make_pair(1000265000, "VK_INDEX_TYPE_UINT8"),
    std::make_pair(1000165000, "VK_INDEX_TYPE_NONE_KHR"),
};
static void print_VkIndexType(VkIndexType obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndexType_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndexType_map[obj] << "\"" << std::endl;
}
static void print_VkIndexType(const VkIndexType* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndexType_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndexType_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkStencilFaceFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_STENCIL_FACE_FRONT_BIT"),
    std::make_pair(1ULL << 1, "VK_STENCIL_FACE_BACK_BIT"),
    std::make_pair(0x00000003, "VK_STENCIL_FACE_FRONT_AND_BACK"),
};
static void print_VkStencilFaceFlagBits(VkStencilFaceFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkStencilFaceFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkStencilFaceFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkStencilFaceFlagBits(const VkStencilFaceFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkStencilFaceFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkStencilFaceFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSubpassContents_map = {
    std::make_pair(0, "VK_SUBPASS_CONTENTS_INLINE"),
    std::make_pair(1, "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"),
    std::make_pair(1000451000, "VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR"),
};
static void print_VkSubpassContents(VkSubpassContents obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSubpassContents_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSubpassContents_map[obj] << "\"" << std::endl;
}
static void print_VkSubpassContents(const VkSubpassContents* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSubpassContents_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSubpassContents_map[*obj] << "\"" << std::endl;
}

static void print_VkAccessFlags(VkAccessFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkAccessFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkAccessFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkImageAspectFlags(VkImageAspectFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkImageAspectFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkImageAspectFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkFormatFeatureFlags(VkFormatFeatureFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkFormatFeatureFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkFormatFeatureFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkImageCreateFlags(VkImageCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkImageCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkImageCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkSampleCountFlags(VkSampleCountFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkSampleCountFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkSampleCountFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkImageUsageFlags(VkImageUsageFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkImageUsageFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkImageUsageFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkInstanceCreateFlags(VkInstanceCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkInstanceCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkInstanceCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkMemoryHeapFlags(VkMemoryHeapFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkMemoryHeapFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkMemoryHeapFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkMemoryPropertyFlags(VkMemoryPropertyFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkMemoryPropertyFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkMemoryPropertyFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkQueueFlags(VkQueueFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkQueueFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkQueueFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkDeviceCreateFlags(VkDeviceCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkDeviceQueueCreateFlags(VkDeviceQueueCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkDeviceQueueCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkDeviceQueueCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPipelineStageFlags(VkPipelineStageFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPipelineStageFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkPipelineStageFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkMemoryMapFlags(VkMemoryMapFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkMemoryMapFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkMemoryMapFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkSparseMemoryBindFlags(VkSparseMemoryBindFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkSparseMemoryBindFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkSparseMemoryBindFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkSparseImageFormatFlags(VkSparseImageFormatFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkSparseImageFormatFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkSparseImageFormatFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkFenceCreateFlags(VkFenceCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkFenceCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkFenceCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkSemaphoreCreateFlags(VkSemaphoreCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkEventCreateFlags(VkEventCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkEventCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkEventCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkQueryPipelineStatisticFlags(VkQueryPipelineStatisticFlags obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkQueryPipelineStatisticFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkQueryPipelineStatisticFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkQueryPoolCreateFlags(VkQueryPoolCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkQueryResultFlags(VkQueryResultFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkQueryResultFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkQueryResultFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkBufferCreateFlags(VkBufferCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkBufferCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkBufferCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkBufferUsageFlags(VkBufferUsageFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkBufferUsageFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkBufferUsageFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkBufferViewCreateFlags(VkBufferViewCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkImageViewCreateFlags(VkImageViewCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkImageViewCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkImageViewCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkShaderModuleCreateFlags(VkShaderModuleCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPipelineCacheCreateFlags(VkPipelineCacheCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPipelineCacheCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkPipelineCacheCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkColorComponentFlags(VkColorComponentFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkColorComponentFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkColorComponentFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPipelineCreateFlags(VkPipelineCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPipelineCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkPipelineCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPipelineShaderStageCreateFlags(VkPipelineShaderStageCreateFlags obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPipelineShaderStageCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkPipelineShaderStageCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkCullModeFlags(VkCullModeFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkCullModeFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkCullModeFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPipelineVertexInputStateCreateFlags(VkPipelineVertexInputStateCreateFlags obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPipelineInputAssemblyStateCreateFlags(VkPipelineInputAssemblyStateCreateFlags obj, const std::string& str,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPipelineTessellationStateCreateFlags(VkPipelineTessellationStateCreateFlags obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPipelineViewportStateCreateFlags(VkPipelineViewportStateCreateFlags obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPipelineRasterizationStateCreateFlags(VkPipelineRasterizationStateCreateFlags obj, const std::string& str,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPipelineMultisampleStateCreateFlags(VkPipelineMultisampleStateCreateFlags obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPipelineDepthStencilStateCreateFlags(VkPipelineDepthStencilStateCreateFlags obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPipelineDepthStencilStateCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkPipelineDepthStencilStateCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPipelineColorBlendStateCreateFlags(VkPipelineColorBlendStateCreateFlags obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPipelineColorBlendStateCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkPipelineColorBlendStateCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPipelineDynamicStateCreateFlags(VkPipelineDynamicStateCreateFlags obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPipelineLayoutCreateFlags(VkPipelineLayoutCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPipelineLayoutCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkPipelineLayoutCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkShaderStageFlags(VkShaderStageFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkShaderStageFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkShaderStageFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkSamplerCreateFlags(VkSamplerCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkSamplerCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkSamplerCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkDescriptorPoolCreateFlags(VkDescriptorPoolCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkDescriptorPoolCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkDescriptorPoolCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkDescriptorPoolResetFlags(VkDescriptorPoolResetFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkDescriptorSetLayoutCreateFlags(VkDescriptorSetLayoutCreateFlags obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkDescriptorSetLayoutCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkDescriptorSetLayoutCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkAttachmentDescriptionFlags(VkAttachmentDescriptionFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkAttachmentDescriptionFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkAttachmentDescriptionFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkDependencyFlags(VkDependencyFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkDependencyFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkDependencyFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkFramebufferCreateFlags(VkFramebufferCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkFramebufferCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkFramebufferCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkRenderPassCreateFlags(VkRenderPassCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkRenderPassCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkRenderPassCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkSubpassDescriptionFlags(VkSubpassDescriptionFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkSubpassDescriptionFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkSubpassDescriptionFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkCommandPoolCreateFlags(VkCommandPoolCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkCommandPoolCreateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkCommandPoolCreateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkCommandPoolResetFlags(VkCommandPoolResetFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkCommandPoolResetFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkCommandPoolResetFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkCommandBufferUsageFlags(VkCommandBufferUsageFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkCommandBufferUsageFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkCommandBufferUsageFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkQueryControlFlags(VkQueryControlFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkQueryControlFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkQueryControlFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkCommandBufferResetFlags(VkCommandBufferResetFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkCommandBufferResetFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkCommandBufferResetFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkStencilFaceFlags(VkStencilFaceFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkStencilFaceFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkStencilFaceFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkExtent2D(VkExtent2D obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.width, "width", 1);

    print_uint32_t(obj.height, "height", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExtent2D(const VkExtent2D* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->width, "width", 1);

    print_uint32_t(obj->height, "height", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExtent3D(VkExtent3D obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.width, "width", 1);

    print_uint32_t(obj.height, "height", 1);

    print_uint32_t(obj.depth, "depth", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExtent3D(const VkExtent3D* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->width, "width", 1);

    print_uint32_t(obj->height, "height", 1);

    print_uint32_t(obj->depth, "depth", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkOffset2D(VkOffset2D obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_int32_t(obj.x, "x", 1);

    print_int32_t(obj.y, "y", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkOffset2D(const VkOffset2D* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_int32_t(obj->x, "x", 1);

    print_int32_t(obj->y, "y", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkOffset3D(VkOffset3D obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_int32_t(obj.x, "x", 1);

    print_int32_t(obj.y, "y", 1);

    print_int32_t(obj.z, "z", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkOffset3D(const VkOffset3D* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_int32_t(obj->x, "x", 1);

    print_int32_t(obj->y, "y", 1);

    print_int32_t(obj->z, "z", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRect2D(VkRect2D obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"offset\": " << std::endl;
    { print_VkOffset2D(obj.offset, "offset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent2D(obj.extent, "extent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRect2D(const VkRect2D* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"offset\": " << std::endl;
    { print_VkOffset2D(obj->offset, "offset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent2D(obj->extent, "extent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBaseInStructure(VkBaseInStructure obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBaseInStructure(const VkBaseInStructure* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBaseOutStructure(VkBaseOutStructure obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBaseOutStructure(const VkBaseOutStructure* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBufferMemoryBarrier(VkBufferMemoryBarrier obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccessFlags(obj.srcAccessMask, "srcAccessMask", 1);

    print_VkAccessFlags(obj.dstAccessMask, "dstAccessMask", 1);

    print_uint32_t(obj.srcQueueFamilyIndex, "srcQueueFamilyIndex", 1);

    print_uint32_t(obj.dstQueueFamilyIndex, "dstQueueFamilyIndex", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.offset, "offset", 1);

    print_VkDeviceSize(obj.size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferMemoryBarrier(const VkBufferMemoryBarrier* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccessFlags(obj->srcAccessMask, "srcAccessMask", 1);

    print_VkAccessFlags(obj->dstAccessMask, "dstAccessMask", 1);

    print_uint32_t(obj->srcQueueFamilyIndex, "srcQueueFamilyIndex", 1);

    print_uint32_t(obj->dstQueueFamilyIndex, "dstQueueFamilyIndex", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->offset, "offset", 1);

    print_VkDeviceSize(obj->size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDispatchIndirectCommand(VkDispatchIndirectCommand obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.x, "x", 1);

    print_uint32_t(obj.y, "y", 1);

    print_uint32_t(obj.z, "z", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDispatchIndirectCommand(const VkDispatchIndirectCommand* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->x, "x", 1);

    print_uint32_t(obj->y, "y", 1);

    print_uint32_t(obj->z, "z", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDrawIndexedIndirectCommand(VkDrawIndexedIndirectCommand obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.indexCount, "indexCount", 1);

    print_uint32_t(obj.instanceCount, "instanceCount", 1);

    print_uint32_t(obj.firstIndex, "firstIndex", 1);

    print_int32_t(obj.vertexOffset, "vertexOffset", 1);

    print_uint32_t(obj.firstInstance, "firstInstance", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDrawIndexedIndirectCommand(const VkDrawIndexedIndirectCommand* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->indexCount, "indexCount", 1);

    print_uint32_t(obj->instanceCount, "instanceCount", 1);

    print_uint32_t(obj->firstIndex, "firstIndex", 1);

    print_int32_t(obj->vertexOffset, "vertexOffset", 1);

    print_uint32_t(obj->firstInstance, "firstInstance", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDrawIndirectCommand(VkDrawIndirectCommand obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.vertexCount, "vertexCount", 1);

    print_uint32_t(obj.instanceCount, "instanceCount", 1);

    print_uint32_t(obj.firstVertex, "firstVertex", 1);

    print_uint32_t(obj.firstInstance, "firstInstance", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDrawIndirectCommand(const VkDrawIndirectCommand* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->vertexCount, "vertexCount", 1);

    print_uint32_t(obj->instanceCount, "instanceCount", 1);

    print_uint32_t(obj->firstVertex, "firstVertex", 1);

    print_uint32_t(obj->firstInstance, "firstInstance", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageSubresourceRange(VkImageSubresourceRange obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkImageAspectFlags(obj.aspectMask, "aspectMask", 1);

    print_uint32_t(obj.baseMipLevel, "baseMipLevel", 1);

    print_uint32_t(obj.levelCount, "levelCount", 1);

    print_uint32_t(obj.baseArrayLayer, "baseArrayLayer", 1);

    print_uint32_t(obj.layerCount, "layerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageSubresourceRange(const VkImageSubresourceRange* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkImageAspectFlags(obj->aspectMask, "aspectMask", 1);

    print_uint32_t(obj->baseMipLevel, "baseMipLevel", 1);

    print_uint32_t(obj->levelCount, "levelCount", 1);

    print_uint32_t(obj->baseArrayLayer, "baseArrayLayer", 1);

    print_uint32_t(obj->layerCount, "layerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageMemoryBarrier(VkImageMemoryBarrier obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccessFlags(obj.srcAccessMask, "srcAccessMask", 1);

    print_VkAccessFlags(obj.dstAccessMask, "dstAccessMask", 1);

    print_VkImageLayout(obj.oldLayout, "oldLayout", 1);

    print_VkImageLayout(obj.newLayout, "newLayout", 1);

    print_uint32_t(obj.srcQueueFamilyIndex, "srcQueueFamilyIndex", 1);

    print_uint32_t(obj.dstQueueFamilyIndex, "dstQueueFamilyIndex", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"subresourceRange\": " << std::endl;
    { print_VkImageSubresourceRange(obj.subresourceRange, "subresourceRange", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageMemoryBarrier(const VkImageMemoryBarrier* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccessFlags(obj->srcAccessMask, "srcAccessMask", 1);

    print_VkAccessFlags(obj->dstAccessMask, "dstAccessMask", 1);

    print_VkImageLayout(obj->oldLayout, "oldLayout", 1);

    print_VkImageLayout(obj->newLayout, "newLayout", 1);

    print_uint32_t(obj->srcQueueFamilyIndex, "srcQueueFamilyIndex", 1);

    print_uint32_t(obj->dstQueueFamilyIndex, "dstQueueFamilyIndex", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"subresourceRange\": " << std::endl;
    { print_VkImageSubresourceRange(obj->subresourceRange, "subresourceRange", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryBarrier(VkMemoryBarrier obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccessFlags(obj.srcAccessMask, "srcAccessMask", 1);

    print_VkAccessFlags(obj.dstAccessMask, "dstAccessMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryBarrier(const VkMemoryBarrier* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccessFlags(obj->srcAccessMask, "srcAccessMask", 1);

    print_VkAccessFlags(obj->dstAccessMask, "dstAccessMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineCacheHeaderVersionOne(VkPipelineCacheHeaderVersionOne obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.headerSize, "headerSize", 1);

    print_VkPipelineCacheHeaderVersion(obj.headerVersion, "headerVersion", 1);

    print_uint32_t(obj.vendorID, "vendorID", 1);

    print_uint32_t(obj.deviceID, "deviceID", 1);

    PRINT_SPACE
    _OUT << "\"pipelineCacheUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj.pipelineCacheUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineCacheHeaderVersionOne(const VkPipelineCacheHeaderVersionOne* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->headerSize, "headerSize", 1);

    print_VkPipelineCacheHeaderVersion(obj->headerVersion, "headerVersion", 1);

    print_uint32_t(obj->vendorID, "vendorID", 1);

    print_uint32_t(obj->deviceID, "deviceID", 1);

    PRINT_SPACE
    _OUT << "\"pipelineCacheUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj->pipelineCacheUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAllocationCallbacks(VkAllocationCallbacks obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: Ignoring void* data. **/

    /** Note: Ignoring function pointer (PFN_vkAllocationFunction). **/

    /** Note: Ignoring function pointer (PFN_vkReallocationFunction). **/

    /** Note: Ignoring function pointer (PFN_vkFreeFunction). **/

    /** Note: Ignoring function pointer (PFN_vkInternalAllocationNotification). **/

    /** Note: Ignoring function pointer (PFN_vkInternalFreeNotification). **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAllocationCallbacks(const VkAllocationCallbacks* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: Ignoring void* data. **/

    /** Note: Ignoring function pointer (PFN_vkAllocationFunction). **/

    /** Note: Ignoring function pointer (PFN_vkReallocationFunction). **/

    /** Note: Ignoring function pointer (PFN_vkFreeFunction). **/

    /** Note: Ignoring function pointer (PFN_vkInternalAllocationNotification). **/

    /** Note: Ignoring function pointer (PFN_vkInternalFreeNotification). **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkApplicationInfo(VkApplicationInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_char(obj.pApplicationName, "pApplicationName", 1);

    print_uint32_t(obj.applicationVersion, "applicationVersion", 1);

    print_char(obj.pEngineName, "pEngineName", 1);

    print_uint32_t(obj.engineVersion, "engineVersion", 1);

    print_uint32_t(obj.apiVersion, "apiVersion", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkApplicationInfo(const VkApplicationInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_char(obj->pApplicationName, "pApplicationName", 1);

    print_uint32_t(obj->applicationVersion, "applicationVersion", 1);

    print_char(obj->pEngineName, "pEngineName", 1);

    print_uint32_t(obj->engineVersion, "engineVersion", 1);

    print_uint32_t(obj->apiVersion, "apiVersion", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkFormatProperties(VkFormatProperties obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkFormatFeatureFlags(obj.linearTilingFeatures, "linearTilingFeatures", 1);

    print_VkFormatFeatureFlags(obj.optimalTilingFeatures, "optimalTilingFeatures", 1);

    print_VkFormatFeatureFlags(obj.bufferFeatures, "bufferFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkFormatProperties(const VkFormatProperties* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkFormatFeatureFlags(obj->linearTilingFeatures, "linearTilingFeatures", 1);

    print_VkFormatFeatureFlags(obj->optimalTilingFeatures, "optimalTilingFeatures", 1);

    print_VkFormatFeatureFlags(obj->bufferFeatures, "bufferFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageFormatProperties(VkImageFormatProperties obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"maxExtent\": " << std::endl;
    { print_VkExtent3D(obj.maxExtent, "maxExtent", 1); }

    print_uint32_t(obj.maxMipLevels, "maxMipLevels", 1);

    print_uint32_t(obj.maxArrayLayers, "maxArrayLayers", 1);

    print_VkSampleCountFlags(obj.sampleCounts, "sampleCounts", 1);

    print_VkDeviceSize(obj.maxResourceSize, "maxResourceSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageFormatProperties(const VkImageFormatProperties* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"maxExtent\": " << std::endl;
    { print_VkExtent3D(obj->maxExtent, "maxExtent", 1); }

    print_uint32_t(obj->maxMipLevels, "maxMipLevels", 1);

    print_uint32_t(obj->maxArrayLayers, "maxArrayLayers", 1);

    print_VkSampleCountFlags(obj->sampleCounts, "sampleCounts", 1);

    print_VkDeviceSize(obj->maxResourceSize, "maxResourceSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkInstanceCreateInfo(VkInstanceCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkInstanceCreateFlags(obj.flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"pApplicationInfo\": " << std::endl;
    if (obj.pApplicationInfo) {
        print_VkApplicationInfo(obj.pApplicationInfo, "pApplicationInfo", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.enabledLayerCount, "enabledLayerCount", 1);

    print_char(obj.ppEnabledLayerNames, "ppEnabledLayerNames", 1);

    print_uint32_t(obj.enabledExtensionCount, "enabledExtensionCount", 1);

    print_char(obj.ppEnabledExtensionNames, "ppEnabledExtensionNames", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkInstanceCreateInfo(const VkInstanceCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkInstanceCreateFlags(obj->flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"pApplicationInfo\": " << std::endl;
    if (obj->pApplicationInfo) {
        print_VkApplicationInfo(obj->pApplicationInfo, "pApplicationInfo", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->enabledLayerCount, "enabledLayerCount", 1);

    print_char(obj->ppEnabledLayerNames, "ppEnabledLayerNames", 1);

    print_uint32_t(obj->enabledExtensionCount, "enabledExtensionCount", 1);

    print_char(obj->ppEnabledExtensionNames, "ppEnabledExtensionNames", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryHeap(VkMemoryHeap obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceSize(obj.size, "size", 1);

    print_VkMemoryHeapFlags(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryHeap(const VkMemoryHeap* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceSize(obj->size, "size", 1);

    print_VkMemoryHeapFlags(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryType(VkMemoryType obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkMemoryPropertyFlags(obj.propertyFlags, "propertyFlags", 1);

    print_uint32_t(obj.heapIndex, "heapIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryType(const VkMemoryType* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkMemoryPropertyFlags(obj->propertyFlags, "propertyFlags", 1);

    print_uint32_t(obj->heapIndex, "heapIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFeatures(VkPhysicalDeviceFeatures obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkBool32(obj.robustBufferAccess, "robustBufferAccess", 1);

    print_VkBool32(obj.fullDrawIndexUint32, "fullDrawIndexUint32", 1);

    print_VkBool32(obj.imageCubeArray, "imageCubeArray", 1);

    print_VkBool32(obj.independentBlend, "independentBlend", 1);

    print_VkBool32(obj.geometryShader, "geometryShader", 1);

    print_VkBool32(obj.tessellationShader, "tessellationShader", 1);

    print_VkBool32(obj.sampleRateShading, "sampleRateShading", 1);

    print_VkBool32(obj.dualSrcBlend, "dualSrcBlend", 1);

    print_VkBool32(obj.logicOp, "logicOp", 1);

    print_VkBool32(obj.multiDrawIndirect, "multiDrawIndirect", 1);

    print_VkBool32(obj.drawIndirectFirstInstance, "drawIndirectFirstInstance", 1);

    print_VkBool32(obj.depthClamp, "depthClamp", 1);

    print_VkBool32(obj.depthBiasClamp, "depthBiasClamp", 1);

    print_VkBool32(obj.fillModeNonSolid, "fillModeNonSolid", 1);

    print_VkBool32(obj.depthBounds, "depthBounds", 1);

    print_VkBool32(obj.wideLines, "wideLines", 1);

    print_VkBool32(obj.largePoints, "largePoints", 1);

    print_VkBool32(obj.alphaToOne, "alphaToOne", 1);

    print_VkBool32(obj.multiViewport, "multiViewport", 1);

    print_VkBool32(obj.samplerAnisotropy, "samplerAnisotropy", 1);

    print_VkBool32(obj.textureCompressionETC2, "textureCompressionETC2", 1);

    print_VkBool32(obj.textureCompressionASTC_LDR, "textureCompressionASTC_LDR", 1);

    print_VkBool32(obj.textureCompressionBC, "textureCompressionBC", 1);

    print_VkBool32(obj.occlusionQueryPrecise, "occlusionQueryPrecise", 1);

    print_VkBool32(obj.pipelineStatisticsQuery, "pipelineStatisticsQuery", 1);

    print_VkBool32(obj.vertexPipelineStoresAndAtomics, "vertexPipelineStoresAndAtomics", 1);

    print_VkBool32(obj.fragmentStoresAndAtomics, "fragmentStoresAndAtomics", 1);

    print_VkBool32(obj.shaderTessellationAndGeometryPointSize, "shaderTessellationAndGeometryPointSize", 1);

    print_VkBool32(obj.shaderImageGatherExtended, "shaderImageGatherExtended", 1);

    print_VkBool32(obj.shaderStorageImageExtendedFormats, "shaderStorageImageExtendedFormats", 1);

    print_VkBool32(obj.shaderStorageImageMultisample, "shaderStorageImageMultisample", 1);

    print_VkBool32(obj.shaderStorageImageReadWithoutFormat, "shaderStorageImageReadWithoutFormat", 1);

    print_VkBool32(obj.shaderStorageImageWriteWithoutFormat, "shaderStorageImageWriteWithoutFormat", 1);

    print_VkBool32(obj.shaderUniformBufferArrayDynamicIndexing, "shaderUniformBufferArrayDynamicIndexing", 1);

    print_VkBool32(obj.shaderSampledImageArrayDynamicIndexing, "shaderSampledImageArrayDynamicIndexing", 1);

    print_VkBool32(obj.shaderStorageBufferArrayDynamicIndexing, "shaderStorageBufferArrayDynamicIndexing", 1);

    print_VkBool32(obj.shaderStorageImageArrayDynamicIndexing, "shaderStorageImageArrayDynamicIndexing", 1);

    print_VkBool32(obj.shaderClipDistance, "shaderClipDistance", 1);

    print_VkBool32(obj.shaderCullDistance, "shaderCullDistance", 1);

    print_VkBool32(obj.shaderFloat64, "shaderFloat64", 1);

    print_VkBool32(obj.shaderInt64, "shaderInt64", 1);

    print_VkBool32(obj.shaderInt16, "shaderInt16", 1);

    print_VkBool32(obj.shaderResourceResidency, "shaderResourceResidency", 1);

    print_VkBool32(obj.shaderResourceMinLod, "shaderResourceMinLod", 1);

    print_VkBool32(obj.sparseBinding, "sparseBinding", 1);

    print_VkBool32(obj.sparseResidencyBuffer, "sparseResidencyBuffer", 1);

    print_VkBool32(obj.sparseResidencyImage2D, "sparseResidencyImage2D", 1);

    print_VkBool32(obj.sparseResidencyImage3D, "sparseResidencyImage3D", 1);

    print_VkBool32(obj.sparseResidency2Samples, "sparseResidency2Samples", 1);

    print_VkBool32(obj.sparseResidency4Samples, "sparseResidency4Samples", 1);

    print_VkBool32(obj.sparseResidency8Samples, "sparseResidency8Samples", 1);

    print_VkBool32(obj.sparseResidency16Samples, "sparseResidency16Samples", 1);

    print_VkBool32(obj.sparseResidencyAliased, "sparseResidencyAliased", 1);

    print_VkBool32(obj.variableMultisampleRate, "variableMultisampleRate", 1);

    print_VkBool32(obj.inheritedQueries, "inheritedQueries", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFeatures(const VkPhysicalDeviceFeatures* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkBool32(obj->robustBufferAccess, "robustBufferAccess", 1);

    print_VkBool32(obj->fullDrawIndexUint32, "fullDrawIndexUint32", 1);

    print_VkBool32(obj->imageCubeArray, "imageCubeArray", 1);

    print_VkBool32(obj->independentBlend, "independentBlend", 1);

    print_VkBool32(obj->geometryShader, "geometryShader", 1);

    print_VkBool32(obj->tessellationShader, "tessellationShader", 1);

    print_VkBool32(obj->sampleRateShading, "sampleRateShading", 1);

    print_VkBool32(obj->dualSrcBlend, "dualSrcBlend", 1);

    print_VkBool32(obj->logicOp, "logicOp", 1);

    print_VkBool32(obj->multiDrawIndirect, "multiDrawIndirect", 1);

    print_VkBool32(obj->drawIndirectFirstInstance, "drawIndirectFirstInstance", 1);

    print_VkBool32(obj->depthClamp, "depthClamp", 1);

    print_VkBool32(obj->depthBiasClamp, "depthBiasClamp", 1);

    print_VkBool32(obj->fillModeNonSolid, "fillModeNonSolid", 1);

    print_VkBool32(obj->depthBounds, "depthBounds", 1);

    print_VkBool32(obj->wideLines, "wideLines", 1);

    print_VkBool32(obj->largePoints, "largePoints", 1);

    print_VkBool32(obj->alphaToOne, "alphaToOne", 1);

    print_VkBool32(obj->multiViewport, "multiViewport", 1);

    print_VkBool32(obj->samplerAnisotropy, "samplerAnisotropy", 1);

    print_VkBool32(obj->textureCompressionETC2, "textureCompressionETC2", 1);

    print_VkBool32(obj->textureCompressionASTC_LDR, "textureCompressionASTC_LDR", 1);

    print_VkBool32(obj->textureCompressionBC, "textureCompressionBC", 1);

    print_VkBool32(obj->occlusionQueryPrecise, "occlusionQueryPrecise", 1);

    print_VkBool32(obj->pipelineStatisticsQuery, "pipelineStatisticsQuery", 1);

    print_VkBool32(obj->vertexPipelineStoresAndAtomics, "vertexPipelineStoresAndAtomics", 1);

    print_VkBool32(obj->fragmentStoresAndAtomics, "fragmentStoresAndAtomics", 1);

    print_VkBool32(obj->shaderTessellationAndGeometryPointSize, "shaderTessellationAndGeometryPointSize", 1);

    print_VkBool32(obj->shaderImageGatherExtended, "shaderImageGatherExtended", 1);

    print_VkBool32(obj->shaderStorageImageExtendedFormats, "shaderStorageImageExtendedFormats", 1);

    print_VkBool32(obj->shaderStorageImageMultisample, "shaderStorageImageMultisample", 1);

    print_VkBool32(obj->shaderStorageImageReadWithoutFormat, "shaderStorageImageReadWithoutFormat", 1);

    print_VkBool32(obj->shaderStorageImageWriteWithoutFormat, "shaderStorageImageWriteWithoutFormat", 1);

    print_VkBool32(obj->shaderUniformBufferArrayDynamicIndexing, "shaderUniformBufferArrayDynamicIndexing", 1);

    print_VkBool32(obj->shaderSampledImageArrayDynamicIndexing, "shaderSampledImageArrayDynamicIndexing", 1);

    print_VkBool32(obj->shaderStorageBufferArrayDynamicIndexing, "shaderStorageBufferArrayDynamicIndexing", 1);

    print_VkBool32(obj->shaderStorageImageArrayDynamicIndexing, "shaderStorageImageArrayDynamicIndexing", 1);

    print_VkBool32(obj->shaderClipDistance, "shaderClipDistance", 1);

    print_VkBool32(obj->shaderCullDistance, "shaderCullDistance", 1);

    print_VkBool32(obj->shaderFloat64, "shaderFloat64", 1);

    print_VkBool32(obj->shaderInt64, "shaderInt64", 1);

    print_VkBool32(obj->shaderInt16, "shaderInt16", 1);

    print_VkBool32(obj->shaderResourceResidency, "shaderResourceResidency", 1);

    print_VkBool32(obj->shaderResourceMinLod, "shaderResourceMinLod", 1);

    print_VkBool32(obj->sparseBinding, "sparseBinding", 1);

    print_VkBool32(obj->sparseResidencyBuffer, "sparseResidencyBuffer", 1);

    print_VkBool32(obj->sparseResidencyImage2D, "sparseResidencyImage2D", 1);

    print_VkBool32(obj->sparseResidencyImage3D, "sparseResidencyImage3D", 1);

    print_VkBool32(obj->sparseResidency2Samples, "sparseResidency2Samples", 1);

    print_VkBool32(obj->sparseResidency4Samples, "sparseResidency4Samples", 1);

    print_VkBool32(obj->sparseResidency8Samples, "sparseResidency8Samples", 1);

    print_VkBool32(obj->sparseResidency16Samples, "sparseResidency16Samples", 1);

    print_VkBool32(obj->sparseResidencyAliased, "sparseResidencyAliased", 1);

    print_VkBool32(obj->variableMultisampleRate, "variableMultisampleRate", 1);

    print_VkBool32(obj->inheritedQueries, "inheritedQueries", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceLimits(VkPhysicalDeviceLimits obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.maxImageDimension1D, "maxImageDimension1D", 1);

    print_uint32_t(obj.maxImageDimension2D, "maxImageDimension2D", 1);

    print_uint32_t(obj.maxImageDimension3D, "maxImageDimension3D", 1);

    print_uint32_t(obj.maxImageDimensionCube, "maxImageDimensionCube", 1);

    print_uint32_t(obj.maxImageArrayLayers, "maxImageArrayLayers", 1);

    print_uint32_t(obj.maxTexelBufferElements, "maxTexelBufferElements", 1);

    print_uint32_t(obj.maxUniformBufferRange, "maxUniformBufferRange", 1);

    print_uint32_t(obj.maxStorageBufferRange, "maxStorageBufferRange", 1);

    print_uint32_t(obj.maxPushConstantsSize, "maxPushConstantsSize", 1);

    print_uint32_t(obj.maxMemoryAllocationCount, "maxMemoryAllocationCount", 1);

    print_uint32_t(obj.maxSamplerAllocationCount, "maxSamplerAllocationCount", 1);

    print_VkDeviceSize(obj.bufferImageGranularity, "bufferImageGranularity", 1);

    print_VkDeviceSize(obj.sparseAddressSpaceSize, "sparseAddressSpaceSize", 1);

    print_uint32_t(obj.maxBoundDescriptorSets, "maxBoundDescriptorSets", 1);

    print_uint32_t(obj.maxPerStageDescriptorSamplers, "maxPerStageDescriptorSamplers", 1);

    print_uint32_t(obj.maxPerStageDescriptorUniformBuffers, "maxPerStageDescriptorUniformBuffers", 1);

    print_uint32_t(obj.maxPerStageDescriptorStorageBuffers, "maxPerStageDescriptorStorageBuffers", 1);

    print_uint32_t(obj.maxPerStageDescriptorSampledImages, "maxPerStageDescriptorSampledImages", 1);

    print_uint32_t(obj.maxPerStageDescriptorStorageImages, "maxPerStageDescriptorStorageImages", 1);

    print_uint32_t(obj.maxPerStageDescriptorInputAttachments, "maxPerStageDescriptorInputAttachments", 1);

    print_uint32_t(obj.maxPerStageResources, "maxPerStageResources", 1);

    print_uint32_t(obj.maxDescriptorSetSamplers, "maxDescriptorSetSamplers", 1);

    print_uint32_t(obj.maxDescriptorSetUniformBuffers, "maxDescriptorSetUniformBuffers", 1);

    print_uint32_t(obj.maxDescriptorSetUniformBuffersDynamic, "maxDescriptorSetUniformBuffersDynamic", 1);

    print_uint32_t(obj.maxDescriptorSetStorageBuffers, "maxDescriptorSetStorageBuffers", 1);

    print_uint32_t(obj.maxDescriptorSetStorageBuffersDynamic, "maxDescriptorSetStorageBuffersDynamic", 1);

    print_uint32_t(obj.maxDescriptorSetSampledImages, "maxDescriptorSetSampledImages", 1);

    print_uint32_t(obj.maxDescriptorSetStorageImages, "maxDescriptorSetStorageImages", 1);

    print_uint32_t(obj.maxDescriptorSetInputAttachments, "maxDescriptorSetInputAttachments", 1);

    print_uint32_t(obj.maxVertexInputAttributes, "maxVertexInputAttributes", 1);

    print_uint32_t(obj.maxVertexInputBindings, "maxVertexInputBindings", 1);

    print_uint32_t(obj.maxVertexInputAttributeOffset, "maxVertexInputAttributeOffset", 1);

    print_uint32_t(obj.maxVertexInputBindingStride, "maxVertexInputBindingStride", 1);

    print_uint32_t(obj.maxVertexOutputComponents, "maxVertexOutputComponents", 1);

    print_uint32_t(obj.maxTessellationGenerationLevel, "maxTessellationGenerationLevel", 1);

    print_uint32_t(obj.maxTessellationPatchSize, "maxTessellationPatchSize", 1);

    print_uint32_t(obj.maxTessellationControlPerVertexInputComponents, "maxTessellationControlPerVertexInputComponents", 1);

    print_uint32_t(obj.maxTessellationControlPerVertexOutputComponents, "maxTessellationControlPerVertexOutputComponents", 1);

    print_uint32_t(obj.maxTessellationControlPerPatchOutputComponents, "maxTessellationControlPerPatchOutputComponents", 1);

    print_uint32_t(obj.maxTessellationControlTotalOutputComponents, "maxTessellationControlTotalOutputComponents", 1);

    print_uint32_t(obj.maxTessellationEvaluationInputComponents, "maxTessellationEvaluationInputComponents", 1);

    print_uint32_t(obj.maxTessellationEvaluationOutputComponents, "maxTessellationEvaluationOutputComponents", 1);

    print_uint32_t(obj.maxGeometryShaderInvocations, "maxGeometryShaderInvocations", 1);

    print_uint32_t(obj.maxGeometryInputComponents, "maxGeometryInputComponents", 1);

    print_uint32_t(obj.maxGeometryOutputComponents, "maxGeometryOutputComponents", 1);

    print_uint32_t(obj.maxGeometryOutputVertices, "maxGeometryOutputVertices", 1);

    print_uint32_t(obj.maxGeometryTotalOutputComponents, "maxGeometryTotalOutputComponents", 1);

    print_uint32_t(obj.maxFragmentInputComponents, "maxFragmentInputComponents", 1);

    print_uint32_t(obj.maxFragmentOutputAttachments, "maxFragmentOutputAttachments", 1);

    print_uint32_t(obj.maxFragmentDualSrcAttachments, "maxFragmentDualSrcAttachments", 1);

    print_uint32_t(obj.maxFragmentCombinedOutputResources, "maxFragmentCombinedOutputResources", 1);

    print_uint32_t(obj.maxComputeSharedMemorySize, "maxComputeSharedMemorySize", 1);

    PRINT_SPACE
    _OUT << "\"maxComputeWorkGroupCount\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj.maxComputeWorkGroupCount[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.maxComputeWorkGroupInvocations, "maxComputeWorkGroupInvocations", 1);

    PRINT_SPACE
    _OUT << "\"maxComputeWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj.maxComputeWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.subPixelPrecisionBits, "subPixelPrecisionBits", 1);

    print_uint32_t(obj.subTexelPrecisionBits, "subTexelPrecisionBits", 1);

    print_uint32_t(obj.mipmapPrecisionBits, "mipmapPrecisionBits", 1);

    print_uint32_t(obj.maxDrawIndexedIndexValue, "maxDrawIndexedIndexValue", 1);

    print_uint32_t(obj.maxDrawIndirectCount, "maxDrawIndirectCount", 1);

    print_float(obj.maxSamplerLodBias, "maxSamplerLodBias", 1);

    print_float(obj.maxSamplerAnisotropy, "maxSamplerAnisotropy", 1);

    print_uint32_t(obj.maxViewports, "maxViewports", 1);

    PRINT_SPACE
    _OUT << "\"maxViewportDimensions\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_uint32_t(obj.maxViewportDimensions[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"viewportBoundsRange\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_float(obj.viewportBoundsRange[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.viewportSubPixelBits, "viewportSubPixelBits", 1);

    print_size_t(obj.minMemoryMapAlignment, "minMemoryMapAlignment", 1);

    print_VkDeviceSize(obj.minTexelBufferOffsetAlignment, "minTexelBufferOffsetAlignment", 1);

    print_VkDeviceSize(obj.minUniformBufferOffsetAlignment, "minUniformBufferOffsetAlignment", 1);

    print_VkDeviceSize(obj.minStorageBufferOffsetAlignment, "minStorageBufferOffsetAlignment", 1);

    print_int32_t(obj.minTexelOffset, "minTexelOffset", 1);

    print_uint32_t(obj.maxTexelOffset, "maxTexelOffset", 1);

    print_int32_t(obj.minTexelGatherOffset, "minTexelGatherOffset", 1);

    print_uint32_t(obj.maxTexelGatherOffset, "maxTexelGatherOffset", 1);

    print_float(obj.minInterpolationOffset, "minInterpolationOffset", 1);

    print_float(obj.maxInterpolationOffset, "maxInterpolationOffset", 1);

    print_uint32_t(obj.subPixelInterpolationOffsetBits, "subPixelInterpolationOffsetBits", 1);

    print_uint32_t(obj.maxFramebufferWidth, "maxFramebufferWidth", 1);

    print_uint32_t(obj.maxFramebufferHeight, "maxFramebufferHeight", 1);

    print_uint32_t(obj.maxFramebufferLayers, "maxFramebufferLayers", 1);

    print_VkSampleCountFlags(obj.framebufferColorSampleCounts, "framebufferColorSampleCounts", 1);

    print_VkSampleCountFlags(obj.framebufferDepthSampleCounts, "framebufferDepthSampleCounts", 1);

    print_VkSampleCountFlags(obj.framebufferStencilSampleCounts, "framebufferStencilSampleCounts", 1);

    print_VkSampleCountFlags(obj.framebufferNoAttachmentsSampleCounts, "framebufferNoAttachmentsSampleCounts", 1);

    print_uint32_t(obj.maxColorAttachments, "maxColorAttachments", 1);

    print_VkSampleCountFlags(obj.sampledImageColorSampleCounts, "sampledImageColorSampleCounts", 1);

    print_VkSampleCountFlags(obj.sampledImageIntegerSampleCounts, "sampledImageIntegerSampleCounts", 1);

    print_VkSampleCountFlags(obj.sampledImageDepthSampleCounts, "sampledImageDepthSampleCounts", 1);

    print_VkSampleCountFlags(obj.sampledImageStencilSampleCounts, "sampledImageStencilSampleCounts", 1);

    print_VkSampleCountFlags(obj.storageImageSampleCounts, "storageImageSampleCounts", 1);

    print_uint32_t(obj.maxSampleMaskWords, "maxSampleMaskWords", 1);

    print_VkBool32(obj.timestampComputeAndGraphics, "timestampComputeAndGraphics", 1);

    print_float(obj.timestampPeriod, "timestampPeriod", 1);

    print_uint32_t(obj.maxClipDistances, "maxClipDistances", 1);

    print_uint32_t(obj.maxCullDistances, "maxCullDistances", 1);

    print_uint32_t(obj.maxCombinedClipAndCullDistances, "maxCombinedClipAndCullDistances", 1);

    print_uint32_t(obj.discreteQueuePriorities, "discreteQueuePriorities", 1);

    PRINT_SPACE
    _OUT << "\"pointSizeRange\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_float(obj.pointSizeRange[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"lineWidthRange\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_float(obj.lineWidthRange[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_float(obj.pointSizeGranularity, "pointSizeGranularity", 1);

    print_float(obj.lineWidthGranularity, "lineWidthGranularity", 1);

    print_VkBool32(obj.strictLines, "strictLines", 1);

    print_VkBool32(obj.standardSampleLocations, "standardSampleLocations", 1);

    print_VkDeviceSize(obj.optimalBufferCopyOffsetAlignment, "optimalBufferCopyOffsetAlignment", 1);

    print_VkDeviceSize(obj.optimalBufferCopyRowPitchAlignment, "optimalBufferCopyRowPitchAlignment", 1);

    print_VkDeviceSize(obj.nonCoherentAtomSize, "nonCoherentAtomSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceLimits(const VkPhysicalDeviceLimits* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->maxImageDimension1D, "maxImageDimension1D", 1);

    print_uint32_t(obj->maxImageDimension2D, "maxImageDimension2D", 1);

    print_uint32_t(obj->maxImageDimension3D, "maxImageDimension3D", 1);

    print_uint32_t(obj->maxImageDimensionCube, "maxImageDimensionCube", 1);

    print_uint32_t(obj->maxImageArrayLayers, "maxImageArrayLayers", 1);

    print_uint32_t(obj->maxTexelBufferElements, "maxTexelBufferElements", 1);

    print_uint32_t(obj->maxUniformBufferRange, "maxUniformBufferRange", 1);

    print_uint32_t(obj->maxStorageBufferRange, "maxStorageBufferRange", 1);

    print_uint32_t(obj->maxPushConstantsSize, "maxPushConstantsSize", 1);

    print_uint32_t(obj->maxMemoryAllocationCount, "maxMemoryAllocationCount", 1);

    print_uint32_t(obj->maxSamplerAllocationCount, "maxSamplerAllocationCount", 1);

    print_VkDeviceSize(obj->bufferImageGranularity, "bufferImageGranularity", 1);

    print_VkDeviceSize(obj->sparseAddressSpaceSize, "sparseAddressSpaceSize", 1);

    print_uint32_t(obj->maxBoundDescriptorSets, "maxBoundDescriptorSets", 1);

    print_uint32_t(obj->maxPerStageDescriptorSamplers, "maxPerStageDescriptorSamplers", 1);

    print_uint32_t(obj->maxPerStageDescriptorUniformBuffers, "maxPerStageDescriptorUniformBuffers", 1);

    print_uint32_t(obj->maxPerStageDescriptorStorageBuffers, "maxPerStageDescriptorStorageBuffers", 1);

    print_uint32_t(obj->maxPerStageDescriptorSampledImages, "maxPerStageDescriptorSampledImages", 1);

    print_uint32_t(obj->maxPerStageDescriptorStorageImages, "maxPerStageDescriptorStorageImages", 1);

    print_uint32_t(obj->maxPerStageDescriptorInputAttachments, "maxPerStageDescriptorInputAttachments", 1);

    print_uint32_t(obj->maxPerStageResources, "maxPerStageResources", 1);

    print_uint32_t(obj->maxDescriptorSetSamplers, "maxDescriptorSetSamplers", 1);

    print_uint32_t(obj->maxDescriptorSetUniformBuffers, "maxDescriptorSetUniformBuffers", 1);

    print_uint32_t(obj->maxDescriptorSetUniformBuffersDynamic, "maxDescriptorSetUniformBuffersDynamic", 1);

    print_uint32_t(obj->maxDescriptorSetStorageBuffers, "maxDescriptorSetStorageBuffers", 1);

    print_uint32_t(obj->maxDescriptorSetStorageBuffersDynamic, "maxDescriptorSetStorageBuffersDynamic", 1);

    print_uint32_t(obj->maxDescriptorSetSampledImages, "maxDescriptorSetSampledImages", 1);

    print_uint32_t(obj->maxDescriptorSetStorageImages, "maxDescriptorSetStorageImages", 1);

    print_uint32_t(obj->maxDescriptorSetInputAttachments, "maxDescriptorSetInputAttachments", 1);

    print_uint32_t(obj->maxVertexInputAttributes, "maxVertexInputAttributes", 1);

    print_uint32_t(obj->maxVertexInputBindings, "maxVertexInputBindings", 1);

    print_uint32_t(obj->maxVertexInputAttributeOffset, "maxVertexInputAttributeOffset", 1);

    print_uint32_t(obj->maxVertexInputBindingStride, "maxVertexInputBindingStride", 1);

    print_uint32_t(obj->maxVertexOutputComponents, "maxVertexOutputComponents", 1);

    print_uint32_t(obj->maxTessellationGenerationLevel, "maxTessellationGenerationLevel", 1);

    print_uint32_t(obj->maxTessellationPatchSize, "maxTessellationPatchSize", 1);

    print_uint32_t(obj->maxTessellationControlPerVertexInputComponents, "maxTessellationControlPerVertexInputComponents", 1);

    print_uint32_t(obj->maxTessellationControlPerVertexOutputComponents, "maxTessellationControlPerVertexOutputComponents", 1);

    print_uint32_t(obj->maxTessellationControlPerPatchOutputComponents, "maxTessellationControlPerPatchOutputComponents", 1);

    print_uint32_t(obj->maxTessellationControlTotalOutputComponents, "maxTessellationControlTotalOutputComponents", 1);

    print_uint32_t(obj->maxTessellationEvaluationInputComponents, "maxTessellationEvaluationInputComponents", 1);

    print_uint32_t(obj->maxTessellationEvaluationOutputComponents, "maxTessellationEvaluationOutputComponents", 1);

    print_uint32_t(obj->maxGeometryShaderInvocations, "maxGeometryShaderInvocations", 1);

    print_uint32_t(obj->maxGeometryInputComponents, "maxGeometryInputComponents", 1);

    print_uint32_t(obj->maxGeometryOutputComponents, "maxGeometryOutputComponents", 1);

    print_uint32_t(obj->maxGeometryOutputVertices, "maxGeometryOutputVertices", 1);

    print_uint32_t(obj->maxGeometryTotalOutputComponents, "maxGeometryTotalOutputComponents", 1);

    print_uint32_t(obj->maxFragmentInputComponents, "maxFragmentInputComponents", 1);

    print_uint32_t(obj->maxFragmentOutputAttachments, "maxFragmentOutputAttachments", 1);

    print_uint32_t(obj->maxFragmentDualSrcAttachments, "maxFragmentDualSrcAttachments", 1);

    print_uint32_t(obj->maxFragmentCombinedOutputResources, "maxFragmentCombinedOutputResources", 1);

    print_uint32_t(obj->maxComputeSharedMemorySize, "maxComputeSharedMemorySize", 1);

    PRINT_SPACE
    _OUT << "\"maxComputeWorkGroupCount\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj->maxComputeWorkGroupCount[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->maxComputeWorkGroupInvocations, "maxComputeWorkGroupInvocations", 1);

    PRINT_SPACE
    _OUT << "\"maxComputeWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj->maxComputeWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->subPixelPrecisionBits, "subPixelPrecisionBits", 1);

    print_uint32_t(obj->subTexelPrecisionBits, "subTexelPrecisionBits", 1);

    print_uint32_t(obj->mipmapPrecisionBits, "mipmapPrecisionBits", 1);

    print_uint32_t(obj->maxDrawIndexedIndexValue, "maxDrawIndexedIndexValue", 1);

    print_uint32_t(obj->maxDrawIndirectCount, "maxDrawIndirectCount", 1);

    print_float(obj->maxSamplerLodBias, "maxSamplerLodBias", 1);

    print_float(obj->maxSamplerAnisotropy, "maxSamplerAnisotropy", 1);

    print_uint32_t(obj->maxViewports, "maxViewports", 1);

    PRINT_SPACE
    _OUT << "\"maxViewportDimensions\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_uint32_t(obj->maxViewportDimensions[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"viewportBoundsRange\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_float(obj->viewportBoundsRange[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->viewportSubPixelBits, "viewportSubPixelBits", 1);

    print_size_t(obj->minMemoryMapAlignment, "minMemoryMapAlignment", 1);

    print_VkDeviceSize(obj->minTexelBufferOffsetAlignment, "minTexelBufferOffsetAlignment", 1);

    print_VkDeviceSize(obj->minUniformBufferOffsetAlignment, "minUniformBufferOffsetAlignment", 1);

    print_VkDeviceSize(obj->minStorageBufferOffsetAlignment, "minStorageBufferOffsetAlignment", 1);

    print_int32_t(obj->minTexelOffset, "minTexelOffset", 1);

    print_uint32_t(obj->maxTexelOffset, "maxTexelOffset", 1);

    print_int32_t(obj->minTexelGatherOffset, "minTexelGatherOffset", 1);

    print_uint32_t(obj->maxTexelGatherOffset, "maxTexelGatherOffset", 1);

    print_float(obj->minInterpolationOffset, "minInterpolationOffset", 1);

    print_float(obj->maxInterpolationOffset, "maxInterpolationOffset", 1);

    print_uint32_t(obj->subPixelInterpolationOffsetBits, "subPixelInterpolationOffsetBits", 1);

    print_uint32_t(obj->maxFramebufferWidth, "maxFramebufferWidth", 1);

    print_uint32_t(obj->maxFramebufferHeight, "maxFramebufferHeight", 1);

    print_uint32_t(obj->maxFramebufferLayers, "maxFramebufferLayers", 1);

    print_VkSampleCountFlags(obj->framebufferColorSampleCounts, "framebufferColorSampleCounts", 1);

    print_VkSampleCountFlags(obj->framebufferDepthSampleCounts, "framebufferDepthSampleCounts", 1);

    print_VkSampleCountFlags(obj->framebufferStencilSampleCounts, "framebufferStencilSampleCounts", 1);

    print_VkSampleCountFlags(obj->framebufferNoAttachmentsSampleCounts, "framebufferNoAttachmentsSampleCounts", 1);

    print_uint32_t(obj->maxColorAttachments, "maxColorAttachments", 1);

    print_VkSampleCountFlags(obj->sampledImageColorSampleCounts, "sampledImageColorSampleCounts", 1);

    print_VkSampleCountFlags(obj->sampledImageIntegerSampleCounts, "sampledImageIntegerSampleCounts", 1);

    print_VkSampleCountFlags(obj->sampledImageDepthSampleCounts, "sampledImageDepthSampleCounts", 1);

    print_VkSampleCountFlags(obj->sampledImageStencilSampleCounts, "sampledImageStencilSampleCounts", 1);

    print_VkSampleCountFlags(obj->storageImageSampleCounts, "storageImageSampleCounts", 1);

    print_uint32_t(obj->maxSampleMaskWords, "maxSampleMaskWords", 1);

    print_VkBool32(obj->timestampComputeAndGraphics, "timestampComputeAndGraphics", 1);

    print_float(obj->timestampPeriod, "timestampPeriod", 1);

    print_uint32_t(obj->maxClipDistances, "maxClipDistances", 1);

    print_uint32_t(obj->maxCullDistances, "maxCullDistances", 1);

    print_uint32_t(obj->maxCombinedClipAndCullDistances, "maxCombinedClipAndCullDistances", 1);

    print_uint32_t(obj->discreteQueuePriorities, "discreteQueuePriorities", 1);

    PRINT_SPACE
    _OUT << "\"pointSizeRange\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_float(obj->pointSizeRange[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"lineWidthRange\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_float(obj->lineWidthRange[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_float(obj->pointSizeGranularity, "pointSizeGranularity", 1);

    print_float(obj->lineWidthGranularity, "lineWidthGranularity", 1);

    print_VkBool32(obj->strictLines, "strictLines", 1);

    print_VkBool32(obj->standardSampleLocations, "standardSampleLocations", 1);

    print_VkDeviceSize(obj->optimalBufferCopyOffsetAlignment, "optimalBufferCopyOffsetAlignment", 1);

    print_VkDeviceSize(obj->optimalBufferCopyRowPitchAlignment, "optimalBufferCopyRowPitchAlignment", 1);

    print_VkDeviceSize(obj->nonCoherentAtomSize, "nonCoherentAtomSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMemoryProperties(VkPhysicalDeviceMemoryProperties obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.memoryTypeCount, "memoryTypeCount", 1);

    PRINT_SPACE
    _OUT << "\"memoryTypes\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_MEMORY_TYPES; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_MEMORY_TYPES;
        print_VkMemoryType(obj.memoryTypes[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.memoryHeapCount, "memoryHeapCount", 1);

    PRINT_SPACE
    _OUT << "\"memoryHeaps\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_MEMORY_HEAPS; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_MEMORY_HEAPS;
        print_VkMemoryHeap(obj.memoryHeaps[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMemoryProperties(const VkPhysicalDeviceMemoryProperties* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->memoryTypeCount, "memoryTypeCount", 1);

    PRINT_SPACE
    _OUT << "\"memoryTypes\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_MEMORY_TYPES; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_MEMORY_TYPES;
        print_VkMemoryType(obj->memoryTypes[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->memoryHeapCount, "memoryHeapCount", 1);

    PRINT_SPACE
    _OUT << "\"memoryHeaps\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_MEMORY_HEAPS; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_MEMORY_HEAPS;
        print_VkMemoryHeap(obj->memoryHeaps[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceSparseProperties(VkPhysicalDeviceSparseProperties obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkBool32(obj.residencyStandard2DBlockShape, "residencyStandard2DBlockShape", 1);

    print_VkBool32(obj.residencyStandard2DMultisampleBlockShape, "residencyStandard2DMultisampleBlockShape", 1);

    print_VkBool32(obj.residencyStandard3DBlockShape, "residencyStandard3DBlockShape", 1);

    print_VkBool32(obj.residencyAlignedMipSize, "residencyAlignedMipSize", 1);

    print_VkBool32(obj.residencyNonResidentStrict, "residencyNonResidentStrict", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSparseProperties(const VkPhysicalDeviceSparseProperties* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkBool32(obj->residencyStandard2DBlockShape, "residencyStandard2DBlockShape", 1);

    print_VkBool32(obj->residencyStandard2DMultisampleBlockShape, "residencyStandard2DMultisampleBlockShape", 1);

    print_VkBool32(obj->residencyStandard3DBlockShape, "residencyStandard3DBlockShape", 1);

    print_VkBool32(obj->residencyAlignedMipSize, "residencyAlignedMipSize", 1);

    print_VkBool32(obj->residencyNonResidentStrict, "residencyNonResidentStrict", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceProperties(VkPhysicalDeviceProperties obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.apiVersion, "apiVersion", 1);

    print_uint32_t(obj.driverVersion, "driverVersion", 1);

    print_uint32_t(obj.vendorID, "vendorID", 1);

    print_uint32_t(obj.deviceID, "deviceID", 1);

    print_VkPhysicalDeviceType(obj.deviceType, "deviceType", 1);

    PRINT_SPACE
    _OUT << "\"deviceName\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_PHYSICAL_DEVICE_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_PHYSICAL_DEVICE_NAME_SIZE;
        print_char(obj.deviceName[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"pipelineCacheUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj.pipelineCacheUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"limits\": " << std::endl;
    { print_VkPhysicalDeviceLimits(obj.limits, "limits", 1); }

    PRINT_SPACE
    _OUT << "\"sparseProperties\": " << std::endl;
    { print_VkPhysicalDeviceSparseProperties(obj.sparseProperties, "sparseProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceProperties(const VkPhysicalDeviceProperties* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->apiVersion, "apiVersion", 1);

    print_uint32_t(obj->driverVersion, "driverVersion", 1);

    print_uint32_t(obj->vendorID, "vendorID", 1);

    print_uint32_t(obj->deviceID, "deviceID", 1);

    print_VkPhysicalDeviceType(obj->deviceType, "deviceType", 1);

    PRINT_SPACE
    _OUT << "\"deviceName\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_PHYSICAL_DEVICE_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_PHYSICAL_DEVICE_NAME_SIZE;
        print_char(obj->deviceName[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"pipelineCacheUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj->pipelineCacheUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"limits\": " << std::endl;
    { print_VkPhysicalDeviceLimits(obj->limits, "limits", 1); }

    PRINT_SPACE
    _OUT << "\"sparseProperties\": " << std::endl;
    { print_VkPhysicalDeviceSparseProperties(obj->sparseProperties, "sparseProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkQueueFamilyProperties(VkQueueFamilyProperties obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkQueueFlags(obj.queueFlags, "queueFlags", 1);

    print_uint32_t(obj.queueCount, "queueCount", 1);

    print_uint32_t(obj.timestampValidBits, "timestampValidBits", 1);

    PRINT_SPACE
    _OUT << "\"minImageTransferGranularity\": " << std::endl;
    { print_VkExtent3D(obj.minImageTransferGranularity, "minImageTransferGranularity", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkQueueFamilyProperties(const VkQueueFamilyProperties* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkQueueFlags(obj->queueFlags, "queueFlags", 1);

    print_uint32_t(obj->queueCount, "queueCount", 1);

    print_uint32_t(obj->timestampValidBits, "timestampValidBits", 1);

    PRINT_SPACE
    _OUT << "\"minImageTransferGranularity\": " << std::endl;
    { print_VkExtent3D(obj->minImageTransferGranularity, "minImageTransferGranularity", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceQueueCreateInfo(VkDeviceQueueCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceQueueCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.queueFamilyIndex, "queueFamilyIndex", 1);

    print_uint32_t(obj.queueCount, "queueCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueuePriorities\":" << std::endl;
    PRINT_SPACE
    if (obj.pQueuePriorities) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.queueCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.queueCount;
            print_float(obj.pQueuePriorities[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceQueueCreateInfo(const VkDeviceQueueCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceQueueCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->queueFamilyIndex, "queueFamilyIndex", 1);

    print_uint32_t(obj->queueCount, "queueCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueuePriorities\":" << std::endl;
    PRINT_SPACE
    if (obj->pQueuePriorities) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->queueCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->queueCount;
            print_float(obj->pQueuePriorities[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceCreateInfo(VkDeviceCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.queueCreateInfoCount, "queueCreateInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueueCreateInfos\": " << std::endl;
    if (obj.pQueueCreateInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.queueCreateInfoCount; i++) {
            if (i + 1 == obj.queueCreateInfoCount)
                print_VkDeviceQueueCreateInfo(obj.pQueueCreateInfos[i], "pQueueCreateInfos", 0);
            else
                print_VkDeviceQueueCreateInfo(obj.pQueueCreateInfos[i], "pQueueCreateInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.enabledLayerCount, "enabledLayerCount", 1);

    print_char(obj.ppEnabledLayerNames, "ppEnabledLayerNames", 1);

    print_uint32_t(obj.enabledExtensionCount, "enabledExtensionCount", 1);

    print_char(obj.ppEnabledExtensionNames, "ppEnabledExtensionNames", 1);

    PRINT_SPACE
    _OUT << "\"pEnabledFeatures\": " << std::endl;
    if (obj.pEnabledFeatures) {
        print_VkPhysicalDeviceFeatures(obj.pEnabledFeatures, "pEnabledFeatures", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceCreateInfo(const VkDeviceCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->queueCreateInfoCount, "queueCreateInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueueCreateInfos\": " << std::endl;
    if (obj->pQueueCreateInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->queueCreateInfoCount; i++) {
            if (i + 1 == obj->queueCreateInfoCount)
                print_VkDeviceQueueCreateInfo(obj->pQueueCreateInfos[i], "pQueueCreateInfos", 0);
            else
                print_VkDeviceQueueCreateInfo(obj->pQueueCreateInfos[i], "pQueueCreateInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->enabledLayerCount, "enabledLayerCount", 1);

    print_char(obj->ppEnabledLayerNames, "ppEnabledLayerNames", 1);

    print_uint32_t(obj->enabledExtensionCount, "enabledExtensionCount", 1);

    print_char(obj->ppEnabledExtensionNames, "ppEnabledExtensionNames", 1);

    PRINT_SPACE
    _OUT << "\"pEnabledFeatures\": " << std::endl;
    if (obj->pEnabledFeatures) {
        print_VkPhysicalDeviceFeatures(obj->pEnabledFeatures, "pEnabledFeatures", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExtensionProperties(VkExtensionProperties obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"extensionName\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_EXTENSION_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_EXTENSION_NAME_SIZE;
        print_char(obj.extensionName[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.specVersion, "specVersion", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExtensionProperties(const VkExtensionProperties* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"extensionName\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_EXTENSION_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_EXTENSION_NAME_SIZE;
        print_char(obj->extensionName[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->specVersion, "specVersion", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkLayerProperties(VkLayerProperties obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"layerName\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_EXTENSION_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_EXTENSION_NAME_SIZE;
        print_char(obj.layerName[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.specVersion, "specVersion", 1);

    print_uint32_t(obj.implementationVersion, "implementationVersion", 1);

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkLayerProperties(const VkLayerProperties* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"layerName\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_EXTENSION_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_EXTENSION_NAME_SIZE;
        print_char(obj->layerName[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->specVersion, "specVersion", 1);

    print_uint32_t(obj->implementationVersion, "implementationVersion", 1);

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubmitInfo(VkSubmitInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.waitSemaphoreCount, "waitSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pWaitSemaphores\":" << std::endl;
    PRINT_SPACE
    if (obj.pWaitSemaphores) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.waitSemaphoreCount; i++) {
            std::stringstream tmp;
            tmp << "pWaitSemaphores"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.waitSemaphoreCount;
            print_VkSemaphore(obj.pWaitSemaphores[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pWaitDstStageMask\":" << std::endl;
    PRINT_SPACE
    if (obj.pWaitDstStageMask) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.waitSemaphoreCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.waitSemaphoreCount;
            print_VkPipelineStageFlags(obj.pWaitDstStageMask[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.commandBufferCount, "commandBufferCount", 1);

    PRINT_SPACE
    _OUT << "\"pCommandBuffers\":" << std::endl;
    PRINT_SPACE
    if (obj.pCommandBuffers) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.commandBufferCount; i++) {
            std::stringstream tmp;
            tmp << "pCommandBuffers"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.commandBufferCount;
            print_VkCommandBuffer(obj.pCommandBuffers[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.signalSemaphoreCount, "signalSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pSignalSemaphores\":" << std::endl;
    PRINT_SPACE
    if (obj.pSignalSemaphores) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.signalSemaphoreCount; i++) {
            std::stringstream tmp;
            tmp << "pSignalSemaphores"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.signalSemaphoreCount;
            print_VkSemaphore(obj.pSignalSemaphores[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubmitInfo(const VkSubmitInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->waitSemaphoreCount, "waitSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pWaitSemaphores\":" << std::endl;
    PRINT_SPACE
    if (obj->pWaitSemaphores) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->waitSemaphoreCount; i++) {
            std::stringstream tmp;
            tmp << "pWaitSemaphores"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->waitSemaphoreCount;
            print_VkSemaphore(obj->pWaitSemaphores[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pWaitDstStageMask\":" << std::endl;
    PRINT_SPACE
    if (obj->pWaitDstStageMask) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->waitSemaphoreCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->waitSemaphoreCount;
            print_VkPipelineStageFlags(obj->pWaitDstStageMask[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->commandBufferCount, "commandBufferCount", 1);

    PRINT_SPACE
    _OUT << "\"pCommandBuffers\":" << std::endl;
    PRINT_SPACE
    if (obj->pCommandBuffers) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->commandBufferCount; i++) {
            std::stringstream tmp;
            tmp << "pCommandBuffers"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->commandBufferCount;
            print_VkCommandBuffer(obj->pCommandBuffers[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->signalSemaphoreCount, "signalSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pSignalSemaphores\":" << std::endl;
    PRINT_SPACE
    if (obj->pSignalSemaphores) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->signalSemaphoreCount; i++) {
            std::stringstream tmp;
            tmp << "pSignalSemaphores"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->signalSemaphoreCount;
            print_VkSemaphore(obj->pSignalSemaphores[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMappedMemoryRange(VkMappedMemoryRange obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.offset, "offset", 1);

    print_VkDeviceSize(obj.size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMappedMemoryRange(const VkMappedMemoryRange* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->offset, "offset", 1);

    print_VkDeviceSize(obj->size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryAllocateInfo(VkMemoryAllocateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj.allocationSize, "allocationSize", 1);

    print_uint32_t(obj.memoryTypeIndex, "memoryTypeIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryAllocateInfo(const VkMemoryAllocateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj->allocationSize, "allocationSize", 1);

    print_uint32_t(obj->memoryTypeIndex, "memoryTypeIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryRequirements(VkMemoryRequirements obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceSize(obj.size, "size", 1);

    print_VkDeviceSize(obj.alignment, "alignment", 1);

    print_uint32_t(obj.memoryTypeBits, "memoryTypeBits", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryRequirements(const VkMemoryRequirements* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceSize(obj->size, "size", 1);

    print_VkDeviceSize(obj->alignment, "alignment", 1);

    print_uint32_t(obj->memoryTypeBits, "memoryTypeBits", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSparseMemoryBind(VkSparseMemoryBind obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceSize(obj.resourceOffset, "resourceOffset", 1);

    print_VkDeviceSize(obj.size, "size", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.memoryOffset, "memoryOffset", 1);

    print_VkSparseMemoryBindFlags(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSparseMemoryBind(const VkSparseMemoryBind* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceSize(obj->resourceOffset, "resourceOffset", 1);

    print_VkDeviceSize(obj->size, "size", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->memoryOffset, "memoryOffset", 1);

    print_VkSparseMemoryBindFlags(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSparseBufferMemoryBindInfo(VkSparseBufferMemoryBindInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.bindCount, "bindCount", 1);

    PRINT_SPACE
    _OUT << "\"pBinds\": " << std::endl;
    if (obj.pBinds) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.bindCount; i++) {
            if (i + 1 == obj.bindCount)
                print_VkSparseMemoryBind(obj.pBinds[i], "pBinds", 0);
            else
                print_VkSparseMemoryBind(obj.pBinds[i], "pBinds", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSparseBufferMemoryBindInfo(const VkSparseBufferMemoryBindInfo* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->bindCount, "bindCount", 1);

    PRINT_SPACE
    _OUT << "\"pBinds\": " << std::endl;
    if (obj->pBinds) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->bindCount; i++) {
            if (i + 1 == obj->bindCount)
                print_VkSparseMemoryBind(obj->pBinds[i], "pBinds", 0);
            else
                print_VkSparseMemoryBind(obj->pBinds[i], "pBinds", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSparseImageOpaqueMemoryBindInfo(VkSparseImageOpaqueMemoryBindInfo obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.bindCount, "bindCount", 1);

    PRINT_SPACE
    _OUT << "\"pBinds\": " << std::endl;
    if (obj.pBinds) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.bindCount; i++) {
            if (i + 1 == obj.bindCount)
                print_VkSparseMemoryBind(obj.pBinds[i], "pBinds", 0);
            else
                print_VkSparseMemoryBind(obj.pBinds[i], "pBinds", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSparseImageOpaqueMemoryBindInfo(const VkSparseImageOpaqueMemoryBindInfo* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->bindCount, "bindCount", 1);

    PRINT_SPACE
    _OUT << "\"pBinds\": " << std::endl;
    if (obj->pBinds) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->bindCount; i++) {
            if (i + 1 == obj->bindCount)
                print_VkSparseMemoryBind(obj->pBinds[i], "pBinds", 0);
            else
                print_VkSparseMemoryBind(obj->pBinds[i], "pBinds", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageSubresource(VkImageSubresource obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkImageAspectFlags(obj.aspectMask, "aspectMask", 1);

    print_uint32_t(obj.mipLevel, "mipLevel", 1);

    print_uint32_t(obj.arrayLayer, "arrayLayer", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageSubresource(const VkImageSubresource* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkImageAspectFlags(obj->aspectMask, "aspectMask", 1);

    print_uint32_t(obj->mipLevel, "mipLevel", 1);

    print_uint32_t(obj->arrayLayer, "arrayLayer", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSparseImageMemoryBind(VkSparseImageMemoryBind obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"subresource\": " << std::endl;
    { print_VkImageSubresource(obj.subresource, "subresource", 1); }

    PRINT_SPACE
    _OUT << "\"offset\": " << std::endl;
    { print_VkOffset3D(obj.offset, "offset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent3D(obj.extent, "extent", 1); }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.memoryOffset, "memoryOffset", 1);

    print_VkSparseMemoryBindFlags(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSparseImageMemoryBind(const VkSparseImageMemoryBind* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"subresource\": " << std::endl;
    { print_VkImageSubresource(obj->subresource, "subresource", 1); }

    PRINT_SPACE
    _OUT << "\"offset\": " << std::endl;
    { print_VkOffset3D(obj->offset, "offset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent3D(obj->extent, "extent", 1); }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->memoryOffset, "memoryOffset", 1);

    print_VkSparseMemoryBindFlags(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSparseImageMemoryBindInfo(VkSparseImageMemoryBindInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.bindCount, "bindCount", 1);

    PRINT_SPACE
    _OUT << "\"pBinds\": " << std::endl;
    if (obj.pBinds) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.bindCount; i++) {
            if (i + 1 == obj.bindCount)
                print_VkSparseImageMemoryBind(obj.pBinds[i], "pBinds", 0);
            else
                print_VkSparseImageMemoryBind(obj.pBinds[i], "pBinds", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSparseImageMemoryBindInfo(const VkSparseImageMemoryBindInfo* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->bindCount, "bindCount", 1);

    PRINT_SPACE
    _OUT << "\"pBinds\": " << std::endl;
    if (obj->pBinds) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->bindCount; i++) {
            if (i + 1 == obj->bindCount)
                print_VkSparseImageMemoryBind(obj->pBinds[i], "pBinds", 0);
            else
                print_VkSparseImageMemoryBind(obj->pBinds[i], "pBinds", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindSparseInfo(VkBindSparseInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.waitSemaphoreCount, "waitSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pWaitSemaphores\":" << std::endl;
    PRINT_SPACE
    if (obj.pWaitSemaphores) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.waitSemaphoreCount; i++) {
            std::stringstream tmp;
            tmp << "pWaitSemaphores"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.waitSemaphoreCount;
            print_VkSemaphore(obj.pWaitSemaphores[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.bufferBindCount, "bufferBindCount", 1);

    PRINT_SPACE
    _OUT << "\"pBufferBinds\": " << std::endl;
    if (obj.pBufferBinds) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.bufferBindCount; i++) {
            if (i + 1 == obj.bufferBindCount)
                print_VkSparseBufferMemoryBindInfo(obj.pBufferBinds[i], "pBufferBinds", 0);
            else
                print_VkSparseBufferMemoryBindInfo(obj.pBufferBinds[i], "pBufferBinds", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.imageOpaqueBindCount, "imageOpaqueBindCount", 1);

    PRINT_SPACE
    _OUT << "\"pImageOpaqueBinds\": " << std::endl;
    if (obj.pImageOpaqueBinds) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.imageOpaqueBindCount; i++) {
            if (i + 1 == obj.imageOpaqueBindCount)
                print_VkSparseImageOpaqueMemoryBindInfo(obj.pImageOpaqueBinds[i], "pImageOpaqueBinds", 0);
            else
                print_VkSparseImageOpaqueMemoryBindInfo(obj.pImageOpaqueBinds[i], "pImageOpaqueBinds", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.imageBindCount, "imageBindCount", 1);

    PRINT_SPACE
    _OUT << "\"pImageBinds\": " << std::endl;
    if (obj.pImageBinds) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.imageBindCount; i++) {
            if (i + 1 == obj.imageBindCount)
                print_VkSparseImageMemoryBindInfo(obj.pImageBinds[i], "pImageBinds", 0);
            else
                print_VkSparseImageMemoryBindInfo(obj.pImageBinds[i], "pImageBinds", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.signalSemaphoreCount, "signalSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pSignalSemaphores\":" << std::endl;
    PRINT_SPACE
    if (obj.pSignalSemaphores) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.signalSemaphoreCount; i++) {
            std::stringstream tmp;
            tmp << "pSignalSemaphores"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.signalSemaphoreCount;
            print_VkSemaphore(obj.pSignalSemaphores[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindSparseInfo(const VkBindSparseInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->waitSemaphoreCount, "waitSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pWaitSemaphores\":" << std::endl;
    PRINT_SPACE
    if (obj->pWaitSemaphores) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->waitSemaphoreCount; i++) {
            std::stringstream tmp;
            tmp << "pWaitSemaphores"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->waitSemaphoreCount;
            print_VkSemaphore(obj->pWaitSemaphores[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->bufferBindCount, "bufferBindCount", 1);

    PRINT_SPACE
    _OUT << "\"pBufferBinds\": " << std::endl;
    if (obj->pBufferBinds) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->bufferBindCount; i++) {
            if (i + 1 == obj->bufferBindCount)
                print_VkSparseBufferMemoryBindInfo(obj->pBufferBinds[i], "pBufferBinds", 0);
            else
                print_VkSparseBufferMemoryBindInfo(obj->pBufferBinds[i], "pBufferBinds", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->imageOpaqueBindCount, "imageOpaqueBindCount", 1);

    PRINT_SPACE
    _OUT << "\"pImageOpaqueBinds\": " << std::endl;
    if (obj->pImageOpaqueBinds) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->imageOpaqueBindCount; i++) {
            if (i + 1 == obj->imageOpaqueBindCount)
                print_VkSparseImageOpaqueMemoryBindInfo(obj->pImageOpaqueBinds[i], "pImageOpaqueBinds", 0);
            else
                print_VkSparseImageOpaqueMemoryBindInfo(obj->pImageOpaqueBinds[i], "pImageOpaqueBinds", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->imageBindCount, "imageBindCount", 1);

    PRINT_SPACE
    _OUT << "\"pImageBinds\": " << std::endl;
    if (obj->pImageBinds) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->imageBindCount; i++) {
            if (i + 1 == obj->imageBindCount)
                print_VkSparseImageMemoryBindInfo(obj->pImageBinds[i], "pImageBinds", 0);
            else
                print_VkSparseImageMemoryBindInfo(obj->pImageBinds[i], "pImageBinds", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->signalSemaphoreCount, "signalSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pSignalSemaphores\":" << std::endl;
    PRINT_SPACE
    if (obj->pSignalSemaphores) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->signalSemaphoreCount; i++) {
            std::stringstream tmp;
            tmp << "pSignalSemaphores"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->signalSemaphoreCount;
            print_VkSemaphore(obj->pSignalSemaphores[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSparseImageFormatProperties(VkSparseImageFormatProperties obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkImageAspectFlags(obj.aspectMask, "aspectMask", 1);

    PRINT_SPACE
    _OUT << "\"imageGranularity\": " << std::endl;
    { print_VkExtent3D(obj.imageGranularity, "imageGranularity", 1); }

    print_VkSparseImageFormatFlags(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSparseImageFormatProperties(const VkSparseImageFormatProperties* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkImageAspectFlags(obj->aspectMask, "aspectMask", 1);

    PRINT_SPACE
    _OUT << "\"imageGranularity\": " << std::endl;
    { print_VkExtent3D(obj->imageGranularity, "imageGranularity", 1); }

    print_VkSparseImageFormatFlags(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSparseImageMemoryRequirements(VkSparseImageMemoryRequirements obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"formatProperties\": " << std::endl;
    { print_VkSparseImageFormatProperties(obj.formatProperties, "formatProperties", 1); }

    print_uint32_t(obj.imageMipTailFirstLod, "imageMipTailFirstLod", 1);

    print_VkDeviceSize(obj.imageMipTailSize, "imageMipTailSize", 1);

    print_VkDeviceSize(obj.imageMipTailOffset, "imageMipTailOffset", 1);

    print_VkDeviceSize(obj.imageMipTailStride, "imageMipTailStride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSparseImageMemoryRequirements(const VkSparseImageMemoryRequirements* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"formatProperties\": " << std::endl;
    { print_VkSparseImageFormatProperties(obj->formatProperties, "formatProperties", 1); }

    print_uint32_t(obj->imageMipTailFirstLod, "imageMipTailFirstLod", 1);

    print_VkDeviceSize(obj->imageMipTailSize, "imageMipTailSize", 1);

    print_VkDeviceSize(obj->imageMipTailOffset, "imageMipTailOffset", 1);

    print_VkDeviceSize(obj->imageMipTailStride, "imageMipTailStride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkFenceCreateInfo(VkFenceCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFenceCreateFlags(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkFenceCreateInfo(const VkFenceCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFenceCreateFlags(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSemaphoreCreateInfo(VkSemaphoreCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSemaphoreCreateFlags(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSemaphoreCreateInfo(const VkSemaphoreCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSemaphoreCreateFlags(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkEventCreateInfo(VkEventCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkEventCreateFlags(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkEventCreateInfo(const VkEventCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkEventCreateFlags(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkQueryPoolCreateInfo(VkQueryPoolCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkQueryPoolCreateFlags(obj.flags, "flags", 1);

    print_VkQueryType(obj.queryType, "queryType", 1);

    print_uint32_t(obj.queryCount, "queryCount", 1);

    print_VkQueryPipelineStatisticFlags(obj.pipelineStatistics, "pipelineStatistics", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkQueryPoolCreateInfo(const VkQueryPoolCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkQueryPoolCreateFlags(obj->flags, "flags", 1);

    print_VkQueryType(obj->queryType, "queryType", 1);

    print_uint32_t(obj->queryCount, "queryCount", 1);

    print_VkQueryPipelineStatisticFlags(obj->pipelineStatistics, "pipelineStatistics", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBufferCreateInfo(VkBufferCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBufferCreateFlags(obj.flags, "flags", 1);

    print_VkDeviceSize(obj.size, "size", 1);

    print_VkBufferUsageFlags(obj.usage, "usage", 1);

    print_VkSharingMode(obj.sharingMode, "sharingMode", 1);

    print_uint32_t(obj.queueFamilyIndexCount, "queueFamilyIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueueFamilyIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pQueueFamilyIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.queueFamilyIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.queueFamilyIndexCount;
            print_uint32_t(obj.pQueueFamilyIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferCreateInfo(const VkBufferCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBufferCreateFlags(obj->flags, "flags", 1);

    print_VkDeviceSize(obj->size, "size", 1);

    print_VkBufferUsageFlags(obj->usage, "usage", 1);

    print_VkSharingMode(obj->sharingMode, "sharingMode", 1);

    print_uint32_t(obj->queueFamilyIndexCount, "queueFamilyIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueueFamilyIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pQueueFamilyIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->queueFamilyIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->queueFamilyIndexCount;
            print_uint32_t(obj->pQueueFamilyIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBufferViewCreateInfo(VkBufferViewCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBufferViewCreateFlags(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkFormat(obj.format, "format", 1);

    print_VkDeviceSize(obj.offset, "offset", 1);

    print_VkDeviceSize(obj.range, "range", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferViewCreateInfo(const VkBufferViewCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBufferViewCreateFlags(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkFormat(obj->format, "format", 1);

    print_VkDeviceSize(obj->offset, "offset", 1);

    print_VkDeviceSize(obj->range, "range", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageCreateInfo(VkImageCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageCreateFlags(obj.flags, "flags", 1);

    print_VkImageType(obj.imageType, "imageType", 1);

    print_VkFormat(obj.format, "format", 1);

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent3D(obj.extent, "extent", 1); }

    print_uint32_t(obj.mipLevels, "mipLevels", 1);

    print_uint32_t(obj.arrayLayers, "arrayLayers", 1);

    print_VkSampleCountFlagBits(obj.samples, "samples", 1);

    print_VkImageTiling(obj.tiling, "tiling", 1);

    print_VkImageUsageFlags(obj.usage, "usage", 1);

    print_VkSharingMode(obj.sharingMode, "sharingMode", 1);

    print_uint32_t(obj.queueFamilyIndexCount, "queueFamilyIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueueFamilyIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pQueueFamilyIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.queueFamilyIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.queueFamilyIndexCount;
            print_uint32_t(obj.pQueueFamilyIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageLayout(obj.initialLayout, "initialLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageCreateInfo(const VkImageCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageCreateFlags(obj->flags, "flags", 1);

    print_VkImageType(obj->imageType, "imageType", 1);

    print_VkFormat(obj->format, "format", 1);

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent3D(obj->extent, "extent", 1); }

    print_uint32_t(obj->mipLevels, "mipLevels", 1);

    print_uint32_t(obj->arrayLayers, "arrayLayers", 1);

    print_VkSampleCountFlagBits(obj->samples, "samples", 1);

    print_VkImageTiling(obj->tiling, "tiling", 1);

    print_VkImageUsageFlags(obj->usage, "usage", 1);

    print_VkSharingMode(obj->sharingMode, "sharingMode", 1);

    print_uint32_t(obj->queueFamilyIndexCount, "queueFamilyIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueueFamilyIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pQueueFamilyIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->queueFamilyIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->queueFamilyIndexCount;
            print_uint32_t(obj->pQueueFamilyIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageLayout(obj->initialLayout, "initialLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubresourceLayout(VkSubresourceLayout obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceSize(obj.offset, "offset", 1);

    print_VkDeviceSize(obj.size, "size", 1);

    print_VkDeviceSize(obj.rowPitch, "rowPitch", 1);

    print_VkDeviceSize(obj.arrayPitch, "arrayPitch", 1);

    print_VkDeviceSize(obj.depthPitch, "depthPitch", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubresourceLayout(const VkSubresourceLayout* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceSize(obj->offset, "offset", 1);

    print_VkDeviceSize(obj->size, "size", 1);

    print_VkDeviceSize(obj->rowPitch, "rowPitch", 1);

    print_VkDeviceSize(obj->arrayPitch, "arrayPitch", 1);

    print_VkDeviceSize(obj->depthPitch, "depthPitch", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkComponentMapping(VkComponentMapping obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkComponentSwizzle(obj.r, "r", 1);

    print_VkComponentSwizzle(obj.g, "g", 1);

    print_VkComponentSwizzle(obj.b, "b", 1);

    print_VkComponentSwizzle(obj.a, "a", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkComponentMapping(const VkComponentMapping* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkComponentSwizzle(obj->r, "r", 1);

    print_VkComponentSwizzle(obj->g, "g", 1);

    print_VkComponentSwizzle(obj->b, "b", 1);

    print_VkComponentSwizzle(obj->a, "a", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageViewCreateInfo(VkImageViewCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageViewCreateFlags(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageViewType(obj.viewType, "viewType", 1);

    print_VkFormat(obj.format, "format", 1);

    PRINT_SPACE
    _OUT << "\"components\": " << std::endl;
    { print_VkComponentMapping(obj.components, "components", 1); }

    PRINT_SPACE
    _OUT << "\"subresourceRange\": " << std::endl;
    { print_VkImageSubresourceRange(obj.subresourceRange, "subresourceRange", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageViewCreateInfo(const VkImageViewCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageViewCreateFlags(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageViewType(obj->viewType, "viewType", 1);

    print_VkFormat(obj->format, "format", 1);

    PRINT_SPACE
    _OUT << "\"components\": " << std::endl;
    { print_VkComponentMapping(obj->components, "components", 1); }

    PRINT_SPACE
    _OUT << "\"subresourceRange\": " << std::endl;
    { print_VkImageSubresourceRange(obj->subresourceRange, "subresourceRange", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkShaderModuleCreateInfo(VkShaderModuleCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderModuleCreateFlags(obj.flags, "flags", 1);

    print_size_t(obj.codeSize, "codeSize", 1);

    print_uint32_t(obj.pCode, "pCode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkShaderModuleCreateInfo(const VkShaderModuleCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderModuleCreateFlags(obj->flags, "flags", 1);

    print_size_t(obj->codeSize, "codeSize", 1);

    print_uint32_t(obj->pCode, "pCode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineCacheCreateInfo(VkPipelineCacheCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCacheCreateFlags(obj.flags, "flags", 1);

    print_size_t(obj.initialDataSize, "initialDataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineCacheCreateInfo(const VkPipelineCacheCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCacheCreateFlags(obj->flags, "flags", 1);

    print_size_t(obj->initialDataSize, "initialDataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSpecializationMapEntry(VkSpecializationMapEntry obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.constantID, "constantID", 1);

    print_uint32_t(obj.offset, "offset", 1);

    print_size_t(obj.size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSpecializationMapEntry(const VkSpecializationMapEntry* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->constantID, "constantID", 1);

    print_uint32_t(obj->offset, "offset", 1);

    print_size_t(obj->size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSpecializationInfo(VkSpecializationInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.mapEntryCount, "mapEntryCount", 1);

    PRINT_SPACE
    _OUT << "\"pMapEntries\": " << std::endl;
    if (obj.pMapEntries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.mapEntryCount; i++) {
            if (i + 1 == obj.mapEntryCount)
                print_VkSpecializationMapEntry(obj.pMapEntries[i], "pMapEntries", 0);
            else
                print_VkSpecializationMapEntry(obj.pMapEntries[i], "pMapEntries", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_size_t(obj.dataSize, "dataSize", 1);

    print_void_data(obj.pData, int(obj.dataSize), "pData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSpecializationInfo(const VkSpecializationInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->mapEntryCount, "mapEntryCount", 1);

    PRINT_SPACE
    _OUT << "\"pMapEntries\": " << std::endl;
    if (obj->pMapEntries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->mapEntryCount; i++) {
            if (i + 1 == obj->mapEntryCount)
                print_VkSpecializationMapEntry(obj->pMapEntries[i], "pMapEntries", 0);
            else
                print_VkSpecializationMapEntry(obj->pMapEntries[i], "pMapEntries", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_size_t(obj->dataSize, "dataSize", 1);

    print_void_data(obj->pData, int(obj->dataSize), "pData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineShaderStageCreateInfo(VkPipelineShaderStageCreateInfo obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineShaderStageCreateFlags(obj.flags, "flags", 1);

    print_VkShaderStageFlagBits(obj.stage, "stage", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "module"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_char(obj.pName, "pName", 1);

    PRINT_SPACE
    _OUT << "\"pSpecializationInfo\": " << std::endl;
    if (obj.pSpecializationInfo) {
        print_VkSpecializationInfo(obj.pSpecializationInfo, "pSpecializationInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineShaderStageCreateInfo(const VkPipelineShaderStageCreateInfo* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineShaderStageCreateFlags(obj->flags, "flags", 1);

    print_VkShaderStageFlagBits(obj->stage, "stage", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "module"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_char(obj->pName, "pName", 1);

    PRINT_SPACE
    _OUT << "\"pSpecializationInfo\": " << std::endl;
    if (obj->pSpecializationInfo) {
        print_VkSpecializationInfo(obj->pSpecializationInfo, "pSpecializationInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkComputePipelineCreateInfo(VkComputePipelineCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCreateFlags(obj.flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"stage\": " << std::endl;
    { print_VkPipelineShaderStageCreateInfo(obj.stage, "stage", 1); }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "basePipelineHandle"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_int32_t(obj.basePipelineIndex, "basePipelineIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkComputePipelineCreateInfo(const VkComputePipelineCreateInfo* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCreateFlags(obj->flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"stage\": " << std::endl;
    { print_VkPipelineShaderStageCreateInfo(obj->stage, "stage", 1); }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "basePipelineHandle"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_int32_t(obj->basePipelineIndex, "basePipelineIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVertexInputBindingDescription(VkVertexInputBindingDescription obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.binding, "binding", 1);

    print_uint32_t(obj.stride, "stride", 1);

    print_VkVertexInputRate(obj.inputRate, "inputRate", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVertexInputBindingDescription(const VkVertexInputBindingDescription* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->binding, "binding", 1);

    print_uint32_t(obj->stride, "stride", 1);

    print_VkVertexInputRate(obj->inputRate, "inputRate", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVertexInputAttributeDescription(VkVertexInputAttributeDescription obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.location, "location", 1);

    print_uint32_t(obj.binding, "binding", 1);

    print_VkFormat(obj.format, "format", 1);

    print_uint32_t(obj.offset, "offset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVertexInputAttributeDescription(const VkVertexInputAttributeDescription* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->location, "location", 1);

    print_uint32_t(obj->binding, "binding", 1);

    print_VkFormat(obj->format, "format", 1);

    print_uint32_t(obj->offset, "offset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineVertexInputStateCreateInfo(VkPipelineVertexInputStateCreateInfo obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineVertexInputStateCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.vertexBindingDescriptionCount, "vertexBindingDescriptionCount", 1);

    PRINT_SPACE
    _OUT << "\"pVertexBindingDescriptions\": " << std::endl;
    if (obj.pVertexBindingDescriptions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.vertexBindingDescriptionCount; i++) {
            if (i + 1 == obj.vertexBindingDescriptionCount)
                print_VkVertexInputBindingDescription(obj.pVertexBindingDescriptions[i], "pVertexBindingDescriptions", 0);
            else
                print_VkVertexInputBindingDescription(obj.pVertexBindingDescriptions[i], "pVertexBindingDescriptions", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.vertexAttributeDescriptionCount, "vertexAttributeDescriptionCount", 1);

    PRINT_SPACE
    _OUT << "\"pVertexAttributeDescriptions\": " << std::endl;
    if (obj.pVertexAttributeDescriptions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.vertexAttributeDescriptionCount; i++) {
            if (i + 1 == obj.vertexAttributeDescriptionCount)
                print_VkVertexInputAttributeDescription(obj.pVertexAttributeDescriptions[i], "pVertexAttributeDescriptions", 0);
            else
                print_VkVertexInputAttributeDescription(obj.pVertexAttributeDescriptions[i], "pVertexAttributeDescriptions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineVertexInputStateCreateInfo(const VkPipelineVertexInputStateCreateInfo* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineVertexInputStateCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->vertexBindingDescriptionCount, "vertexBindingDescriptionCount", 1);

    PRINT_SPACE
    _OUT << "\"pVertexBindingDescriptions\": " << std::endl;
    if (obj->pVertexBindingDescriptions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->vertexBindingDescriptionCount; i++) {
            if (i + 1 == obj->vertexBindingDescriptionCount)
                print_VkVertexInputBindingDescription(obj->pVertexBindingDescriptions[i], "pVertexBindingDescriptions", 0);
            else
                print_VkVertexInputBindingDescription(obj->pVertexBindingDescriptions[i], "pVertexBindingDescriptions", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->vertexAttributeDescriptionCount, "vertexAttributeDescriptionCount", 1);

    PRINT_SPACE
    _OUT << "\"pVertexAttributeDescriptions\": " << std::endl;
    if (obj->pVertexAttributeDescriptions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->vertexAttributeDescriptionCount; i++) {
            if (i + 1 == obj->vertexAttributeDescriptionCount)
                print_VkVertexInputAttributeDescription(obj->pVertexAttributeDescriptions[i], "pVertexAttributeDescriptions", 0);
            else
                print_VkVertexInputAttributeDescription(obj->pVertexAttributeDescriptions[i], "pVertexAttributeDescriptions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineInputAssemblyStateCreateInfo(VkPipelineInputAssemblyStateCreateInfo obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineInputAssemblyStateCreateFlags(obj.flags, "flags", 1);

    print_VkPrimitiveTopology(obj.topology, "topology", 1);

    print_VkBool32(obj.primitiveRestartEnable, "primitiveRestartEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineInputAssemblyStateCreateInfo(const VkPipelineInputAssemblyStateCreateInfo* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineInputAssemblyStateCreateFlags(obj->flags, "flags", 1);

    print_VkPrimitiveTopology(obj->topology, "topology", 1);

    print_VkBool32(obj->primitiveRestartEnable, "primitiveRestartEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineTessellationStateCreateInfo(VkPipelineTessellationStateCreateInfo obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineTessellationStateCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.patchControlPoints, "patchControlPoints", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineTessellationStateCreateInfo(const VkPipelineTessellationStateCreateInfo* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineTessellationStateCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->patchControlPoints, "patchControlPoints", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkViewport(VkViewport obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj.x, "x", 1);

    print_float(obj.y, "y", 1);

    print_float(obj.width, "width", 1);

    print_float(obj.height, "height", 1);

    print_float(obj.minDepth, "minDepth", 1);

    print_float(obj.maxDepth, "maxDepth", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkViewport(const VkViewport* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj->x, "x", 1);

    print_float(obj->y, "y", 1);

    print_float(obj->width, "width", 1);

    print_float(obj->height, "height", 1);

    print_float(obj->minDepth, "minDepth", 1);

    print_float(obj->maxDepth, "maxDepth", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineViewportStateCreateInfo(VkPipelineViewportStateCreateInfo obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineViewportStateCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.viewportCount, "viewportCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewports\": " << std::endl;
    if (obj.pViewports) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.viewportCount; i++) {
            if (i + 1 == obj.viewportCount)
                print_VkViewport(obj.pViewports[i], "pViewports", 0);
            else
                print_VkViewport(obj.pViewports[i], "pViewports", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.scissorCount, "scissorCount", 1);

    PRINT_SPACE
    _OUT << "\"pScissors\": " << std::endl;
    if (obj.pScissors) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.scissorCount; i++) {
            if (i + 1 == obj.scissorCount)
                print_VkRect2D(obj.pScissors[i], "pScissors", 0);
            else
                print_VkRect2D(obj.pScissors[i], "pScissors", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineViewportStateCreateInfo(const VkPipelineViewportStateCreateInfo* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineViewportStateCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->viewportCount, "viewportCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewports\": " << std::endl;
    if (obj->pViewports) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->viewportCount; i++) {
            if (i + 1 == obj->viewportCount)
                print_VkViewport(obj->pViewports[i], "pViewports", 0);
            else
                print_VkViewport(obj->pViewports[i], "pViewports", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->scissorCount, "scissorCount", 1);

    PRINT_SPACE
    _OUT << "\"pScissors\": " << std::endl;
    if (obj->pScissors) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->scissorCount; i++) {
            if (i + 1 == obj->scissorCount)
                print_VkRect2D(obj->pScissors[i], "pScissors", 0);
            else
                print_VkRect2D(obj->pScissors[i], "pScissors", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineRasterizationStateCreateInfo(VkPipelineRasterizationStateCreateInfo obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineRasterizationStateCreateFlags(obj.flags, "flags", 1);

    print_VkBool32(obj.depthClampEnable, "depthClampEnable", 1);

    print_VkBool32(obj.rasterizerDiscardEnable, "rasterizerDiscardEnable", 1);

    print_VkPolygonMode(obj.polygonMode, "polygonMode", 1);

    print_VkCullModeFlags(obj.cullMode, "cullMode", 1);

    print_VkFrontFace(obj.frontFace, "frontFace", 1);

    print_VkBool32(obj.depthBiasEnable, "depthBiasEnable", 1);

    print_float(obj.depthBiasConstantFactor, "depthBiasConstantFactor", 1);

    print_float(obj.depthBiasClamp, "depthBiasClamp", 1);

    print_float(obj.depthBiasSlopeFactor, "depthBiasSlopeFactor", 1);

    print_float(obj.lineWidth, "lineWidth", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineRasterizationStateCreateInfo(const VkPipelineRasterizationStateCreateInfo* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineRasterizationStateCreateFlags(obj->flags, "flags", 1);

    print_VkBool32(obj->depthClampEnable, "depthClampEnable", 1);

    print_VkBool32(obj->rasterizerDiscardEnable, "rasterizerDiscardEnable", 1);

    print_VkPolygonMode(obj->polygonMode, "polygonMode", 1);

    print_VkCullModeFlags(obj->cullMode, "cullMode", 1);

    print_VkFrontFace(obj->frontFace, "frontFace", 1);

    print_VkBool32(obj->depthBiasEnable, "depthBiasEnable", 1);

    print_float(obj->depthBiasConstantFactor, "depthBiasConstantFactor", 1);

    print_float(obj->depthBiasClamp, "depthBiasClamp", 1);

    print_float(obj->depthBiasSlopeFactor, "depthBiasSlopeFactor", 1);

    print_float(obj->lineWidth, "lineWidth", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineMultisampleStateCreateInfo(VkPipelineMultisampleStateCreateInfo obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineMultisampleStateCreateFlags(obj.flags, "flags", 1);

    print_VkSampleCountFlagBits(obj.rasterizationSamples, "rasterizationSamples", 1);

    print_VkBool32(obj.sampleShadingEnable, "sampleShadingEnable", 1);

    print_float(obj.minSampleShading, "minSampleShading", 1);

    uint32_t sampleMaskSize = ((obj.rasterizationSamples + 31) / 32);
    PRINT_SPACE
    _OUT << "\"pSampleMask\":" << std::endl;
    PRINT_SPACE
    if (obj.pSampleMask) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < sampleMaskSize; i++) {
            bool isCommaNeeded = (i + 1) != sampleMaskSize;
            print_uint32_t(obj.pSampleMask[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.alphaToCoverageEnable, "alphaToCoverageEnable", 1);

    print_VkBool32(obj.alphaToOneEnable, "alphaToOneEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineMultisampleStateCreateInfo(const VkPipelineMultisampleStateCreateInfo* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineMultisampleStateCreateFlags(obj->flags, "flags", 1);

    print_VkSampleCountFlagBits(obj->rasterizationSamples, "rasterizationSamples", 1);

    print_VkBool32(obj->sampleShadingEnable, "sampleShadingEnable", 1);

    print_float(obj->minSampleShading, "minSampleShading", 1);

    uint32_t sampleMaskSize = ((obj->rasterizationSamples + 31) / 32);
    PRINT_SPACE
    _OUT << "\"pSampleMask\":" << std::endl;
    PRINT_SPACE
    if (obj->pSampleMask) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < sampleMaskSize; i++) {
            bool isCommaNeeded = (i + 1) != sampleMaskSize;
            print_uint32_t(obj->pSampleMask[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->alphaToCoverageEnable, "alphaToCoverageEnable", 1);

    print_VkBool32(obj->alphaToOneEnable, "alphaToOneEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkStencilOpState(VkStencilOpState obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStencilOp(obj.failOp, "failOp", 1);

    print_VkStencilOp(obj.passOp, "passOp", 1);

    print_VkStencilOp(obj.depthFailOp, "depthFailOp", 1);

    print_VkCompareOp(obj.compareOp, "compareOp", 1);

    print_uint32_t(obj.compareMask, "compareMask", 1);

    print_uint32_t(obj.writeMask, "writeMask", 1);

    print_uint32_t(obj.reference, "reference", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkStencilOpState(const VkStencilOpState* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStencilOp(obj->failOp, "failOp", 1);

    print_VkStencilOp(obj->passOp, "passOp", 1);

    print_VkStencilOp(obj->depthFailOp, "depthFailOp", 1);

    print_VkCompareOp(obj->compareOp, "compareOp", 1);

    print_uint32_t(obj->compareMask, "compareMask", 1);

    print_uint32_t(obj->writeMask, "writeMask", 1);

    print_uint32_t(obj->reference, "reference", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineDepthStencilStateCreateInfo(VkPipelineDepthStencilStateCreateInfo obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineDepthStencilStateCreateFlags(obj.flags, "flags", 1);

    print_VkBool32(obj.depthTestEnable, "depthTestEnable", 1);

    print_VkBool32(obj.depthWriteEnable, "depthWriteEnable", 1);

    print_VkCompareOp(obj.depthCompareOp, "depthCompareOp", 1);

    print_VkBool32(obj.depthBoundsTestEnable, "depthBoundsTestEnable", 1);

    print_VkBool32(obj.stencilTestEnable, "stencilTestEnable", 1);

    PRINT_SPACE
    _OUT << "\"front\": " << std::endl;
    { print_VkStencilOpState(obj.front, "front", 1); }

    PRINT_SPACE
    _OUT << "\"back\": " << std::endl;
    { print_VkStencilOpState(obj.back, "back", 1); }

    print_float(obj.minDepthBounds, "minDepthBounds", 1);

    print_float(obj.maxDepthBounds, "maxDepthBounds", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineDepthStencilStateCreateInfo(const VkPipelineDepthStencilStateCreateInfo* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineDepthStencilStateCreateFlags(obj->flags, "flags", 1);

    print_VkBool32(obj->depthTestEnable, "depthTestEnable", 1);

    print_VkBool32(obj->depthWriteEnable, "depthWriteEnable", 1);

    print_VkCompareOp(obj->depthCompareOp, "depthCompareOp", 1);

    print_VkBool32(obj->depthBoundsTestEnable, "depthBoundsTestEnable", 1);

    print_VkBool32(obj->stencilTestEnable, "stencilTestEnable", 1);

    PRINT_SPACE
    _OUT << "\"front\": " << std::endl;
    { print_VkStencilOpState(obj->front, "front", 1); }

    PRINT_SPACE
    _OUT << "\"back\": " << std::endl;
    { print_VkStencilOpState(obj->back, "back", 1); }

    print_float(obj->minDepthBounds, "minDepthBounds", 1);

    print_float(obj->maxDepthBounds, "maxDepthBounds", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineColorBlendAttachmentState(VkPipelineColorBlendAttachmentState obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkBool32(obj.blendEnable, "blendEnable", 1);

    print_VkBlendFactor(obj.srcColorBlendFactor, "srcColorBlendFactor", 1);

    print_VkBlendFactor(obj.dstColorBlendFactor, "dstColorBlendFactor", 1);

    print_VkBlendOp(obj.colorBlendOp, "colorBlendOp", 1);

    print_VkBlendFactor(obj.srcAlphaBlendFactor, "srcAlphaBlendFactor", 1);

    print_VkBlendFactor(obj.dstAlphaBlendFactor, "dstAlphaBlendFactor", 1);

    print_VkBlendOp(obj.alphaBlendOp, "alphaBlendOp", 1);

    print_VkColorComponentFlags(obj.colorWriteMask, "colorWriteMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineColorBlendAttachmentState(const VkPipelineColorBlendAttachmentState* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkBool32(obj->blendEnable, "blendEnable", 1);

    print_VkBlendFactor(obj->srcColorBlendFactor, "srcColorBlendFactor", 1);

    print_VkBlendFactor(obj->dstColorBlendFactor, "dstColorBlendFactor", 1);

    print_VkBlendOp(obj->colorBlendOp, "colorBlendOp", 1);

    print_VkBlendFactor(obj->srcAlphaBlendFactor, "srcAlphaBlendFactor", 1);

    print_VkBlendFactor(obj->dstAlphaBlendFactor, "dstAlphaBlendFactor", 1);

    print_VkBlendOp(obj->alphaBlendOp, "alphaBlendOp", 1);

    print_VkColorComponentFlags(obj->colorWriteMask, "colorWriteMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineColorBlendStateCreateInfo(VkPipelineColorBlendStateCreateInfo obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineColorBlendStateCreateFlags(obj.flags, "flags", 1);

    print_VkBool32(obj.logicOpEnable, "logicOpEnable", 1);

    print_VkLogicOp(obj.logicOp, "logicOp", 1);

    print_uint32_t(obj.attachmentCount, "attachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachments\": " << std::endl;
    if (obj.pAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.attachmentCount; i++) {
            if (i + 1 == obj.attachmentCount)
                print_VkPipelineColorBlendAttachmentState(obj.pAttachments[i], "pAttachments", 0);
            else
                print_VkPipelineColorBlendAttachmentState(obj.pAttachments[i], "pAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"blendConstants\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 4; i++) {
        bool isCommaNeeded = (i + 1) != 4;
        print_float(obj.blendConstants[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineColorBlendStateCreateInfo(const VkPipelineColorBlendStateCreateInfo* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineColorBlendStateCreateFlags(obj->flags, "flags", 1);

    print_VkBool32(obj->logicOpEnable, "logicOpEnable", 1);

    print_VkLogicOp(obj->logicOp, "logicOp", 1);

    print_uint32_t(obj->attachmentCount, "attachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachments\": " << std::endl;
    if (obj->pAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->attachmentCount; i++) {
            if (i + 1 == obj->attachmentCount)
                print_VkPipelineColorBlendAttachmentState(obj->pAttachments[i], "pAttachments", 0);
            else
                print_VkPipelineColorBlendAttachmentState(obj->pAttachments[i], "pAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"blendConstants\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 4; i++) {
        bool isCommaNeeded = (i + 1) != 4;
        print_float(obj->blendConstants[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineDynamicStateCreateInfo(VkPipelineDynamicStateCreateInfo obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineDynamicStateCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.dynamicStateCount, "dynamicStateCount", 1);

    PRINT_SPACE
    _OUT << "\"pDynamicStates\":" << std::endl;
    PRINT_SPACE
    if (obj.pDynamicStates) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.dynamicStateCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.dynamicStateCount;
            print_VkDynamicState(obj.pDynamicStates[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineDynamicStateCreateInfo(const VkPipelineDynamicStateCreateInfo* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineDynamicStateCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->dynamicStateCount, "dynamicStateCount", 1);

    PRINT_SPACE
    _OUT << "\"pDynamicStates\":" << std::endl;
    PRINT_SPACE
    if (obj->pDynamicStates) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->dynamicStateCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->dynamicStateCount;
            print_VkDynamicState(obj->pDynamicStates[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGraphicsPipelineCreateInfo(VkGraphicsPipelineCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.stageCount, "stageCount", 1);

    PRINT_SPACE
    _OUT << "\"pStages\": " << std::endl;
    if (obj.pStages) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stageCount; i++) {
            if (i + 1 == obj.stageCount)
                print_VkPipelineShaderStageCreateInfo(obj.pStages[i], "pStages", 0);
            else
                print_VkPipelineShaderStageCreateInfo(obj.pStages[i], "pStages", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pVertexInputState\": " << std::endl;
    if (obj.pVertexInputState) {
        print_VkPipelineVertexInputStateCreateInfo(obj.pVertexInputState, "pVertexInputState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pInputAssemblyState\": " << std::endl;
    if (obj.pInputAssemblyState) {
        print_VkPipelineInputAssemblyStateCreateInfo(obj.pInputAssemblyState, "pInputAssemblyState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pTessellationState\": " << std::endl;
    if (obj.pTessellationState) {
        print_VkPipelineTessellationStateCreateInfo(obj.pTessellationState, "pTessellationState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pViewportState\": " << std::endl;
    if (obj.pViewportState) {
        print_VkPipelineViewportStateCreateInfo(obj.pViewportState, "pViewportState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pRasterizationState\": " << std::endl;
    if (obj.pRasterizationState) {
        print_VkPipelineRasterizationStateCreateInfo(obj.pRasterizationState, "pRasterizationState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pMultisampleState\": " << std::endl;
    if (obj.pMultisampleState) {
        print_VkPipelineMultisampleStateCreateInfo(obj.pMultisampleState, "pMultisampleState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pDepthStencilState\": " << std::endl;
    if (obj.pDepthStencilState) {
        print_VkPipelineDepthStencilStateCreateInfo(obj.pDepthStencilState, "pDepthStencilState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pColorBlendState\": " << std::endl;
    if (obj.pColorBlendState) {
        print_VkPipelineColorBlendStateCreateInfo(obj.pColorBlendState, "pColorBlendState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pDynamicState\": " << std::endl;
    if (obj.pDynamicState) {
        print_VkPipelineDynamicStateCreateInfo(obj.pDynamicState, "pDynamicState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "renderPass"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.subpass, "subpass", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "basePipelineHandle"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_int32_t(obj.basePipelineIndex, "basePipelineIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGraphicsPipelineCreateInfo(const VkGraphicsPipelineCreateInfo* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->stageCount, "stageCount", 1);

    PRINT_SPACE
    _OUT << "\"pStages\": " << std::endl;
    if (obj->pStages) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stageCount; i++) {
            if (i + 1 == obj->stageCount)
                print_VkPipelineShaderStageCreateInfo(obj->pStages[i], "pStages", 0);
            else
                print_VkPipelineShaderStageCreateInfo(obj->pStages[i], "pStages", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pVertexInputState\": " << std::endl;
    if (obj->pVertexInputState) {
        print_VkPipelineVertexInputStateCreateInfo(obj->pVertexInputState, "pVertexInputState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pInputAssemblyState\": " << std::endl;
    if (obj->pInputAssemblyState) {
        print_VkPipelineInputAssemblyStateCreateInfo(obj->pInputAssemblyState, "pInputAssemblyState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pTessellationState\": " << std::endl;
    if (obj->pTessellationState) {
        print_VkPipelineTessellationStateCreateInfo(obj->pTessellationState, "pTessellationState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pViewportState\": " << std::endl;
    if (obj->pViewportState) {
        print_VkPipelineViewportStateCreateInfo(obj->pViewportState, "pViewportState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pRasterizationState\": " << std::endl;
    if (obj->pRasterizationState) {
        print_VkPipelineRasterizationStateCreateInfo(obj->pRasterizationState, "pRasterizationState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pMultisampleState\": " << std::endl;
    if (obj->pMultisampleState) {
        print_VkPipelineMultisampleStateCreateInfo(obj->pMultisampleState, "pMultisampleState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pDepthStencilState\": " << std::endl;
    if (obj->pDepthStencilState) {
        print_VkPipelineDepthStencilStateCreateInfo(obj->pDepthStencilState, "pDepthStencilState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pColorBlendState\": " << std::endl;
    if (obj->pColorBlendState) {
        print_VkPipelineColorBlendStateCreateInfo(obj->pColorBlendState, "pColorBlendState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pDynamicState\": " << std::endl;
    if (obj->pDynamicState) {
        print_VkPipelineDynamicStateCreateInfo(obj->pDynamicState, "pDynamicState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "renderPass"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->subpass, "subpass", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "basePipelineHandle"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_int32_t(obj->basePipelineIndex, "basePipelineIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPushConstantRange(VkPushConstantRange obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkShaderStageFlags(obj.stageFlags, "stageFlags", 1);

    print_uint32_t(obj.offset, "offset", 1);

    print_uint32_t(obj.size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPushConstantRange(const VkPushConstantRange* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkShaderStageFlags(obj->stageFlags, "stageFlags", 1);

    print_uint32_t(obj->offset, "offset", 1);

    print_uint32_t(obj->size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineLayoutCreateInfo(VkPipelineLayoutCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineLayoutCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.setLayoutCount, "setLayoutCount", 1);

    PRINT_SPACE
    _OUT << "\"pSetLayouts\":" << std::endl;
    PRINT_SPACE
    if (obj.pSetLayouts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.setLayoutCount; i++) {
            std::stringstream tmp;
            tmp << "pSetLayouts"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.setLayoutCount;
            print_VkDescriptorSetLayout(obj.pSetLayouts[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.pushConstantRangeCount, "pushConstantRangeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPushConstantRanges\": " << std::endl;
    if (obj.pPushConstantRanges) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.pushConstantRangeCount; i++) {
            if (i + 1 == obj.pushConstantRangeCount)
                print_VkPushConstantRange(obj.pPushConstantRanges[i], "pPushConstantRanges", 0);
            else
                print_VkPushConstantRange(obj.pPushConstantRanges[i], "pPushConstantRanges", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineLayoutCreateInfo(const VkPipelineLayoutCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineLayoutCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->setLayoutCount, "setLayoutCount", 1);

    PRINT_SPACE
    _OUT << "\"pSetLayouts\":" << std::endl;
    PRINT_SPACE
    if (obj->pSetLayouts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->setLayoutCount; i++) {
            std::stringstream tmp;
            tmp << "pSetLayouts"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->setLayoutCount;
            print_VkDescriptorSetLayout(obj->pSetLayouts[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->pushConstantRangeCount, "pushConstantRangeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPushConstantRanges\": " << std::endl;
    if (obj->pPushConstantRanges) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->pushConstantRangeCount; i++) {
            if (i + 1 == obj->pushConstantRangeCount)
                print_VkPushConstantRange(obj->pPushConstantRanges[i], "pPushConstantRanges", 0);
            else
                print_VkPushConstantRange(obj->pPushConstantRanges[i], "pPushConstantRanges", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSamplerCreateInfo(VkSamplerCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSamplerCreateFlags(obj.flags, "flags", 1);

    print_VkFilter(obj.magFilter, "magFilter", 1);

    print_VkFilter(obj.minFilter, "minFilter", 1);

    print_VkSamplerMipmapMode(obj.mipmapMode, "mipmapMode", 1);

    print_VkSamplerAddressMode(obj.addressModeU, "addressModeU", 1);

    print_VkSamplerAddressMode(obj.addressModeV, "addressModeV", 1);

    print_VkSamplerAddressMode(obj.addressModeW, "addressModeW", 1);

    print_float(obj.mipLodBias, "mipLodBias", 1);

    print_VkBool32(obj.anisotropyEnable, "anisotropyEnable", 1);

    print_float(obj.maxAnisotropy, "maxAnisotropy", 1);

    print_VkBool32(obj.compareEnable, "compareEnable", 1);

    print_VkCompareOp(obj.compareOp, "compareOp", 1);

    print_float(obj.minLod, "minLod", 1);

    print_float(obj.maxLod, "maxLod", 1);

    print_VkBorderColor(obj.borderColor, "borderColor", 1);

    print_VkBool32(obj.unnormalizedCoordinates, "unnormalizedCoordinates", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSamplerCreateInfo(const VkSamplerCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSamplerCreateFlags(obj->flags, "flags", 1);

    print_VkFilter(obj->magFilter, "magFilter", 1);

    print_VkFilter(obj->minFilter, "minFilter", 1);

    print_VkSamplerMipmapMode(obj->mipmapMode, "mipmapMode", 1);

    print_VkSamplerAddressMode(obj->addressModeU, "addressModeU", 1);

    print_VkSamplerAddressMode(obj->addressModeV, "addressModeV", 1);

    print_VkSamplerAddressMode(obj->addressModeW, "addressModeW", 1);

    print_float(obj->mipLodBias, "mipLodBias", 1);

    print_VkBool32(obj->anisotropyEnable, "anisotropyEnable", 1);

    print_float(obj->maxAnisotropy, "maxAnisotropy", 1);

    print_VkBool32(obj->compareEnable, "compareEnable", 1);

    print_VkCompareOp(obj->compareOp, "compareOp", 1);

    print_float(obj->minLod, "minLod", 1);

    print_float(obj->maxLod, "maxLod", 1);

    print_VkBorderColor(obj->borderColor, "borderColor", 1);

    print_VkBool32(obj->unnormalizedCoordinates, "unnormalizedCoordinates", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCopyDescriptorSet(VkCopyDescriptorSet obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcSet"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.srcBinding, "srcBinding", 1);

    print_uint32_t(obj.srcArrayElement, "srcArrayElement", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstSet"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.dstBinding, "dstBinding", 1);

    print_uint32_t(obj.dstArrayElement, "dstArrayElement", 1);

    print_uint32_t(obj.descriptorCount, "descriptorCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyDescriptorSet(const VkCopyDescriptorSet* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcSet"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->srcBinding, "srcBinding", 1);

    print_uint32_t(obj->srcArrayElement, "srcArrayElement", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstSet"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->dstBinding, "dstBinding", 1);

    print_uint32_t(obj->dstArrayElement, "dstArrayElement", 1);

    print_uint32_t(obj->descriptorCount, "descriptorCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorBufferInfo(VkDescriptorBufferInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.offset, "offset", 1);

    print_VkDeviceSize(obj.range, "range", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorBufferInfo(const VkDescriptorBufferInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->offset, "offset", 1);

    print_VkDeviceSize(obj->range, "range", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorImageInfo(VkDescriptorImageInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "sampler"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.imageLayout, "imageLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorImageInfo(const VkDescriptorImageInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "sampler"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->imageLayout, "imageLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorPoolSize(VkDescriptorPoolSize obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDescriptorType(obj.type, "type", 1);

    print_uint32_t(obj.descriptorCount, "descriptorCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorPoolSize(const VkDescriptorPoolSize* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDescriptorType(obj->type, "type", 1);

    print_uint32_t(obj->descriptorCount, "descriptorCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorPoolCreateInfo(VkDescriptorPoolCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDescriptorPoolCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.maxSets, "maxSets", 1);

    print_uint32_t(obj.poolSizeCount, "poolSizeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPoolSizes\": " << std::endl;
    if (obj.pPoolSizes) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.poolSizeCount; i++) {
            if (i + 1 == obj.poolSizeCount)
                print_VkDescriptorPoolSize(obj.pPoolSizes[i], "pPoolSizes", 0);
            else
                print_VkDescriptorPoolSize(obj.pPoolSizes[i], "pPoolSizes", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorPoolCreateInfo(const VkDescriptorPoolCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDescriptorPoolCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->maxSets, "maxSets", 1);

    print_uint32_t(obj->poolSizeCount, "poolSizeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPoolSizes\": " << std::endl;
    if (obj->pPoolSizes) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->poolSizeCount; i++) {
            if (i + 1 == obj->poolSizeCount)
                print_VkDescriptorPoolSize(obj->pPoolSizes[i], "pPoolSizes", 0);
            else
                print_VkDescriptorPoolSize(obj->pPoolSizes[i], "pPoolSizes", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorSetAllocateInfo(VkDescriptorSetAllocateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "descriptorPool"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.descriptorSetCount, "descriptorSetCount", 1);

    PRINT_SPACE
    _OUT << "\"pSetLayouts\":" << std::endl;
    PRINT_SPACE
    if (obj.pSetLayouts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.descriptorSetCount; i++) {
            std::stringstream tmp;
            tmp << "pSetLayouts"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.descriptorSetCount;
            print_VkDescriptorSetLayout(obj.pSetLayouts[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorSetAllocateInfo(const VkDescriptorSetAllocateInfo* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "descriptorPool"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->descriptorSetCount, "descriptorSetCount", 1);

    PRINT_SPACE
    _OUT << "\"pSetLayouts\":" << std::endl;
    PRINT_SPACE
    if (obj->pSetLayouts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->descriptorSetCount; i++) {
            std::stringstream tmp;
            tmp << "pSetLayouts"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->descriptorSetCount;
            print_VkDescriptorSetLayout(obj->pSetLayouts[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorSetLayoutBinding(VkDescriptorSetLayoutBinding obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.binding, "binding", 1);

    print_VkDescriptorType(obj.descriptorType, "descriptorType", 1);

    print_uint32_t(obj.descriptorCount, "descriptorCount", 1);

    print_VkShaderStageFlags(obj.stageFlags, "stageFlags", 1);

    PRINT_SPACE
    _OUT << "\"pImmutableSamplers\":" << std::endl;
    PRINT_SPACE
    if (obj.pImmutableSamplers) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.descriptorCount; i++) {
            std::stringstream tmp;
            tmp << "pImmutableSamplers"
                << "_" << (obj.binding) << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.descriptorCount;
            print_VkSampler(obj.pImmutableSamplers[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorSetLayoutBinding(const VkDescriptorSetLayoutBinding* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->binding, "binding", 1);

    print_VkDescriptorType(obj->descriptorType, "descriptorType", 1);

    print_uint32_t(obj->descriptorCount, "descriptorCount", 1);

    print_VkShaderStageFlags(obj->stageFlags, "stageFlags", 1);

    PRINT_SPACE
    _OUT << "\"pImmutableSamplers\":" << std::endl;
    PRINT_SPACE
    if (obj->pImmutableSamplers) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->descriptorCount; i++) {
            std::stringstream tmp;
            tmp << "pImmutableSamplers"
                << "_" << (obj->binding) << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->descriptorCount;
            print_VkSampler(obj->pImmutableSamplers[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorSetLayoutCreateInfo(VkDescriptorSetLayoutCreateInfo obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDescriptorSetLayoutCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.bindingCount, "bindingCount", 1);

    PRINT_SPACE
    _OUT << "\"pBindings\": " << std::endl;
    if (obj.pBindings) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.bindingCount; i++) {
            if (i + 1 == obj.bindingCount)
                print_VkDescriptorSetLayoutBinding(obj.pBindings[i], "pBindings", 0);
            else
                print_VkDescriptorSetLayoutBinding(obj.pBindings[i], "pBindings", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorSetLayoutCreateInfo(const VkDescriptorSetLayoutCreateInfo* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDescriptorSetLayoutCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->bindingCount, "bindingCount", 1);

    PRINT_SPACE
    _OUT << "\"pBindings\": " << std::endl;
    if (obj->pBindings) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->bindingCount; i++) {
            if (i + 1 == obj->bindingCount)
                print_VkDescriptorSetLayoutBinding(obj->pBindings[i], "pBindings", 0);
            else
                print_VkDescriptorSetLayoutBinding(obj->pBindings[i], "pBindings", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkWriteDescriptorSet(VkWriteDescriptorSet obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstSet"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.dstBinding, "dstBinding", 1);

    print_uint32_t(obj.dstArrayElement, "dstArrayElement", 1);

    print_uint32_t(obj.descriptorCount, "descriptorCount", 1);

    print_VkDescriptorType(obj.descriptorType, "descriptorType", 1);

    PRINT_SPACE
    _OUT << "\"pImageInfo\": " << std::endl;
    if (obj.pImageInfo) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.descriptorCount; i++) {
            if (i + 1 == obj.descriptorCount)
                print_VkDescriptorImageInfo(obj.pImageInfo[i], "pImageInfo", 0);
            else
                print_VkDescriptorImageInfo(obj.pImageInfo[i], "pImageInfo", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pBufferInfo\": " << std::endl;
    if (obj.pBufferInfo) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.descriptorCount; i++) {
            if (i + 1 == obj.descriptorCount)
                print_VkDescriptorBufferInfo(obj.pBufferInfo[i], "pBufferInfo", 0);
            else
                print_VkDescriptorBufferInfo(obj.pBufferInfo[i], "pBufferInfo", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pTexelBufferView\":" << std::endl;
    PRINT_SPACE
    if (obj.pTexelBufferView) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.descriptorCount; i++) {
            std::stringstream tmp;
            tmp << "pTexelBufferView"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.descriptorCount;
            print_VkBufferView(obj.pTexelBufferView[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkWriteDescriptorSet(const VkWriteDescriptorSet* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstSet"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->dstBinding, "dstBinding", 1);

    print_uint32_t(obj->dstArrayElement, "dstArrayElement", 1);

    print_uint32_t(obj->descriptorCount, "descriptorCount", 1);

    print_VkDescriptorType(obj->descriptorType, "descriptorType", 1);

    PRINT_SPACE
    _OUT << "\"pImageInfo\": " << std::endl;
    if (obj->pImageInfo) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->descriptorCount; i++) {
            if (i + 1 == obj->descriptorCount)
                print_VkDescriptorImageInfo(obj->pImageInfo[i], "pImageInfo", 0);
            else
                print_VkDescriptorImageInfo(obj->pImageInfo[i], "pImageInfo", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pBufferInfo\": " << std::endl;
    if (obj->pBufferInfo) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->descriptorCount; i++) {
            if (i + 1 == obj->descriptorCount)
                print_VkDescriptorBufferInfo(obj->pBufferInfo[i], "pBufferInfo", 0);
            else
                print_VkDescriptorBufferInfo(obj->pBufferInfo[i], "pBufferInfo", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pTexelBufferView\":" << std::endl;
    PRINT_SPACE
    if (obj->pTexelBufferView) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->descriptorCount; i++) {
            std::stringstream tmp;
            tmp << "pTexelBufferView"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->descriptorCount;
            print_VkBufferView(obj->pTexelBufferView[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAttachmentDescription(VkAttachmentDescription obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkAttachmentDescriptionFlags(obj.flags, "flags", 1);

    print_VkFormat(obj.format, "format", 1);

    print_VkSampleCountFlagBits(obj.samples, "samples", 1);

    print_VkAttachmentLoadOp(obj.loadOp, "loadOp", 1);

    print_VkAttachmentStoreOp(obj.storeOp, "storeOp", 1);

    print_VkAttachmentLoadOp(obj.stencilLoadOp, "stencilLoadOp", 1);

    print_VkAttachmentStoreOp(obj.stencilStoreOp, "stencilStoreOp", 1);

    print_VkImageLayout(obj.initialLayout, "initialLayout", 1);

    print_VkImageLayout(obj.finalLayout, "finalLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAttachmentDescription(const VkAttachmentDescription* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkAttachmentDescriptionFlags(obj->flags, "flags", 1);

    print_VkFormat(obj->format, "format", 1);

    print_VkSampleCountFlagBits(obj->samples, "samples", 1);

    print_VkAttachmentLoadOp(obj->loadOp, "loadOp", 1);

    print_VkAttachmentStoreOp(obj->storeOp, "storeOp", 1);

    print_VkAttachmentLoadOp(obj->stencilLoadOp, "stencilLoadOp", 1);

    print_VkAttachmentStoreOp(obj->stencilStoreOp, "stencilStoreOp", 1);

    print_VkImageLayout(obj->initialLayout, "initialLayout", 1);

    print_VkImageLayout(obj->finalLayout, "finalLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAttachmentReference(VkAttachmentReference obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.attachment, "attachment", 1);

    print_VkImageLayout(obj.layout, "layout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAttachmentReference(const VkAttachmentReference* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->attachment, "attachment", 1);

    print_VkImageLayout(obj->layout, "layout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkFramebufferCreateInfo(VkFramebufferCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFramebufferCreateFlags(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "renderPass"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.attachmentCount, "attachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachments\":" << std::endl;
    PRINT_SPACE
    if (obj.pAttachments) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.attachmentCount; i++) {
            std::stringstream tmp;
            tmp << "pAttachments"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.attachmentCount;
            print_VkImageView(obj.pAttachments[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.width, "width", 1);

    print_uint32_t(obj.height, "height", 1);

    print_uint32_t(obj.layers, "layers", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkFramebufferCreateInfo(const VkFramebufferCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFramebufferCreateFlags(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "renderPass"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->attachmentCount, "attachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachments\":" << std::endl;
    PRINT_SPACE
    if (obj->pAttachments) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->attachmentCount; i++) {
            std::stringstream tmp;
            tmp << "pAttachments"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->attachmentCount;
            print_VkImageView(obj->pAttachments[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->width, "width", 1);

    print_uint32_t(obj->height, "height", 1);

    print_uint32_t(obj->layers, "layers", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubpassDescription(VkSubpassDescription obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkSubpassDescriptionFlags(obj.flags, "flags", 1);

    print_VkPipelineBindPoint(obj.pipelineBindPoint, "pipelineBindPoint", 1);

    print_uint32_t(obj.inputAttachmentCount, "inputAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pInputAttachments\": " << std::endl;
    if (obj.pInputAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.inputAttachmentCount; i++) {
            if (i + 1 == obj.inputAttachmentCount)
                print_VkAttachmentReference(obj.pInputAttachments[i], "pInputAttachments", 0);
            else
                print_VkAttachmentReference(obj.pInputAttachments[i], "pInputAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachments\": " << std::endl;
    if (obj.pColorAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.colorAttachmentCount; i++) {
            if (i + 1 == obj.colorAttachmentCount)
                print_VkAttachmentReference(obj.pColorAttachments[i], "pColorAttachments", 0);
            else
                print_VkAttachmentReference(obj.pColorAttachments[i], "pColorAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pResolveAttachments\": " << std::endl;
    if (obj.pResolveAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.colorAttachmentCount; i++) {
            if (i + 1 == obj.colorAttachmentCount)
                print_VkAttachmentReference(obj.pResolveAttachments[i], "pResolveAttachments", 0);
            else
                print_VkAttachmentReference(obj.pResolveAttachments[i], "pResolveAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pDepthStencilAttachment\": " << std::endl;
    if (obj.pDepthStencilAttachment) {
        print_VkAttachmentReference(obj.pDepthStencilAttachment, "pDepthStencilAttachment", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.preserveAttachmentCount, "preserveAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pPreserveAttachments\":" << std::endl;
    PRINT_SPACE
    if (obj.pPreserveAttachments) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.preserveAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.preserveAttachmentCount;
            print_uint32_t(obj.pPreserveAttachments[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubpassDescription(const VkSubpassDescription* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkSubpassDescriptionFlags(obj->flags, "flags", 1);

    print_VkPipelineBindPoint(obj->pipelineBindPoint, "pipelineBindPoint", 1);

    print_uint32_t(obj->inputAttachmentCount, "inputAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pInputAttachments\": " << std::endl;
    if (obj->pInputAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->inputAttachmentCount; i++) {
            if (i + 1 == obj->inputAttachmentCount)
                print_VkAttachmentReference(obj->pInputAttachments[i], "pInputAttachments", 0);
            else
                print_VkAttachmentReference(obj->pInputAttachments[i], "pInputAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachments\": " << std::endl;
    if (obj->pColorAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->colorAttachmentCount; i++) {
            if (i + 1 == obj->colorAttachmentCount)
                print_VkAttachmentReference(obj->pColorAttachments[i], "pColorAttachments", 0);
            else
                print_VkAttachmentReference(obj->pColorAttachments[i], "pColorAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pResolveAttachments\": " << std::endl;
    if (obj->pResolveAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->colorAttachmentCount; i++) {
            if (i + 1 == obj->colorAttachmentCount)
                print_VkAttachmentReference(obj->pResolveAttachments[i], "pResolveAttachments", 0);
            else
                print_VkAttachmentReference(obj->pResolveAttachments[i], "pResolveAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pDepthStencilAttachment\": " << std::endl;
    if (obj->pDepthStencilAttachment) {
        print_VkAttachmentReference(obj->pDepthStencilAttachment, "pDepthStencilAttachment", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->preserveAttachmentCount, "preserveAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pPreserveAttachments\":" << std::endl;
    PRINT_SPACE
    if (obj->pPreserveAttachments) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->preserveAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->preserveAttachmentCount;
            print_uint32_t(obj->pPreserveAttachments[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubpassDependency(VkSubpassDependency obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.srcSubpass, "srcSubpass", 1);

    print_uint32_t(obj.dstSubpass, "dstSubpass", 1);

    print_VkPipelineStageFlags(obj.srcStageMask, "srcStageMask", 1);

    print_VkPipelineStageFlags(obj.dstStageMask, "dstStageMask", 1);

    print_VkAccessFlags(obj.srcAccessMask, "srcAccessMask", 1);

    print_VkAccessFlags(obj.dstAccessMask, "dstAccessMask", 1);

    print_VkDependencyFlags(obj.dependencyFlags, "dependencyFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubpassDependency(const VkSubpassDependency* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->srcSubpass, "srcSubpass", 1);

    print_uint32_t(obj->dstSubpass, "dstSubpass", 1);

    print_VkPipelineStageFlags(obj->srcStageMask, "srcStageMask", 1);

    print_VkPipelineStageFlags(obj->dstStageMask, "dstStageMask", 1);

    print_VkAccessFlags(obj->srcAccessMask, "srcAccessMask", 1);

    print_VkAccessFlags(obj->dstAccessMask, "dstAccessMask", 1);

    print_VkDependencyFlags(obj->dependencyFlags, "dependencyFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassCreateInfo(VkRenderPassCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRenderPassCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.attachmentCount, "attachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachments\": " << std::endl;
    if (obj.pAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.attachmentCount; i++) {
            if (i + 1 == obj.attachmentCount)
                print_VkAttachmentDescription(obj.pAttachments[i], "pAttachments", 0);
            else
                print_VkAttachmentDescription(obj.pAttachments[i], "pAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.subpassCount, "subpassCount", 1);

    PRINT_SPACE
    _OUT << "\"pSubpasses\": " << std::endl;
    if (obj.pSubpasses) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.subpassCount; i++) {
            if (i + 1 == obj.subpassCount)
                print_VkSubpassDescription(obj.pSubpasses[i], "pSubpasses", 0);
            else
                print_VkSubpassDescription(obj.pSubpasses[i], "pSubpasses", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.dependencyCount, "dependencyCount", 1);

    PRINT_SPACE
    _OUT << "\"pDependencies\": " << std::endl;
    if (obj.pDependencies) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.dependencyCount; i++) {
            if (i + 1 == obj.dependencyCount)
                print_VkSubpassDependency(obj.pDependencies[i], "pDependencies", 0);
            else
                print_VkSubpassDependency(obj.pDependencies[i], "pDependencies", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassCreateInfo(const VkRenderPassCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRenderPassCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->attachmentCount, "attachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachments\": " << std::endl;
    if (obj->pAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->attachmentCount; i++) {
            if (i + 1 == obj->attachmentCount)
                print_VkAttachmentDescription(obj->pAttachments[i], "pAttachments", 0);
            else
                print_VkAttachmentDescription(obj->pAttachments[i], "pAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->subpassCount, "subpassCount", 1);

    PRINT_SPACE
    _OUT << "\"pSubpasses\": " << std::endl;
    if (obj->pSubpasses) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->subpassCount; i++) {
            if (i + 1 == obj->subpassCount)
                print_VkSubpassDescription(obj->pSubpasses[i], "pSubpasses", 0);
            else
                print_VkSubpassDescription(obj->pSubpasses[i], "pSubpasses", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->dependencyCount, "dependencyCount", 1);

    PRINT_SPACE
    _OUT << "\"pDependencies\": " << std::endl;
    if (obj->pDependencies) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->dependencyCount; i++) {
            if (i + 1 == obj->dependencyCount)
                print_VkSubpassDependency(obj->pDependencies[i], "pDependencies", 0);
            else
                print_VkSubpassDependency(obj->pDependencies[i], "pDependencies", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCommandPoolCreateInfo(VkCommandPoolCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkCommandPoolCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.queueFamilyIndex, "queueFamilyIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCommandPoolCreateInfo(const VkCommandPoolCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkCommandPoolCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->queueFamilyIndex, "queueFamilyIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCommandBufferAllocateInfo(VkCommandBufferAllocateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "commandPool"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkCommandBufferLevel(obj.level, "level", 1);

    print_uint32_t(obj.commandBufferCount, "commandBufferCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCommandBufferAllocateInfo(const VkCommandBufferAllocateInfo* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "commandPool"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkCommandBufferLevel(obj->level, "level", 1);

    print_uint32_t(obj->commandBufferCount, "commandBufferCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCommandBufferInheritanceInfo(VkCommandBufferInheritanceInfo obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "renderPass"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.subpass, "subpass", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "framebuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkBool32(obj.occlusionQueryEnable, "occlusionQueryEnable", 1);

    print_VkQueryControlFlags(obj.queryFlags, "queryFlags", 1);

    print_VkQueryPipelineStatisticFlags(obj.pipelineStatistics, "pipelineStatistics", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCommandBufferInheritanceInfo(const VkCommandBufferInheritanceInfo* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "renderPass"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->subpass, "subpass", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "framebuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkBool32(obj->occlusionQueryEnable, "occlusionQueryEnable", 1);

    print_VkQueryControlFlags(obj->queryFlags, "queryFlags", 1);

    print_VkQueryPipelineStatisticFlags(obj->pipelineStatistics, "pipelineStatistics", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCommandBufferBeginInfo(VkCommandBufferBeginInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkCommandBufferUsageFlags(obj.flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"pInheritanceInfo\": " << std::endl;
    if (obj.pInheritanceInfo) {
        print_VkCommandBufferInheritanceInfo(obj.pInheritanceInfo, "pInheritanceInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCommandBufferBeginInfo(const VkCommandBufferBeginInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkCommandBufferUsageFlags(obj->flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"pInheritanceInfo\": " << std::endl;
    if (obj->pInheritanceInfo) {
        print_VkCommandBufferInheritanceInfo(obj->pInheritanceInfo, "pInheritanceInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBufferCopy(VkBufferCopy obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceSize(obj.srcOffset, "srcOffset", 1);

    print_VkDeviceSize(obj.dstOffset, "dstOffset", 1);

    print_VkDeviceSize(obj.size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferCopy(const VkBufferCopy* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceSize(obj->srcOffset, "srcOffset", 1);

    print_VkDeviceSize(obj->dstOffset, "dstOffset", 1);

    print_VkDeviceSize(obj->size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageSubresourceLayers(VkImageSubresourceLayers obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkImageAspectFlags(obj.aspectMask, "aspectMask", 1);

    print_uint32_t(obj.mipLevel, "mipLevel", 1);

    print_uint32_t(obj.baseArrayLayer, "baseArrayLayer", 1);

    print_uint32_t(obj.layerCount, "layerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageSubresourceLayers(const VkImageSubresourceLayers* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkImageAspectFlags(obj->aspectMask, "aspectMask", 1);

    print_uint32_t(obj->mipLevel, "mipLevel", 1);

    print_uint32_t(obj->baseArrayLayer, "baseArrayLayer", 1);

    print_uint32_t(obj->layerCount, "layerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBufferImageCopy(VkBufferImageCopy obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceSize(obj.bufferOffset, "bufferOffset", 1);

    print_uint32_t(obj.bufferRowLength, "bufferRowLength", 1);

    print_uint32_t(obj.bufferImageHeight, "bufferImageHeight", 1);

    PRINT_SPACE
    _OUT << "\"imageSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.imageSubresource, "imageSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"imageOffset\": " << std::endl;
    { print_VkOffset3D(obj.imageOffset, "imageOffset", 1); }

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent3D(obj.imageExtent, "imageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferImageCopy(const VkBufferImageCopy* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceSize(obj->bufferOffset, "bufferOffset", 1);

    print_uint32_t(obj->bufferRowLength, "bufferRowLength", 1);

    print_uint32_t(obj->bufferImageHeight, "bufferImageHeight", 1);

    PRINT_SPACE
    _OUT << "\"imageSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->imageSubresource, "imageSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"imageOffset\": " << std::endl;
    { print_VkOffset3D(obj->imageOffset, "imageOffset", 1); }

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent3D(obj->imageExtent, "imageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClearColorValue(VkClearColorValue obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"float32\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 4; i++) {
        bool isCommaNeeded = (i + 1) != 4;
        print_float(obj.float32[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"int32\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 4; i++) {
        bool isCommaNeeded = (i + 1) != 4;
        print_int32_t(obj.int32[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"uint32\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 4; i++) {
        bool isCommaNeeded = (i + 1) != 4;
        print_uint32_t(obj.uint32[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClearColorValue(const VkClearColorValue* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"float32\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 4; i++) {
        bool isCommaNeeded = (i + 1) != 4;
        print_float(obj->float32[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"int32\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 4; i++) {
        bool isCommaNeeded = (i + 1) != 4;
        print_int32_t(obj->int32[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"uint32\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 4; i++) {
        bool isCommaNeeded = (i + 1) != 4;
        print_uint32_t(obj->uint32[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClearDepthStencilValue(VkClearDepthStencilValue obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj.depth, "depth", 1);

    print_uint32_t(obj.stencil, "stencil", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClearDepthStencilValue(const VkClearDepthStencilValue* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj->depth, "depth", 1);

    print_uint32_t(obj->stencil, "stencil", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClearValue(VkClearValue obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkClearColorValue(obj.color, "color", 1);

    PRINT_SPACE
    _OUT << "\"depthStencil\": " << std::endl;
    { print_VkClearDepthStencilValue(obj.depthStencil, "depthStencil", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClearValue(const VkClearValue* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkClearColorValue(obj->color, "color", 1);

    PRINT_SPACE
    _OUT << "\"depthStencil\": " << std::endl;
    { print_VkClearDepthStencilValue(obj->depthStencil, "depthStencil", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClearAttachment(VkClearAttachment obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkImageAspectFlags(obj.aspectMask, "aspectMask", 1);

    print_uint32_t(obj.colorAttachment, "colorAttachment", 1);

    print_VkClearValue(obj.clearValue, "clearValue", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClearAttachment(const VkClearAttachment* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkImageAspectFlags(obj->aspectMask, "aspectMask", 1);

    print_uint32_t(obj->colorAttachment, "colorAttachment", 1);

    print_VkClearValue(obj->clearValue, "clearValue", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClearRect(VkClearRect obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"rect\": " << std::endl;
    { print_VkRect2D(obj.rect, "rect", 1); }

    print_uint32_t(obj.baseArrayLayer, "baseArrayLayer", 1);

    print_uint32_t(obj.layerCount, "layerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClearRect(const VkClearRect* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"rect\": " << std::endl;
    { print_VkRect2D(obj->rect, "rect", 1); }

    print_uint32_t(obj->baseArrayLayer, "baseArrayLayer", 1);

    print_uint32_t(obj->layerCount, "layerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageBlit(VkImageBlit obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"srcSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.srcSubresource, "srcSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"srcOffsets\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_VkOffset3D(obj.srcOffsets[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"dstSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.dstSubresource, "dstSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"dstOffsets\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_VkOffset3D(obj.dstOffsets[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageBlit(const VkImageBlit* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"srcSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->srcSubresource, "srcSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"srcOffsets\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_VkOffset3D(obj->srcOffsets[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"dstSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->dstSubresource, "dstSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"dstOffsets\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_VkOffset3D(obj->dstOffsets[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageCopy(VkImageCopy obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"srcSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.srcSubresource, "srcSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"srcOffset\": " << std::endl;
    { print_VkOffset3D(obj.srcOffset, "srcOffset", 1); }

    PRINT_SPACE
    _OUT << "\"dstSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.dstSubresource, "dstSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"dstOffset\": " << std::endl;
    { print_VkOffset3D(obj.dstOffset, "dstOffset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent3D(obj.extent, "extent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageCopy(const VkImageCopy* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"srcSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->srcSubresource, "srcSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"srcOffset\": " << std::endl;
    { print_VkOffset3D(obj->srcOffset, "srcOffset", 1); }

    PRINT_SPACE
    _OUT << "\"dstSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->dstSubresource, "dstSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"dstOffset\": " << std::endl;
    { print_VkOffset3D(obj->dstOffset, "dstOffset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent3D(obj->extent, "extent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageResolve(VkImageResolve obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"srcSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.srcSubresource, "srcSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"srcOffset\": " << std::endl;
    { print_VkOffset3D(obj.srcOffset, "srcOffset", 1); }

    PRINT_SPACE
    _OUT << "\"dstSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.dstSubresource, "dstSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"dstOffset\": " << std::endl;
    { print_VkOffset3D(obj.dstOffset, "dstOffset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent3D(obj.extent, "extent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageResolve(const VkImageResolve* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"srcSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->srcSubresource, "srcSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"srcOffset\": " << std::endl;
    { print_VkOffset3D(obj->srcOffset, "srcOffset", 1); }

    PRINT_SPACE
    _OUT << "\"dstSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->dstSubresource, "dstSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"dstOffset\": " << std::endl;
    { print_VkOffset3D(obj->dstOffset, "dstOffset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent3D(obj->extent, "extent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassBeginInfo(VkRenderPassBeginInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "renderPass"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "framebuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"renderArea\": " << std::endl;
    { print_VkRect2D(obj.renderArea, "renderArea", 1); }

    print_uint32_t(obj.clearValueCount, "clearValueCount", 1);

    PRINT_SPACE
    _OUT << "\"pClearValues\":" << std::endl;
    PRINT_SPACE
    if (obj.pClearValues) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.clearValueCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.clearValueCount;
            print_VkClearValue(obj.pClearValues[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassBeginInfo(const VkRenderPassBeginInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "renderPass"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "framebuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"renderArea\": " << std::endl;
    { print_VkRect2D(obj->renderArea, "renderArea", 1); }

    print_uint32_t(obj->clearValueCount, "clearValueCount", 1);

    PRINT_SPACE
    _OUT << "\"pClearValues\":" << std::endl;
    PRINT_SPACE
    if (obj->pClearValues) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->clearValueCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->clearValueCount;
            print_VkClearValue(obj->pClearValues[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSamplerYcbcrConversion(VkSamplerYcbcrConversion obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkDescriptorUpdateTemplate(VkDescriptorUpdateTemplate obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSubgroupFeatureFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_SUBGROUP_FEATURE_BASIC_BIT"),
    std::make_pair(1ULL << 1, "VK_SUBGROUP_FEATURE_VOTE_BIT"),
    std::make_pair(1ULL << 2, "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT"),
    std::make_pair(1ULL << 3, "VK_SUBGROUP_FEATURE_BALLOT_BIT"),
    std::make_pair(1ULL << 4, "VK_SUBGROUP_FEATURE_SHUFFLE_BIT"),
    std::make_pair(1ULL << 5, "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT"),
    std::make_pair(1ULL << 6, "VK_SUBGROUP_FEATURE_CLUSTERED_BIT"),
    std::make_pair(1ULL << 7, "VK_SUBGROUP_FEATURE_QUAD_BIT"),
    std::make_pair(1ULL << 9, "VK_SUBGROUP_FEATURE_ROTATE_BIT"),
    std::make_pair(1ULL << 10, "VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT"),
    std::make_pair(1ULL << 8, "VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV"),
};
static void print_VkSubgroupFeatureFlagBits(VkSubgroupFeatureFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSubgroupFeatureFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSubgroupFeatureFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkSubgroupFeatureFlagBits(const VkSubgroupFeatureFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSubgroupFeatureFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSubgroupFeatureFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPeerMemoryFeatureFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT"),
    std::make_pair(1ULL << 1, "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT"),
    std::make_pair(1ULL << 2, "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT"),
    std::make_pair(1ULL << 3, "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT"),
};
static void print_VkPeerMemoryFeatureFlagBits(VkPeerMemoryFeatureFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPeerMemoryFeatureFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPeerMemoryFeatureFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkPeerMemoryFeatureFlagBits(const VkPeerMemoryFeatureFlagBits* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPeerMemoryFeatureFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPeerMemoryFeatureFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkMemoryAllocateFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT"),
    std::make_pair(1ULL << 1, "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT"),
    std::make_pair(1ULL << 2, "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"),
};
static void print_VkMemoryAllocateFlagBits(VkMemoryAllocateFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryAllocateFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryAllocateFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkMemoryAllocateFlagBits(const VkMemoryAllocateFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryAllocateFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryAllocateFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPointClippingBehavior_map = {
    std::make_pair(0, "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES"),
    std::make_pair(1, "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY"),
};
static void print_VkPointClippingBehavior(VkPointClippingBehavior obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPointClippingBehavior_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPointClippingBehavior_map[obj] << "\"" << std::endl;
}
static void print_VkPointClippingBehavior(const VkPointClippingBehavior* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPointClippingBehavior_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPointClippingBehavior_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkTessellationDomainOrigin_map = {
    std::make_pair(0, "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT"),
    std::make_pair(1, "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT"),
};
static void print_VkTessellationDomainOrigin(VkTessellationDomainOrigin obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkTessellationDomainOrigin_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkTessellationDomainOrigin_map[obj] << "\"" << std::endl;
}
static void print_VkTessellationDomainOrigin(const VkTessellationDomainOrigin* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkTessellationDomainOrigin_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkTessellationDomainOrigin_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSamplerYcbcrModelConversion_map = {
    std::make_pair(0, "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY"),
    std::make_pair(1, "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY"),
    std::make_pair(2, "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709"),
    std::make_pair(3, "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601"),
    std::make_pair(4, "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020"),
};
static void print_VkSamplerYcbcrModelConversion(VkSamplerYcbcrModelConversion obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerYcbcrModelConversion_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerYcbcrModelConversion_map[obj] << "\"" << std::endl;
}
static void print_VkSamplerYcbcrModelConversion(const VkSamplerYcbcrModelConversion* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerYcbcrModelConversion_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerYcbcrModelConversion_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSamplerYcbcrRange_map = {
    std::make_pair(0, "VK_SAMPLER_YCBCR_RANGE_ITU_FULL"),
    std::make_pair(1, "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW"),
};
static void print_VkSamplerYcbcrRange(VkSamplerYcbcrRange obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerYcbcrRange_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerYcbcrRange_map[obj] << "\"" << std::endl;
}
static void print_VkSamplerYcbcrRange(const VkSamplerYcbcrRange* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerYcbcrRange_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerYcbcrRange_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkChromaLocation_map = {
    std::make_pair(0, "VK_CHROMA_LOCATION_COSITED_EVEN"),
    std::make_pair(1, "VK_CHROMA_LOCATION_MIDPOINT"),
};
static void print_VkChromaLocation(VkChromaLocation obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkChromaLocation_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkChromaLocation_map[obj] << "\"" << std::endl;
}
static void print_VkChromaLocation(const VkChromaLocation* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkChromaLocation_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkChromaLocation_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDescriptorUpdateTemplateType_map = {
    std::make_pair(0, "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"),
    std::make_pair(1, "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS"),
};
static void print_VkDescriptorUpdateTemplateType(VkDescriptorUpdateTemplateType obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorUpdateTemplateType_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorUpdateTemplateType_map[obj] << "\"" << std::endl;
}
static void print_VkDescriptorUpdateTemplateType(const VkDescriptorUpdateTemplateType* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorUpdateTemplateType_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorUpdateTemplateType_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkExternalMemoryHandleTypeFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT"),
    std::make_pair(1ULL << 2, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"),
    std::make_pair(1ULL << 3, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT"),
    std::make_pair(1ULL << 4, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT"),
    std::make_pair(1ULL << 5, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT"),
    std::make_pair(1ULL << 6, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT"),
    std::make_pair(1ULL << 9, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT"),
    std::make_pair(1ULL << 10, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID"),
    std::make_pair(1ULL << 7, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT"),
    std::make_pair(1ULL << 8, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT"),
    std::make_pair(1ULL << 11, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA"),
    std::make_pair(1ULL << 12, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV"),
    std::make_pair(1ULL << 13, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV"),
    std::make_pair(1ULL << 14, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX"),
    std::make_pair(1ULL << 15, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_590_BIT_HUAWEI"),
    std::make_pair(1ULL << 16, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT"),
    std::make_pair(1ULL << 17, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT"),
    std::make_pair(1ULL << 18, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT"),
};
static void print_VkExternalMemoryHandleTypeFlagBits(VkExternalMemoryHandleTypeFlagBits obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalMemoryHandleTypeFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalMemoryHandleTypeFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkExternalMemoryHandleTypeFlagBits(const VkExternalMemoryHandleTypeFlagBits* obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalMemoryHandleTypeFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalMemoryHandleTypeFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkExternalMemoryFeatureFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT"),
    std::make_pair(1ULL << 2, "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT"),
};
static void print_VkExternalMemoryFeatureFlagBits(VkExternalMemoryFeatureFlagBits obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalMemoryFeatureFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalMemoryFeatureFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkExternalMemoryFeatureFlagBits(const VkExternalMemoryFeatureFlagBits* obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalMemoryFeatureFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalMemoryFeatureFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkExternalFenceHandleTypeFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT"),
    std::make_pair(1ULL << 2, "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"),
    std::make_pair(1ULL << 3, "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT"),
    std::make_pair(1ULL << 4, "VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"),
    std::make_pair(1ULL << 5, "VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV"),
    std::make_pair(1ULL << 4, "VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"),
    std::make_pair(1ULL << 5, "VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV"),
};
static void print_VkExternalFenceHandleTypeFlagBits(VkExternalFenceHandleTypeFlagBits obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalFenceHandleTypeFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalFenceHandleTypeFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkExternalFenceHandleTypeFlagBits(const VkExternalFenceHandleTypeFlagBits* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalFenceHandleTypeFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalFenceHandleTypeFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkExternalFenceFeatureFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT"),
};
static void print_VkExternalFenceFeatureFlagBits(VkExternalFenceFeatureFlagBits obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalFenceFeatureFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalFenceFeatureFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkExternalFenceFeatureFlagBits(const VkExternalFenceFeatureFlagBits* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalFenceFeatureFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalFenceFeatureFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkFenceImportFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_FENCE_IMPORT_TEMPORARY_BIT"),
};
static void print_VkFenceImportFlagBits(VkFenceImportFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFenceImportFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFenceImportFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkFenceImportFlagBits(const VkFenceImportFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFenceImportFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFenceImportFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSemaphoreImportFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT"),
};
static void print_VkSemaphoreImportFlagBits(VkSemaphoreImportFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSemaphoreImportFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSemaphoreImportFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkSemaphoreImportFlagBits(const VkSemaphoreImportFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSemaphoreImportFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSemaphoreImportFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkExternalSemaphoreHandleTypeFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT"),
    std::make_pair(1ULL << 2, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"),
    std::make_pair(1ULL << 3, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"),
    std::make_pair(1ULL << 4, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT"),
    std::make_pair(1ULL << 7, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA"),
    std::make_pair(1ULL << 5, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"),
};
static void print_VkExternalSemaphoreHandleTypeFlagBits(VkExternalSemaphoreHandleTypeFlagBits obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalSemaphoreHandleTypeFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalSemaphoreHandleTypeFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkExternalSemaphoreHandleTypeFlagBits(const VkExternalSemaphoreHandleTypeFlagBits* obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalSemaphoreHandleTypeFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalSemaphoreHandleTypeFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkExternalSemaphoreFeatureFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT"),
};
static void print_VkExternalSemaphoreFeatureFlagBits(VkExternalSemaphoreFeatureFlagBits obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalSemaphoreFeatureFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalSemaphoreFeatureFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkExternalSemaphoreFeatureFlagBits(const VkExternalSemaphoreFeatureFlagBits* obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalSemaphoreFeatureFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalSemaphoreFeatureFlagBits_map[*obj] << "\"" << std::endl;
}

static void print_VkSubgroupFeatureFlags(VkSubgroupFeatureFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkSubgroupFeatureFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkSubgroupFeatureFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPeerMemoryFeatureFlags(VkPeerMemoryFeatureFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPeerMemoryFeatureFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkPeerMemoryFeatureFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkMemoryAllocateFlags(VkMemoryAllocateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkMemoryAllocateFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkMemoryAllocateFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkCommandPoolTrimFlags(VkCommandPoolTrimFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkDescriptorUpdateTemplateCreateFlags(VkDescriptorUpdateTemplateCreateFlags obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkExternalMemoryHandleTypeFlags(VkExternalMemoryHandleTypeFlags obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkExternalMemoryHandleTypeFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkExternalMemoryHandleTypeFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkExternalMemoryFeatureFlags(VkExternalMemoryFeatureFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkExternalMemoryFeatureFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkExternalMemoryFeatureFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkExternalFenceHandleTypeFlags(VkExternalFenceHandleTypeFlags obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkExternalFenceHandleTypeFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkExternalFenceHandleTypeFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkExternalFenceFeatureFlags(VkExternalFenceFeatureFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkExternalFenceFeatureFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkExternalFenceFeatureFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkFenceImportFlags(VkFenceImportFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkFenceImportFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkFenceImportFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkSemaphoreImportFlags(VkSemaphoreImportFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkSemaphoreImportFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkSemaphoreImportFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkExternalSemaphoreHandleTypeFlags(VkExternalSemaphoreHandleTypeFlags obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkExternalSemaphoreHandleTypeFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkExternalSemaphoreHandleTypeFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkExternalSemaphoreFeatureFlags(VkExternalSemaphoreFeatureFlags obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkExternalSemaphoreFeatureFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkExternalSemaphoreFeatureFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceSubgroupProperties(VkPhysicalDeviceSubgroupProperties obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.subgroupSize, "subgroupSize", 1);

    print_VkShaderStageFlags(obj.supportedStages, "supportedStages", 1);

    print_VkSubgroupFeatureFlags(obj.supportedOperations, "supportedOperations", 1);

    print_VkBool32(obj.quadOperationsInAllStages, "quadOperationsInAllStages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSubgroupProperties(const VkPhysicalDeviceSubgroupProperties* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->subgroupSize, "subgroupSize", 1);

    print_VkShaderStageFlags(obj->supportedStages, "supportedStages", 1);

    print_VkSubgroupFeatureFlags(obj->supportedOperations, "supportedOperations", 1);

    print_VkBool32(obj->quadOperationsInAllStages, "quadOperationsInAllStages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindBufferMemoryInfo(VkBindBufferMemoryInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.memoryOffset, "memoryOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindBufferMemoryInfo(const VkBindBufferMemoryInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->memoryOffset, "memoryOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindImageMemoryInfo(VkBindImageMemoryInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.memoryOffset, "memoryOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindImageMemoryInfo(const VkBindImageMemoryInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->memoryOffset, "memoryOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevice16BitStorageFeatures(VkPhysicalDevice16BitStorageFeatures obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.storageBuffer16BitAccess, "storageBuffer16BitAccess", 1);

    print_VkBool32(obj.uniformAndStorageBuffer16BitAccess, "uniformAndStorageBuffer16BitAccess", 1);

    print_VkBool32(obj.storagePushConstant16, "storagePushConstant16", 1);

    print_VkBool32(obj.storageInputOutput16, "storageInputOutput16", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevice16BitStorageFeatures(const VkPhysicalDevice16BitStorageFeatures* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->storageBuffer16BitAccess, "storageBuffer16BitAccess", 1);

    print_VkBool32(obj->uniformAndStorageBuffer16BitAccess, "uniformAndStorageBuffer16BitAccess", 1);

    print_VkBool32(obj->storagePushConstant16, "storagePushConstant16", 1);

    print_VkBool32(obj->storageInputOutput16, "storageInputOutput16", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryDedicatedRequirements(VkMemoryDedicatedRequirements obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.prefersDedicatedAllocation, "prefersDedicatedAllocation", 1);

    print_VkBool32(obj.requiresDedicatedAllocation, "requiresDedicatedAllocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryDedicatedRequirements(const VkMemoryDedicatedRequirements* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->prefersDedicatedAllocation, "prefersDedicatedAllocation", 1);

    print_VkBool32(obj->requiresDedicatedAllocation, "requiresDedicatedAllocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryDedicatedAllocateInfo(VkMemoryDedicatedAllocateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryDedicatedAllocateInfo(const VkMemoryDedicatedAllocateInfo* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryAllocateFlagsInfo(VkMemoryAllocateFlagsInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMemoryAllocateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.deviceMask, "deviceMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryAllocateFlagsInfo(const VkMemoryAllocateFlagsInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMemoryAllocateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->deviceMask, "deviceMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceGroupRenderPassBeginInfo(VkDeviceGroupRenderPassBeginInfo obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.deviceMask, "deviceMask", 1);

    print_uint32_t(obj.deviceRenderAreaCount, "deviceRenderAreaCount", 1);

    PRINT_SPACE
    _OUT << "\"pDeviceRenderAreas\": " << std::endl;
    if (obj.pDeviceRenderAreas) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.deviceRenderAreaCount; i++) {
            if (i + 1 == obj.deviceRenderAreaCount)
                print_VkRect2D(obj.pDeviceRenderAreas[i], "pDeviceRenderAreas", 0);
            else
                print_VkRect2D(obj.pDeviceRenderAreas[i], "pDeviceRenderAreas", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceGroupRenderPassBeginInfo(const VkDeviceGroupRenderPassBeginInfo* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->deviceMask, "deviceMask", 1);

    print_uint32_t(obj->deviceRenderAreaCount, "deviceRenderAreaCount", 1);

    PRINT_SPACE
    _OUT << "\"pDeviceRenderAreas\": " << std::endl;
    if (obj->pDeviceRenderAreas) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->deviceRenderAreaCount; i++) {
            if (i + 1 == obj->deviceRenderAreaCount)
                print_VkRect2D(obj->pDeviceRenderAreas[i], "pDeviceRenderAreas", 0);
            else
                print_VkRect2D(obj->pDeviceRenderAreas[i], "pDeviceRenderAreas", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceGroupCommandBufferBeginInfo(VkDeviceGroupCommandBufferBeginInfo obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.deviceMask, "deviceMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceGroupCommandBufferBeginInfo(const VkDeviceGroupCommandBufferBeginInfo* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->deviceMask, "deviceMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceGroupSubmitInfo(VkDeviceGroupSubmitInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.waitSemaphoreCount, "waitSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pWaitSemaphoreDeviceIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pWaitSemaphoreDeviceIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.waitSemaphoreCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.waitSemaphoreCount;
            print_uint32_t(obj.pWaitSemaphoreDeviceIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.commandBufferCount, "commandBufferCount", 1);

    PRINT_SPACE
    _OUT << "\"pCommandBufferDeviceMasks\":" << std::endl;
    PRINT_SPACE
    if (obj.pCommandBufferDeviceMasks) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.commandBufferCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.commandBufferCount;
            print_uint32_t(obj.pCommandBufferDeviceMasks[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.signalSemaphoreCount, "signalSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pSignalSemaphoreDeviceIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pSignalSemaphoreDeviceIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.signalSemaphoreCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.signalSemaphoreCount;
            print_uint32_t(obj.pSignalSemaphoreDeviceIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceGroupSubmitInfo(const VkDeviceGroupSubmitInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->waitSemaphoreCount, "waitSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pWaitSemaphoreDeviceIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pWaitSemaphoreDeviceIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->waitSemaphoreCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->waitSemaphoreCount;
            print_uint32_t(obj->pWaitSemaphoreDeviceIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->commandBufferCount, "commandBufferCount", 1);

    PRINT_SPACE
    _OUT << "\"pCommandBufferDeviceMasks\":" << std::endl;
    PRINT_SPACE
    if (obj->pCommandBufferDeviceMasks) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->commandBufferCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->commandBufferCount;
            print_uint32_t(obj->pCommandBufferDeviceMasks[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->signalSemaphoreCount, "signalSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pSignalSemaphoreDeviceIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pSignalSemaphoreDeviceIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->signalSemaphoreCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->signalSemaphoreCount;
            print_uint32_t(obj->pSignalSemaphoreDeviceIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceGroupBindSparseInfo(VkDeviceGroupBindSparseInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.resourceDeviceIndex, "resourceDeviceIndex", 1);

    print_uint32_t(obj.memoryDeviceIndex, "memoryDeviceIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceGroupBindSparseInfo(const VkDeviceGroupBindSparseInfo* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->resourceDeviceIndex, "resourceDeviceIndex", 1);

    print_uint32_t(obj->memoryDeviceIndex, "memoryDeviceIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindBufferMemoryDeviceGroupInfo(VkBindBufferMemoryDeviceGroupInfo obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.deviceIndexCount, "deviceIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pDeviceIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pDeviceIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.deviceIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.deviceIndexCount;
            print_uint32_t(obj.pDeviceIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindBufferMemoryDeviceGroupInfo(const VkBindBufferMemoryDeviceGroupInfo* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->deviceIndexCount, "deviceIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pDeviceIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pDeviceIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->deviceIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->deviceIndexCount;
            print_uint32_t(obj->pDeviceIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindImageMemoryDeviceGroupInfo(VkBindImageMemoryDeviceGroupInfo obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.deviceIndexCount, "deviceIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pDeviceIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pDeviceIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.deviceIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.deviceIndexCount;
            print_uint32_t(obj.pDeviceIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.splitInstanceBindRegionCount, "splitInstanceBindRegionCount", 1);

    PRINT_SPACE
    _OUT << "\"pSplitInstanceBindRegions\": " << std::endl;
    if (obj.pSplitInstanceBindRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.splitInstanceBindRegionCount; i++) {
            if (i + 1 == obj.splitInstanceBindRegionCount)
                print_VkRect2D(obj.pSplitInstanceBindRegions[i], "pSplitInstanceBindRegions", 0);
            else
                print_VkRect2D(obj.pSplitInstanceBindRegions[i], "pSplitInstanceBindRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindImageMemoryDeviceGroupInfo(const VkBindImageMemoryDeviceGroupInfo* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->deviceIndexCount, "deviceIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pDeviceIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pDeviceIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->deviceIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->deviceIndexCount;
            print_uint32_t(obj->pDeviceIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->splitInstanceBindRegionCount, "splitInstanceBindRegionCount", 1);

    PRINT_SPACE
    _OUT << "\"pSplitInstanceBindRegions\": " << std::endl;
    if (obj->pSplitInstanceBindRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->splitInstanceBindRegionCount; i++) {
            if (i + 1 == obj->splitInstanceBindRegionCount)
                print_VkRect2D(obj->pSplitInstanceBindRegions[i], "pSplitInstanceBindRegions", 0);
            else
                print_VkRect2D(obj->pSplitInstanceBindRegions[i], "pSplitInstanceBindRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceGroupProperties(VkPhysicalDeviceGroupProperties obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.physicalDeviceCount, "physicalDeviceCount", 1);

    PRINT_SPACE
    _OUT << "\"physicalDevices\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DEVICE_GROUP_SIZE; i++) {
        std::stringstream tmp;
        tmp << "physicalDevices"
            << "_" << i;
        bool isCommaNeeded = (i + 1) != VK_MAX_DEVICE_GROUP_SIZE;
        print_VkPhysicalDevice(obj.physicalDevices[i], tmp.str(), isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkBool32(obj.subsetAllocation, "subsetAllocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceGroupProperties(const VkPhysicalDeviceGroupProperties* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->physicalDeviceCount, "physicalDeviceCount", 1);

    PRINT_SPACE
    _OUT << "\"physicalDevices\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DEVICE_GROUP_SIZE; i++) {
        std::stringstream tmp;
        tmp << "physicalDevices"
            << "_" << i;
        bool isCommaNeeded = (i + 1) != VK_MAX_DEVICE_GROUP_SIZE;
        print_VkPhysicalDevice(obj->physicalDevices[i], tmp.str(), isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkBool32(obj->subsetAllocation, "subsetAllocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceGroupDeviceCreateInfo(VkDeviceGroupDeviceCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.physicalDeviceCount, "physicalDeviceCount", 1);

    PRINT_SPACE
    _OUT << "\"pPhysicalDevices\":" << std::endl;
    PRINT_SPACE
    if (obj.pPhysicalDevices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.physicalDeviceCount; i++) {
            std::stringstream tmp;
            tmp << "pPhysicalDevices"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.physicalDeviceCount;
            print_VkPhysicalDevice(obj.pPhysicalDevices[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceGroupDeviceCreateInfo(const VkDeviceGroupDeviceCreateInfo* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->physicalDeviceCount, "physicalDeviceCount", 1);

    PRINT_SPACE
    _OUT << "\"pPhysicalDevices\":" << std::endl;
    PRINT_SPACE
    if (obj->pPhysicalDevices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->physicalDeviceCount; i++) {
            std::stringstream tmp;
            tmp << "pPhysicalDevices"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->physicalDeviceCount;
            print_VkPhysicalDevice(obj->pPhysicalDevices[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBufferMemoryRequirementsInfo2(VkBufferMemoryRequirementsInfo2 obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferMemoryRequirementsInfo2(const VkBufferMemoryRequirementsInfo2* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageMemoryRequirementsInfo2(VkImageMemoryRequirementsInfo2 obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageMemoryRequirementsInfo2(const VkImageMemoryRequirementsInfo2* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageSparseMemoryRequirementsInfo2(VkImageSparseMemoryRequirementsInfo2 obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageSparseMemoryRequirementsInfo2(const VkImageSparseMemoryRequirementsInfo2* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryRequirements2(VkMemoryRequirements2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"memoryRequirements\": " << std::endl;
    { print_VkMemoryRequirements(obj.memoryRequirements, "memoryRequirements", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryRequirements2(const VkMemoryRequirements2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"memoryRequirements\": " << std::endl;
    { print_VkMemoryRequirements(obj->memoryRequirements, "memoryRequirements", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSparseImageMemoryRequirements2(VkSparseImageMemoryRequirements2 obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"memoryRequirements\": " << std::endl;
    { print_VkSparseImageMemoryRequirements(obj.memoryRequirements, "memoryRequirements", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSparseImageMemoryRequirements2(const VkSparseImageMemoryRequirements2* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"memoryRequirements\": " << std::endl;
    { print_VkSparseImageMemoryRequirements(obj->memoryRequirements, "memoryRequirements", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFeatures2(VkPhysicalDeviceFeatures2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"features\": " << std::endl;
    { print_VkPhysicalDeviceFeatures(obj.features, "features", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFeatures2(const VkPhysicalDeviceFeatures2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"features\": " << std::endl;
    { print_VkPhysicalDeviceFeatures(obj->features, "features", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceProperties2(VkPhysicalDeviceProperties2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"properties\": " << std::endl;
    { print_VkPhysicalDeviceProperties(obj.properties, "properties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceProperties2(const VkPhysicalDeviceProperties2* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"properties\": " << std::endl;
    { print_VkPhysicalDeviceProperties(obj->properties, "properties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkFormatProperties2(VkFormatProperties2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"formatProperties\": " << std::endl;
    { print_VkFormatProperties(obj.formatProperties, "formatProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkFormatProperties2(const VkFormatProperties2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"formatProperties\": " << std::endl;
    { print_VkFormatProperties(obj->formatProperties, "formatProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageFormatProperties2(VkImageFormatProperties2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"imageFormatProperties\": " << std::endl;
    { print_VkImageFormatProperties(obj.imageFormatProperties, "imageFormatProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageFormatProperties2(const VkImageFormatProperties2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"imageFormatProperties\": " << std::endl;
    { print_VkImageFormatProperties(obj->imageFormatProperties, "imageFormatProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceImageFormatInfo2(VkPhysicalDeviceImageFormatInfo2 obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj.format, "format", 1);

    print_VkImageType(obj.type, "type", 1);

    print_VkImageTiling(obj.tiling, "tiling", 1);

    print_VkImageUsageFlags(obj.usage, "usage", 1);

    print_VkImageCreateFlags(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageFormatInfo2(const VkPhysicalDeviceImageFormatInfo2* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj->format, "format", 1);

    print_VkImageType(obj->type, "type", 1);

    print_VkImageTiling(obj->tiling, "tiling", 1);

    print_VkImageUsageFlags(obj->usage, "usage", 1);

    print_VkImageCreateFlags(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkQueueFamilyProperties2(VkQueueFamilyProperties2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"queueFamilyProperties\": " << std::endl;
    { print_VkQueueFamilyProperties(obj.queueFamilyProperties, "queueFamilyProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkQueueFamilyProperties2(const VkQueueFamilyProperties2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"queueFamilyProperties\": " << std::endl;
    { print_VkQueueFamilyProperties(obj->queueFamilyProperties, "queueFamilyProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMemoryProperties2(VkPhysicalDeviceMemoryProperties2 obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"memoryProperties\": " << std::endl;
    { print_VkPhysicalDeviceMemoryProperties(obj.memoryProperties, "memoryProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMemoryProperties2(const VkPhysicalDeviceMemoryProperties2* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"memoryProperties\": " << std::endl;
    { print_VkPhysicalDeviceMemoryProperties(obj->memoryProperties, "memoryProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSparseImageFormatProperties2(VkSparseImageFormatProperties2 obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"properties\": " << std::endl;
    { print_VkSparseImageFormatProperties(obj.properties, "properties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSparseImageFormatProperties2(const VkSparseImageFormatProperties2* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"properties\": " << std::endl;
    { print_VkSparseImageFormatProperties(obj->properties, "properties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceSparseImageFormatInfo2(VkPhysicalDeviceSparseImageFormatInfo2 obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj.format, "format", 1);

    print_VkImageType(obj.type, "type", 1);

    print_VkSampleCountFlagBits(obj.samples, "samples", 1);

    print_VkImageUsageFlags(obj.usage, "usage", 1);

    print_VkImageTiling(obj.tiling, "tiling", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSparseImageFormatInfo2(const VkPhysicalDeviceSparseImageFormatInfo2* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj->format, "format", 1);

    print_VkImageType(obj->type, "type", 1);

    print_VkSampleCountFlagBits(obj->samples, "samples", 1);

    print_VkImageUsageFlags(obj->usage, "usage", 1);

    print_VkImageTiling(obj->tiling, "tiling", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePointClippingProperties(VkPhysicalDevicePointClippingProperties obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPointClippingBehavior(obj.pointClippingBehavior, "pointClippingBehavior", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePointClippingProperties(const VkPhysicalDevicePointClippingProperties* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPointClippingBehavior(obj->pointClippingBehavior, "pointClippingBehavior", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkInputAttachmentAspectReference(VkInputAttachmentAspectReference obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.subpass, "subpass", 1);

    print_uint32_t(obj.inputAttachmentIndex, "inputAttachmentIndex", 1);

    print_VkImageAspectFlags(obj.aspectMask, "aspectMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkInputAttachmentAspectReference(const VkInputAttachmentAspectReference* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->subpass, "subpass", 1);

    print_uint32_t(obj->inputAttachmentIndex, "inputAttachmentIndex", 1);

    print_VkImageAspectFlags(obj->aspectMask, "aspectMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassInputAttachmentAspectCreateInfo(VkRenderPassInputAttachmentAspectCreateInfo obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.aspectReferenceCount, "aspectReferenceCount", 1);

    PRINT_SPACE
    _OUT << "\"pAspectReferences\": " << std::endl;
    if (obj.pAspectReferences) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.aspectReferenceCount; i++) {
            if (i + 1 == obj.aspectReferenceCount)
                print_VkInputAttachmentAspectReference(obj.pAspectReferences[i], "pAspectReferences", 0);
            else
                print_VkInputAttachmentAspectReference(obj.pAspectReferences[i], "pAspectReferences", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassInputAttachmentAspectCreateInfo(const VkRenderPassInputAttachmentAspectCreateInfo* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->aspectReferenceCount, "aspectReferenceCount", 1);

    PRINT_SPACE
    _OUT << "\"pAspectReferences\": " << std::endl;
    if (obj->pAspectReferences) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->aspectReferenceCount; i++) {
            if (i + 1 == obj->aspectReferenceCount)
                print_VkInputAttachmentAspectReference(obj->pAspectReferences[i], "pAspectReferences", 0);
            else
                print_VkInputAttachmentAspectReference(obj->pAspectReferences[i], "pAspectReferences", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageViewUsageCreateInfo(VkImageViewUsageCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageUsageFlags(obj.usage, "usage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageViewUsageCreateInfo(const VkImageViewUsageCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageUsageFlags(obj->usage, "usage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineTessellationDomainOriginStateCreateInfo(VkPipelineTessellationDomainOriginStateCreateInfo obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkTessellationDomainOrigin(obj.domainOrigin, "domainOrigin", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineTessellationDomainOriginStateCreateInfo(const VkPipelineTessellationDomainOriginStateCreateInfo* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkTessellationDomainOrigin(obj->domainOrigin, "domainOrigin", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassMultiviewCreateInfo(VkRenderPassMultiviewCreateInfo obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.subpassCount, "subpassCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewMasks\":" << std::endl;
    PRINT_SPACE
    if (obj.pViewMasks) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.subpassCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.subpassCount;
            print_uint32_t(obj.pViewMasks[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.dependencyCount, "dependencyCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewOffsets\":" << std::endl;
    PRINT_SPACE
    if (obj.pViewOffsets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.dependencyCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.dependencyCount;
            print_int32_t(obj.pViewOffsets[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.correlationMaskCount, "correlationMaskCount", 1);

    PRINT_SPACE
    _OUT << "\"pCorrelationMasks\":" << std::endl;
    PRINT_SPACE
    if (obj.pCorrelationMasks) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.correlationMaskCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.correlationMaskCount;
            print_uint32_t(obj.pCorrelationMasks[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassMultiviewCreateInfo(const VkRenderPassMultiviewCreateInfo* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->subpassCount, "subpassCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewMasks\":" << std::endl;
    PRINT_SPACE
    if (obj->pViewMasks) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->subpassCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->subpassCount;
            print_uint32_t(obj->pViewMasks[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->dependencyCount, "dependencyCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewOffsets\":" << std::endl;
    PRINT_SPACE
    if (obj->pViewOffsets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->dependencyCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->dependencyCount;
            print_int32_t(obj->pViewOffsets[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->correlationMaskCount, "correlationMaskCount", 1);

    PRINT_SPACE
    _OUT << "\"pCorrelationMasks\":" << std::endl;
    PRINT_SPACE
    if (obj->pCorrelationMasks) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->correlationMaskCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->correlationMaskCount;
            print_uint32_t(obj->pCorrelationMasks[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMultiviewFeatures(VkPhysicalDeviceMultiviewFeatures obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.multiview, "multiview", 1);

    print_VkBool32(obj.multiviewGeometryShader, "multiviewGeometryShader", 1);

    print_VkBool32(obj.multiviewTessellationShader, "multiviewTessellationShader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMultiviewFeatures(const VkPhysicalDeviceMultiviewFeatures* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->multiview, "multiview", 1);

    print_VkBool32(obj->multiviewGeometryShader, "multiviewGeometryShader", 1);

    print_VkBool32(obj->multiviewTessellationShader, "multiviewTessellationShader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMultiviewProperties(VkPhysicalDeviceMultiviewProperties obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxMultiviewViewCount, "maxMultiviewViewCount", 1);

    print_uint32_t(obj.maxMultiviewInstanceIndex, "maxMultiviewInstanceIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMultiviewProperties(const VkPhysicalDeviceMultiviewProperties* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxMultiviewViewCount, "maxMultiviewViewCount", 1);

    print_uint32_t(obj->maxMultiviewInstanceIndex, "maxMultiviewInstanceIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceVariablePointersFeatures(VkPhysicalDeviceVariablePointersFeatures obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.variablePointersStorageBuffer, "variablePointersStorageBuffer", 1);

    print_VkBool32(obj.variablePointers, "variablePointers", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVariablePointersFeatures(const VkPhysicalDeviceVariablePointersFeatures* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->variablePointersStorageBuffer, "variablePointersStorageBuffer", 1);

    print_VkBool32(obj->variablePointers, "variablePointers", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceVariablePointersFeatures VkPhysicalDeviceVariablePointerFeatures;

static void print_VkPhysicalDeviceProtectedMemoryFeatures(VkPhysicalDeviceProtectedMemoryFeatures obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.protectedMemory, "protectedMemory", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceProtectedMemoryFeatures(const VkPhysicalDeviceProtectedMemoryFeatures* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->protectedMemory, "protectedMemory", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceProtectedMemoryProperties(VkPhysicalDeviceProtectedMemoryProperties obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.protectedNoFault, "protectedNoFault", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceProtectedMemoryProperties(const VkPhysicalDeviceProtectedMemoryProperties* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->protectedNoFault, "protectedNoFault", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceQueueInfo2(VkDeviceQueueInfo2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceQueueCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.queueFamilyIndex, "queueFamilyIndex", 1);

    print_uint32_t(obj.queueIndex, "queueIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceQueueInfo2(const VkDeviceQueueInfo2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceQueueCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->queueFamilyIndex, "queueFamilyIndex", 1);

    print_uint32_t(obj->queueIndex, "queueIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkProtectedSubmitInfo(VkProtectedSubmitInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.protectedSubmit, "protectedSubmit", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkProtectedSubmitInfo(const VkProtectedSubmitInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->protectedSubmit, "protectedSubmit", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSamplerYcbcrConversionCreateInfo(VkSamplerYcbcrConversionCreateInfo obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj.format, "format", 1);

    print_VkSamplerYcbcrModelConversion(obj.ycbcrModel, "ycbcrModel", 1);

    print_VkSamplerYcbcrRange(obj.ycbcrRange, "ycbcrRange", 1);

    PRINT_SPACE
    _OUT << "\"components\": " << std::endl;
    { print_VkComponentMapping(obj.components, "components", 1); }

    print_VkChromaLocation(obj.xChromaOffset, "xChromaOffset", 1);

    print_VkChromaLocation(obj.yChromaOffset, "yChromaOffset", 1);

    print_VkFilter(obj.chromaFilter, "chromaFilter", 1);

    print_VkBool32(obj.forceExplicitReconstruction, "forceExplicitReconstruction", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSamplerYcbcrConversionCreateInfo(const VkSamplerYcbcrConversionCreateInfo* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj->format, "format", 1);

    print_VkSamplerYcbcrModelConversion(obj->ycbcrModel, "ycbcrModel", 1);

    print_VkSamplerYcbcrRange(obj->ycbcrRange, "ycbcrRange", 1);

    PRINT_SPACE
    _OUT << "\"components\": " << std::endl;
    { print_VkComponentMapping(obj->components, "components", 1); }

    print_VkChromaLocation(obj->xChromaOffset, "xChromaOffset", 1);

    print_VkChromaLocation(obj->yChromaOffset, "yChromaOffset", 1);

    print_VkFilter(obj->chromaFilter, "chromaFilter", 1);

    print_VkBool32(obj->forceExplicitReconstruction, "forceExplicitReconstruction", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSamplerYcbcrConversionInfo(VkSamplerYcbcrConversionInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "conversion"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSamplerYcbcrConversionInfo(const VkSamplerYcbcrConversionInfo* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "conversion"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindImagePlaneMemoryInfo(VkBindImagePlaneMemoryInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageAspectFlagBits(obj.planeAspect, "planeAspect", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindImagePlaneMemoryInfo(const VkBindImagePlaneMemoryInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageAspectFlagBits(obj->planeAspect, "planeAspect", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImagePlaneMemoryRequirementsInfo(VkImagePlaneMemoryRequirementsInfo obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageAspectFlagBits(obj.planeAspect, "planeAspect", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImagePlaneMemoryRequirementsInfo(const VkImagePlaneMemoryRequirementsInfo* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageAspectFlagBits(obj->planeAspect, "planeAspect", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceSamplerYcbcrConversionFeatures(VkPhysicalDeviceSamplerYcbcrConversionFeatures obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.samplerYcbcrConversion, "samplerYcbcrConversion", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSamplerYcbcrConversionFeatures(const VkPhysicalDeviceSamplerYcbcrConversionFeatures* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->samplerYcbcrConversion, "samplerYcbcrConversion", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSamplerYcbcrConversionImageFormatProperties(VkSamplerYcbcrConversionImageFormatProperties obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.combinedImageSamplerDescriptorCount, "combinedImageSamplerDescriptorCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSamplerYcbcrConversionImageFormatProperties(const VkSamplerYcbcrConversionImageFormatProperties* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->combinedImageSamplerDescriptorCount, "combinedImageSamplerDescriptorCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorUpdateTemplateEntry(VkDescriptorUpdateTemplateEntry obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.dstBinding, "dstBinding", 1);

    print_uint32_t(obj.dstArrayElement, "dstArrayElement", 1);

    print_uint32_t(obj.descriptorCount, "descriptorCount", 1);

    print_VkDescriptorType(obj.descriptorType, "descriptorType", 1);

    print_size_t(obj.offset, "offset", 1);

    print_size_t(obj.stride, "stride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorUpdateTemplateEntry(const VkDescriptorUpdateTemplateEntry* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->dstBinding, "dstBinding", 1);

    print_uint32_t(obj->dstArrayElement, "dstArrayElement", 1);

    print_uint32_t(obj->descriptorCount, "descriptorCount", 1);

    print_VkDescriptorType(obj->descriptorType, "descriptorType", 1);

    print_size_t(obj->offset, "offset", 1);

    print_size_t(obj->stride, "stride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorUpdateTemplateCreateInfo(VkDescriptorUpdateTemplateCreateInfo obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDescriptorUpdateTemplateCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.descriptorUpdateEntryCount, "descriptorUpdateEntryCount", 1);

    PRINT_SPACE
    _OUT << "\"pDescriptorUpdateEntries\": " << std::endl;
    if (obj.pDescriptorUpdateEntries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.descriptorUpdateEntryCount; i++) {
            if (i + 1 == obj.descriptorUpdateEntryCount)
                print_VkDescriptorUpdateTemplateEntry(obj.pDescriptorUpdateEntries[i], "pDescriptorUpdateEntries", 0);
            else
                print_VkDescriptorUpdateTemplateEntry(obj.pDescriptorUpdateEntries[i], "pDescriptorUpdateEntries", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkDescriptorUpdateTemplateType(obj.templateType, "templateType", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "descriptorSetLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkPipelineBindPoint(obj.pipelineBindPoint, "pipelineBindPoint", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipelineLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.set, "set", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorUpdateTemplateCreateInfo(const VkDescriptorUpdateTemplateCreateInfo* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDescriptorUpdateTemplateCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->descriptorUpdateEntryCount, "descriptorUpdateEntryCount", 1);

    PRINT_SPACE
    _OUT << "\"pDescriptorUpdateEntries\": " << std::endl;
    if (obj->pDescriptorUpdateEntries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->descriptorUpdateEntryCount; i++) {
            if (i + 1 == obj->descriptorUpdateEntryCount)
                print_VkDescriptorUpdateTemplateEntry(obj->pDescriptorUpdateEntries[i], "pDescriptorUpdateEntries", 0);
            else
                print_VkDescriptorUpdateTemplateEntry(obj->pDescriptorUpdateEntries[i], "pDescriptorUpdateEntries", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkDescriptorUpdateTemplateType(obj->templateType, "templateType", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "descriptorSetLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkPipelineBindPoint(obj->pipelineBindPoint, "pipelineBindPoint", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipelineLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->set, "set", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExternalMemoryProperties(VkExternalMemoryProperties obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkExternalMemoryFeatureFlags(obj.externalMemoryFeatures, "externalMemoryFeatures", 1);

    print_VkExternalMemoryHandleTypeFlags(obj.exportFromImportedHandleTypes, "exportFromImportedHandleTypes", 1);

    print_VkExternalMemoryHandleTypeFlags(obj.compatibleHandleTypes, "compatibleHandleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExternalMemoryProperties(const VkExternalMemoryProperties* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkExternalMemoryFeatureFlags(obj->externalMemoryFeatures, "externalMemoryFeatures", 1);

    print_VkExternalMemoryHandleTypeFlags(obj->exportFromImportedHandleTypes, "exportFromImportedHandleTypes", 1);

    print_VkExternalMemoryHandleTypeFlags(obj->compatibleHandleTypes, "compatibleHandleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceExternalImageFormatInfo(VkPhysicalDeviceExternalImageFormatInfo obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlagBits(obj.handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceExternalImageFormatInfo(const VkPhysicalDeviceExternalImageFormatInfo* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlagBits(obj->handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExternalImageFormatProperties(VkExternalImageFormatProperties obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"externalMemoryProperties\": " << std::endl;
    { print_VkExternalMemoryProperties(obj.externalMemoryProperties, "externalMemoryProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExternalImageFormatProperties(const VkExternalImageFormatProperties* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"externalMemoryProperties\": " << std::endl;
    { print_VkExternalMemoryProperties(obj->externalMemoryProperties, "externalMemoryProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceExternalBufferInfo(VkPhysicalDeviceExternalBufferInfo obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBufferCreateFlags(obj.flags, "flags", 1);

    print_VkBufferUsageFlags(obj.usage, "usage", 1);

    print_VkExternalMemoryHandleTypeFlagBits(obj.handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceExternalBufferInfo(const VkPhysicalDeviceExternalBufferInfo* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBufferCreateFlags(obj->flags, "flags", 1);

    print_VkBufferUsageFlags(obj->usage, "usage", 1);

    print_VkExternalMemoryHandleTypeFlagBits(obj->handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExternalBufferProperties(VkExternalBufferProperties obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"externalMemoryProperties\": " << std::endl;
    { print_VkExternalMemoryProperties(obj.externalMemoryProperties, "externalMemoryProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExternalBufferProperties(const VkExternalBufferProperties* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"externalMemoryProperties\": " << std::endl;
    { print_VkExternalMemoryProperties(obj->externalMemoryProperties, "externalMemoryProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceIDProperties(VkPhysicalDeviceIDProperties obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"deviceUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj.deviceUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"driverUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj.driverUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"deviceLUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_LUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_LUID_SIZE;
        print_uint8_t(obj.deviceLUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.deviceNodeMask, "deviceNodeMask", 1);

    print_VkBool32(obj.deviceLUIDValid, "deviceLUIDValid", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceIDProperties(const VkPhysicalDeviceIDProperties* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"deviceUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj->deviceUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"driverUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj->driverUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"deviceLUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_LUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_LUID_SIZE;
        print_uint8_t(obj->deviceLUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->deviceNodeMask, "deviceNodeMask", 1);

    print_VkBool32(obj->deviceLUIDValid, "deviceLUIDValid", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExternalMemoryImageCreateInfo(VkExternalMemoryImageCreateInfo obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlags(obj.handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExternalMemoryImageCreateInfo(const VkExternalMemoryImageCreateInfo* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlags(obj->handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExternalMemoryBufferCreateInfo(VkExternalMemoryBufferCreateInfo obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlags(obj.handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExternalMemoryBufferCreateInfo(const VkExternalMemoryBufferCreateInfo* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlags(obj->handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExportMemoryAllocateInfo(VkExportMemoryAllocateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlags(obj.handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExportMemoryAllocateInfo(const VkExportMemoryAllocateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlags(obj->handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceExternalFenceInfo(VkPhysicalDeviceExternalFenceInfo obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalFenceHandleTypeFlagBits(obj.handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceExternalFenceInfo(const VkPhysicalDeviceExternalFenceInfo* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalFenceHandleTypeFlagBits(obj->handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExternalFenceProperties(VkExternalFenceProperties obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalFenceHandleTypeFlags(obj.exportFromImportedHandleTypes, "exportFromImportedHandleTypes", 1);

    print_VkExternalFenceHandleTypeFlags(obj.compatibleHandleTypes, "compatibleHandleTypes", 1);

    print_VkExternalFenceFeatureFlags(obj.externalFenceFeatures, "externalFenceFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExternalFenceProperties(const VkExternalFenceProperties* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalFenceHandleTypeFlags(obj->exportFromImportedHandleTypes, "exportFromImportedHandleTypes", 1);

    print_VkExternalFenceHandleTypeFlags(obj->compatibleHandleTypes, "compatibleHandleTypes", 1);

    print_VkExternalFenceFeatureFlags(obj->externalFenceFeatures, "externalFenceFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExportFenceCreateInfo(VkExportFenceCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalFenceHandleTypeFlags(obj.handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExportFenceCreateInfo(const VkExportFenceCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalFenceHandleTypeFlags(obj->handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExportSemaphoreCreateInfo(VkExportSemaphoreCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalSemaphoreHandleTypeFlags(obj.handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExportSemaphoreCreateInfo(const VkExportSemaphoreCreateInfo* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalSemaphoreHandleTypeFlags(obj->handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceExternalSemaphoreInfo(VkPhysicalDeviceExternalSemaphoreInfo obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalSemaphoreHandleTypeFlagBits(obj.handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceExternalSemaphoreInfo(const VkPhysicalDeviceExternalSemaphoreInfo* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalSemaphoreHandleTypeFlagBits(obj->handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExternalSemaphoreProperties(VkExternalSemaphoreProperties obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalSemaphoreHandleTypeFlags(obj.exportFromImportedHandleTypes, "exportFromImportedHandleTypes", 1);

    print_VkExternalSemaphoreHandleTypeFlags(obj.compatibleHandleTypes, "compatibleHandleTypes", 1);

    print_VkExternalSemaphoreFeatureFlags(obj.externalSemaphoreFeatures, "externalSemaphoreFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExternalSemaphoreProperties(const VkExternalSemaphoreProperties* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalSemaphoreHandleTypeFlags(obj->exportFromImportedHandleTypes, "exportFromImportedHandleTypes", 1);

    print_VkExternalSemaphoreHandleTypeFlags(obj->compatibleHandleTypes, "compatibleHandleTypes", 1);

    print_VkExternalSemaphoreFeatureFlags(obj->externalSemaphoreFeatures, "externalSemaphoreFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMaintenance3Properties(VkPhysicalDeviceMaintenance3Properties obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxPerSetDescriptors, "maxPerSetDescriptors", 1);

    print_VkDeviceSize(obj.maxMemoryAllocationSize, "maxMemoryAllocationSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMaintenance3Properties(const VkPhysicalDeviceMaintenance3Properties* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxPerSetDescriptors, "maxPerSetDescriptors", 1);

    print_VkDeviceSize(obj->maxMemoryAllocationSize, "maxMemoryAllocationSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorSetLayoutSupport(VkDescriptorSetLayoutSupport obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.supported, "supported", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorSetLayoutSupport(const VkDescriptorSetLayoutSupport* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->supported, "supported", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderDrawParametersFeatures(VkPhysicalDeviceShaderDrawParametersFeatures obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderDrawParameters, "shaderDrawParameters", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderDrawParametersFeatures(const VkPhysicalDeviceShaderDrawParametersFeatures* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderDrawParameters, "shaderDrawParameters", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceShaderDrawParametersFeatures VkPhysicalDeviceShaderDrawParameterFeatures;

static std::map<uint64_t, std::string> VkDriverId_map = {
    std::make_pair(1, "VK_DRIVER_ID_AMD_PROPRIETARY"),
    std::make_pair(2, "VK_DRIVER_ID_AMD_OPEN_SOURCE"),
    std::make_pair(3, "VK_DRIVER_ID_MESA_RADV"),
    std::make_pair(4, "VK_DRIVER_ID_NVIDIA_PROPRIETARY"),
    std::make_pair(5, "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS"),
    std::make_pair(6, "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA"),
    std::make_pair(7, "VK_DRIVER_ID_IMAGINATION_PROPRIETARY"),
    std::make_pair(8, "VK_DRIVER_ID_QUALCOMM_PROPRIETARY"),
    std::make_pair(9, "VK_DRIVER_ID_ARM_PROPRIETARY"),
    std::make_pair(10, "VK_DRIVER_ID_GOOGLE_SWIFTSHADER"),
    std::make_pair(11, "VK_DRIVER_ID_GGP_PROPRIETARY"),
    std::make_pair(12, "VK_DRIVER_ID_BROADCOM_PROPRIETARY"),
    std::make_pair(13, "VK_DRIVER_ID_MESA_LLVMPIPE"),
    std::make_pair(14, "VK_DRIVER_ID_MOLTENVK"),
    std::make_pair(15, "VK_DRIVER_ID_COREAVI_PROPRIETARY"),
    std::make_pair(16, "VK_DRIVER_ID_JUICE_PROPRIETARY"),
    std::make_pair(17, "VK_DRIVER_ID_VERISILICON_PROPRIETARY"),
    std::make_pair(18, "VK_DRIVER_ID_MESA_TURNIP"),
    std::make_pair(19, "VK_DRIVER_ID_MESA_V3DV"),
    std::make_pair(20, "VK_DRIVER_ID_MESA_PANVK"),
    std::make_pair(21, "VK_DRIVER_ID_SAMSUNG_PROPRIETARY"),
    std::make_pair(22, "VK_DRIVER_ID_MESA_VENUS"),
    std::make_pair(23, "VK_DRIVER_ID_MESA_DOZEN"),
    std::make_pair(24, "VK_DRIVER_ID_MESA_NVK"),
    std::make_pair(25, "VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA"),
    std::make_pair(26, "VK_DRIVER_ID_MESA_HONEYKRISP"),
    std::make_pair(27, "VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN"),
};
static void print_VkDriverId(VkDriverId obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDriverId_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDriverId_map[obj] << "\"" << std::endl;
}
static void print_VkDriverId(const VkDriverId* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDriverId_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDriverId_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkShaderFloatControlsIndependence_map = {
    std::make_pair(0, "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY"),
    std::make_pair(1, "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL"),
    std::make_pair(2, "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE"),
};
static void print_VkShaderFloatControlsIndependence(VkShaderFloatControlsIndependence obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderFloatControlsIndependence_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderFloatControlsIndependence_map[obj] << "\"" << std::endl;
}
static void print_VkShaderFloatControlsIndependence(const VkShaderFloatControlsIndependence* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderFloatControlsIndependence_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderFloatControlsIndependence_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkResolveModeFlagBits_map = {
    std::make_pair(0, "VK_RESOLVE_MODE_NONE"),
    std::make_pair(1ULL << 0, "VK_RESOLVE_MODE_SAMPLE_ZERO_BIT"),
    std::make_pair(1ULL << 1, "VK_RESOLVE_MODE_AVERAGE_BIT"),
    std::make_pair(1ULL << 2, "VK_RESOLVE_MODE_MIN_BIT"),
    std::make_pair(1ULL << 3, "VK_RESOLVE_MODE_MAX_BIT"),
    std::make_pair(1ULL << 4, "VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID"),
};
static void print_VkResolveModeFlagBits(VkResolveModeFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkResolveModeFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkResolveModeFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkResolveModeFlagBits(const VkResolveModeFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkResolveModeFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkResolveModeFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDescriptorBindingFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT"),
    std::make_pair(1ULL << 1, "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT"),
    std::make_pair(1ULL << 2, "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT"),
    std::make_pair(1ULL << 3, "VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT"),
    std::make_pair(1ULL << 4, "VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM"),
};
static void print_VkDescriptorBindingFlagBits(VkDescriptorBindingFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorBindingFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorBindingFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkDescriptorBindingFlagBits(const VkDescriptorBindingFlagBits* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorBindingFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorBindingFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSamplerReductionMode_map = {
    std::make_pair(0, "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE"),
    std::make_pair(1, "VK_SAMPLER_REDUCTION_MODE_MIN"),
    std::make_pair(2, "VK_SAMPLER_REDUCTION_MODE_MAX"),
    std::make_pair(1000521000, "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM"),
};
static void print_VkSamplerReductionMode(VkSamplerReductionMode obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerReductionMode_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerReductionMode_map[obj] << "\"" << std::endl;
}
static void print_VkSamplerReductionMode(const VkSamplerReductionMode* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerReductionMode_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerReductionMode_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSemaphoreType_map = {
    std::make_pair(0, "VK_SEMAPHORE_TYPE_BINARY"),
    std::make_pair(1, "VK_SEMAPHORE_TYPE_TIMELINE"),
};
static void print_VkSemaphoreType(VkSemaphoreType obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSemaphoreType_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSemaphoreType_map[obj] << "\"" << std::endl;
}
static void print_VkSemaphoreType(const VkSemaphoreType* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSemaphoreType_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSemaphoreType_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSemaphoreWaitFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_SEMAPHORE_WAIT_ANY_BIT"),
};
static void print_VkSemaphoreWaitFlagBits(VkSemaphoreWaitFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSemaphoreWaitFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSemaphoreWaitFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkSemaphoreWaitFlagBits(const VkSemaphoreWaitFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSemaphoreWaitFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSemaphoreWaitFlagBits_map[*obj] << "\"" << std::endl;
}

static void print_VkResolveModeFlags(VkResolveModeFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkResolveModeFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkResolveModeFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkDescriptorBindingFlags(VkDescriptorBindingFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkDescriptorBindingFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkDescriptorBindingFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkSemaphoreWaitFlags(VkSemaphoreWaitFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkSemaphoreWaitFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkSemaphoreWaitFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceVulkan11Features(VkPhysicalDeviceVulkan11Features obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.storageBuffer16BitAccess, "storageBuffer16BitAccess", 1);

    print_VkBool32(obj.uniformAndStorageBuffer16BitAccess, "uniformAndStorageBuffer16BitAccess", 1);

    print_VkBool32(obj.storagePushConstant16, "storagePushConstant16", 1);

    print_VkBool32(obj.storageInputOutput16, "storageInputOutput16", 1);

    print_VkBool32(obj.multiview, "multiview", 1);

    print_VkBool32(obj.multiviewGeometryShader, "multiviewGeometryShader", 1);

    print_VkBool32(obj.multiviewTessellationShader, "multiviewTessellationShader", 1);

    print_VkBool32(obj.variablePointersStorageBuffer, "variablePointersStorageBuffer", 1);

    print_VkBool32(obj.variablePointers, "variablePointers", 1);

    print_VkBool32(obj.protectedMemory, "protectedMemory", 1);

    print_VkBool32(obj.samplerYcbcrConversion, "samplerYcbcrConversion", 1);

    print_VkBool32(obj.shaderDrawParameters, "shaderDrawParameters", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVulkan11Features(const VkPhysicalDeviceVulkan11Features* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->storageBuffer16BitAccess, "storageBuffer16BitAccess", 1);

    print_VkBool32(obj->uniformAndStorageBuffer16BitAccess, "uniformAndStorageBuffer16BitAccess", 1);

    print_VkBool32(obj->storagePushConstant16, "storagePushConstant16", 1);

    print_VkBool32(obj->storageInputOutput16, "storageInputOutput16", 1);

    print_VkBool32(obj->multiview, "multiview", 1);

    print_VkBool32(obj->multiviewGeometryShader, "multiviewGeometryShader", 1);

    print_VkBool32(obj->multiviewTessellationShader, "multiviewTessellationShader", 1);

    print_VkBool32(obj->variablePointersStorageBuffer, "variablePointersStorageBuffer", 1);

    print_VkBool32(obj->variablePointers, "variablePointers", 1);

    print_VkBool32(obj->protectedMemory, "protectedMemory", 1);

    print_VkBool32(obj->samplerYcbcrConversion, "samplerYcbcrConversion", 1);

    print_VkBool32(obj->shaderDrawParameters, "shaderDrawParameters", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceVulkan11Properties(VkPhysicalDeviceVulkan11Properties obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"deviceUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj.deviceUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"driverUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj.driverUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"deviceLUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_LUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_LUID_SIZE;
        print_uint8_t(obj.deviceLUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.deviceNodeMask, "deviceNodeMask", 1);

    print_VkBool32(obj.deviceLUIDValid, "deviceLUIDValid", 1);

    print_uint32_t(obj.subgroupSize, "subgroupSize", 1);

    print_VkShaderStageFlags(obj.subgroupSupportedStages, "subgroupSupportedStages", 1);

    print_VkSubgroupFeatureFlags(obj.subgroupSupportedOperations, "subgroupSupportedOperations", 1);

    print_VkBool32(obj.subgroupQuadOperationsInAllStages, "subgroupQuadOperationsInAllStages", 1);

    print_VkPointClippingBehavior(obj.pointClippingBehavior, "pointClippingBehavior", 1);

    print_uint32_t(obj.maxMultiviewViewCount, "maxMultiviewViewCount", 1);

    print_uint32_t(obj.maxMultiviewInstanceIndex, "maxMultiviewInstanceIndex", 1);

    print_VkBool32(obj.protectedNoFault, "protectedNoFault", 1);

    print_uint32_t(obj.maxPerSetDescriptors, "maxPerSetDescriptors", 1);

    print_VkDeviceSize(obj.maxMemoryAllocationSize, "maxMemoryAllocationSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVulkan11Properties(const VkPhysicalDeviceVulkan11Properties* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"deviceUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj->deviceUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"driverUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj->driverUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"deviceLUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_LUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_LUID_SIZE;
        print_uint8_t(obj->deviceLUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->deviceNodeMask, "deviceNodeMask", 1);

    print_VkBool32(obj->deviceLUIDValid, "deviceLUIDValid", 1);

    print_uint32_t(obj->subgroupSize, "subgroupSize", 1);

    print_VkShaderStageFlags(obj->subgroupSupportedStages, "subgroupSupportedStages", 1);

    print_VkSubgroupFeatureFlags(obj->subgroupSupportedOperations, "subgroupSupportedOperations", 1);

    print_VkBool32(obj->subgroupQuadOperationsInAllStages, "subgroupQuadOperationsInAllStages", 1);

    print_VkPointClippingBehavior(obj->pointClippingBehavior, "pointClippingBehavior", 1);

    print_uint32_t(obj->maxMultiviewViewCount, "maxMultiviewViewCount", 1);

    print_uint32_t(obj->maxMultiviewInstanceIndex, "maxMultiviewInstanceIndex", 1);

    print_VkBool32(obj->protectedNoFault, "protectedNoFault", 1);

    print_uint32_t(obj->maxPerSetDescriptors, "maxPerSetDescriptors", 1);

    print_VkDeviceSize(obj->maxMemoryAllocationSize, "maxMemoryAllocationSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceVulkan12Features(VkPhysicalDeviceVulkan12Features obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.samplerMirrorClampToEdge, "samplerMirrorClampToEdge", 1);

    print_VkBool32(obj.drawIndirectCount, "drawIndirectCount", 1);

    print_VkBool32(obj.storageBuffer8BitAccess, "storageBuffer8BitAccess", 1);

    print_VkBool32(obj.uniformAndStorageBuffer8BitAccess, "uniformAndStorageBuffer8BitAccess", 1);

    print_VkBool32(obj.storagePushConstant8, "storagePushConstant8", 1);

    print_VkBool32(obj.shaderBufferInt64Atomics, "shaderBufferInt64Atomics", 1);

    print_VkBool32(obj.shaderSharedInt64Atomics, "shaderSharedInt64Atomics", 1);

    print_VkBool32(obj.shaderFloat16, "shaderFloat16", 1);

    print_VkBool32(obj.shaderInt8, "shaderInt8", 1);

    print_VkBool32(obj.descriptorIndexing, "descriptorIndexing", 1);

    print_VkBool32(obj.shaderInputAttachmentArrayDynamicIndexing, "shaderInputAttachmentArrayDynamicIndexing", 1);

    print_VkBool32(obj.shaderUniformTexelBufferArrayDynamicIndexing, "shaderUniformTexelBufferArrayDynamicIndexing", 1);

    print_VkBool32(obj.shaderStorageTexelBufferArrayDynamicIndexing, "shaderStorageTexelBufferArrayDynamicIndexing", 1);

    print_VkBool32(obj.shaderUniformBufferArrayNonUniformIndexing, "shaderUniformBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj.shaderSampledImageArrayNonUniformIndexing, "shaderSampledImageArrayNonUniformIndexing", 1);

    print_VkBool32(obj.shaderStorageBufferArrayNonUniformIndexing, "shaderStorageBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj.shaderStorageImageArrayNonUniformIndexing, "shaderStorageImageArrayNonUniformIndexing", 1);

    print_VkBool32(obj.shaderInputAttachmentArrayNonUniformIndexing, "shaderInputAttachmentArrayNonUniformIndexing", 1);

    print_VkBool32(obj.shaderUniformTexelBufferArrayNonUniformIndexing, "shaderUniformTexelBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj.shaderStorageTexelBufferArrayNonUniformIndexing, "shaderStorageTexelBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj.descriptorBindingUniformBufferUpdateAfterBind, "descriptorBindingUniformBufferUpdateAfterBind", 1);

    print_VkBool32(obj.descriptorBindingSampledImageUpdateAfterBind, "descriptorBindingSampledImageUpdateAfterBind", 1);

    print_VkBool32(obj.descriptorBindingStorageImageUpdateAfterBind, "descriptorBindingStorageImageUpdateAfterBind", 1);

    print_VkBool32(obj.descriptorBindingStorageBufferUpdateAfterBind, "descriptorBindingStorageBufferUpdateAfterBind", 1);

    print_VkBool32(obj.descriptorBindingUniformTexelBufferUpdateAfterBind, "descriptorBindingUniformTexelBufferUpdateAfterBind", 1);

    print_VkBool32(obj.descriptorBindingStorageTexelBufferUpdateAfterBind, "descriptorBindingStorageTexelBufferUpdateAfterBind", 1);

    print_VkBool32(obj.descriptorBindingUpdateUnusedWhilePending, "descriptorBindingUpdateUnusedWhilePending", 1);

    print_VkBool32(obj.descriptorBindingPartiallyBound, "descriptorBindingPartiallyBound", 1);

    print_VkBool32(obj.descriptorBindingVariableDescriptorCount, "descriptorBindingVariableDescriptorCount", 1);

    print_VkBool32(obj.runtimeDescriptorArray, "runtimeDescriptorArray", 1);

    print_VkBool32(obj.samplerFilterMinmax, "samplerFilterMinmax", 1);

    print_VkBool32(obj.scalarBlockLayout, "scalarBlockLayout", 1);

    print_VkBool32(obj.imagelessFramebuffer, "imagelessFramebuffer", 1);

    print_VkBool32(obj.uniformBufferStandardLayout, "uniformBufferStandardLayout", 1);

    print_VkBool32(obj.shaderSubgroupExtendedTypes, "shaderSubgroupExtendedTypes", 1);

    print_VkBool32(obj.separateDepthStencilLayouts, "separateDepthStencilLayouts", 1);

    print_VkBool32(obj.hostQueryReset, "hostQueryReset", 1);

    print_VkBool32(obj.timelineSemaphore, "timelineSemaphore", 1);

    print_VkBool32(obj.bufferDeviceAddress, "bufferDeviceAddress", 1);

    print_VkBool32(obj.bufferDeviceAddressCaptureReplay, "bufferDeviceAddressCaptureReplay", 1);

    print_VkBool32(obj.bufferDeviceAddressMultiDevice, "bufferDeviceAddressMultiDevice", 1);

    print_VkBool32(obj.vulkanMemoryModel, "vulkanMemoryModel", 1);

    print_VkBool32(obj.vulkanMemoryModelDeviceScope, "vulkanMemoryModelDeviceScope", 1);

    print_VkBool32(obj.vulkanMemoryModelAvailabilityVisibilityChains, "vulkanMemoryModelAvailabilityVisibilityChains", 1);

    print_VkBool32(obj.shaderOutputViewportIndex, "shaderOutputViewportIndex", 1);

    print_VkBool32(obj.shaderOutputLayer, "shaderOutputLayer", 1);

    print_VkBool32(obj.subgroupBroadcastDynamicId, "subgroupBroadcastDynamicId", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVulkan12Features(const VkPhysicalDeviceVulkan12Features* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->samplerMirrorClampToEdge, "samplerMirrorClampToEdge", 1);

    print_VkBool32(obj->drawIndirectCount, "drawIndirectCount", 1);

    print_VkBool32(obj->storageBuffer8BitAccess, "storageBuffer8BitAccess", 1);

    print_VkBool32(obj->uniformAndStorageBuffer8BitAccess, "uniformAndStorageBuffer8BitAccess", 1);

    print_VkBool32(obj->storagePushConstant8, "storagePushConstant8", 1);

    print_VkBool32(obj->shaderBufferInt64Atomics, "shaderBufferInt64Atomics", 1);

    print_VkBool32(obj->shaderSharedInt64Atomics, "shaderSharedInt64Atomics", 1);

    print_VkBool32(obj->shaderFloat16, "shaderFloat16", 1);

    print_VkBool32(obj->shaderInt8, "shaderInt8", 1);

    print_VkBool32(obj->descriptorIndexing, "descriptorIndexing", 1);

    print_VkBool32(obj->shaderInputAttachmentArrayDynamicIndexing, "shaderInputAttachmentArrayDynamicIndexing", 1);

    print_VkBool32(obj->shaderUniformTexelBufferArrayDynamicIndexing, "shaderUniformTexelBufferArrayDynamicIndexing", 1);

    print_VkBool32(obj->shaderStorageTexelBufferArrayDynamicIndexing, "shaderStorageTexelBufferArrayDynamicIndexing", 1);

    print_VkBool32(obj->shaderUniformBufferArrayNonUniformIndexing, "shaderUniformBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj->shaderSampledImageArrayNonUniformIndexing, "shaderSampledImageArrayNonUniformIndexing", 1);

    print_VkBool32(obj->shaderStorageBufferArrayNonUniformIndexing, "shaderStorageBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj->shaderStorageImageArrayNonUniformIndexing, "shaderStorageImageArrayNonUniformIndexing", 1);

    print_VkBool32(obj->shaderInputAttachmentArrayNonUniformIndexing, "shaderInputAttachmentArrayNonUniformIndexing", 1);

    print_VkBool32(obj->shaderUniformTexelBufferArrayNonUniformIndexing, "shaderUniformTexelBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj->shaderStorageTexelBufferArrayNonUniformIndexing, "shaderStorageTexelBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj->descriptorBindingUniformBufferUpdateAfterBind, "descriptorBindingUniformBufferUpdateAfterBind", 1);

    print_VkBool32(obj->descriptorBindingSampledImageUpdateAfterBind, "descriptorBindingSampledImageUpdateAfterBind", 1);

    print_VkBool32(obj->descriptorBindingStorageImageUpdateAfterBind, "descriptorBindingStorageImageUpdateAfterBind", 1);

    print_VkBool32(obj->descriptorBindingStorageBufferUpdateAfterBind, "descriptorBindingStorageBufferUpdateAfterBind", 1);

    print_VkBool32(obj->descriptorBindingUniformTexelBufferUpdateAfterBind, "descriptorBindingUniformTexelBufferUpdateAfterBind",
                   1);

    print_VkBool32(obj->descriptorBindingStorageTexelBufferUpdateAfterBind, "descriptorBindingStorageTexelBufferUpdateAfterBind",
                   1);

    print_VkBool32(obj->descriptorBindingUpdateUnusedWhilePending, "descriptorBindingUpdateUnusedWhilePending", 1);

    print_VkBool32(obj->descriptorBindingPartiallyBound, "descriptorBindingPartiallyBound", 1);

    print_VkBool32(obj->descriptorBindingVariableDescriptorCount, "descriptorBindingVariableDescriptorCount", 1);

    print_VkBool32(obj->runtimeDescriptorArray, "runtimeDescriptorArray", 1);

    print_VkBool32(obj->samplerFilterMinmax, "samplerFilterMinmax", 1);

    print_VkBool32(obj->scalarBlockLayout, "scalarBlockLayout", 1);

    print_VkBool32(obj->imagelessFramebuffer, "imagelessFramebuffer", 1);

    print_VkBool32(obj->uniformBufferStandardLayout, "uniformBufferStandardLayout", 1);

    print_VkBool32(obj->shaderSubgroupExtendedTypes, "shaderSubgroupExtendedTypes", 1);

    print_VkBool32(obj->separateDepthStencilLayouts, "separateDepthStencilLayouts", 1);

    print_VkBool32(obj->hostQueryReset, "hostQueryReset", 1);

    print_VkBool32(obj->timelineSemaphore, "timelineSemaphore", 1);

    print_VkBool32(obj->bufferDeviceAddress, "bufferDeviceAddress", 1);

    print_VkBool32(obj->bufferDeviceAddressCaptureReplay, "bufferDeviceAddressCaptureReplay", 1);

    print_VkBool32(obj->bufferDeviceAddressMultiDevice, "bufferDeviceAddressMultiDevice", 1);

    print_VkBool32(obj->vulkanMemoryModel, "vulkanMemoryModel", 1);

    print_VkBool32(obj->vulkanMemoryModelDeviceScope, "vulkanMemoryModelDeviceScope", 1);

    print_VkBool32(obj->vulkanMemoryModelAvailabilityVisibilityChains, "vulkanMemoryModelAvailabilityVisibilityChains", 1);

    print_VkBool32(obj->shaderOutputViewportIndex, "shaderOutputViewportIndex", 1);

    print_VkBool32(obj->shaderOutputLayer, "shaderOutputLayer", 1);

    print_VkBool32(obj->subgroupBroadcastDynamicId, "subgroupBroadcastDynamicId", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkConformanceVersion(VkConformanceVersion obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint8_t(obj.major, "major", 1);

    print_uint8_t(obj.minor, "minor", 1);

    print_uint8_t(obj.subminor, "subminor", 1);

    print_uint8_t(obj.patch, "patch", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkConformanceVersion(const VkConformanceVersion* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint8_t(obj->major, "major", 1);

    print_uint8_t(obj->minor, "minor", 1);

    print_uint8_t(obj->subminor, "subminor", 1);

    print_uint8_t(obj->patch, "patch", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceVulkan12Properties(VkPhysicalDeviceVulkan12Properties obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDriverId(obj.driverID, "driverID", 1);

    PRINT_SPACE
    _OUT << "\"driverName\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DRIVER_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DRIVER_NAME_SIZE;
        print_char(obj.driverName[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"driverInfo\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DRIVER_INFO_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DRIVER_INFO_SIZE;
        print_char(obj.driverInfo[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"conformanceVersion\": " << std::endl;
    { print_VkConformanceVersion(obj.conformanceVersion, "conformanceVersion", 1); }

    print_VkShaderFloatControlsIndependence(obj.denormBehaviorIndependence, "denormBehaviorIndependence", 1);

    print_VkShaderFloatControlsIndependence(obj.roundingModeIndependence, "roundingModeIndependence", 1);

    print_VkBool32(obj.shaderSignedZeroInfNanPreserveFloat16, "shaderSignedZeroInfNanPreserveFloat16", 1);

    print_VkBool32(obj.shaderSignedZeroInfNanPreserveFloat32, "shaderSignedZeroInfNanPreserveFloat32", 1);

    print_VkBool32(obj.shaderSignedZeroInfNanPreserveFloat64, "shaderSignedZeroInfNanPreserveFloat64", 1);

    print_VkBool32(obj.shaderDenormPreserveFloat16, "shaderDenormPreserveFloat16", 1);

    print_VkBool32(obj.shaderDenormPreserveFloat32, "shaderDenormPreserveFloat32", 1);

    print_VkBool32(obj.shaderDenormPreserveFloat64, "shaderDenormPreserveFloat64", 1);

    print_VkBool32(obj.shaderDenormFlushToZeroFloat16, "shaderDenormFlushToZeroFloat16", 1);

    print_VkBool32(obj.shaderDenormFlushToZeroFloat32, "shaderDenormFlushToZeroFloat32", 1);

    print_VkBool32(obj.shaderDenormFlushToZeroFloat64, "shaderDenormFlushToZeroFloat64", 1);

    print_VkBool32(obj.shaderRoundingModeRTEFloat16, "shaderRoundingModeRTEFloat16", 1);

    print_VkBool32(obj.shaderRoundingModeRTEFloat32, "shaderRoundingModeRTEFloat32", 1);

    print_VkBool32(obj.shaderRoundingModeRTEFloat64, "shaderRoundingModeRTEFloat64", 1);

    print_VkBool32(obj.shaderRoundingModeRTZFloat16, "shaderRoundingModeRTZFloat16", 1);

    print_VkBool32(obj.shaderRoundingModeRTZFloat32, "shaderRoundingModeRTZFloat32", 1);

    print_VkBool32(obj.shaderRoundingModeRTZFloat64, "shaderRoundingModeRTZFloat64", 1);

    print_uint32_t(obj.maxUpdateAfterBindDescriptorsInAllPools, "maxUpdateAfterBindDescriptorsInAllPools", 1);

    print_VkBool32(obj.shaderUniformBufferArrayNonUniformIndexingNative, "shaderUniformBufferArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj.shaderSampledImageArrayNonUniformIndexingNative, "shaderSampledImageArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj.shaderStorageBufferArrayNonUniformIndexingNative, "shaderStorageBufferArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj.shaderStorageImageArrayNonUniformIndexingNative, "shaderStorageImageArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj.shaderInputAttachmentArrayNonUniformIndexingNative, "shaderInputAttachmentArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj.robustBufferAccessUpdateAfterBind, "robustBufferAccessUpdateAfterBind", 1);

    print_VkBool32(obj.quadDivergentImplicitLod, "quadDivergentImplicitLod", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindSamplers, "maxPerStageDescriptorUpdateAfterBindSamplers", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindUniformBuffers, "maxPerStageDescriptorUpdateAfterBindUniformBuffers", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindStorageBuffers, "maxPerStageDescriptorUpdateAfterBindStorageBuffers", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindSampledImages, "maxPerStageDescriptorUpdateAfterBindSampledImages", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindStorageImages, "maxPerStageDescriptorUpdateAfterBindStorageImages", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindInputAttachments, "maxPerStageDescriptorUpdateAfterBindInputAttachments",
                   1);

    print_uint32_t(obj.maxPerStageUpdateAfterBindResources, "maxPerStageUpdateAfterBindResources", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindSamplers, "maxDescriptorSetUpdateAfterBindSamplers", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindUniformBuffers, "maxDescriptorSetUpdateAfterBindUniformBuffers", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic",
                   1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindStorageBuffers, "maxDescriptorSetUpdateAfterBindStorageBuffers", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic",
                   1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindSampledImages, "maxDescriptorSetUpdateAfterBindSampledImages", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindStorageImages, "maxDescriptorSetUpdateAfterBindStorageImages", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindInputAttachments, "maxDescriptorSetUpdateAfterBindInputAttachments", 1);

    print_VkResolveModeFlags(obj.supportedDepthResolveModes, "supportedDepthResolveModes", 1);

    print_VkResolveModeFlags(obj.supportedStencilResolveModes, "supportedStencilResolveModes", 1);

    print_VkBool32(obj.independentResolveNone, "independentResolveNone", 1);

    print_VkBool32(obj.independentResolve, "independentResolve", 1);

    print_VkBool32(obj.filterMinmaxSingleComponentFormats, "filterMinmaxSingleComponentFormats", 1);

    print_VkBool32(obj.filterMinmaxImageComponentMapping, "filterMinmaxImageComponentMapping", 1);

    print_uint64_t(obj.maxTimelineSemaphoreValueDifference, "maxTimelineSemaphoreValueDifference", 1);

    print_VkSampleCountFlags(obj.framebufferIntegerColorSampleCounts, "framebufferIntegerColorSampleCounts", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVulkan12Properties(const VkPhysicalDeviceVulkan12Properties* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDriverId(obj->driverID, "driverID", 1);

    PRINT_SPACE
    _OUT << "\"driverName\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DRIVER_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DRIVER_NAME_SIZE;
        print_char(obj->driverName[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"driverInfo\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DRIVER_INFO_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DRIVER_INFO_SIZE;
        print_char(obj->driverInfo[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"conformanceVersion\": " << std::endl;
    { print_VkConformanceVersion(obj->conformanceVersion, "conformanceVersion", 1); }

    print_VkShaderFloatControlsIndependence(obj->denormBehaviorIndependence, "denormBehaviorIndependence", 1);

    print_VkShaderFloatControlsIndependence(obj->roundingModeIndependence, "roundingModeIndependence", 1);

    print_VkBool32(obj->shaderSignedZeroInfNanPreserveFloat16, "shaderSignedZeroInfNanPreserveFloat16", 1);

    print_VkBool32(obj->shaderSignedZeroInfNanPreserveFloat32, "shaderSignedZeroInfNanPreserveFloat32", 1);

    print_VkBool32(obj->shaderSignedZeroInfNanPreserveFloat64, "shaderSignedZeroInfNanPreserveFloat64", 1);

    print_VkBool32(obj->shaderDenormPreserveFloat16, "shaderDenormPreserveFloat16", 1);

    print_VkBool32(obj->shaderDenormPreserveFloat32, "shaderDenormPreserveFloat32", 1);

    print_VkBool32(obj->shaderDenormPreserveFloat64, "shaderDenormPreserveFloat64", 1);

    print_VkBool32(obj->shaderDenormFlushToZeroFloat16, "shaderDenormFlushToZeroFloat16", 1);

    print_VkBool32(obj->shaderDenormFlushToZeroFloat32, "shaderDenormFlushToZeroFloat32", 1);

    print_VkBool32(obj->shaderDenormFlushToZeroFloat64, "shaderDenormFlushToZeroFloat64", 1);

    print_VkBool32(obj->shaderRoundingModeRTEFloat16, "shaderRoundingModeRTEFloat16", 1);

    print_VkBool32(obj->shaderRoundingModeRTEFloat32, "shaderRoundingModeRTEFloat32", 1);

    print_VkBool32(obj->shaderRoundingModeRTEFloat64, "shaderRoundingModeRTEFloat64", 1);

    print_VkBool32(obj->shaderRoundingModeRTZFloat16, "shaderRoundingModeRTZFloat16", 1);

    print_VkBool32(obj->shaderRoundingModeRTZFloat32, "shaderRoundingModeRTZFloat32", 1);

    print_VkBool32(obj->shaderRoundingModeRTZFloat64, "shaderRoundingModeRTZFloat64", 1);

    print_uint32_t(obj->maxUpdateAfterBindDescriptorsInAllPools, "maxUpdateAfterBindDescriptorsInAllPools", 1);

    print_VkBool32(obj->shaderUniformBufferArrayNonUniformIndexingNative, "shaderUniformBufferArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj->shaderSampledImageArrayNonUniformIndexingNative, "shaderSampledImageArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj->shaderStorageBufferArrayNonUniformIndexingNative, "shaderStorageBufferArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj->shaderStorageImageArrayNonUniformIndexingNative, "shaderStorageImageArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj->shaderInputAttachmentArrayNonUniformIndexingNative, "shaderInputAttachmentArrayNonUniformIndexingNative",
                   1);

    print_VkBool32(obj->robustBufferAccessUpdateAfterBind, "robustBufferAccessUpdateAfterBind", 1);

    print_VkBool32(obj->quadDivergentImplicitLod, "quadDivergentImplicitLod", 1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindSamplers, "maxPerStageDescriptorUpdateAfterBindSamplers", 1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindUniformBuffers, "maxPerStageDescriptorUpdateAfterBindUniformBuffers",
                   1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindStorageBuffers, "maxPerStageDescriptorUpdateAfterBindStorageBuffers",
                   1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindSampledImages, "maxPerStageDescriptorUpdateAfterBindSampledImages", 1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindStorageImages, "maxPerStageDescriptorUpdateAfterBindStorageImages", 1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindInputAttachments,
                   "maxPerStageDescriptorUpdateAfterBindInputAttachments", 1);

    print_uint32_t(obj->maxPerStageUpdateAfterBindResources, "maxPerStageUpdateAfterBindResources", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindSamplers, "maxDescriptorSetUpdateAfterBindSamplers", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindUniformBuffers, "maxDescriptorSetUpdateAfterBindUniformBuffers", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic,
                   "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindStorageBuffers, "maxDescriptorSetUpdateAfterBindStorageBuffers", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic,
                   "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindSampledImages, "maxDescriptorSetUpdateAfterBindSampledImages", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindStorageImages, "maxDescriptorSetUpdateAfterBindStorageImages", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindInputAttachments, "maxDescriptorSetUpdateAfterBindInputAttachments", 1);

    print_VkResolveModeFlags(obj->supportedDepthResolveModes, "supportedDepthResolveModes", 1);

    print_VkResolveModeFlags(obj->supportedStencilResolveModes, "supportedStencilResolveModes", 1);

    print_VkBool32(obj->independentResolveNone, "independentResolveNone", 1);

    print_VkBool32(obj->independentResolve, "independentResolve", 1);

    print_VkBool32(obj->filterMinmaxSingleComponentFormats, "filterMinmaxSingleComponentFormats", 1);

    print_VkBool32(obj->filterMinmaxImageComponentMapping, "filterMinmaxImageComponentMapping", 1);

    print_uint64_t(obj->maxTimelineSemaphoreValueDifference, "maxTimelineSemaphoreValueDifference", 1);

    print_VkSampleCountFlags(obj->framebufferIntegerColorSampleCounts, "framebufferIntegerColorSampleCounts", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageFormatListCreateInfo(VkImageFormatListCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.viewFormatCount, "viewFormatCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewFormats\":" << std::endl;
    PRINT_SPACE
    if (obj.pViewFormats) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.viewFormatCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.viewFormatCount;
            print_VkFormat(obj.pViewFormats[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageFormatListCreateInfo(const VkImageFormatListCreateInfo* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->viewFormatCount, "viewFormatCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewFormats\":" << std::endl;
    PRINT_SPACE
    if (obj->pViewFormats) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->viewFormatCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->viewFormatCount;
            print_VkFormat(obj->pViewFormats[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAttachmentDescription2(VkAttachmentDescription2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAttachmentDescriptionFlags(obj.flags, "flags", 1);

    print_VkFormat(obj.format, "format", 1);

    print_VkSampleCountFlagBits(obj.samples, "samples", 1);

    print_VkAttachmentLoadOp(obj.loadOp, "loadOp", 1);

    print_VkAttachmentStoreOp(obj.storeOp, "storeOp", 1);

    print_VkAttachmentLoadOp(obj.stencilLoadOp, "stencilLoadOp", 1);

    print_VkAttachmentStoreOp(obj.stencilStoreOp, "stencilStoreOp", 1);

    print_VkImageLayout(obj.initialLayout, "initialLayout", 1);

    print_VkImageLayout(obj.finalLayout, "finalLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAttachmentDescription2(const VkAttachmentDescription2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAttachmentDescriptionFlags(obj->flags, "flags", 1);

    print_VkFormat(obj->format, "format", 1);

    print_VkSampleCountFlagBits(obj->samples, "samples", 1);

    print_VkAttachmentLoadOp(obj->loadOp, "loadOp", 1);

    print_VkAttachmentStoreOp(obj->storeOp, "storeOp", 1);

    print_VkAttachmentLoadOp(obj->stencilLoadOp, "stencilLoadOp", 1);

    print_VkAttachmentStoreOp(obj->stencilStoreOp, "stencilStoreOp", 1);

    print_VkImageLayout(obj->initialLayout, "initialLayout", 1);

    print_VkImageLayout(obj->finalLayout, "finalLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAttachmentReference2(VkAttachmentReference2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.attachment, "attachment", 1);

    print_VkImageLayout(obj.layout, "layout", 1);

    print_VkImageAspectFlags(obj.aspectMask, "aspectMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAttachmentReference2(const VkAttachmentReference2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->attachment, "attachment", 1);

    print_VkImageLayout(obj->layout, "layout", 1);

    print_VkImageAspectFlags(obj->aspectMask, "aspectMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubpassDescription2(VkSubpassDescription2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSubpassDescriptionFlags(obj.flags, "flags", 1);

    print_VkPipelineBindPoint(obj.pipelineBindPoint, "pipelineBindPoint", 1);

    print_uint32_t(obj.viewMask, "viewMask", 1);

    print_uint32_t(obj.inputAttachmentCount, "inputAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pInputAttachments\": " << std::endl;
    if (obj.pInputAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.inputAttachmentCount; i++) {
            if (i + 1 == obj.inputAttachmentCount)
                print_VkAttachmentReference2(obj.pInputAttachments[i], "pInputAttachments", 0);
            else
                print_VkAttachmentReference2(obj.pInputAttachments[i], "pInputAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachments\": " << std::endl;
    if (obj.pColorAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.colorAttachmentCount; i++) {
            if (i + 1 == obj.colorAttachmentCount)
                print_VkAttachmentReference2(obj.pColorAttachments[i], "pColorAttachments", 0);
            else
                print_VkAttachmentReference2(obj.pColorAttachments[i], "pColorAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pResolveAttachments\": " << std::endl;
    if (obj.pResolveAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.colorAttachmentCount; i++) {
            if (i + 1 == obj.colorAttachmentCount)
                print_VkAttachmentReference2(obj.pResolveAttachments[i], "pResolveAttachments", 0);
            else
                print_VkAttachmentReference2(obj.pResolveAttachments[i], "pResolveAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pDepthStencilAttachment\": " << std::endl;
    if (obj.pDepthStencilAttachment) {
        print_VkAttachmentReference2(obj.pDepthStencilAttachment, "pDepthStencilAttachment", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.preserveAttachmentCount, "preserveAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pPreserveAttachments\":" << std::endl;
    PRINT_SPACE
    if (obj.pPreserveAttachments) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.preserveAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.preserveAttachmentCount;
            print_uint32_t(obj.pPreserveAttachments[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubpassDescription2(const VkSubpassDescription2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSubpassDescriptionFlags(obj->flags, "flags", 1);

    print_VkPipelineBindPoint(obj->pipelineBindPoint, "pipelineBindPoint", 1);

    print_uint32_t(obj->viewMask, "viewMask", 1);

    print_uint32_t(obj->inputAttachmentCount, "inputAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pInputAttachments\": " << std::endl;
    if (obj->pInputAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->inputAttachmentCount; i++) {
            if (i + 1 == obj->inputAttachmentCount)
                print_VkAttachmentReference2(obj->pInputAttachments[i], "pInputAttachments", 0);
            else
                print_VkAttachmentReference2(obj->pInputAttachments[i], "pInputAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachments\": " << std::endl;
    if (obj->pColorAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->colorAttachmentCount; i++) {
            if (i + 1 == obj->colorAttachmentCount)
                print_VkAttachmentReference2(obj->pColorAttachments[i], "pColorAttachments", 0);
            else
                print_VkAttachmentReference2(obj->pColorAttachments[i], "pColorAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pResolveAttachments\": " << std::endl;
    if (obj->pResolveAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->colorAttachmentCount; i++) {
            if (i + 1 == obj->colorAttachmentCount)
                print_VkAttachmentReference2(obj->pResolveAttachments[i], "pResolveAttachments", 0);
            else
                print_VkAttachmentReference2(obj->pResolveAttachments[i], "pResolveAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pDepthStencilAttachment\": " << std::endl;
    if (obj->pDepthStencilAttachment) {
        print_VkAttachmentReference2(obj->pDepthStencilAttachment, "pDepthStencilAttachment", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->preserveAttachmentCount, "preserveAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pPreserveAttachments\":" << std::endl;
    PRINT_SPACE
    if (obj->pPreserveAttachments) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->preserveAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->preserveAttachmentCount;
            print_uint32_t(obj->pPreserveAttachments[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubpassDependency2(VkSubpassDependency2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.srcSubpass, "srcSubpass", 1);

    print_uint32_t(obj.dstSubpass, "dstSubpass", 1);

    print_VkPipelineStageFlags(obj.srcStageMask, "srcStageMask", 1);

    print_VkPipelineStageFlags(obj.dstStageMask, "dstStageMask", 1);

    print_VkAccessFlags(obj.srcAccessMask, "srcAccessMask", 1);

    print_VkAccessFlags(obj.dstAccessMask, "dstAccessMask", 1);

    print_VkDependencyFlags(obj.dependencyFlags, "dependencyFlags", 1);

    print_int32_t(obj.viewOffset, "viewOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubpassDependency2(const VkSubpassDependency2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->srcSubpass, "srcSubpass", 1);

    print_uint32_t(obj->dstSubpass, "dstSubpass", 1);

    print_VkPipelineStageFlags(obj->srcStageMask, "srcStageMask", 1);

    print_VkPipelineStageFlags(obj->dstStageMask, "dstStageMask", 1);

    print_VkAccessFlags(obj->srcAccessMask, "srcAccessMask", 1);

    print_VkAccessFlags(obj->dstAccessMask, "dstAccessMask", 1);

    print_VkDependencyFlags(obj->dependencyFlags, "dependencyFlags", 1);

    print_int32_t(obj->viewOffset, "viewOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassCreateInfo2(VkRenderPassCreateInfo2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRenderPassCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.attachmentCount, "attachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachments\": " << std::endl;
    if (obj.pAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.attachmentCount; i++) {
            if (i + 1 == obj.attachmentCount)
                print_VkAttachmentDescription2(obj.pAttachments[i], "pAttachments", 0);
            else
                print_VkAttachmentDescription2(obj.pAttachments[i], "pAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.subpassCount, "subpassCount", 1);

    PRINT_SPACE
    _OUT << "\"pSubpasses\": " << std::endl;
    if (obj.pSubpasses) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.subpassCount; i++) {
            if (i + 1 == obj.subpassCount)
                print_VkSubpassDescription2(obj.pSubpasses[i], "pSubpasses", 0);
            else
                print_VkSubpassDescription2(obj.pSubpasses[i], "pSubpasses", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.dependencyCount, "dependencyCount", 1);

    PRINT_SPACE
    _OUT << "\"pDependencies\": " << std::endl;
    if (obj.pDependencies) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.dependencyCount; i++) {
            if (i + 1 == obj.dependencyCount)
                print_VkSubpassDependency2(obj.pDependencies[i], "pDependencies", 0);
            else
                print_VkSubpassDependency2(obj.pDependencies[i], "pDependencies", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.correlatedViewMaskCount, "correlatedViewMaskCount", 1);

    PRINT_SPACE
    _OUT << "\"pCorrelatedViewMasks\":" << std::endl;
    PRINT_SPACE
    if (obj.pCorrelatedViewMasks) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.correlatedViewMaskCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.correlatedViewMaskCount;
            print_uint32_t(obj.pCorrelatedViewMasks[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassCreateInfo2(const VkRenderPassCreateInfo2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRenderPassCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->attachmentCount, "attachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachments\": " << std::endl;
    if (obj->pAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->attachmentCount; i++) {
            if (i + 1 == obj->attachmentCount)
                print_VkAttachmentDescription2(obj->pAttachments[i], "pAttachments", 0);
            else
                print_VkAttachmentDescription2(obj->pAttachments[i], "pAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->subpassCount, "subpassCount", 1);

    PRINT_SPACE
    _OUT << "\"pSubpasses\": " << std::endl;
    if (obj->pSubpasses) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->subpassCount; i++) {
            if (i + 1 == obj->subpassCount)
                print_VkSubpassDescription2(obj->pSubpasses[i], "pSubpasses", 0);
            else
                print_VkSubpassDescription2(obj->pSubpasses[i], "pSubpasses", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->dependencyCount, "dependencyCount", 1);

    PRINT_SPACE
    _OUT << "\"pDependencies\": " << std::endl;
    if (obj->pDependencies) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->dependencyCount; i++) {
            if (i + 1 == obj->dependencyCount)
                print_VkSubpassDependency2(obj->pDependencies[i], "pDependencies", 0);
            else
                print_VkSubpassDependency2(obj->pDependencies[i], "pDependencies", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->correlatedViewMaskCount, "correlatedViewMaskCount", 1);

    PRINT_SPACE
    _OUT << "\"pCorrelatedViewMasks\":" << std::endl;
    PRINT_SPACE
    if (obj->pCorrelatedViewMasks) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->correlatedViewMaskCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->correlatedViewMaskCount;
            print_uint32_t(obj->pCorrelatedViewMasks[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubpassBeginInfo(VkSubpassBeginInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSubpassContents(obj.contents, "contents", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubpassBeginInfo(const VkSubpassBeginInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSubpassContents(obj->contents, "contents", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubpassEndInfo(VkSubpassEndInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubpassEndInfo(const VkSubpassEndInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevice8BitStorageFeatures(VkPhysicalDevice8BitStorageFeatures obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.storageBuffer8BitAccess, "storageBuffer8BitAccess", 1);

    print_VkBool32(obj.uniformAndStorageBuffer8BitAccess, "uniformAndStorageBuffer8BitAccess", 1);

    print_VkBool32(obj.storagePushConstant8, "storagePushConstant8", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevice8BitStorageFeatures(const VkPhysicalDevice8BitStorageFeatures* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->storageBuffer8BitAccess, "storageBuffer8BitAccess", 1);

    print_VkBool32(obj->uniformAndStorageBuffer8BitAccess, "uniformAndStorageBuffer8BitAccess", 1);

    print_VkBool32(obj->storagePushConstant8, "storagePushConstant8", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDriverProperties(VkPhysicalDeviceDriverProperties obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDriverId(obj.driverID, "driverID", 1);

    PRINT_SPACE
    _OUT << "\"driverName\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DRIVER_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DRIVER_NAME_SIZE;
        print_char(obj.driverName[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"driverInfo\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DRIVER_INFO_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DRIVER_INFO_SIZE;
        print_char(obj.driverInfo[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"conformanceVersion\": " << std::endl;
    { print_VkConformanceVersion(obj.conformanceVersion, "conformanceVersion", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDriverProperties(const VkPhysicalDeviceDriverProperties* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDriverId(obj->driverID, "driverID", 1);

    PRINT_SPACE
    _OUT << "\"driverName\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DRIVER_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DRIVER_NAME_SIZE;
        print_char(obj->driverName[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"driverInfo\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DRIVER_INFO_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DRIVER_INFO_SIZE;
        print_char(obj->driverInfo[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"conformanceVersion\": " << std::endl;
    { print_VkConformanceVersion(obj->conformanceVersion, "conformanceVersion", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderAtomicInt64Features(VkPhysicalDeviceShaderAtomicInt64Features obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderBufferInt64Atomics, "shaderBufferInt64Atomics", 1);

    print_VkBool32(obj.shaderSharedInt64Atomics, "shaderSharedInt64Atomics", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderAtomicInt64Features(const VkPhysicalDeviceShaderAtomicInt64Features* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderBufferInt64Atomics, "shaderBufferInt64Atomics", 1);

    print_VkBool32(obj->shaderSharedInt64Atomics, "shaderSharedInt64Atomics", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderFloat16Int8Features(VkPhysicalDeviceShaderFloat16Int8Features obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderFloat16, "shaderFloat16", 1);

    print_VkBool32(obj.shaderInt8, "shaderInt8", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderFloat16Int8Features(const VkPhysicalDeviceShaderFloat16Int8Features* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderFloat16, "shaderFloat16", 1);

    print_VkBool32(obj->shaderInt8, "shaderInt8", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFloatControlsProperties(VkPhysicalDeviceFloatControlsProperties obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderFloatControlsIndependence(obj.denormBehaviorIndependence, "denormBehaviorIndependence", 1);

    print_VkShaderFloatControlsIndependence(obj.roundingModeIndependence, "roundingModeIndependence", 1);

    print_VkBool32(obj.shaderSignedZeroInfNanPreserveFloat16, "shaderSignedZeroInfNanPreserveFloat16", 1);

    print_VkBool32(obj.shaderSignedZeroInfNanPreserveFloat32, "shaderSignedZeroInfNanPreserveFloat32", 1);

    print_VkBool32(obj.shaderSignedZeroInfNanPreserveFloat64, "shaderSignedZeroInfNanPreserveFloat64", 1);

    print_VkBool32(obj.shaderDenormPreserveFloat16, "shaderDenormPreserveFloat16", 1);

    print_VkBool32(obj.shaderDenormPreserveFloat32, "shaderDenormPreserveFloat32", 1);

    print_VkBool32(obj.shaderDenormPreserveFloat64, "shaderDenormPreserveFloat64", 1);

    print_VkBool32(obj.shaderDenormFlushToZeroFloat16, "shaderDenormFlushToZeroFloat16", 1);

    print_VkBool32(obj.shaderDenormFlushToZeroFloat32, "shaderDenormFlushToZeroFloat32", 1);

    print_VkBool32(obj.shaderDenormFlushToZeroFloat64, "shaderDenormFlushToZeroFloat64", 1);

    print_VkBool32(obj.shaderRoundingModeRTEFloat16, "shaderRoundingModeRTEFloat16", 1);

    print_VkBool32(obj.shaderRoundingModeRTEFloat32, "shaderRoundingModeRTEFloat32", 1);

    print_VkBool32(obj.shaderRoundingModeRTEFloat64, "shaderRoundingModeRTEFloat64", 1);

    print_VkBool32(obj.shaderRoundingModeRTZFloat16, "shaderRoundingModeRTZFloat16", 1);

    print_VkBool32(obj.shaderRoundingModeRTZFloat32, "shaderRoundingModeRTZFloat32", 1);

    print_VkBool32(obj.shaderRoundingModeRTZFloat64, "shaderRoundingModeRTZFloat64", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFloatControlsProperties(const VkPhysicalDeviceFloatControlsProperties* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderFloatControlsIndependence(obj->denormBehaviorIndependence, "denormBehaviorIndependence", 1);

    print_VkShaderFloatControlsIndependence(obj->roundingModeIndependence, "roundingModeIndependence", 1);

    print_VkBool32(obj->shaderSignedZeroInfNanPreserveFloat16, "shaderSignedZeroInfNanPreserveFloat16", 1);

    print_VkBool32(obj->shaderSignedZeroInfNanPreserveFloat32, "shaderSignedZeroInfNanPreserveFloat32", 1);

    print_VkBool32(obj->shaderSignedZeroInfNanPreserveFloat64, "shaderSignedZeroInfNanPreserveFloat64", 1);

    print_VkBool32(obj->shaderDenormPreserveFloat16, "shaderDenormPreserveFloat16", 1);

    print_VkBool32(obj->shaderDenormPreserveFloat32, "shaderDenormPreserveFloat32", 1);

    print_VkBool32(obj->shaderDenormPreserveFloat64, "shaderDenormPreserveFloat64", 1);

    print_VkBool32(obj->shaderDenormFlushToZeroFloat16, "shaderDenormFlushToZeroFloat16", 1);

    print_VkBool32(obj->shaderDenormFlushToZeroFloat32, "shaderDenormFlushToZeroFloat32", 1);

    print_VkBool32(obj->shaderDenormFlushToZeroFloat64, "shaderDenormFlushToZeroFloat64", 1);

    print_VkBool32(obj->shaderRoundingModeRTEFloat16, "shaderRoundingModeRTEFloat16", 1);

    print_VkBool32(obj->shaderRoundingModeRTEFloat32, "shaderRoundingModeRTEFloat32", 1);

    print_VkBool32(obj->shaderRoundingModeRTEFloat64, "shaderRoundingModeRTEFloat64", 1);

    print_VkBool32(obj->shaderRoundingModeRTZFloat16, "shaderRoundingModeRTZFloat16", 1);

    print_VkBool32(obj->shaderRoundingModeRTZFloat32, "shaderRoundingModeRTZFloat32", 1);

    print_VkBool32(obj->shaderRoundingModeRTZFloat64, "shaderRoundingModeRTZFloat64", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorSetLayoutBindingFlagsCreateInfo(VkDescriptorSetLayoutBindingFlagsCreateInfo obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.bindingCount, "bindingCount", 1);

    PRINT_SPACE
    _OUT << "\"pBindingFlags\":" << std::endl;
    PRINT_SPACE
    if (obj.pBindingFlags) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.bindingCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.bindingCount;
            print_VkDescriptorBindingFlags(obj.pBindingFlags[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorSetLayoutBindingFlagsCreateInfo(const VkDescriptorSetLayoutBindingFlagsCreateInfo* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->bindingCount, "bindingCount", 1);

    PRINT_SPACE
    _OUT << "\"pBindingFlags\":" << std::endl;
    PRINT_SPACE
    if (obj->pBindingFlags) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->bindingCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->bindingCount;
            print_VkDescriptorBindingFlags(obj->pBindingFlags[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDescriptorIndexingFeatures(VkPhysicalDeviceDescriptorIndexingFeatures obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderInputAttachmentArrayDynamicIndexing, "shaderInputAttachmentArrayDynamicIndexing", 1);

    print_VkBool32(obj.shaderUniformTexelBufferArrayDynamicIndexing, "shaderUniformTexelBufferArrayDynamicIndexing", 1);

    print_VkBool32(obj.shaderStorageTexelBufferArrayDynamicIndexing, "shaderStorageTexelBufferArrayDynamicIndexing", 1);

    print_VkBool32(obj.shaderUniformBufferArrayNonUniformIndexing, "shaderUniformBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj.shaderSampledImageArrayNonUniformIndexing, "shaderSampledImageArrayNonUniformIndexing", 1);

    print_VkBool32(obj.shaderStorageBufferArrayNonUniformIndexing, "shaderStorageBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj.shaderStorageImageArrayNonUniformIndexing, "shaderStorageImageArrayNonUniformIndexing", 1);

    print_VkBool32(obj.shaderInputAttachmentArrayNonUniformIndexing, "shaderInputAttachmentArrayNonUniformIndexing", 1);

    print_VkBool32(obj.shaderUniformTexelBufferArrayNonUniformIndexing, "shaderUniformTexelBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj.shaderStorageTexelBufferArrayNonUniformIndexing, "shaderStorageTexelBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj.descriptorBindingUniformBufferUpdateAfterBind, "descriptorBindingUniformBufferUpdateAfterBind", 1);

    print_VkBool32(obj.descriptorBindingSampledImageUpdateAfterBind, "descriptorBindingSampledImageUpdateAfterBind", 1);

    print_VkBool32(obj.descriptorBindingStorageImageUpdateAfterBind, "descriptorBindingStorageImageUpdateAfterBind", 1);

    print_VkBool32(obj.descriptorBindingStorageBufferUpdateAfterBind, "descriptorBindingStorageBufferUpdateAfterBind", 1);

    print_VkBool32(obj.descriptorBindingUniformTexelBufferUpdateAfterBind, "descriptorBindingUniformTexelBufferUpdateAfterBind", 1);

    print_VkBool32(obj.descriptorBindingStorageTexelBufferUpdateAfterBind, "descriptorBindingStorageTexelBufferUpdateAfterBind", 1);

    print_VkBool32(obj.descriptorBindingUpdateUnusedWhilePending, "descriptorBindingUpdateUnusedWhilePending", 1);

    print_VkBool32(obj.descriptorBindingPartiallyBound, "descriptorBindingPartiallyBound", 1);

    print_VkBool32(obj.descriptorBindingVariableDescriptorCount, "descriptorBindingVariableDescriptorCount", 1);

    print_VkBool32(obj.runtimeDescriptorArray, "runtimeDescriptorArray", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDescriptorIndexingFeatures(const VkPhysicalDeviceDescriptorIndexingFeatures* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderInputAttachmentArrayDynamicIndexing, "shaderInputAttachmentArrayDynamicIndexing", 1);

    print_VkBool32(obj->shaderUniformTexelBufferArrayDynamicIndexing, "shaderUniformTexelBufferArrayDynamicIndexing", 1);

    print_VkBool32(obj->shaderStorageTexelBufferArrayDynamicIndexing, "shaderStorageTexelBufferArrayDynamicIndexing", 1);

    print_VkBool32(obj->shaderUniformBufferArrayNonUniformIndexing, "shaderUniformBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj->shaderSampledImageArrayNonUniformIndexing, "shaderSampledImageArrayNonUniformIndexing", 1);

    print_VkBool32(obj->shaderStorageBufferArrayNonUniformIndexing, "shaderStorageBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj->shaderStorageImageArrayNonUniformIndexing, "shaderStorageImageArrayNonUniformIndexing", 1);

    print_VkBool32(obj->shaderInputAttachmentArrayNonUniformIndexing, "shaderInputAttachmentArrayNonUniformIndexing", 1);

    print_VkBool32(obj->shaderUniformTexelBufferArrayNonUniformIndexing, "shaderUniformTexelBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj->shaderStorageTexelBufferArrayNonUniformIndexing, "shaderStorageTexelBufferArrayNonUniformIndexing", 1);

    print_VkBool32(obj->descriptorBindingUniformBufferUpdateAfterBind, "descriptorBindingUniformBufferUpdateAfterBind", 1);

    print_VkBool32(obj->descriptorBindingSampledImageUpdateAfterBind, "descriptorBindingSampledImageUpdateAfterBind", 1);

    print_VkBool32(obj->descriptorBindingStorageImageUpdateAfterBind, "descriptorBindingStorageImageUpdateAfterBind", 1);

    print_VkBool32(obj->descriptorBindingStorageBufferUpdateAfterBind, "descriptorBindingStorageBufferUpdateAfterBind", 1);

    print_VkBool32(obj->descriptorBindingUniformTexelBufferUpdateAfterBind, "descriptorBindingUniformTexelBufferUpdateAfterBind",
                   1);

    print_VkBool32(obj->descriptorBindingStorageTexelBufferUpdateAfterBind, "descriptorBindingStorageTexelBufferUpdateAfterBind",
                   1);

    print_VkBool32(obj->descriptorBindingUpdateUnusedWhilePending, "descriptorBindingUpdateUnusedWhilePending", 1);

    print_VkBool32(obj->descriptorBindingPartiallyBound, "descriptorBindingPartiallyBound", 1);

    print_VkBool32(obj->descriptorBindingVariableDescriptorCount, "descriptorBindingVariableDescriptorCount", 1);

    print_VkBool32(obj->runtimeDescriptorArray, "runtimeDescriptorArray", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDescriptorIndexingProperties(VkPhysicalDeviceDescriptorIndexingProperties obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxUpdateAfterBindDescriptorsInAllPools, "maxUpdateAfterBindDescriptorsInAllPools", 1);

    print_VkBool32(obj.shaderUniformBufferArrayNonUniformIndexingNative, "shaderUniformBufferArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj.shaderSampledImageArrayNonUniformIndexingNative, "shaderSampledImageArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj.shaderStorageBufferArrayNonUniformIndexingNative, "shaderStorageBufferArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj.shaderStorageImageArrayNonUniformIndexingNative, "shaderStorageImageArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj.shaderInputAttachmentArrayNonUniformIndexingNative, "shaderInputAttachmentArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj.robustBufferAccessUpdateAfterBind, "robustBufferAccessUpdateAfterBind", 1);

    print_VkBool32(obj.quadDivergentImplicitLod, "quadDivergentImplicitLod", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindSamplers, "maxPerStageDescriptorUpdateAfterBindSamplers", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindUniformBuffers, "maxPerStageDescriptorUpdateAfterBindUniformBuffers", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindStorageBuffers, "maxPerStageDescriptorUpdateAfterBindStorageBuffers", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindSampledImages, "maxPerStageDescriptorUpdateAfterBindSampledImages", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindStorageImages, "maxPerStageDescriptorUpdateAfterBindStorageImages", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindInputAttachments, "maxPerStageDescriptorUpdateAfterBindInputAttachments",
                   1);

    print_uint32_t(obj.maxPerStageUpdateAfterBindResources, "maxPerStageUpdateAfterBindResources", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindSamplers, "maxDescriptorSetUpdateAfterBindSamplers", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindUniformBuffers, "maxDescriptorSetUpdateAfterBindUniformBuffers", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic",
                   1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindStorageBuffers, "maxDescriptorSetUpdateAfterBindStorageBuffers", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic",
                   1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindSampledImages, "maxDescriptorSetUpdateAfterBindSampledImages", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindStorageImages, "maxDescriptorSetUpdateAfterBindStorageImages", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindInputAttachments, "maxDescriptorSetUpdateAfterBindInputAttachments", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDescriptorIndexingProperties(const VkPhysicalDeviceDescriptorIndexingProperties* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxUpdateAfterBindDescriptorsInAllPools, "maxUpdateAfterBindDescriptorsInAllPools", 1);

    print_VkBool32(obj->shaderUniformBufferArrayNonUniformIndexingNative, "shaderUniformBufferArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj->shaderSampledImageArrayNonUniformIndexingNative, "shaderSampledImageArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj->shaderStorageBufferArrayNonUniformIndexingNative, "shaderStorageBufferArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj->shaderStorageImageArrayNonUniformIndexingNative, "shaderStorageImageArrayNonUniformIndexingNative", 1);

    print_VkBool32(obj->shaderInputAttachmentArrayNonUniformIndexingNative, "shaderInputAttachmentArrayNonUniformIndexingNative",
                   1);

    print_VkBool32(obj->robustBufferAccessUpdateAfterBind, "robustBufferAccessUpdateAfterBind", 1);

    print_VkBool32(obj->quadDivergentImplicitLod, "quadDivergentImplicitLod", 1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindSamplers, "maxPerStageDescriptorUpdateAfterBindSamplers", 1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindUniformBuffers, "maxPerStageDescriptorUpdateAfterBindUniformBuffers",
                   1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindStorageBuffers, "maxPerStageDescriptorUpdateAfterBindStorageBuffers",
                   1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindSampledImages, "maxPerStageDescriptorUpdateAfterBindSampledImages", 1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindStorageImages, "maxPerStageDescriptorUpdateAfterBindStorageImages", 1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindInputAttachments,
                   "maxPerStageDescriptorUpdateAfterBindInputAttachments", 1);

    print_uint32_t(obj->maxPerStageUpdateAfterBindResources, "maxPerStageUpdateAfterBindResources", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindSamplers, "maxDescriptorSetUpdateAfterBindSamplers", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindUniformBuffers, "maxDescriptorSetUpdateAfterBindUniformBuffers", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic,
                   "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindStorageBuffers, "maxDescriptorSetUpdateAfterBindStorageBuffers", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic,
                   "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindSampledImages, "maxDescriptorSetUpdateAfterBindSampledImages", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindStorageImages, "maxDescriptorSetUpdateAfterBindStorageImages", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindInputAttachments, "maxDescriptorSetUpdateAfterBindInputAttachments", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorSetVariableDescriptorCountAllocateInfo(VkDescriptorSetVariableDescriptorCountAllocateInfo obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.descriptorSetCount, "descriptorSetCount", 1);

    PRINT_SPACE
    _OUT << "\"pDescriptorCounts\":" << std::endl;
    PRINT_SPACE
    if (obj.pDescriptorCounts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.descriptorSetCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.descriptorSetCount;
            print_uint32_t(obj.pDescriptorCounts[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorSetVariableDescriptorCountAllocateInfo(const VkDescriptorSetVariableDescriptorCountAllocateInfo* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->descriptorSetCount, "descriptorSetCount", 1);

    PRINT_SPACE
    _OUT << "\"pDescriptorCounts\":" << std::endl;
    PRINT_SPACE
    if (obj->pDescriptorCounts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->descriptorSetCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->descriptorSetCount;
            print_uint32_t(obj->pDescriptorCounts[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorSetVariableDescriptorCountLayoutSupport(VkDescriptorSetVariableDescriptorCountLayoutSupport obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxVariableDescriptorCount, "maxVariableDescriptorCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorSetVariableDescriptorCountLayoutSupport(
    const VkDescriptorSetVariableDescriptorCountLayoutSupport* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxVariableDescriptorCount, "maxVariableDescriptorCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubpassDescriptionDepthStencilResolve(VkSubpassDescriptionDepthStencilResolve obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkResolveModeFlagBits(obj.depthResolveMode, "depthResolveMode", 1);

    print_VkResolveModeFlagBits(obj.stencilResolveMode, "stencilResolveMode", 1);

    PRINT_SPACE
    _OUT << "\"pDepthStencilResolveAttachment\": " << std::endl;
    if (obj.pDepthStencilResolveAttachment) {
        print_VkAttachmentReference2(obj.pDepthStencilResolveAttachment, "pDepthStencilResolveAttachment", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubpassDescriptionDepthStencilResolve(const VkSubpassDescriptionDepthStencilResolve* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkResolveModeFlagBits(obj->depthResolveMode, "depthResolveMode", 1);

    print_VkResolveModeFlagBits(obj->stencilResolveMode, "stencilResolveMode", 1);

    PRINT_SPACE
    _OUT << "\"pDepthStencilResolveAttachment\": " << std::endl;
    if (obj->pDepthStencilResolveAttachment) {
        print_VkAttachmentReference2(obj->pDepthStencilResolveAttachment, "pDepthStencilResolveAttachment", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDepthStencilResolveProperties(VkPhysicalDeviceDepthStencilResolveProperties obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkResolveModeFlags(obj.supportedDepthResolveModes, "supportedDepthResolveModes", 1);

    print_VkResolveModeFlags(obj.supportedStencilResolveModes, "supportedStencilResolveModes", 1);

    print_VkBool32(obj.independentResolveNone, "independentResolveNone", 1);

    print_VkBool32(obj.independentResolve, "independentResolve", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDepthStencilResolveProperties(const VkPhysicalDeviceDepthStencilResolveProperties* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkResolveModeFlags(obj->supportedDepthResolveModes, "supportedDepthResolveModes", 1);

    print_VkResolveModeFlags(obj->supportedStencilResolveModes, "supportedStencilResolveModes", 1);

    print_VkBool32(obj->independentResolveNone, "independentResolveNone", 1);

    print_VkBool32(obj->independentResolve, "independentResolve", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceScalarBlockLayoutFeatures(VkPhysicalDeviceScalarBlockLayoutFeatures obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.scalarBlockLayout, "scalarBlockLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceScalarBlockLayoutFeatures(const VkPhysicalDeviceScalarBlockLayoutFeatures* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->scalarBlockLayout, "scalarBlockLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageStencilUsageCreateInfo(VkImageStencilUsageCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageUsageFlags(obj.stencilUsage, "stencilUsage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageStencilUsageCreateInfo(const VkImageStencilUsageCreateInfo* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageUsageFlags(obj->stencilUsage, "stencilUsage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSamplerReductionModeCreateInfo(VkSamplerReductionModeCreateInfo obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSamplerReductionMode(obj.reductionMode, "reductionMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSamplerReductionModeCreateInfo(const VkSamplerReductionModeCreateInfo* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSamplerReductionMode(obj->reductionMode, "reductionMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceSamplerFilterMinmaxProperties(VkPhysicalDeviceSamplerFilterMinmaxProperties obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.filterMinmaxSingleComponentFormats, "filterMinmaxSingleComponentFormats", 1);

    print_VkBool32(obj.filterMinmaxImageComponentMapping, "filterMinmaxImageComponentMapping", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSamplerFilterMinmaxProperties(const VkPhysicalDeviceSamplerFilterMinmaxProperties* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->filterMinmaxSingleComponentFormats, "filterMinmaxSingleComponentFormats", 1);

    print_VkBool32(obj->filterMinmaxImageComponentMapping, "filterMinmaxImageComponentMapping", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceVulkanMemoryModelFeatures(VkPhysicalDeviceVulkanMemoryModelFeatures obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.vulkanMemoryModel, "vulkanMemoryModel", 1);

    print_VkBool32(obj.vulkanMemoryModelDeviceScope, "vulkanMemoryModelDeviceScope", 1);

    print_VkBool32(obj.vulkanMemoryModelAvailabilityVisibilityChains, "vulkanMemoryModelAvailabilityVisibilityChains", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVulkanMemoryModelFeatures(const VkPhysicalDeviceVulkanMemoryModelFeatures* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->vulkanMemoryModel, "vulkanMemoryModel", 1);

    print_VkBool32(obj->vulkanMemoryModelDeviceScope, "vulkanMemoryModelDeviceScope", 1);

    print_VkBool32(obj->vulkanMemoryModelAvailabilityVisibilityChains, "vulkanMemoryModelAvailabilityVisibilityChains", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceImagelessFramebufferFeatures(VkPhysicalDeviceImagelessFramebufferFeatures obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.imagelessFramebuffer, "imagelessFramebuffer", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImagelessFramebufferFeatures(const VkPhysicalDeviceImagelessFramebufferFeatures* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->imagelessFramebuffer, "imagelessFramebuffer", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkFramebufferAttachmentImageInfo(VkFramebufferAttachmentImageInfo obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageCreateFlags(obj.flags, "flags", 1);

    print_VkImageUsageFlags(obj.usage, "usage", 1);

    print_uint32_t(obj.width, "width", 1);

    print_uint32_t(obj.height, "height", 1);

    print_uint32_t(obj.layerCount, "layerCount", 1);

    print_uint32_t(obj.viewFormatCount, "viewFormatCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewFormats\":" << std::endl;
    PRINT_SPACE
    if (obj.pViewFormats) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.viewFormatCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.viewFormatCount;
            print_VkFormat(obj.pViewFormats[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkFramebufferAttachmentImageInfo(const VkFramebufferAttachmentImageInfo* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageCreateFlags(obj->flags, "flags", 1);

    print_VkImageUsageFlags(obj->usage, "usage", 1);

    print_uint32_t(obj->width, "width", 1);

    print_uint32_t(obj->height, "height", 1);

    print_uint32_t(obj->layerCount, "layerCount", 1);

    print_uint32_t(obj->viewFormatCount, "viewFormatCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewFormats\":" << std::endl;
    PRINT_SPACE
    if (obj->pViewFormats) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->viewFormatCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->viewFormatCount;
            print_VkFormat(obj->pViewFormats[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkFramebufferAttachmentsCreateInfo(VkFramebufferAttachmentsCreateInfo obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.attachmentImageInfoCount, "attachmentImageInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachmentImageInfos\": " << std::endl;
    if (obj.pAttachmentImageInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.attachmentImageInfoCount; i++) {
            if (i + 1 == obj.attachmentImageInfoCount)
                print_VkFramebufferAttachmentImageInfo(obj.pAttachmentImageInfos[i], "pAttachmentImageInfos", 0);
            else
                print_VkFramebufferAttachmentImageInfo(obj.pAttachmentImageInfos[i], "pAttachmentImageInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkFramebufferAttachmentsCreateInfo(const VkFramebufferAttachmentsCreateInfo* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->attachmentImageInfoCount, "attachmentImageInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachmentImageInfos\": " << std::endl;
    if (obj->pAttachmentImageInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->attachmentImageInfoCount; i++) {
            if (i + 1 == obj->attachmentImageInfoCount)
                print_VkFramebufferAttachmentImageInfo(obj->pAttachmentImageInfos[i], "pAttachmentImageInfos", 0);
            else
                print_VkFramebufferAttachmentImageInfo(obj->pAttachmentImageInfos[i], "pAttachmentImageInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassAttachmentBeginInfo(VkRenderPassAttachmentBeginInfo obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.attachmentCount, "attachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachments\":" << std::endl;
    PRINT_SPACE
    if (obj.pAttachments) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.attachmentCount; i++) {
            std::stringstream tmp;
            tmp << "pAttachments"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.attachmentCount;
            print_VkImageView(obj.pAttachments[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassAttachmentBeginInfo(const VkRenderPassAttachmentBeginInfo* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->attachmentCount, "attachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachments\":" << std::endl;
    PRINT_SPACE
    if (obj->pAttachments) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->attachmentCount; i++) {
            std::stringstream tmp;
            tmp << "pAttachments"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->attachmentCount;
            print_VkImageView(obj->pAttachments[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(VkPhysicalDeviceUniformBufferStandardLayoutFeatures obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.uniformBufferStandardLayout, "uniformBufferStandardLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
    const VkPhysicalDeviceUniformBufferStandardLayoutFeatures* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->uniformBufferStandardLayout, "uniformBufferStandardLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderSubgroupExtendedTypes, "shaderSubgroupExtendedTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
    const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderSubgroupExtendedTypes, "shaderSubgroupExtendedTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.separateDepthStencilLayouts, "separateDepthStencilLayouts", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
    const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->separateDepthStencilLayouts, "separateDepthStencilLayouts", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAttachmentReferenceStencilLayout(VkAttachmentReferenceStencilLayout obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageLayout(obj.stencilLayout, "stencilLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAttachmentReferenceStencilLayout(const VkAttachmentReferenceStencilLayout* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageLayout(obj->stencilLayout, "stencilLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAttachmentDescriptionStencilLayout(VkAttachmentDescriptionStencilLayout obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageLayout(obj.stencilInitialLayout, "stencilInitialLayout", 1);

    print_VkImageLayout(obj.stencilFinalLayout, "stencilFinalLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAttachmentDescriptionStencilLayout(const VkAttachmentDescriptionStencilLayout* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageLayout(obj->stencilInitialLayout, "stencilInitialLayout", 1);

    print_VkImageLayout(obj->stencilFinalLayout, "stencilFinalLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceHostQueryResetFeatures(VkPhysicalDeviceHostQueryResetFeatures obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.hostQueryReset, "hostQueryReset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceHostQueryResetFeatures(const VkPhysicalDeviceHostQueryResetFeatures* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->hostQueryReset, "hostQueryReset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceTimelineSemaphoreFeatures(VkPhysicalDeviceTimelineSemaphoreFeatures obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.timelineSemaphore, "timelineSemaphore", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceTimelineSemaphoreFeatures(const VkPhysicalDeviceTimelineSemaphoreFeatures* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->timelineSemaphore, "timelineSemaphore", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceTimelineSemaphoreProperties(VkPhysicalDeviceTimelineSemaphoreProperties obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.maxTimelineSemaphoreValueDifference, "maxTimelineSemaphoreValueDifference", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceTimelineSemaphoreProperties(const VkPhysicalDeviceTimelineSemaphoreProperties* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->maxTimelineSemaphoreValueDifference, "maxTimelineSemaphoreValueDifference", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSemaphoreTypeCreateInfo(VkSemaphoreTypeCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSemaphoreType(obj.semaphoreType, "semaphoreType", 1);

    print_uint64_t(obj.initialValue, "initialValue", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSemaphoreTypeCreateInfo(const VkSemaphoreTypeCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSemaphoreType(obj->semaphoreType, "semaphoreType", 1);

    print_uint64_t(obj->initialValue, "initialValue", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkTimelineSemaphoreSubmitInfo(VkTimelineSemaphoreSubmitInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.waitSemaphoreValueCount, "waitSemaphoreValueCount", 1);

    PRINT_SPACE
    _OUT << "\"pWaitSemaphoreValues\":" << std::endl;
    PRINT_SPACE
    if (obj.pWaitSemaphoreValues) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.waitSemaphoreValueCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.waitSemaphoreValueCount;
            print_uint64_t(obj.pWaitSemaphoreValues[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.signalSemaphoreValueCount, "signalSemaphoreValueCount", 1);

    PRINT_SPACE
    _OUT << "\"pSignalSemaphoreValues\":" << std::endl;
    PRINT_SPACE
    if (obj.pSignalSemaphoreValues) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.signalSemaphoreValueCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.signalSemaphoreValueCount;
            print_uint64_t(obj.pSignalSemaphoreValues[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkTimelineSemaphoreSubmitInfo(const VkTimelineSemaphoreSubmitInfo* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->waitSemaphoreValueCount, "waitSemaphoreValueCount", 1);

    PRINT_SPACE
    _OUT << "\"pWaitSemaphoreValues\":" << std::endl;
    PRINT_SPACE
    if (obj->pWaitSemaphoreValues) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->waitSemaphoreValueCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->waitSemaphoreValueCount;
            print_uint64_t(obj->pWaitSemaphoreValues[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->signalSemaphoreValueCount, "signalSemaphoreValueCount", 1);

    PRINT_SPACE
    _OUT << "\"pSignalSemaphoreValues\":" << std::endl;
    PRINT_SPACE
    if (obj->pSignalSemaphoreValues) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->signalSemaphoreValueCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->signalSemaphoreValueCount;
            print_uint64_t(obj->pSignalSemaphoreValues[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSemaphoreWaitInfo(VkSemaphoreWaitInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSemaphoreWaitFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.semaphoreCount, "semaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pSemaphores\":" << std::endl;
    PRINT_SPACE
    if (obj.pSemaphores) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.semaphoreCount; i++) {
            std::stringstream tmp;
            tmp << "pSemaphores"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.semaphoreCount;
            print_VkSemaphore(obj.pSemaphores[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pValues\":" << std::endl;
    PRINT_SPACE
    if (obj.pValues) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.semaphoreCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.semaphoreCount;
            print_uint64_t(obj.pValues[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSemaphoreWaitInfo(const VkSemaphoreWaitInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSemaphoreWaitFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->semaphoreCount, "semaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pSemaphores\":" << std::endl;
    PRINT_SPACE
    if (obj->pSemaphores) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->semaphoreCount; i++) {
            std::stringstream tmp;
            tmp << "pSemaphores"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->semaphoreCount;
            print_VkSemaphore(obj->pSemaphores[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pValues\":" << std::endl;
    PRINT_SPACE
    if (obj->pValues) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->semaphoreCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->semaphoreCount;
            print_uint64_t(obj->pValues[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSemaphoreSignalInfo(VkSemaphoreSignalInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "semaphore"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint64_t(obj.value, "value", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSemaphoreSignalInfo(const VkSemaphoreSignalInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "semaphore"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint64_t(obj->value, "value", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceBufferDeviceAddressFeatures(VkPhysicalDeviceBufferDeviceAddressFeatures obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.bufferDeviceAddress, "bufferDeviceAddress", 1);

    print_VkBool32(obj.bufferDeviceAddressCaptureReplay, "bufferDeviceAddressCaptureReplay", 1);

    print_VkBool32(obj.bufferDeviceAddressMultiDevice, "bufferDeviceAddressMultiDevice", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceBufferDeviceAddressFeatures(const VkPhysicalDeviceBufferDeviceAddressFeatures* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->bufferDeviceAddress, "bufferDeviceAddress", 1);

    print_VkBool32(obj->bufferDeviceAddressCaptureReplay, "bufferDeviceAddressCaptureReplay", 1);

    print_VkBool32(obj->bufferDeviceAddressMultiDevice, "bufferDeviceAddressMultiDevice", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBufferDeviceAddressInfo(VkBufferDeviceAddressInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferDeviceAddressInfo(const VkBufferDeviceAddressInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBufferOpaqueCaptureAddressCreateInfo(VkBufferOpaqueCaptureAddressCreateInfo obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.opaqueCaptureAddress, "opaqueCaptureAddress", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferOpaqueCaptureAddressCreateInfo(const VkBufferOpaqueCaptureAddressCreateInfo* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->opaqueCaptureAddress, "opaqueCaptureAddress", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryOpaqueCaptureAddressAllocateInfo(VkMemoryOpaqueCaptureAddressAllocateInfo obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.opaqueCaptureAddress, "opaqueCaptureAddress", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryOpaqueCaptureAddressAllocateInfo(const VkMemoryOpaqueCaptureAddressAllocateInfo* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->opaqueCaptureAddress, "opaqueCaptureAddress", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceMemoryOpaqueCaptureAddressInfo(VkDeviceMemoryOpaqueCaptureAddressInfo obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceMemoryOpaqueCaptureAddressInfo(const VkDeviceMemoryOpaqueCaptureAddressInfo* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSurfaceKHR(VkSurfaceKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSurfaceTransformFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"),
    std::make_pair(1ULL << 5, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"),
    std::make_pair(1ULL << 6, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"),
    std::make_pair(1ULL << 7, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"),
    std::make_pair(1ULL << 8, "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"),
};
static void print_VkSurfaceTransformFlagBitsKHR(VkSurfaceTransformFlagBitsKHR obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSurfaceTransformFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSurfaceTransformFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkSurfaceTransformFlagBitsKHR(const VkSurfaceTransformFlagBitsKHR* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSurfaceTransformFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSurfaceTransformFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPresentModeKHR_map = {
    std::make_pair(0, "VK_PRESENT_MODE_IMMEDIATE_KHR"),
    std::make_pair(1, "VK_PRESENT_MODE_MAILBOX_KHR"),
    std::make_pair(2, "VK_PRESENT_MODE_FIFO_KHR"),
    std::make_pair(3, "VK_PRESENT_MODE_FIFO_RELAXED_KHR"),
    std::make_pair(1000111000, "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR"),
    std::make_pair(1000111001, "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR"),
    std::make_pair(1000361000, "VK_PRESENT_MODE_FIFO_LATEST_READY_EXT"),
};
static void print_VkPresentModeKHR(VkPresentModeKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPresentModeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPresentModeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkPresentModeKHR(const VkPresentModeKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPresentModeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPresentModeKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkColorSpaceKHR_map = {
    std::make_pair(0, "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"),
    std::make_pair(1000104001, "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT"),
    std::make_pair(1000104002, "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT"),
    std::make_pair(1000104003, "VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT"),
    std::make_pair(1000104004, "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT"),
    std::make_pair(1000104005, "VK_COLOR_SPACE_BT709_LINEAR_EXT"),
    std::make_pair(1000104006, "VK_COLOR_SPACE_BT709_NONLINEAR_EXT"),
    std::make_pair(1000104007, "VK_COLOR_SPACE_BT2020_LINEAR_EXT"),
    std::make_pair(1000104008, "VK_COLOR_SPACE_HDR10_ST2084_EXT"),
    std::make_pair(1000104009, "VK_COLOR_SPACE_DOLBYVISION_EXT"),
    std::make_pair(1000104010, "VK_COLOR_SPACE_HDR10_HLG_EXT"),
    std::make_pair(1000104011, "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT"),
    std::make_pair(1000104012, "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT"),
    std::make_pair(1000104013, "VK_COLOR_SPACE_PASS_THROUGH_EXT"),
    std::make_pair(1000104014, "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT"),
    std::make_pair(1000213000, "VK_COLOR_SPACE_DISPLAY_NATIVE_AMD"),
};
static void print_VkColorSpaceKHR(VkColorSpaceKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkColorSpaceKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkColorSpaceKHR_map[obj] << "\"" << std::endl;
}
static void print_VkColorSpaceKHR(const VkColorSpaceKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkColorSpaceKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkColorSpaceKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkCompositeAlphaFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"),
};
static void print_VkCompositeAlphaFlagBitsKHR(VkCompositeAlphaFlagBitsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCompositeAlphaFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCompositeAlphaFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkCompositeAlphaFlagBitsKHR(const VkCompositeAlphaFlagBitsKHR* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCompositeAlphaFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCompositeAlphaFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkCompositeAlphaFlagsKHR(VkCompositeAlphaFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkCompositeAlphaFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkCompositeAlphaFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkSurfaceTransformFlagsKHR(VkSurfaceTransformFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkSurfaceTransformFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkSurfaceTransformFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkSurfaceCapabilitiesKHR(VkSurfaceCapabilitiesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.minImageCount, "minImageCount", 1);

    print_uint32_t(obj.maxImageCount, "maxImageCount", 1);

    PRINT_SPACE
    _OUT << "\"currentExtent\": " << std::endl;
    { print_VkExtent2D(obj.currentExtent, "currentExtent", 1); }

    PRINT_SPACE
    _OUT << "\"minImageExtent\": " << std::endl;
    { print_VkExtent2D(obj.minImageExtent, "minImageExtent", 1); }

    PRINT_SPACE
    _OUT << "\"maxImageExtent\": " << std::endl;
    { print_VkExtent2D(obj.maxImageExtent, "maxImageExtent", 1); }

    print_uint32_t(obj.maxImageArrayLayers, "maxImageArrayLayers", 1);

    print_VkSurfaceTransformFlagsKHR(obj.supportedTransforms, "supportedTransforms", 1);

    print_VkSurfaceTransformFlagBitsKHR(obj.currentTransform, "currentTransform", 1);

    print_VkCompositeAlphaFlagsKHR(obj.supportedCompositeAlpha, "supportedCompositeAlpha", 1);

    print_VkImageUsageFlags(obj.supportedUsageFlags, "supportedUsageFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSurfaceCapabilitiesKHR(const VkSurfaceCapabilitiesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->minImageCount, "minImageCount", 1);

    print_uint32_t(obj->maxImageCount, "maxImageCount", 1);

    PRINT_SPACE
    _OUT << "\"currentExtent\": " << std::endl;
    { print_VkExtent2D(obj->currentExtent, "currentExtent", 1); }

    PRINT_SPACE
    _OUT << "\"minImageExtent\": " << std::endl;
    { print_VkExtent2D(obj->minImageExtent, "minImageExtent", 1); }

    PRINT_SPACE
    _OUT << "\"maxImageExtent\": " << std::endl;
    { print_VkExtent2D(obj->maxImageExtent, "maxImageExtent", 1); }

    print_uint32_t(obj->maxImageArrayLayers, "maxImageArrayLayers", 1);

    print_VkSurfaceTransformFlagsKHR(obj->supportedTransforms, "supportedTransforms", 1);

    print_VkSurfaceTransformFlagBitsKHR(obj->currentTransform, "currentTransform", 1);

    print_VkCompositeAlphaFlagsKHR(obj->supportedCompositeAlpha, "supportedCompositeAlpha", 1);

    print_VkImageUsageFlags(obj->supportedUsageFlags, "supportedUsageFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSurfaceFormatKHR(VkSurfaceFormatKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkFormat(obj.format, "format", 1);

    print_VkColorSpaceKHR(obj.colorSpace, "colorSpace", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSurfaceFormatKHR(const VkSurfaceFormatKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkFormat(obj->format, "format", 1);

    print_VkColorSpaceKHR(obj->colorSpace, "colorSpace", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSwapchainKHR(VkSwapchainKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSwapchainCreateFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR"),
    std::make_pair(1ULL << 0, "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT"),
    std::make_pair(1ULL << 4, "VK_SWAPCHAIN_CREATE_RESERVED_4_BIT_EXT"),
};
static void print_VkSwapchainCreateFlagBitsKHR(VkSwapchainCreateFlagBitsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSwapchainCreateFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSwapchainCreateFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkSwapchainCreateFlagBitsKHR(const VkSwapchainCreateFlagBitsKHR* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSwapchainCreateFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSwapchainCreateFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDeviceGroupPresentModeFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR"),
};
static void print_VkDeviceGroupPresentModeFlagBitsKHR(VkDeviceGroupPresentModeFlagBitsKHR obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceGroupPresentModeFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceGroupPresentModeFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkDeviceGroupPresentModeFlagBitsKHR(const VkDeviceGroupPresentModeFlagBitsKHR* obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceGroupPresentModeFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceGroupPresentModeFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkSwapchainCreateFlagsKHR(VkSwapchainCreateFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkSwapchainCreateFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkSwapchainCreateFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkDeviceGroupPresentModeFlagsKHR(VkDeviceGroupPresentModeFlagsKHR obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkDeviceGroupPresentModeFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkDeviceGroupPresentModeFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkSwapchainCreateInfoKHR(VkSwapchainCreateInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSwapchainCreateFlagsKHR(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "surface"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.minImageCount, "minImageCount", 1);

    print_VkFormat(obj.imageFormat, "imageFormat", 1);

    print_VkColorSpaceKHR(obj.imageColorSpace, "imageColorSpace", 1);

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent2D(obj.imageExtent, "imageExtent", 1); }

    print_uint32_t(obj.imageArrayLayers, "imageArrayLayers", 1);

    print_VkImageUsageFlags(obj.imageUsage, "imageUsage", 1);

    print_VkSharingMode(obj.imageSharingMode, "imageSharingMode", 1);

    print_uint32_t(obj.queueFamilyIndexCount, "queueFamilyIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueueFamilyIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pQueueFamilyIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.queueFamilyIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.queueFamilyIndexCount;
            print_uint32_t(obj.pQueueFamilyIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSurfaceTransformFlagBitsKHR(obj.preTransform, "preTransform", 1);

    print_VkCompositeAlphaFlagBitsKHR(obj.compositeAlpha, "compositeAlpha", 1);

    print_VkPresentModeKHR(obj.presentMode, "presentMode", 1);

    print_VkBool32(obj.clipped, "clipped", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "oldSwapchain"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSwapchainCreateInfoKHR(const VkSwapchainCreateInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSwapchainCreateFlagsKHR(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "surface"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->minImageCount, "minImageCount", 1);

    print_VkFormat(obj->imageFormat, "imageFormat", 1);

    print_VkColorSpaceKHR(obj->imageColorSpace, "imageColorSpace", 1);

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent2D(obj->imageExtent, "imageExtent", 1); }

    print_uint32_t(obj->imageArrayLayers, "imageArrayLayers", 1);

    print_VkImageUsageFlags(obj->imageUsage, "imageUsage", 1);

    print_VkSharingMode(obj->imageSharingMode, "imageSharingMode", 1);

    print_uint32_t(obj->queueFamilyIndexCount, "queueFamilyIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueueFamilyIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pQueueFamilyIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->queueFamilyIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->queueFamilyIndexCount;
            print_uint32_t(obj->pQueueFamilyIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSurfaceTransformFlagBitsKHR(obj->preTransform, "preTransform", 1);

    print_VkCompositeAlphaFlagBitsKHR(obj->compositeAlpha, "compositeAlpha", 1);

    print_VkPresentModeKHR(obj->presentMode, "presentMode", 1);

    print_VkBool32(obj->clipped, "clipped", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "oldSwapchain"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPresentInfoKHR(VkPresentInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.waitSemaphoreCount, "waitSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pWaitSemaphores\":" << std::endl;
    PRINT_SPACE
    if (obj.pWaitSemaphores) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.waitSemaphoreCount; i++) {
            std::stringstream tmp;
            tmp << "pWaitSemaphores"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.waitSemaphoreCount;
            print_VkSemaphore(obj.pWaitSemaphores[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pSwapchains\":" << std::endl;
    PRINT_SPACE
    if (obj.pSwapchains) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.swapchainCount; i++) {
            std::stringstream tmp;
            tmp << "pSwapchains"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.swapchainCount;
            print_VkSwapchainKHR(obj.pSwapchains[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pImageIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pImageIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.swapchainCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.swapchainCount;
            print_uint32_t(obj.pImageIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pResults\":" << std::endl;
    PRINT_SPACE
    if (obj.pResults) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.swapchainCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.swapchainCount;
            print_VkResult(obj.pResults[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPresentInfoKHR(const VkPresentInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->waitSemaphoreCount, "waitSemaphoreCount", 1);

    PRINT_SPACE
    _OUT << "\"pWaitSemaphores\":" << std::endl;
    PRINT_SPACE
    if (obj->pWaitSemaphores) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->waitSemaphoreCount; i++) {
            std::stringstream tmp;
            tmp << "pWaitSemaphores"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->waitSemaphoreCount;
            print_VkSemaphore(obj->pWaitSemaphores[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pSwapchains\":" << std::endl;
    PRINT_SPACE
    if (obj->pSwapchains) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->swapchainCount; i++) {
            std::stringstream tmp;
            tmp << "pSwapchains"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->swapchainCount;
            print_VkSwapchainKHR(obj->pSwapchains[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pImageIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pImageIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->swapchainCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->swapchainCount;
            print_uint32_t(obj->pImageIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pResults\":" << std::endl;
    PRINT_SPACE
    if (obj->pResults) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->swapchainCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->swapchainCount;
            print_VkResult(obj->pResults[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageSwapchainCreateInfoKHR(VkImageSwapchainCreateInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "swapchain"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageSwapchainCreateInfoKHR(const VkImageSwapchainCreateInfoKHR* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "swapchain"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindImageMemorySwapchainInfoKHR(VkBindImageMemorySwapchainInfoKHR obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "swapchain"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.imageIndex, "imageIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindImageMemorySwapchainInfoKHR(const VkBindImageMemorySwapchainInfoKHR* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "swapchain"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->imageIndex, "imageIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAcquireNextImageInfoKHR(VkAcquireNextImageInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "swapchain"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint64_t(obj.timeout, "timeout", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "semaphore"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "fence"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.deviceMask, "deviceMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAcquireNextImageInfoKHR(const VkAcquireNextImageInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "swapchain"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint64_t(obj->timeout, "timeout", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "semaphore"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "fence"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->deviceMask, "deviceMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceGroupPresentCapabilitiesKHR(VkDeviceGroupPresentCapabilitiesKHR obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"presentMask\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DEVICE_GROUP_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DEVICE_GROUP_SIZE;
        print_uint32_t(obj.presentMask[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkDeviceGroupPresentModeFlagsKHR(obj.modes, "modes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceGroupPresentCapabilitiesKHR(const VkDeviceGroupPresentCapabilitiesKHR* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"presentMask\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DEVICE_GROUP_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DEVICE_GROUP_SIZE;
        print_uint32_t(obj->presentMask[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkDeviceGroupPresentModeFlagsKHR(obj->modes, "modes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceGroupPresentInfoKHR(VkDeviceGroupPresentInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pDeviceMasks\":" << std::endl;
    PRINT_SPACE
    if (obj.pDeviceMasks) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.swapchainCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.swapchainCount;
            print_uint32_t(obj.pDeviceMasks[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceGroupPresentModeFlagBitsKHR(obj.mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceGroupPresentInfoKHR(const VkDeviceGroupPresentInfoKHR* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pDeviceMasks\":" << std::endl;
    PRINT_SPACE
    if (obj->pDeviceMasks) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->swapchainCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->swapchainCount;
            print_uint32_t(obj->pDeviceMasks[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceGroupPresentModeFlagBitsKHR(obj->mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceGroupSwapchainCreateInfoKHR(VkDeviceGroupSwapchainCreateInfoKHR obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceGroupPresentModeFlagsKHR(obj.modes, "modes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceGroupSwapchainCreateInfoKHR(const VkDeviceGroupSwapchainCreateInfoKHR* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceGroupPresentModeFlagsKHR(obj->modes, "modes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayKHR(VkDisplayKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkDisplayModeKHR(VkDisplayModeKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDisplayPlaneAlphaFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"),
};
static void print_VkDisplayPlaneAlphaFlagBitsKHR(VkDisplayPlaneAlphaFlagBitsKHR obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDisplayPlaneAlphaFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDisplayPlaneAlphaFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkDisplayPlaneAlphaFlagBitsKHR(const VkDisplayPlaneAlphaFlagBitsKHR* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDisplayPlaneAlphaFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDisplayPlaneAlphaFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkDisplayModeCreateFlagsKHR(VkDisplayModeCreateFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkDisplayPlaneAlphaFlagsKHR(VkDisplayPlaneAlphaFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkDisplayPlaneAlphaFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkDisplayPlaneAlphaFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkDisplaySurfaceCreateFlagsKHR(VkDisplaySurfaceCreateFlagsKHR obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkDisplayModeParametersKHR(VkDisplayModeParametersKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"visibleRegion\": " << std::endl;
    { print_VkExtent2D(obj.visibleRegion, "visibleRegion", 1); }

    print_uint32_t(obj.refreshRate, "refreshRate", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayModeParametersKHR(const VkDisplayModeParametersKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"visibleRegion\": " << std::endl;
    { print_VkExtent2D(obj->visibleRegion, "visibleRegion", 1); }

    print_uint32_t(obj->refreshRate, "refreshRate", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayModeCreateInfoKHR(VkDisplayModeCreateInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDisplayModeCreateFlagsKHR(obj.flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"parameters\": " << std::endl;
    { print_VkDisplayModeParametersKHR(obj.parameters, "parameters", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayModeCreateInfoKHR(const VkDisplayModeCreateInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDisplayModeCreateFlagsKHR(obj->flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"parameters\": " << std::endl;
    { print_VkDisplayModeParametersKHR(obj->parameters, "parameters", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayModePropertiesKHR(VkDisplayModePropertiesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "displayMode"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"parameters\": " << std::endl;
    { print_VkDisplayModeParametersKHR(obj.parameters, "parameters", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayModePropertiesKHR(const VkDisplayModePropertiesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "displayMode"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"parameters\": " << std::endl;
    { print_VkDisplayModeParametersKHR(obj->parameters, "parameters", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayPlaneCapabilitiesKHR(VkDisplayPlaneCapabilitiesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDisplayPlaneAlphaFlagsKHR(obj.supportedAlpha, "supportedAlpha", 1);

    PRINT_SPACE
    _OUT << "\"minSrcPosition\": " << std::endl;
    { print_VkOffset2D(obj.minSrcPosition, "minSrcPosition", 1); }

    PRINT_SPACE
    _OUT << "\"maxSrcPosition\": " << std::endl;
    { print_VkOffset2D(obj.maxSrcPosition, "maxSrcPosition", 1); }

    PRINT_SPACE
    _OUT << "\"minSrcExtent\": " << std::endl;
    { print_VkExtent2D(obj.minSrcExtent, "minSrcExtent", 1); }

    PRINT_SPACE
    _OUT << "\"maxSrcExtent\": " << std::endl;
    { print_VkExtent2D(obj.maxSrcExtent, "maxSrcExtent", 1); }

    PRINT_SPACE
    _OUT << "\"minDstPosition\": " << std::endl;
    { print_VkOffset2D(obj.minDstPosition, "minDstPosition", 1); }

    PRINT_SPACE
    _OUT << "\"maxDstPosition\": " << std::endl;
    { print_VkOffset2D(obj.maxDstPosition, "maxDstPosition", 1); }

    PRINT_SPACE
    _OUT << "\"minDstExtent\": " << std::endl;
    { print_VkExtent2D(obj.minDstExtent, "minDstExtent", 1); }

    PRINT_SPACE
    _OUT << "\"maxDstExtent\": " << std::endl;
    { print_VkExtent2D(obj.maxDstExtent, "maxDstExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayPlaneCapabilitiesKHR(const VkDisplayPlaneCapabilitiesKHR* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDisplayPlaneAlphaFlagsKHR(obj->supportedAlpha, "supportedAlpha", 1);

    PRINT_SPACE
    _OUT << "\"minSrcPosition\": " << std::endl;
    { print_VkOffset2D(obj->minSrcPosition, "minSrcPosition", 1); }

    PRINT_SPACE
    _OUT << "\"maxSrcPosition\": " << std::endl;
    { print_VkOffset2D(obj->maxSrcPosition, "maxSrcPosition", 1); }

    PRINT_SPACE
    _OUT << "\"minSrcExtent\": " << std::endl;
    { print_VkExtent2D(obj->minSrcExtent, "minSrcExtent", 1); }

    PRINT_SPACE
    _OUT << "\"maxSrcExtent\": " << std::endl;
    { print_VkExtent2D(obj->maxSrcExtent, "maxSrcExtent", 1); }

    PRINT_SPACE
    _OUT << "\"minDstPosition\": " << std::endl;
    { print_VkOffset2D(obj->minDstPosition, "minDstPosition", 1); }

    PRINT_SPACE
    _OUT << "\"maxDstPosition\": " << std::endl;
    { print_VkOffset2D(obj->maxDstPosition, "maxDstPosition", 1); }

    PRINT_SPACE
    _OUT << "\"minDstExtent\": " << std::endl;
    { print_VkExtent2D(obj->minDstExtent, "minDstExtent", 1); }

    PRINT_SPACE
    _OUT << "\"maxDstExtent\": " << std::endl;
    { print_VkExtent2D(obj->maxDstExtent, "maxDstExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayPlanePropertiesKHR(VkDisplayPlanePropertiesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "currentDisplay"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.currentStackIndex, "currentStackIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayPlanePropertiesKHR(const VkDisplayPlanePropertiesKHR* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "currentDisplay"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->currentStackIndex, "currentStackIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayPropertiesKHR(VkDisplayPropertiesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "display"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_char(obj.displayName, "displayName", 1);

    PRINT_SPACE
    _OUT << "\"physicalDimensions\": " << std::endl;
    { print_VkExtent2D(obj.physicalDimensions, "physicalDimensions", 1); }

    PRINT_SPACE
    _OUT << "\"physicalResolution\": " << std::endl;
    { print_VkExtent2D(obj.physicalResolution, "physicalResolution", 1); }

    print_VkSurfaceTransformFlagsKHR(obj.supportedTransforms, "supportedTransforms", 1);

    print_VkBool32(obj.planeReorderPossible, "planeReorderPossible", 1);

    print_VkBool32(obj.persistentContent, "persistentContent", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayPropertiesKHR(const VkDisplayPropertiesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "display"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_char(obj->displayName, "displayName", 1);

    PRINT_SPACE
    _OUT << "\"physicalDimensions\": " << std::endl;
    { print_VkExtent2D(obj->physicalDimensions, "physicalDimensions", 1); }

    PRINT_SPACE
    _OUT << "\"physicalResolution\": " << std::endl;
    { print_VkExtent2D(obj->physicalResolution, "physicalResolution", 1); }

    print_VkSurfaceTransformFlagsKHR(obj->supportedTransforms, "supportedTransforms", 1);

    print_VkBool32(obj->planeReorderPossible, "planeReorderPossible", 1);

    print_VkBool32(obj->persistentContent, "persistentContent", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplaySurfaceCreateInfoKHR(VkDisplaySurfaceCreateInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDisplaySurfaceCreateFlagsKHR(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "displayMode"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.planeIndex, "planeIndex", 1);

    print_uint32_t(obj.planeStackIndex, "planeStackIndex", 1);

    print_VkSurfaceTransformFlagBitsKHR(obj.transform, "transform", 1);

    print_float(obj.globalAlpha, "globalAlpha", 1);

    print_VkDisplayPlaneAlphaFlagBitsKHR(obj.alphaMode, "alphaMode", 1);

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent2D(obj.imageExtent, "imageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplaySurfaceCreateInfoKHR(const VkDisplaySurfaceCreateInfoKHR* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDisplaySurfaceCreateFlagsKHR(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "displayMode"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->planeIndex, "planeIndex", 1);

    print_uint32_t(obj->planeStackIndex, "planeStackIndex", 1);

    print_VkSurfaceTransformFlagBitsKHR(obj->transform, "transform", 1);

    print_float(obj->globalAlpha, "globalAlpha", 1);

    print_VkDisplayPlaneAlphaFlagBitsKHR(obj->alphaMode, "alphaMode", 1);

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent2D(obj->imageExtent, "imageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayPresentInfoKHR(VkDisplayPresentInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"srcRect\": " << std::endl;
    { print_VkRect2D(obj.srcRect, "srcRect", 1); }

    PRINT_SPACE
    _OUT << "\"dstRect\": " << std::endl;
    { print_VkRect2D(obj.dstRect, "dstRect", 1); }

    print_VkBool32(obj.persistent, "persistent", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayPresentInfoKHR(const VkDisplayPresentInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"srcRect\": " << std::endl;
    { print_VkRect2D(obj->srcRect, "srcRect", 1); }

    PRINT_SPACE
    _OUT << "\"dstRect\": " << std::endl;
    { print_VkRect2D(obj->dstRect, "dstRect", 1); }

    print_VkBool32(obj->persistent, "persistent", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoSessionKHR(VkVideoSessionKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkVideoSessionParametersKHR(VkVideoSessionParametersKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoCodecOperationFlagBitsKHR_map = {
    std::make_pair(0, "VK_VIDEO_CODEC_OPERATION_NONE_KHR"),
    std::make_pair(1ULL << 16, "VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR"),
    std::make_pair(1ULL << 17, "VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR"),
    std::make_pair(1ULL << 0, "VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR"),
    std::make_pair(1ULL << 18, "VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR"),
};
static void print_VkVideoCodecOperationFlagBitsKHR(VkVideoCodecOperationFlagBitsKHR obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoCodecOperationFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoCodecOperationFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoCodecOperationFlagBitsKHR(const VkVideoCodecOperationFlagBitsKHR* obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoCodecOperationFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoCodecOperationFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoChromaSubsamplingFlagBitsKHR_map = {
    std::make_pair(0, "VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR"),
    std::make_pair(1ULL << 0, "VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR"),
};
static void print_VkVideoChromaSubsamplingFlagBitsKHR(VkVideoChromaSubsamplingFlagBitsKHR obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoChromaSubsamplingFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoChromaSubsamplingFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoChromaSubsamplingFlagBitsKHR(const VkVideoChromaSubsamplingFlagBitsKHR* obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoChromaSubsamplingFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoChromaSubsamplingFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoComponentBitDepthFlagBitsKHR_map = {
    std::make_pair(0, "VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR"),
    std::make_pair(1ULL << 0, "VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR"),
};
static void print_VkVideoComponentBitDepthFlagBitsKHR(VkVideoComponentBitDepthFlagBitsKHR obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoComponentBitDepthFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoComponentBitDepthFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoComponentBitDepthFlagBitsKHR(const VkVideoComponentBitDepthFlagBitsKHR* obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoComponentBitDepthFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoComponentBitDepthFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoCapabilityFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR"),
};
static void print_VkVideoCapabilityFlagBitsKHR(VkVideoCapabilityFlagBitsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoCapabilityFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoCapabilityFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoCapabilityFlagBitsKHR(const VkVideoCapabilityFlagBitsKHR* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoCapabilityFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoCapabilityFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoSessionCreateFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR"),
    std::make_pair(1ULL << 5, "VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR"),
};
static void print_VkVideoSessionCreateFlagBitsKHR(VkVideoSessionCreateFlagBitsKHR obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoSessionCreateFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoSessionCreateFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoSessionCreateFlagBitsKHR(const VkVideoSessionCreateFlagBitsKHR* obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoSessionCreateFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoSessionCreateFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoSessionParametersCreateFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR"),
};
static void print_VkVideoSessionParametersCreateFlagBitsKHR(VkVideoSessionParametersCreateFlagBitsKHR obj, const std::string& str,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoSessionParametersCreateFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoSessionParametersCreateFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoSessionParametersCreateFlagBitsKHR(const VkVideoSessionParametersCreateFlagBitsKHR* obj,
                                                            const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoSessionParametersCreateFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoSessionParametersCreateFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoCodingControlFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR"),
};
static void print_VkVideoCodingControlFlagBitsKHR(VkVideoCodingControlFlagBitsKHR obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoCodingControlFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoCodingControlFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoCodingControlFlagBitsKHR(const VkVideoCodingControlFlagBitsKHR* obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoCodingControlFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoCodingControlFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkQueryResultStatusKHR_map = {
    std::make_pair(-1, "VK_QUERY_RESULT_STATUS_ERROR_KHR"),
    std::make_pair(0, "VK_QUERY_RESULT_STATUS_NOT_READY_KHR"),
    std::make_pair(1, "VK_QUERY_RESULT_STATUS_COMPLETE_KHR"),
    std::make_pair(-1000299000, "VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR"),
};
static void print_VkQueryResultStatusKHR(VkQueryResultStatusKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueryResultStatusKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueryResultStatusKHR_map[obj] << "\"" << std::endl;
}
static void print_VkQueryResultStatusKHR(const VkQueryResultStatusKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueryResultStatusKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueryResultStatusKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkVideoCodecOperationFlagsKHR(VkVideoCodecOperationFlagsKHR obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoCodecOperationFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoCodecOperationFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoChromaSubsamplingFlagsKHR(VkVideoChromaSubsamplingFlagsKHR obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoChromaSubsamplingFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoChromaSubsamplingFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoComponentBitDepthFlagsKHR(VkVideoComponentBitDepthFlagsKHR obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoComponentBitDepthFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoComponentBitDepthFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoCapabilityFlagsKHR(VkVideoCapabilityFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoCapabilityFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoCapabilityFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoSessionCreateFlagsKHR(VkVideoSessionCreateFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoSessionCreateFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoSessionCreateFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoSessionParametersCreateFlagsKHR(VkVideoSessionParametersCreateFlagsKHR obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoSessionParametersCreateFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoSessionParametersCreateFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoBeginCodingFlagsKHR(VkVideoBeginCodingFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkVideoEndCodingFlagsKHR(VkVideoEndCodingFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkVideoCodingControlFlagsKHR(VkVideoCodingControlFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoCodingControlFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoCodingControlFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkQueueFamilyQueryResultStatusPropertiesKHR(VkQueueFamilyQueryResultStatusPropertiesKHR obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.queryResultStatusSupport, "queryResultStatusSupport", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkQueueFamilyQueryResultStatusPropertiesKHR(const VkQueueFamilyQueryResultStatusPropertiesKHR* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->queryResultStatusSupport, "queryResultStatusSupport", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkQueueFamilyVideoPropertiesKHR(VkQueueFamilyVideoPropertiesKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoCodecOperationFlagsKHR(obj.videoCodecOperations, "videoCodecOperations", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkQueueFamilyVideoPropertiesKHR(const VkQueueFamilyVideoPropertiesKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoCodecOperationFlagsKHR(obj->videoCodecOperations, "videoCodecOperations", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoProfileInfoKHR(VkVideoProfileInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoCodecOperationFlagBitsKHR(obj.videoCodecOperation, "videoCodecOperation", 1);

    print_VkVideoChromaSubsamplingFlagsKHR(obj.chromaSubsampling, "chromaSubsampling", 1);

    print_VkVideoComponentBitDepthFlagsKHR(obj.lumaBitDepth, "lumaBitDepth", 1);

    print_VkVideoComponentBitDepthFlagsKHR(obj.chromaBitDepth, "chromaBitDepth", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoProfileInfoKHR(const VkVideoProfileInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoCodecOperationFlagBitsKHR(obj->videoCodecOperation, "videoCodecOperation", 1);

    print_VkVideoChromaSubsamplingFlagsKHR(obj->chromaSubsampling, "chromaSubsampling", 1);

    print_VkVideoComponentBitDepthFlagsKHR(obj->lumaBitDepth, "lumaBitDepth", 1);

    print_VkVideoComponentBitDepthFlagsKHR(obj->chromaBitDepth, "chromaBitDepth", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoProfileListInfoKHR(VkVideoProfileListInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.profileCount, "profileCount", 1);

    PRINT_SPACE
    _OUT << "\"pProfiles\": " << std::endl;
    if (obj.pProfiles) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.profileCount; i++) {
            if (i + 1 == obj.profileCount)
                print_VkVideoProfileInfoKHR(obj.pProfiles[i], "pProfiles", 0);
            else
                print_VkVideoProfileInfoKHR(obj.pProfiles[i], "pProfiles", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoProfileListInfoKHR(const VkVideoProfileListInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->profileCount, "profileCount", 1);

    PRINT_SPACE
    _OUT << "\"pProfiles\": " << std::endl;
    if (obj->pProfiles) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->profileCount; i++) {
            if (i + 1 == obj->profileCount)
                print_VkVideoProfileInfoKHR(obj->pProfiles[i], "pProfiles", 0);
            else
                print_VkVideoProfileInfoKHR(obj->pProfiles[i], "pProfiles", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoCapabilitiesKHR(VkVideoCapabilitiesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoCapabilityFlagsKHR(obj.flags, "flags", 1);

    print_VkDeviceSize(obj.minBitstreamBufferOffsetAlignment, "minBitstreamBufferOffsetAlignment", 1);

    print_VkDeviceSize(obj.minBitstreamBufferSizeAlignment, "minBitstreamBufferSizeAlignment", 1);

    PRINT_SPACE
    _OUT << "\"pictureAccessGranularity\": " << std::endl;
    { print_VkExtent2D(obj.pictureAccessGranularity, "pictureAccessGranularity", 1); }

    PRINT_SPACE
    _OUT << "\"minCodedExtent\": " << std::endl;
    { print_VkExtent2D(obj.minCodedExtent, "minCodedExtent", 1); }

    PRINT_SPACE
    _OUT << "\"maxCodedExtent\": " << std::endl;
    { print_VkExtent2D(obj.maxCodedExtent, "maxCodedExtent", 1); }

    print_uint32_t(obj.maxDpbSlots, "maxDpbSlots", 1);

    print_uint32_t(obj.maxActiveReferencePictures, "maxActiveReferencePictures", 1);

    PRINT_SPACE
    _OUT << "\"stdHeaderVersion\": " << std::endl;
    { print_VkExtensionProperties(obj.stdHeaderVersion, "stdHeaderVersion", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoCapabilitiesKHR(const VkVideoCapabilitiesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoCapabilityFlagsKHR(obj->flags, "flags", 1);

    print_VkDeviceSize(obj->minBitstreamBufferOffsetAlignment, "minBitstreamBufferOffsetAlignment", 1);

    print_VkDeviceSize(obj->minBitstreamBufferSizeAlignment, "minBitstreamBufferSizeAlignment", 1);

    PRINT_SPACE
    _OUT << "\"pictureAccessGranularity\": " << std::endl;
    { print_VkExtent2D(obj->pictureAccessGranularity, "pictureAccessGranularity", 1); }

    PRINT_SPACE
    _OUT << "\"minCodedExtent\": " << std::endl;
    { print_VkExtent2D(obj->minCodedExtent, "minCodedExtent", 1); }

    PRINT_SPACE
    _OUT << "\"maxCodedExtent\": " << std::endl;
    { print_VkExtent2D(obj->maxCodedExtent, "maxCodedExtent", 1); }

    print_uint32_t(obj->maxDpbSlots, "maxDpbSlots", 1);

    print_uint32_t(obj->maxActiveReferencePictures, "maxActiveReferencePictures", 1);

    PRINT_SPACE
    _OUT << "\"stdHeaderVersion\": " << std::endl;
    { print_VkExtensionProperties(obj->stdHeaderVersion, "stdHeaderVersion", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceVideoFormatInfoKHR(VkPhysicalDeviceVideoFormatInfoKHR obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageUsageFlags(obj.imageUsage, "imageUsage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVideoFormatInfoKHR(const VkPhysicalDeviceVideoFormatInfoKHR* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageUsageFlags(obj->imageUsage, "imageUsage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoFormatPropertiesKHR(VkVideoFormatPropertiesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj.format, "format", 1);

    PRINT_SPACE
    _OUT << "\"componentMapping\": " << std::endl;
    { print_VkComponentMapping(obj.componentMapping, "componentMapping", 1); }

    print_VkImageCreateFlags(obj.imageCreateFlags, "imageCreateFlags", 1);

    print_VkImageType(obj.imageType, "imageType", 1);

    print_VkImageTiling(obj.imageTiling, "imageTiling", 1);

    print_VkImageUsageFlags(obj.imageUsageFlags, "imageUsageFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoFormatPropertiesKHR(const VkVideoFormatPropertiesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj->format, "format", 1);

    PRINT_SPACE
    _OUT << "\"componentMapping\": " << std::endl;
    { print_VkComponentMapping(obj->componentMapping, "componentMapping", 1); }

    print_VkImageCreateFlags(obj->imageCreateFlags, "imageCreateFlags", 1);

    print_VkImageType(obj->imageType, "imageType", 1);

    print_VkImageTiling(obj->imageTiling, "imageTiling", 1);

    print_VkImageUsageFlags(obj->imageUsageFlags, "imageUsageFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoPictureResourceInfoKHR(VkVideoPictureResourceInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"codedOffset\": " << std::endl;
    { print_VkOffset2D(obj.codedOffset, "codedOffset", 1); }

    PRINT_SPACE
    _OUT << "\"codedExtent\": " << std::endl;
    { print_VkExtent2D(obj.codedExtent, "codedExtent", 1); }

    print_uint32_t(obj.baseArrayLayer, "baseArrayLayer", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageViewBinding"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoPictureResourceInfoKHR(const VkVideoPictureResourceInfoKHR* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"codedOffset\": " << std::endl;
    { print_VkOffset2D(obj->codedOffset, "codedOffset", 1); }

    PRINT_SPACE
    _OUT << "\"codedExtent\": " << std::endl;
    { print_VkExtent2D(obj->codedExtent, "codedExtent", 1); }

    print_uint32_t(obj->baseArrayLayer, "baseArrayLayer", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageViewBinding"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoReferenceSlotInfoKHR(VkVideoReferenceSlotInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_int32_t(obj.slotIndex, "slotIndex", 1);

    PRINT_SPACE
    _OUT << "\"pPictureResource\": " << std::endl;
    if (obj.pPictureResource) {
        print_VkVideoPictureResourceInfoKHR(obj.pPictureResource, "pPictureResource", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoReferenceSlotInfoKHR(const VkVideoReferenceSlotInfoKHR* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_int32_t(obj->slotIndex, "slotIndex", 1);

    PRINT_SPACE
    _OUT << "\"pPictureResource\": " << std::endl;
    if (obj->pPictureResource) {
        print_VkVideoPictureResourceInfoKHR(obj->pPictureResource, "pPictureResource", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoSessionMemoryRequirementsKHR(VkVideoSessionMemoryRequirementsKHR obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.memoryBindIndex, "memoryBindIndex", 1);

    PRINT_SPACE
    _OUT << "\"memoryRequirements\": " << std::endl;
    { print_VkMemoryRequirements(obj.memoryRequirements, "memoryRequirements", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoSessionMemoryRequirementsKHR(const VkVideoSessionMemoryRequirementsKHR* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->memoryBindIndex, "memoryBindIndex", 1);

    PRINT_SPACE
    _OUT << "\"memoryRequirements\": " << std::endl;
    { print_VkMemoryRequirements(obj->memoryRequirements, "memoryRequirements", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindVideoSessionMemoryInfoKHR(VkBindVideoSessionMemoryInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.memoryBindIndex, "memoryBindIndex", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.memoryOffset, "memoryOffset", 1);

    print_VkDeviceSize(obj.memorySize, "memorySize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindVideoSessionMemoryInfoKHR(const VkBindVideoSessionMemoryInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->memoryBindIndex, "memoryBindIndex", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->memoryOffset, "memoryOffset", 1);

    print_VkDeviceSize(obj->memorySize, "memorySize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoSessionCreateInfoKHR(VkVideoSessionCreateInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.queueFamilyIndex, "queueFamilyIndex", 1);

    print_VkVideoSessionCreateFlagsKHR(obj.flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"pVideoProfile\": " << std::endl;
    if (obj.pVideoProfile) {
        print_VkVideoProfileInfoKHR(obj.pVideoProfile, "pVideoProfile", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkFormat(obj.pictureFormat, "pictureFormat", 1);

    PRINT_SPACE
    _OUT << "\"maxCodedExtent\": " << std::endl;
    { print_VkExtent2D(obj.maxCodedExtent, "maxCodedExtent", 1); }

    print_VkFormat(obj.referencePictureFormat, "referencePictureFormat", 1);

    print_uint32_t(obj.maxDpbSlots, "maxDpbSlots", 1);

    print_uint32_t(obj.maxActiveReferencePictures, "maxActiveReferencePictures", 1);

    PRINT_SPACE
    _OUT << "\"pStdHeaderVersion\": " << std::endl;
    if (obj.pStdHeaderVersion) {
        print_VkExtensionProperties(obj.pStdHeaderVersion, "pStdHeaderVersion", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoSessionCreateInfoKHR(const VkVideoSessionCreateInfoKHR* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->queueFamilyIndex, "queueFamilyIndex", 1);

    print_VkVideoSessionCreateFlagsKHR(obj->flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"pVideoProfile\": " << std::endl;
    if (obj->pVideoProfile) {
        print_VkVideoProfileInfoKHR(obj->pVideoProfile, "pVideoProfile", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkFormat(obj->pictureFormat, "pictureFormat", 1);

    PRINT_SPACE
    _OUT << "\"maxCodedExtent\": " << std::endl;
    { print_VkExtent2D(obj->maxCodedExtent, "maxCodedExtent", 1); }

    print_VkFormat(obj->referencePictureFormat, "referencePictureFormat", 1);

    print_uint32_t(obj->maxDpbSlots, "maxDpbSlots", 1);

    print_uint32_t(obj->maxActiveReferencePictures, "maxActiveReferencePictures", 1);

    PRINT_SPACE
    _OUT << "\"pStdHeaderVersion\": " << std::endl;
    if (obj->pStdHeaderVersion) {
        print_VkExtensionProperties(obj->pStdHeaderVersion, "pStdHeaderVersion", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoSessionParametersCreateInfoKHR(VkVideoSessionParametersCreateInfoKHR obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoSessionParametersCreateFlagsKHR(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "videoSessionParametersTemplate"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "videoSession"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoSessionParametersCreateInfoKHR(const VkVideoSessionParametersCreateInfoKHR* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoSessionParametersCreateFlagsKHR(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "videoSessionParametersTemplate"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "videoSession"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoSessionParametersUpdateInfoKHR(VkVideoSessionParametersUpdateInfoKHR obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.updateSequenceCount, "updateSequenceCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoSessionParametersUpdateInfoKHR(const VkVideoSessionParametersUpdateInfoKHR* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->updateSequenceCount, "updateSequenceCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoBeginCodingInfoKHR(VkVideoBeginCodingInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoBeginCodingFlagsKHR(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "videoSession"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "videoSessionParameters"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.referenceSlotCount, "referenceSlotCount", 1);

    PRINT_SPACE
    _OUT << "\"pReferenceSlots\": " << std::endl;
    if (obj.pReferenceSlots) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.referenceSlotCount; i++) {
            if (i + 1 == obj.referenceSlotCount)
                print_VkVideoReferenceSlotInfoKHR(obj.pReferenceSlots[i], "pReferenceSlots", 0);
            else
                print_VkVideoReferenceSlotInfoKHR(obj.pReferenceSlots[i], "pReferenceSlots", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoBeginCodingInfoKHR(const VkVideoBeginCodingInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoBeginCodingFlagsKHR(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "videoSession"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "videoSessionParameters"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->referenceSlotCount, "referenceSlotCount", 1);

    PRINT_SPACE
    _OUT << "\"pReferenceSlots\": " << std::endl;
    if (obj->pReferenceSlots) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->referenceSlotCount; i++) {
            if (i + 1 == obj->referenceSlotCount)
                print_VkVideoReferenceSlotInfoKHR(obj->pReferenceSlots[i], "pReferenceSlots", 0);
            else
                print_VkVideoReferenceSlotInfoKHR(obj->pReferenceSlots[i], "pReferenceSlots", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEndCodingInfoKHR(VkVideoEndCodingInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEndCodingFlagsKHR(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEndCodingInfoKHR(const VkVideoEndCodingInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEndCodingFlagsKHR(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoCodingControlInfoKHR(VkVideoCodingControlInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoCodingControlFlagsKHR(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoCodingControlInfoKHR(const VkVideoCodingControlInfoKHR* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoCodingControlFlagsKHR(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoDecodeCapabilityFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR"),
};
static void print_VkVideoDecodeCapabilityFlagBitsKHR(VkVideoDecodeCapabilityFlagBitsKHR obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoDecodeCapabilityFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoDecodeCapabilityFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoDecodeCapabilityFlagBitsKHR(const VkVideoDecodeCapabilityFlagBitsKHR* obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoDecodeCapabilityFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoDecodeCapabilityFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoDecodeUsageFlagBitsKHR_map = {
    std::make_pair(0, "VK_VIDEO_DECODE_USAGE_DEFAULT_KHR"),
    std::make_pair(1ULL << 0, "VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR"),
};
static void print_VkVideoDecodeUsageFlagBitsKHR(VkVideoDecodeUsageFlagBitsKHR obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoDecodeUsageFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoDecodeUsageFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoDecodeUsageFlagBitsKHR(const VkVideoDecodeUsageFlagBitsKHR* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoDecodeUsageFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoDecodeUsageFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkVideoDecodeCapabilityFlagsKHR(VkVideoDecodeCapabilityFlagsKHR obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoDecodeCapabilityFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoDecodeCapabilityFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoDecodeUsageFlagsKHR(VkVideoDecodeUsageFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoDecodeUsageFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoDecodeUsageFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoDecodeFlagsKHR(VkVideoDecodeFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkVideoDecodeCapabilitiesKHR(VkVideoDecodeCapabilitiesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoDecodeCapabilityFlagsKHR(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeCapabilitiesKHR(const VkVideoDecodeCapabilitiesKHR* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoDecodeCapabilityFlagsKHR(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeUsageInfoKHR(VkVideoDecodeUsageInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoDecodeUsageFlagsKHR(obj.videoUsageHints, "videoUsageHints", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeUsageInfoKHR(const VkVideoDecodeUsageInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoDecodeUsageFlagsKHR(obj->videoUsageHints, "videoUsageHints", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeInfoKHR(VkVideoDecodeInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoDecodeFlagsKHR(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.srcBufferOffset, "srcBufferOffset", 1);

    print_VkDeviceSize(obj.srcBufferRange, "srcBufferRange", 1);

    PRINT_SPACE
    _OUT << "\"dstPictureResource\": " << std::endl;
    { print_VkVideoPictureResourceInfoKHR(obj.dstPictureResource, "dstPictureResource", 1); }

    PRINT_SPACE
    _OUT << "\"pSetupReferenceSlot\": " << std::endl;
    if (obj.pSetupReferenceSlot) {
        print_VkVideoReferenceSlotInfoKHR(obj.pSetupReferenceSlot, "pSetupReferenceSlot", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.referenceSlotCount, "referenceSlotCount", 1);

    PRINT_SPACE
    _OUT << "\"pReferenceSlots\": " << std::endl;
    if (obj.pReferenceSlots) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.referenceSlotCount; i++) {
            if (i + 1 == obj.referenceSlotCount)
                print_VkVideoReferenceSlotInfoKHR(obj.pReferenceSlots[i], "pReferenceSlots", 0);
            else
                print_VkVideoReferenceSlotInfoKHR(obj.pReferenceSlots[i], "pReferenceSlots", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeInfoKHR(const VkVideoDecodeInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoDecodeFlagsKHR(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->srcBufferOffset, "srcBufferOffset", 1);

    print_VkDeviceSize(obj->srcBufferRange, "srcBufferRange", 1);

    PRINT_SPACE
    _OUT << "\"dstPictureResource\": " << std::endl;
    { print_VkVideoPictureResourceInfoKHR(obj->dstPictureResource, "dstPictureResource", 1); }

    PRINT_SPACE
    _OUT << "\"pSetupReferenceSlot\": " << std::endl;
    if (obj->pSetupReferenceSlot) {
        print_VkVideoReferenceSlotInfoKHR(obj->pSetupReferenceSlot, "pSetupReferenceSlot", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->referenceSlotCount, "referenceSlotCount", 1);

    PRINT_SPACE
    _OUT << "\"pReferenceSlots\": " << std::endl;
    if (obj->pReferenceSlots) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->referenceSlotCount; i++) {
            if (i + 1 == obj->referenceSlotCount)
                print_VkVideoReferenceSlotInfoKHR(obj->pReferenceSlots[i], "pReferenceSlots", 0);
            else
                print_VkVideoReferenceSlotInfoKHR(obj->pReferenceSlots[i], "pReferenceSlots", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeH264CapabilityFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR"),
    std::make_pair(1ULL << 5, "VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR"),
    std::make_pair(1ULL << 6, "VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR"),
    std::make_pair(1ULL << 7, "VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR"),
    std::make_pair(1ULL << 8, "VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR"),
    std::make_pair(1ULL << 10, "VK_VIDEO_ENCODE_H264_CAPABILITY_RESERVED_10_BIT_KHR"),
    std::make_pair(1ULL << 9, "VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR"),
};
static void print_VkVideoEncodeH264CapabilityFlagBitsKHR(VkVideoEncodeH264CapabilityFlagBitsKHR obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH264CapabilityFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH264CapabilityFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeH264CapabilityFlagBitsKHR(const VkVideoEncodeH264CapabilityFlagBitsKHR* obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH264CapabilityFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH264CapabilityFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeH264StdFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR"),
    std::make_pair(1ULL << 5, "VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR"),
    std::make_pair(1ULL << 6, "VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 7, "VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR"),
    std::make_pair(1ULL << 8, "VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR"),
    std::make_pair(1ULL << 9, "VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 10, "VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR"),
    std::make_pair(1ULL << 11, "VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR"),
    std::make_pair(1ULL << 12, "VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 13, "VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR"),
    std::make_pair(1ULL << 14, "VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 15, "VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR"),
    std::make_pair(1ULL << 16, "VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR"),
    std::make_pair(1ULL << 17, "VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR"),
    std::make_pair(1ULL << 19, "VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR"),
    std::make_pair(1ULL << 20, "VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR"),
};
static void print_VkVideoEncodeH264StdFlagBitsKHR(VkVideoEncodeH264StdFlagBitsKHR obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH264StdFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH264StdFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeH264StdFlagBitsKHR(const VkVideoEncodeH264StdFlagBitsKHR* obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH264StdFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH264StdFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeH264RateControlFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR"),
};
static void print_VkVideoEncodeH264RateControlFlagBitsKHR(VkVideoEncodeH264RateControlFlagBitsKHR obj, const std::string& str,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH264RateControlFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH264RateControlFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeH264RateControlFlagBitsKHR(const VkVideoEncodeH264RateControlFlagBitsKHR* obj,
                                                          const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH264RateControlFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH264RateControlFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkVideoEncodeH264CapabilityFlagsKHR(VkVideoEncodeH264CapabilityFlagsKHR obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeH264CapabilityFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeH264CapabilityFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeH264StdFlagsKHR(VkVideoEncodeH264StdFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeH264StdFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeH264StdFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeH264RateControlFlagsKHR(VkVideoEncodeH264RateControlFlagsKHR obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeH264RateControlFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeH264RateControlFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeH264CapabilitiesKHR(VkVideoEncodeH264CapabilitiesKHR obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH264CapabilityFlagsKHR(obj.flags, "flags", 1);

    print_StdVideoH264LevelIdc(obj.maxLevelIdc, "maxLevelIdc", 1);

    print_uint32_t(obj.maxSliceCount, "maxSliceCount", 1);

    print_uint32_t(obj.maxPPictureL0ReferenceCount, "maxPPictureL0ReferenceCount", 1);

    print_uint32_t(obj.maxBPictureL0ReferenceCount, "maxBPictureL0ReferenceCount", 1);

    print_uint32_t(obj.maxL1ReferenceCount, "maxL1ReferenceCount", 1);

    print_uint32_t(obj.maxTemporalLayerCount, "maxTemporalLayerCount", 1);

    print_VkBool32(obj.expectDyadicTemporalLayerPattern, "expectDyadicTemporalLayerPattern", 1);

    print_int32_t(obj.minQp, "minQp", 1);

    print_int32_t(obj.maxQp, "maxQp", 1);

    print_VkBool32(obj.prefersGopRemainingFrames, "prefersGopRemainingFrames", 1);

    print_VkBool32(obj.requiresGopRemainingFrames, "requiresGopRemainingFrames", 1);

    print_VkVideoEncodeH264StdFlagsKHR(obj.stdSyntaxFlags, "stdSyntaxFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264CapabilitiesKHR(const VkVideoEncodeH264CapabilitiesKHR* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH264CapabilityFlagsKHR(obj->flags, "flags", 1);

    print_StdVideoH264LevelIdc(obj->maxLevelIdc, "maxLevelIdc", 1);

    print_uint32_t(obj->maxSliceCount, "maxSliceCount", 1);

    print_uint32_t(obj->maxPPictureL0ReferenceCount, "maxPPictureL0ReferenceCount", 1);

    print_uint32_t(obj->maxBPictureL0ReferenceCount, "maxBPictureL0ReferenceCount", 1);

    print_uint32_t(obj->maxL1ReferenceCount, "maxL1ReferenceCount", 1);

    print_uint32_t(obj->maxTemporalLayerCount, "maxTemporalLayerCount", 1);

    print_VkBool32(obj->expectDyadicTemporalLayerPattern, "expectDyadicTemporalLayerPattern", 1);

    print_int32_t(obj->minQp, "minQp", 1);

    print_int32_t(obj->maxQp, "maxQp", 1);

    print_VkBool32(obj->prefersGopRemainingFrames, "prefersGopRemainingFrames", 1);

    print_VkBool32(obj->requiresGopRemainingFrames, "requiresGopRemainingFrames", 1);

    print_VkVideoEncodeH264StdFlagsKHR(obj->stdSyntaxFlags, "stdSyntaxFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264QpKHR(VkVideoEncodeH264QpKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_int32_t(obj.qpI, "qpI", 1);

    print_int32_t(obj.qpP, "qpP", 1);

    print_int32_t(obj.qpB, "qpB", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264QpKHR(const VkVideoEncodeH264QpKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_int32_t(obj->qpI, "qpI", 1);

    print_int32_t(obj->qpP, "qpP", 1);

    print_int32_t(obj->qpB, "qpB", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264QualityLevelPropertiesKHR(VkVideoEncodeH264QualityLevelPropertiesKHR obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH264RateControlFlagsKHR(obj.preferredRateControlFlags, "preferredRateControlFlags", 1);

    print_uint32_t(obj.preferredGopFrameCount, "preferredGopFrameCount", 1);

    print_uint32_t(obj.preferredIdrPeriod, "preferredIdrPeriod", 1);

    print_uint32_t(obj.preferredConsecutiveBFrameCount, "preferredConsecutiveBFrameCount", 1);

    print_uint32_t(obj.preferredTemporalLayerCount, "preferredTemporalLayerCount", 1);

    PRINT_SPACE
    _OUT << "\"preferredConstantQp\": " << std::endl;
    { print_VkVideoEncodeH264QpKHR(obj.preferredConstantQp, "preferredConstantQp", 1); }

    print_uint32_t(obj.preferredMaxL0ReferenceCount, "preferredMaxL0ReferenceCount", 1);

    print_uint32_t(obj.preferredMaxL1ReferenceCount, "preferredMaxL1ReferenceCount", 1);

    print_VkBool32(obj.preferredStdEntropyCodingModeFlag, "preferredStdEntropyCodingModeFlag", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264QualityLevelPropertiesKHR(const VkVideoEncodeH264QualityLevelPropertiesKHR* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH264RateControlFlagsKHR(obj->preferredRateControlFlags, "preferredRateControlFlags", 1);

    print_uint32_t(obj->preferredGopFrameCount, "preferredGopFrameCount", 1);

    print_uint32_t(obj->preferredIdrPeriod, "preferredIdrPeriod", 1);

    print_uint32_t(obj->preferredConsecutiveBFrameCount, "preferredConsecutiveBFrameCount", 1);

    print_uint32_t(obj->preferredTemporalLayerCount, "preferredTemporalLayerCount", 1);

    PRINT_SPACE
    _OUT << "\"preferredConstantQp\": " << std::endl;
    { print_VkVideoEncodeH264QpKHR(obj->preferredConstantQp, "preferredConstantQp", 1); }

    print_uint32_t(obj->preferredMaxL0ReferenceCount, "preferredMaxL0ReferenceCount", 1);

    print_uint32_t(obj->preferredMaxL1ReferenceCount, "preferredMaxL1ReferenceCount", 1);

    print_VkBool32(obj->preferredStdEntropyCodingModeFlag, "preferredStdEntropyCodingModeFlag", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264SessionCreateInfoKHR(VkVideoEncodeH264SessionCreateInfoKHR obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.useMaxLevelIdc, "useMaxLevelIdc", 1);

    print_StdVideoH264LevelIdc(obj.maxLevelIdc, "maxLevelIdc", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264SessionCreateInfoKHR(const VkVideoEncodeH264SessionCreateInfoKHR* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->useMaxLevelIdc, "useMaxLevelIdc", 1);

    print_StdVideoH264LevelIdc(obj->maxLevelIdc, "maxLevelIdc", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264SessionParametersAddInfoKHR(VkVideoEncodeH264SessionParametersAddInfoKHR obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.stdSPSCount, "stdSPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdSPSs\":" << std::endl;
    PRINT_SPACE
    if (obj.pStdSPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stdSPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.stdSPSCount;
            print_StdVideoH264SequenceParameterSet(obj.pStdSPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.stdPPSCount, "stdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdPPSs\":" << std::endl;
    PRINT_SPACE
    if (obj.pStdPPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stdPPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.stdPPSCount;
            print_StdVideoH264PictureParameterSet(obj.pStdPPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264SessionParametersAddInfoKHR(const VkVideoEncodeH264SessionParametersAddInfoKHR* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->stdSPSCount, "stdSPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdSPSs\":" << std::endl;
    PRINT_SPACE
    if (obj->pStdSPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stdSPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->stdSPSCount;
            print_StdVideoH264SequenceParameterSet(obj->pStdSPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->stdPPSCount, "stdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdPPSs\":" << std::endl;
    PRINT_SPACE
    if (obj->pStdPPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stdPPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->stdPPSCount;
            print_StdVideoH264PictureParameterSet(obj->pStdPPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264SessionParametersCreateInfoKHR(VkVideoEncodeH264SessionParametersCreateInfoKHR obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxStdSPSCount, "maxStdSPSCount", 1);

    print_uint32_t(obj.maxStdPPSCount, "maxStdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pParametersAddInfo\": " << std::endl;
    if (obj.pParametersAddInfo) {
        print_VkVideoEncodeH264SessionParametersAddInfoKHR(obj.pParametersAddInfo, "pParametersAddInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264SessionParametersCreateInfoKHR(const VkVideoEncodeH264SessionParametersCreateInfoKHR* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxStdSPSCount, "maxStdSPSCount", 1);

    print_uint32_t(obj->maxStdPPSCount, "maxStdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pParametersAddInfo\": " << std::endl;
    if (obj->pParametersAddInfo) {
        print_VkVideoEncodeH264SessionParametersAddInfoKHR(obj->pParametersAddInfo, "pParametersAddInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264SessionParametersGetInfoKHR(VkVideoEncodeH264SessionParametersGetInfoKHR obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.writeStdSPS, "writeStdSPS", 1);

    print_VkBool32(obj.writeStdPPS, "writeStdPPS", 1);

    print_uint32_t(obj.stdSPSId, "stdSPSId", 1);

    print_uint32_t(obj.stdPPSId, "stdPPSId", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264SessionParametersGetInfoKHR(const VkVideoEncodeH264SessionParametersGetInfoKHR* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->writeStdSPS, "writeStdSPS", 1);

    print_VkBool32(obj->writeStdPPS, "writeStdPPS", 1);

    print_uint32_t(obj->stdSPSId, "stdSPSId", 1);

    print_uint32_t(obj->stdPPSId, "stdPPSId", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264SessionParametersFeedbackInfoKHR(VkVideoEncodeH264SessionParametersFeedbackInfoKHR obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.hasStdSPSOverrides, "hasStdSPSOverrides", 1);

    print_VkBool32(obj.hasStdPPSOverrides, "hasStdPPSOverrides", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264SessionParametersFeedbackInfoKHR(const VkVideoEncodeH264SessionParametersFeedbackInfoKHR* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->hasStdSPSOverrides, "hasStdSPSOverrides", 1);

    print_VkBool32(obj->hasStdPPSOverrides, "hasStdPPSOverrides", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264NaluSliceInfoKHR(VkVideoEncodeH264NaluSliceInfoKHR obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_int32_t(obj.constantQp, "constantQp", 1);

    print_StdVideoEncodeH264SliceHeader(obj.pStdSliceHeader, "pStdSliceHeader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264NaluSliceInfoKHR(const VkVideoEncodeH264NaluSliceInfoKHR* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_int32_t(obj->constantQp, "constantQp", 1);

    print_StdVideoEncodeH264SliceHeader(obj->pStdSliceHeader, "pStdSliceHeader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264PictureInfoKHR(VkVideoEncodeH264PictureInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.naluSliceEntryCount, "naluSliceEntryCount", 1);

    PRINT_SPACE
    _OUT << "\"pNaluSliceEntries\": " << std::endl;
    if (obj.pNaluSliceEntries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.naluSliceEntryCount; i++) {
            if (i + 1 == obj.naluSliceEntryCount)
                print_VkVideoEncodeH264NaluSliceInfoKHR(obj.pNaluSliceEntries[i], "pNaluSliceEntries", 0);
            else
                print_VkVideoEncodeH264NaluSliceInfoKHR(obj.pNaluSliceEntries[i], "pNaluSliceEntries", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_StdVideoEncodeH264PictureInfo(obj.pStdPictureInfo, "pStdPictureInfo", 1);

    print_VkBool32(obj.generatePrefixNalu, "generatePrefixNalu", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264PictureInfoKHR(const VkVideoEncodeH264PictureInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->naluSliceEntryCount, "naluSliceEntryCount", 1);

    PRINT_SPACE
    _OUT << "\"pNaluSliceEntries\": " << std::endl;
    if (obj->pNaluSliceEntries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->naluSliceEntryCount; i++) {
            if (i + 1 == obj->naluSliceEntryCount)
                print_VkVideoEncodeH264NaluSliceInfoKHR(obj->pNaluSliceEntries[i], "pNaluSliceEntries", 0);
            else
                print_VkVideoEncodeH264NaluSliceInfoKHR(obj->pNaluSliceEntries[i], "pNaluSliceEntries", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_StdVideoEncodeH264PictureInfo(obj->pStdPictureInfo, "pStdPictureInfo", 1);

    print_VkBool32(obj->generatePrefixNalu, "generatePrefixNalu", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264DpbSlotInfoKHR(VkVideoEncodeH264DpbSlotInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoEncodeH264ReferenceInfo(obj.pStdReferenceInfo, "pStdReferenceInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264DpbSlotInfoKHR(const VkVideoEncodeH264DpbSlotInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoEncodeH264ReferenceInfo(obj->pStdReferenceInfo, "pStdReferenceInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264ProfileInfoKHR(VkVideoEncodeH264ProfileInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH264ProfileIdc(obj.stdProfileIdc, "stdProfileIdc", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264ProfileInfoKHR(const VkVideoEncodeH264ProfileInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH264ProfileIdc(obj->stdProfileIdc, "stdProfileIdc", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264RateControlInfoKHR(VkVideoEncodeH264RateControlInfoKHR obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH264RateControlFlagsKHR(obj.flags, "flags", 1);

    print_uint32_t(obj.gopFrameCount, "gopFrameCount", 1);

    print_uint32_t(obj.idrPeriod, "idrPeriod", 1);

    print_uint32_t(obj.consecutiveBFrameCount, "consecutiveBFrameCount", 1);

    print_uint32_t(obj.temporalLayerCount, "temporalLayerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264RateControlInfoKHR(const VkVideoEncodeH264RateControlInfoKHR* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH264RateControlFlagsKHR(obj->flags, "flags", 1);

    print_uint32_t(obj->gopFrameCount, "gopFrameCount", 1);

    print_uint32_t(obj->idrPeriod, "idrPeriod", 1);

    print_uint32_t(obj->consecutiveBFrameCount, "consecutiveBFrameCount", 1);

    print_uint32_t(obj->temporalLayerCount, "temporalLayerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264FrameSizeKHR(VkVideoEncodeH264FrameSizeKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.frameISize, "frameISize", 1);

    print_uint32_t(obj.framePSize, "framePSize", 1);

    print_uint32_t(obj.frameBSize, "frameBSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264FrameSizeKHR(const VkVideoEncodeH264FrameSizeKHR* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->frameISize, "frameISize", 1);

    print_uint32_t(obj->framePSize, "framePSize", 1);

    print_uint32_t(obj->frameBSize, "frameBSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264RateControlLayerInfoKHR(VkVideoEncodeH264RateControlLayerInfoKHR obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.useMinQp, "useMinQp", 1);

    PRINT_SPACE
    _OUT << "\"minQp\": " << std::endl;
    { print_VkVideoEncodeH264QpKHR(obj.minQp, "minQp", 1); }

    print_VkBool32(obj.useMaxQp, "useMaxQp", 1);

    PRINT_SPACE
    _OUT << "\"maxQp\": " << std::endl;
    { print_VkVideoEncodeH264QpKHR(obj.maxQp, "maxQp", 1); }

    print_VkBool32(obj.useMaxFrameSize, "useMaxFrameSize", 1);

    PRINT_SPACE
    _OUT << "\"maxFrameSize\": " << std::endl;
    { print_VkVideoEncodeH264FrameSizeKHR(obj.maxFrameSize, "maxFrameSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264RateControlLayerInfoKHR(const VkVideoEncodeH264RateControlLayerInfoKHR* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->useMinQp, "useMinQp", 1);

    PRINT_SPACE
    _OUT << "\"minQp\": " << std::endl;
    { print_VkVideoEncodeH264QpKHR(obj->minQp, "minQp", 1); }

    print_VkBool32(obj->useMaxQp, "useMaxQp", 1);

    PRINT_SPACE
    _OUT << "\"maxQp\": " << std::endl;
    { print_VkVideoEncodeH264QpKHR(obj->maxQp, "maxQp", 1); }

    print_VkBool32(obj->useMaxFrameSize, "useMaxFrameSize", 1);

    PRINT_SPACE
    _OUT << "\"maxFrameSize\": " << std::endl;
    { print_VkVideoEncodeH264FrameSizeKHR(obj->maxFrameSize, "maxFrameSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264GopRemainingFrameInfoKHR(VkVideoEncodeH264GopRemainingFrameInfoKHR obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.useGopRemainingFrames, "useGopRemainingFrames", 1);

    print_uint32_t(obj.gopRemainingI, "gopRemainingI", 1);

    print_uint32_t(obj.gopRemainingP, "gopRemainingP", 1);

    print_uint32_t(obj.gopRemainingB, "gopRemainingB", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264GopRemainingFrameInfoKHR(const VkVideoEncodeH264GopRemainingFrameInfoKHR* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->useGopRemainingFrames, "useGopRemainingFrames", 1);

    print_uint32_t(obj->gopRemainingI, "gopRemainingI", 1);

    print_uint32_t(obj->gopRemainingP, "gopRemainingP", 1);

    print_uint32_t(obj->gopRemainingB, "gopRemainingB", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeH265CapabilityFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR"),
    std::make_pair(1ULL << 5, "VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR"),
    std::make_pair(1ULL << 6, "VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR"),
    std::make_pair(1ULL << 7, "VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR"),
    std::make_pair(1ULL << 8, "VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR"),
    std::make_pair(1ULL << 9, "VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR"),
    std::make_pair(1ULL << 11, "VK_VIDEO_ENCODE_H265_CAPABILITY_RESERVED_11_BIT_KHR"),
    std::make_pair(1ULL << 10, "VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR"),
};
static void print_VkVideoEncodeH265CapabilityFlagBitsKHR(VkVideoEncodeH265CapabilityFlagBitsKHR obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH265CapabilityFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH265CapabilityFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeH265CapabilityFlagBitsKHR(const VkVideoEncodeH265CapabilityFlagBitsKHR* obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH265CapabilityFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH265CapabilityFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeH265StdFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 5, "VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR"),
    std::make_pair(1ULL << 6, "VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 7, "VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 8, "VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR"),
    std::make_pair(1ULL << 9, "VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 10, "VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 11, "VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR"),
    std::make_pair(1ULL << 12, "VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 13, "VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 14, "VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 15, "VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 16, "VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 17, "VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 18, "VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 19, "VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR"),
    std::make_pair(1ULL << 20, "VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR"),
};
static void print_VkVideoEncodeH265StdFlagBitsKHR(VkVideoEncodeH265StdFlagBitsKHR obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH265StdFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH265StdFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeH265StdFlagBitsKHR(const VkVideoEncodeH265StdFlagBitsKHR* obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH265StdFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH265StdFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeH265CtbSizeFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR"),
};
static void print_VkVideoEncodeH265CtbSizeFlagBitsKHR(VkVideoEncodeH265CtbSizeFlagBitsKHR obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH265CtbSizeFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH265CtbSizeFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeH265CtbSizeFlagBitsKHR(const VkVideoEncodeH265CtbSizeFlagBitsKHR* obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH265CtbSizeFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH265CtbSizeFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeH265TransformBlockSizeFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR"),
};
static void print_VkVideoEncodeH265TransformBlockSizeFlagBitsKHR(VkVideoEncodeH265TransformBlockSizeFlagBitsKHR obj,
                                                                 const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH265TransformBlockSizeFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH265TransformBlockSizeFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeH265TransformBlockSizeFlagBitsKHR(const VkVideoEncodeH265TransformBlockSizeFlagBitsKHR* obj,
                                                                 const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH265TransformBlockSizeFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH265TransformBlockSizeFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeH265RateControlFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR"),
};
static void print_VkVideoEncodeH265RateControlFlagBitsKHR(VkVideoEncodeH265RateControlFlagBitsKHR obj, const std::string& str,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH265RateControlFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH265RateControlFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeH265RateControlFlagBitsKHR(const VkVideoEncodeH265RateControlFlagBitsKHR* obj,
                                                          const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeH265RateControlFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeH265RateControlFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkVideoEncodeH265CapabilityFlagsKHR(VkVideoEncodeH265CapabilityFlagsKHR obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeH265CapabilityFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeH265CapabilityFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeH265StdFlagsKHR(VkVideoEncodeH265StdFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeH265StdFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeH265StdFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeH265CtbSizeFlagsKHR(VkVideoEncodeH265CtbSizeFlagsKHR obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeH265CtbSizeFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeH265CtbSizeFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeH265TransformBlockSizeFlagsKHR(VkVideoEncodeH265TransformBlockSizeFlagsKHR obj,
                                                              const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeH265TransformBlockSizeFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeH265TransformBlockSizeFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeH265RateControlFlagsKHR(VkVideoEncodeH265RateControlFlagsKHR obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeH265RateControlFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeH265RateControlFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeH265CapabilitiesKHR(VkVideoEncodeH265CapabilitiesKHR obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH265CapabilityFlagsKHR(obj.flags, "flags", 1);

    print_StdVideoH265LevelIdc(obj.maxLevelIdc, "maxLevelIdc", 1);

    print_uint32_t(obj.maxSliceSegmentCount, "maxSliceSegmentCount", 1);

    PRINT_SPACE
    _OUT << "\"maxTiles\": " << std::endl;
    { print_VkExtent2D(obj.maxTiles, "maxTiles", 1); }

    print_VkVideoEncodeH265CtbSizeFlagsKHR(obj.ctbSizes, "ctbSizes", 1);

    print_VkVideoEncodeH265TransformBlockSizeFlagsKHR(obj.transformBlockSizes, "transformBlockSizes", 1);

    print_uint32_t(obj.maxPPictureL0ReferenceCount, "maxPPictureL0ReferenceCount", 1);

    print_uint32_t(obj.maxBPictureL0ReferenceCount, "maxBPictureL0ReferenceCount", 1);

    print_uint32_t(obj.maxL1ReferenceCount, "maxL1ReferenceCount", 1);

    print_uint32_t(obj.maxSubLayerCount, "maxSubLayerCount", 1);

    print_VkBool32(obj.expectDyadicTemporalSubLayerPattern, "expectDyadicTemporalSubLayerPattern", 1);

    print_int32_t(obj.minQp, "minQp", 1);

    print_int32_t(obj.maxQp, "maxQp", 1);

    print_VkBool32(obj.prefersGopRemainingFrames, "prefersGopRemainingFrames", 1);

    print_VkBool32(obj.requiresGopRemainingFrames, "requiresGopRemainingFrames", 1);

    print_VkVideoEncodeH265StdFlagsKHR(obj.stdSyntaxFlags, "stdSyntaxFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265CapabilitiesKHR(const VkVideoEncodeH265CapabilitiesKHR* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH265CapabilityFlagsKHR(obj->flags, "flags", 1);

    print_StdVideoH265LevelIdc(obj->maxLevelIdc, "maxLevelIdc", 1);

    print_uint32_t(obj->maxSliceSegmentCount, "maxSliceSegmentCount", 1);

    PRINT_SPACE
    _OUT << "\"maxTiles\": " << std::endl;
    { print_VkExtent2D(obj->maxTiles, "maxTiles", 1); }

    print_VkVideoEncodeH265CtbSizeFlagsKHR(obj->ctbSizes, "ctbSizes", 1);

    print_VkVideoEncodeH265TransformBlockSizeFlagsKHR(obj->transformBlockSizes, "transformBlockSizes", 1);

    print_uint32_t(obj->maxPPictureL0ReferenceCount, "maxPPictureL0ReferenceCount", 1);

    print_uint32_t(obj->maxBPictureL0ReferenceCount, "maxBPictureL0ReferenceCount", 1);

    print_uint32_t(obj->maxL1ReferenceCount, "maxL1ReferenceCount", 1);

    print_uint32_t(obj->maxSubLayerCount, "maxSubLayerCount", 1);

    print_VkBool32(obj->expectDyadicTemporalSubLayerPattern, "expectDyadicTemporalSubLayerPattern", 1);

    print_int32_t(obj->minQp, "minQp", 1);

    print_int32_t(obj->maxQp, "maxQp", 1);

    print_VkBool32(obj->prefersGopRemainingFrames, "prefersGopRemainingFrames", 1);

    print_VkBool32(obj->requiresGopRemainingFrames, "requiresGopRemainingFrames", 1);

    print_VkVideoEncodeH265StdFlagsKHR(obj->stdSyntaxFlags, "stdSyntaxFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265SessionCreateInfoKHR(VkVideoEncodeH265SessionCreateInfoKHR obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.useMaxLevelIdc, "useMaxLevelIdc", 1);

    print_StdVideoH265LevelIdc(obj.maxLevelIdc, "maxLevelIdc", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265SessionCreateInfoKHR(const VkVideoEncodeH265SessionCreateInfoKHR* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->useMaxLevelIdc, "useMaxLevelIdc", 1);

    print_StdVideoH265LevelIdc(obj->maxLevelIdc, "maxLevelIdc", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265QpKHR(VkVideoEncodeH265QpKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_int32_t(obj.qpI, "qpI", 1);

    print_int32_t(obj.qpP, "qpP", 1);

    print_int32_t(obj.qpB, "qpB", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265QpKHR(const VkVideoEncodeH265QpKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_int32_t(obj->qpI, "qpI", 1);

    print_int32_t(obj->qpP, "qpP", 1);

    print_int32_t(obj->qpB, "qpB", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265QualityLevelPropertiesKHR(VkVideoEncodeH265QualityLevelPropertiesKHR obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH265RateControlFlagsKHR(obj.preferredRateControlFlags, "preferredRateControlFlags", 1);

    print_uint32_t(obj.preferredGopFrameCount, "preferredGopFrameCount", 1);

    print_uint32_t(obj.preferredIdrPeriod, "preferredIdrPeriod", 1);

    print_uint32_t(obj.preferredConsecutiveBFrameCount, "preferredConsecutiveBFrameCount", 1);

    print_uint32_t(obj.preferredSubLayerCount, "preferredSubLayerCount", 1);

    PRINT_SPACE
    _OUT << "\"preferredConstantQp\": " << std::endl;
    { print_VkVideoEncodeH265QpKHR(obj.preferredConstantQp, "preferredConstantQp", 1); }

    print_uint32_t(obj.preferredMaxL0ReferenceCount, "preferredMaxL0ReferenceCount", 1);

    print_uint32_t(obj.preferredMaxL1ReferenceCount, "preferredMaxL1ReferenceCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265QualityLevelPropertiesKHR(const VkVideoEncodeH265QualityLevelPropertiesKHR* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH265RateControlFlagsKHR(obj->preferredRateControlFlags, "preferredRateControlFlags", 1);

    print_uint32_t(obj->preferredGopFrameCount, "preferredGopFrameCount", 1);

    print_uint32_t(obj->preferredIdrPeriod, "preferredIdrPeriod", 1);

    print_uint32_t(obj->preferredConsecutiveBFrameCount, "preferredConsecutiveBFrameCount", 1);

    print_uint32_t(obj->preferredSubLayerCount, "preferredSubLayerCount", 1);

    PRINT_SPACE
    _OUT << "\"preferredConstantQp\": " << std::endl;
    { print_VkVideoEncodeH265QpKHR(obj->preferredConstantQp, "preferredConstantQp", 1); }

    print_uint32_t(obj->preferredMaxL0ReferenceCount, "preferredMaxL0ReferenceCount", 1);

    print_uint32_t(obj->preferredMaxL1ReferenceCount, "preferredMaxL1ReferenceCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265SessionParametersAddInfoKHR(VkVideoEncodeH265SessionParametersAddInfoKHR obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.stdVPSCount, "stdVPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdVPSs\":" << std::endl;
    PRINT_SPACE
    if (obj.pStdVPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stdVPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.stdVPSCount;
            print_StdVideoH265VideoParameterSet(obj.pStdVPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.stdSPSCount, "stdSPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdSPSs\":" << std::endl;
    PRINT_SPACE
    if (obj.pStdSPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stdSPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.stdSPSCount;
            print_StdVideoH265SequenceParameterSet(obj.pStdSPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.stdPPSCount, "stdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdPPSs\":" << std::endl;
    PRINT_SPACE
    if (obj.pStdPPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stdPPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.stdPPSCount;
            print_StdVideoH265PictureParameterSet(obj.pStdPPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265SessionParametersAddInfoKHR(const VkVideoEncodeH265SessionParametersAddInfoKHR* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->stdVPSCount, "stdVPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdVPSs\":" << std::endl;
    PRINT_SPACE
    if (obj->pStdVPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stdVPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->stdVPSCount;
            print_StdVideoH265VideoParameterSet(obj->pStdVPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->stdSPSCount, "stdSPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdSPSs\":" << std::endl;
    PRINT_SPACE
    if (obj->pStdSPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stdSPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->stdSPSCount;
            print_StdVideoH265SequenceParameterSet(obj->pStdSPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->stdPPSCount, "stdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdPPSs\":" << std::endl;
    PRINT_SPACE
    if (obj->pStdPPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stdPPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->stdPPSCount;
            print_StdVideoH265PictureParameterSet(obj->pStdPPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265SessionParametersCreateInfoKHR(VkVideoEncodeH265SessionParametersCreateInfoKHR obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxStdVPSCount, "maxStdVPSCount", 1);

    print_uint32_t(obj.maxStdSPSCount, "maxStdSPSCount", 1);

    print_uint32_t(obj.maxStdPPSCount, "maxStdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pParametersAddInfo\": " << std::endl;
    if (obj.pParametersAddInfo) {
        print_VkVideoEncodeH265SessionParametersAddInfoKHR(obj.pParametersAddInfo, "pParametersAddInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265SessionParametersCreateInfoKHR(const VkVideoEncodeH265SessionParametersCreateInfoKHR* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxStdVPSCount, "maxStdVPSCount", 1);

    print_uint32_t(obj->maxStdSPSCount, "maxStdSPSCount", 1);

    print_uint32_t(obj->maxStdPPSCount, "maxStdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pParametersAddInfo\": " << std::endl;
    if (obj->pParametersAddInfo) {
        print_VkVideoEncodeH265SessionParametersAddInfoKHR(obj->pParametersAddInfo, "pParametersAddInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265SessionParametersGetInfoKHR(VkVideoEncodeH265SessionParametersGetInfoKHR obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.writeStdVPS, "writeStdVPS", 1);

    print_VkBool32(obj.writeStdSPS, "writeStdSPS", 1);

    print_VkBool32(obj.writeStdPPS, "writeStdPPS", 1);

    print_uint32_t(obj.stdVPSId, "stdVPSId", 1);

    print_uint32_t(obj.stdSPSId, "stdSPSId", 1);

    print_uint32_t(obj.stdPPSId, "stdPPSId", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265SessionParametersGetInfoKHR(const VkVideoEncodeH265SessionParametersGetInfoKHR* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->writeStdVPS, "writeStdVPS", 1);

    print_VkBool32(obj->writeStdSPS, "writeStdSPS", 1);

    print_VkBool32(obj->writeStdPPS, "writeStdPPS", 1);

    print_uint32_t(obj->stdVPSId, "stdVPSId", 1);

    print_uint32_t(obj->stdSPSId, "stdSPSId", 1);

    print_uint32_t(obj->stdPPSId, "stdPPSId", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265SessionParametersFeedbackInfoKHR(VkVideoEncodeH265SessionParametersFeedbackInfoKHR obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.hasStdVPSOverrides, "hasStdVPSOverrides", 1);

    print_VkBool32(obj.hasStdSPSOverrides, "hasStdSPSOverrides", 1);

    print_VkBool32(obj.hasStdPPSOverrides, "hasStdPPSOverrides", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265SessionParametersFeedbackInfoKHR(const VkVideoEncodeH265SessionParametersFeedbackInfoKHR* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->hasStdVPSOverrides, "hasStdVPSOverrides", 1);

    print_VkBool32(obj->hasStdSPSOverrides, "hasStdSPSOverrides", 1);

    print_VkBool32(obj->hasStdPPSOverrides, "hasStdPPSOverrides", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265NaluSliceSegmentInfoKHR(VkVideoEncodeH265NaluSliceSegmentInfoKHR obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_int32_t(obj.constantQp, "constantQp", 1);

    print_StdVideoEncodeH265SliceSegmentHeader(obj.pStdSliceSegmentHeader, "pStdSliceSegmentHeader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265NaluSliceSegmentInfoKHR(const VkVideoEncodeH265NaluSliceSegmentInfoKHR* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_int32_t(obj->constantQp, "constantQp", 1);

    print_StdVideoEncodeH265SliceSegmentHeader(obj->pStdSliceSegmentHeader, "pStdSliceSegmentHeader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265PictureInfoKHR(VkVideoEncodeH265PictureInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.naluSliceSegmentEntryCount, "naluSliceSegmentEntryCount", 1);

    PRINT_SPACE
    _OUT << "\"pNaluSliceSegmentEntries\": " << std::endl;
    if (obj.pNaluSliceSegmentEntries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.naluSliceSegmentEntryCount; i++) {
            if (i + 1 == obj.naluSliceSegmentEntryCount)
                print_VkVideoEncodeH265NaluSliceSegmentInfoKHR(obj.pNaluSliceSegmentEntries[i], "pNaluSliceSegmentEntries", 0);
            else
                print_VkVideoEncodeH265NaluSliceSegmentInfoKHR(obj.pNaluSliceSegmentEntries[i], "pNaluSliceSegmentEntries", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_StdVideoEncodeH265PictureInfo(obj.pStdPictureInfo, "pStdPictureInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265PictureInfoKHR(const VkVideoEncodeH265PictureInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->naluSliceSegmentEntryCount, "naluSliceSegmentEntryCount", 1);

    PRINT_SPACE
    _OUT << "\"pNaluSliceSegmentEntries\": " << std::endl;
    if (obj->pNaluSliceSegmentEntries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->naluSliceSegmentEntryCount; i++) {
            if (i + 1 == obj->naluSliceSegmentEntryCount)
                print_VkVideoEncodeH265NaluSliceSegmentInfoKHR(obj->pNaluSliceSegmentEntries[i], "pNaluSliceSegmentEntries", 0);
            else
                print_VkVideoEncodeH265NaluSliceSegmentInfoKHR(obj->pNaluSliceSegmentEntries[i], "pNaluSliceSegmentEntries", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_StdVideoEncodeH265PictureInfo(obj->pStdPictureInfo, "pStdPictureInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265DpbSlotInfoKHR(VkVideoEncodeH265DpbSlotInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoEncodeH265ReferenceInfo(obj.pStdReferenceInfo, "pStdReferenceInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265DpbSlotInfoKHR(const VkVideoEncodeH265DpbSlotInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoEncodeH265ReferenceInfo(obj->pStdReferenceInfo, "pStdReferenceInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265ProfileInfoKHR(VkVideoEncodeH265ProfileInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH265ProfileIdc(obj.stdProfileIdc, "stdProfileIdc", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265ProfileInfoKHR(const VkVideoEncodeH265ProfileInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH265ProfileIdc(obj->stdProfileIdc, "stdProfileIdc", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265RateControlInfoKHR(VkVideoEncodeH265RateControlInfoKHR obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH265RateControlFlagsKHR(obj.flags, "flags", 1);

    print_uint32_t(obj.gopFrameCount, "gopFrameCount", 1);

    print_uint32_t(obj.idrPeriod, "idrPeriod", 1);

    print_uint32_t(obj.consecutiveBFrameCount, "consecutiveBFrameCount", 1);

    print_uint32_t(obj.subLayerCount, "subLayerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265RateControlInfoKHR(const VkVideoEncodeH265RateControlInfoKHR* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH265RateControlFlagsKHR(obj->flags, "flags", 1);

    print_uint32_t(obj->gopFrameCount, "gopFrameCount", 1);

    print_uint32_t(obj->idrPeriod, "idrPeriod", 1);

    print_uint32_t(obj->consecutiveBFrameCount, "consecutiveBFrameCount", 1);

    print_uint32_t(obj->subLayerCount, "subLayerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265FrameSizeKHR(VkVideoEncodeH265FrameSizeKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.frameISize, "frameISize", 1);

    print_uint32_t(obj.framePSize, "framePSize", 1);

    print_uint32_t(obj.frameBSize, "frameBSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265FrameSizeKHR(const VkVideoEncodeH265FrameSizeKHR* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->frameISize, "frameISize", 1);

    print_uint32_t(obj->framePSize, "framePSize", 1);

    print_uint32_t(obj->frameBSize, "frameBSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265RateControlLayerInfoKHR(VkVideoEncodeH265RateControlLayerInfoKHR obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.useMinQp, "useMinQp", 1);

    PRINT_SPACE
    _OUT << "\"minQp\": " << std::endl;
    { print_VkVideoEncodeH265QpKHR(obj.minQp, "minQp", 1); }

    print_VkBool32(obj.useMaxQp, "useMaxQp", 1);

    PRINT_SPACE
    _OUT << "\"maxQp\": " << std::endl;
    { print_VkVideoEncodeH265QpKHR(obj.maxQp, "maxQp", 1); }

    print_VkBool32(obj.useMaxFrameSize, "useMaxFrameSize", 1);

    PRINT_SPACE
    _OUT << "\"maxFrameSize\": " << std::endl;
    { print_VkVideoEncodeH265FrameSizeKHR(obj.maxFrameSize, "maxFrameSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265RateControlLayerInfoKHR(const VkVideoEncodeH265RateControlLayerInfoKHR* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->useMinQp, "useMinQp", 1);

    PRINT_SPACE
    _OUT << "\"minQp\": " << std::endl;
    { print_VkVideoEncodeH265QpKHR(obj->minQp, "minQp", 1); }

    print_VkBool32(obj->useMaxQp, "useMaxQp", 1);

    PRINT_SPACE
    _OUT << "\"maxQp\": " << std::endl;
    { print_VkVideoEncodeH265QpKHR(obj->maxQp, "maxQp", 1); }

    print_VkBool32(obj->useMaxFrameSize, "useMaxFrameSize", 1);

    PRINT_SPACE
    _OUT << "\"maxFrameSize\": " << std::endl;
    { print_VkVideoEncodeH265FrameSizeKHR(obj->maxFrameSize, "maxFrameSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265GopRemainingFrameInfoKHR(VkVideoEncodeH265GopRemainingFrameInfoKHR obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.useGopRemainingFrames, "useGopRemainingFrames", 1);

    print_uint32_t(obj.gopRemainingI, "gopRemainingI", 1);

    print_uint32_t(obj.gopRemainingP, "gopRemainingP", 1);

    print_uint32_t(obj.gopRemainingB, "gopRemainingB", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265GopRemainingFrameInfoKHR(const VkVideoEncodeH265GopRemainingFrameInfoKHR* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->useGopRemainingFrames, "useGopRemainingFrames", 1);

    print_uint32_t(obj->gopRemainingI, "gopRemainingI", 1);

    print_uint32_t(obj->gopRemainingP, "gopRemainingP", 1);

    print_uint32_t(obj->gopRemainingB, "gopRemainingB", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoDecodeH264PictureLayoutFlagBitsKHR_map = {
    std::make_pair(0, "VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR"),
    std::make_pair(1ULL << 0, "VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR"),
};
static void print_VkVideoDecodeH264PictureLayoutFlagBitsKHR(VkVideoDecodeH264PictureLayoutFlagBitsKHR obj, const std::string& str,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoDecodeH264PictureLayoutFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoDecodeH264PictureLayoutFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoDecodeH264PictureLayoutFlagBitsKHR(const VkVideoDecodeH264PictureLayoutFlagBitsKHR* obj,
                                                            const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoDecodeH264PictureLayoutFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoDecodeH264PictureLayoutFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkVideoDecodeH264PictureLayoutFlagsKHR(VkVideoDecodeH264PictureLayoutFlagsKHR obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoDecodeH264PictureLayoutFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoDecodeH264PictureLayoutFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoDecodeH264ProfileInfoKHR(VkVideoDecodeH264ProfileInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH264ProfileIdc(obj.stdProfileIdc, "stdProfileIdc", 1);

    print_VkVideoDecodeH264PictureLayoutFlagBitsKHR(obj.pictureLayout, "pictureLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH264ProfileInfoKHR(const VkVideoDecodeH264ProfileInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH264ProfileIdc(obj->stdProfileIdc, "stdProfileIdc", 1);

    print_VkVideoDecodeH264PictureLayoutFlagBitsKHR(obj->pictureLayout, "pictureLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeH264CapabilitiesKHR(VkVideoDecodeH264CapabilitiesKHR obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH264LevelIdc(obj.maxLevelIdc, "maxLevelIdc", 1);

    PRINT_SPACE
    _OUT << "\"fieldOffsetGranularity\": " << std::endl;
    { print_VkOffset2D(obj.fieldOffsetGranularity, "fieldOffsetGranularity", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH264CapabilitiesKHR(const VkVideoDecodeH264CapabilitiesKHR* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH264LevelIdc(obj->maxLevelIdc, "maxLevelIdc", 1);

    PRINT_SPACE
    _OUT << "\"fieldOffsetGranularity\": " << std::endl;
    { print_VkOffset2D(obj->fieldOffsetGranularity, "fieldOffsetGranularity", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeH264SessionParametersAddInfoKHR(VkVideoDecodeH264SessionParametersAddInfoKHR obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.stdSPSCount, "stdSPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdSPSs\":" << std::endl;
    PRINT_SPACE
    if (obj.pStdSPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stdSPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.stdSPSCount;
            print_StdVideoH264SequenceParameterSet(obj.pStdSPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.stdPPSCount, "stdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdPPSs\":" << std::endl;
    PRINT_SPACE
    if (obj.pStdPPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stdPPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.stdPPSCount;
            print_StdVideoH264PictureParameterSet(obj.pStdPPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH264SessionParametersAddInfoKHR(const VkVideoDecodeH264SessionParametersAddInfoKHR* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->stdSPSCount, "stdSPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdSPSs\":" << std::endl;
    PRINT_SPACE
    if (obj->pStdSPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stdSPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->stdSPSCount;
            print_StdVideoH264SequenceParameterSet(obj->pStdSPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->stdPPSCount, "stdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdPPSs\":" << std::endl;
    PRINT_SPACE
    if (obj->pStdPPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stdPPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->stdPPSCount;
            print_StdVideoH264PictureParameterSet(obj->pStdPPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeH264SessionParametersCreateInfoKHR(VkVideoDecodeH264SessionParametersCreateInfoKHR obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxStdSPSCount, "maxStdSPSCount", 1);

    print_uint32_t(obj.maxStdPPSCount, "maxStdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pParametersAddInfo\": " << std::endl;
    if (obj.pParametersAddInfo) {
        print_VkVideoDecodeH264SessionParametersAddInfoKHR(obj.pParametersAddInfo, "pParametersAddInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH264SessionParametersCreateInfoKHR(const VkVideoDecodeH264SessionParametersCreateInfoKHR* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxStdSPSCount, "maxStdSPSCount", 1);

    print_uint32_t(obj->maxStdPPSCount, "maxStdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pParametersAddInfo\": " << std::endl;
    if (obj->pParametersAddInfo) {
        print_VkVideoDecodeH264SessionParametersAddInfoKHR(obj->pParametersAddInfo, "pParametersAddInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeH264PictureInfoKHR(VkVideoDecodeH264PictureInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoDecodeH264PictureInfo(obj.pStdPictureInfo, "pStdPictureInfo", 1);

    print_uint32_t(obj.sliceCount, "sliceCount", 1);

    PRINT_SPACE
    _OUT << "\"pSliceOffsets\":" << std::endl;
    PRINT_SPACE
    if (obj.pSliceOffsets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.sliceCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.sliceCount;
            print_uint32_t(obj.pSliceOffsets[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH264PictureInfoKHR(const VkVideoDecodeH264PictureInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoDecodeH264PictureInfo(obj->pStdPictureInfo, "pStdPictureInfo", 1);

    print_uint32_t(obj->sliceCount, "sliceCount", 1);

    PRINT_SPACE
    _OUT << "\"pSliceOffsets\":" << std::endl;
    PRINT_SPACE
    if (obj->pSliceOffsets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->sliceCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->sliceCount;
            print_uint32_t(obj->pSliceOffsets[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeH264DpbSlotInfoKHR(VkVideoDecodeH264DpbSlotInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoDecodeH264ReferenceInfo(obj.pStdReferenceInfo, "pStdReferenceInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH264DpbSlotInfoKHR(const VkVideoDecodeH264DpbSlotInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoDecodeH264ReferenceInfo(obj->pStdReferenceInfo, "pStdReferenceInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkRenderingFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT"),
    std::make_pair(1ULL << 1, "VK_RENDERING_SUSPENDING_BIT"),
    std::make_pair(1ULL << 2, "VK_RENDERING_RESUMING_BIT"),
    std::make_pair(1ULL << 3, "VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT"),
    std::make_pair(1ULL << 4, "VK_RENDERING_CONTENTS_INLINE_BIT_KHR"),
};
static void print_VkRenderingFlagBits(VkRenderingFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRenderingFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRenderingFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkRenderingFlagBits(const VkRenderingFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRenderingFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRenderingFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkRenderingFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT"),
    std::make_pair(1ULL << 1, "VK_RENDERING_SUSPENDING_BIT"),
    std::make_pair(1ULL << 2, "VK_RENDERING_RESUMING_BIT"),
    std::make_pair(1ULL << 3, "VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT"),
    std::make_pair(1ULL << 4, "VK_RENDERING_CONTENTS_INLINE_BIT_KHR"),
};
static void print_VkRenderingFlagBitsKHR(VkRenderingFlagBitsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRenderingFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRenderingFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkRenderingFlagBitsKHR(const VkRenderingFlagBitsKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRenderingFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRenderingFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkRenderingFlags(VkRenderingFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkRenderingFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkRenderingFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkRenderingAttachmentInfo(VkRenderingAttachmentInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.imageLayout, "imageLayout", 1);

    print_VkResolveModeFlagBits(obj.resolveMode, "resolveMode", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "resolveImageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.resolveImageLayout, "resolveImageLayout", 1);

    print_VkAttachmentLoadOp(obj.loadOp, "loadOp", 1);

    print_VkAttachmentStoreOp(obj.storeOp, "storeOp", 1);

    print_VkClearValue(obj.clearValue, "clearValue", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderingAttachmentInfo(const VkRenderingAttachmentInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->imageLayout, "imageLayout", 1);

    print_VkResolveModeFlagBits(obj->resolveMode, "resolveMode", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "resolveImageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->resolveImageLayout, "resolveImageLayout", 1);

    print_VkAttachmentLoadOp(obj->loadOp, "loadOp", 1);

    print_VkAttachmentStoreOp(obj->storeOp, "storeOp", 1);

    print_VkClearValue(obj->clearValue, "clearValue", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderingInfo(VkRenderingInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRenderingFlags(obj.flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"renderArea\": " << std::endl;
    { print_VkRect2D(obj.renderArea, "renderArea", 1); }

    print_uint32_t(obj.layerCount, "layerCount", 1);

    print_uint32_t(obj.viewMask, "viewMask", 1);

    print_uint32_t(obj.colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachments\": " << std::endl;
    if (obj.pColorAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.colorAttachmentCount; i++) {
            if (i + 1 == obj.colorAttachmentCount)
                print_VkRenderingAttachmentInfo(obj.pColorAttachments[i], "pColorAttachments", 0);
            else
                print_VkRenderingAttachmentInfo(obj.pColorAttachments[i], "pColorAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pDepthAttachment\": " << std::endl;
    if (obj.pDepthAttachment) {
        print_VkRenderingAttachmentInfo(obj.pDepthAttachment, "pDepthAttachment", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pStencilAttachment\": " << std::endl;
    if (obj.pStencilAttachment) {
        print_VkRenderingAttachmentInfo(obj.pStencilAttachment, "pStencilAttachment", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderingInfo(const VkRenderingInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRenderingFlags(obj->flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"renderArea\": " << std::endl;
    { print_VkRect2D(obj->renderArea, "renderArea", 1); }

    print_uint32_t(obj->layerCount, "layerCount", 1);

    print_uint32_t(obj->viewMask, "viewMask", 1);

    print_uint32_t(obj->colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachments\": " << std::endl;
    if (obj->pColorAttachments) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->colorAttachmentCount; i++) {
            if (i + 1 == obj->colorAttachmentCount)
                print_VkRenderingAttachmentInfo(obj->pColorAttachments[i], "pColorAttachments", 0);
            else
                print_VkRenderingAttachmentInfo(obj->pColorAttachments[i], "pColorAttachments", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pDepthAttachment\": " << std::endl;
    if (obj->pDepthAttachment) {
        print_VkRenderingAttachmentInfo(obj->pDepthAttachment, "pDepthAttachment", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pStencilAttachment\": " << std::endl;
    if (obj->pStencilAttachment) {
        print_VkRenderingAttachmentInfo(obj->pStencilAttachment, "pStencilAttachment", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkRenderingInfo VkRenderingInfoKHR;

typedef VkRenderingAttachmentInfo VkRenderingAttachmentInfoKHR;

static void print_VkPipelineRenderingCreateInfo(VkPipelineRenderingCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.viewMask, "viewMask", 1);

    print_uint32_t(obj.colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachmentFormats\":" << std::endl;
    PRINT_SPACE
    if (obj.pColorAttachmentFormats) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.colorAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.colorAttachmentCount;
            print_VkFormat(obj.pColorAttachmentFormats[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj.depthAttachmentFormat, "depthAttachmentFormat", 1);

    print_VkFormat(obj.stencilAttachmentFormat, "stencilAttachmentFormat", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineRenderingCreateInfo(const VkPipelineRenderingCreateInfo* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->viewMask, "viewMask", 1);

    print_uint32_t(obj->colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachmentFormats\":" << std::endl;
    PRINT_SPACE
    if (obj->pColorAttachmentFormats) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->colorAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->colorAttachmentCount;
            print_VkFormat(obj->pColorAttachmentFormats[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj->depthAttachmentFormat, "depthAttachmentFormat", 1);

    print_VkFormat(obj->stencilAttachmentFormat, "stencilAttachmentFormat", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPipelineRenderingCreateInfo VkPipelineRenderingCreateInfoKHR;

static void print_VkPhysicalDeviceDynamicRenderingFeatures(VkPhysicalDeviceDynamicRenderingFeatures obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.dynamicRendering, "dynamicRendering", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDynamicRenderingFeatures(const VkPhysicalDeviceDynamicRenderingFeatures* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->dynamicRendering, "dynamicRendering", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceDynamicRenderingFeatures VkPhysicalDeviceDynamicRenderingFeaturesKHR;

static void print_VkCommandBufferInheritanceRenderingInfo(VkCommandBufferInheritanceRenderingInfo obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRenderingFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.viewMask, "viewMask", 1);

    print_uint32_t(obj.colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachmentFormats\":" << std::endl;
    PRINT_SPACE
    if (obj.pColorAttachmentFormats) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.colorAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.colorAttachmentCount;
            print_VkFormat(obj.pColorAttachmentFormats[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj.depthAttachmentFormat, "depthAttachmentFormat", 1);

    print_VkFormat(obj.stencilAttachmentFormat, "stencilAttachmentFormat", 1);

    print_VkSampleCountFlagBits(obj.rasterizationSamples, "rasterizationSamples", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCommandBufferInheritanceRenderingInfo(const VkCommandBufferInheritanceRenderingInfo* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRenderingFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->viewMask, "viewMask", 1);

    print_uint32_t(obj->colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachmentFormats\":" << std::endl;
    PRINT_SPACE
    if (obj->pColorAttachmentFormats) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->colorAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->colorAttachmentCount;
            print_VkFormat(obj->pColorAttachmentFormats[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj->depthAttachmentFormat, "depthAttachmentFormat", 1);

    print_VkFormat(obj->stencilAttachmentFormat, "stencilAttachmentFormat", 1);

    print_VkSampleCountFlagBits(obj->rasterizationSamples, "rasterizationSamples", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkCommandBufferInheritanceRenderingInfo VkCommandBufferInheritanceRenderingInfoKHR;

typedef VkRenderPassMultiviewCreateInfo VkRenderPassMultiviewCreateInfoKHR;

typedef VkPhysicalDeviceMultiviewFeatures VkPhysicalDeviceMultiviewFeaturesKHR;

typedef VkPhysicalDeviceMultiviewProperties VkPhysicalDeviceMultiviewPropertiesKHR;

typedef VkPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2KHR;

typedef VkPhysicalDeviceProperties2 VkPhysicalDeviceProperties2KHR;

typedef VkFormatProperties2 VkFormatProperties2KHR;

typedef VkImageFormatProperties2 VkImageFormatProperties2KHR;

typedef VkPhysicalDeviceImageFormatInfo2 VkPhysicalDeviceImageFormatInfo2KHR;

typedef VkQueueFamilyProperties2 VkQueueFamilyProperties2KHR;

typedef VkPhysicalDeviceMemoryProperties2 VkPhysicalDeviceMemoryProperties2KHR;

typedef VkSparseImageFormatProperties2 VkSparseImageFormatProperties2KHR;

typedef VkPhysicalDeviceSparseImageFormatInfo2 VkPhysicalDeviceSparseImageFormatInfo2KHR;

static std::map<uint64_t, std::string> VkPeerMemoryFeatureFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT"),
    std::make_pair(1ULL << 1, "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT"),
    std::make_pair(1ULL << 2, "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT"),
    std::make_pair(1ULL << 3, "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT"),
};
static void print_VkPeerMemoryFeatureFlagBitsKHR(VkPeerMemoryFeatureFlagBitsKHR obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPeerMemoryFeatureFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPeerMemoryFeatureFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkPeerMemoryFeatureFlagBitsKHR(const VkPeerMemoryFeatureFlagBitsKHR* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPeerMemoryFeatureFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPeerMemoryFeatureFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkMemoryAllocateFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT"),
    std::make_pair(1ULL << 1, "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT"),
    std::make_pair(1ULL << 2, "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"),
};
static void print_VkMemoryAllocateFlagBitsKHR(VkMemoryAllocateFlagBitsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryAllocateFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryAllocateFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkMemoryAllocateFlagBitsKHR(const VkMemoryAllocateFlagBitsKHR* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryAllocateFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryAllocateFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

typedef VkMemoryAllocateFlagsInfo VkMemoryAllocateFlagsInfoKHR;

typedef VkDeviceGroupRenderPassBeginInfo VkDeviceGroupRenderPassBeginInfoKHR;

typedef VkDeviceGroupCommandBufferBeginInfo VkDeviceGroupCommandBufferBeginInfoKHR;

typedef VkDeviceGroupSubmitInfo VkDeviceGroupSubmitInfoKHR;

typedef VkDeviceGroupBindSparseInfo VkDeviceGroupBindSparseInfoKHR;

typedef VkBindBufferMemoryDeviceGroupInfo VkBindBufferMemoryDeviceGroupInfoKHR;

typedef VkBindImageMemoryDeviceGroupInfo VkBindImageMemoryDeviceGroupInfoKHR;

typedef VkPhysicalDeviceGroupProperties VkPhysicalDeviceGroupPropertiesKHR;

typedef VkDeviceGroupDeviceCreateInfo VkDeviceGroupDeviceCreateInfoKHR;

static std::map<uint64_t, std::string> VkExternalMemoryHandleTypeFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT"),
    std::make_pair(1ULL << 2, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"),
    std::make_pair(1ULL << 3, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT"),
    std::make_pair(1ULL << 4, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT"),
    std::make_pair(1ULL << 5, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT"),
    std::make_pair(1ULL << 6, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT"),
    std::make_pair(1ULL << 9, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT"),
    std::make_pair(1ULL << 10, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID"),
    std::make_pair(1ULL << 7, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT"),
    std::make_pair(1ULL << 8, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT"),
    std::make_pair(1ULL << 11, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA"),
    std::make_pair(1ULL << 12, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV"),
    std::make_pair(1ULL << 13, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV"),
    std::make_pair(1ULL << 14, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX"),
    std::make_pair(1ULL << 15, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_590_BIT_HUAWEI"),
    std::make_pair(1ULL << 16, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT"),
    std::make_pair(1ULL << 17, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT"),
    std::make_pair(1ULL << 18, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT"),
};
static void print_VkExternalMemoryHandleTypeFlagBitsKHR(VkExternalMemoryHandleTypeFlagBitsKHR obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalMemoryHandleTypeFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalMemoryHandleTypeFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkExternalMemoryHandleTypeFlagBitsKHR(const VkExternalMemoryHandleTypeFlagBitsKHR* obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalMemoryHandleTypeFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalMemoryHandleTypeFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkExternalMemoryFeatureFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT"),
    std::make_pair(1ULL << 2, "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT"),
};
static void print_VkExternalMemoryFeatureFlagBitsKHR(VkExternalMemoryFeatureFlagBitsKHR obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalMemoryFeatureFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalMemoryFeatureFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkExternalMemoryFeatureFlagBitsKHR(const VkExternalMemoryFeatureFlagBitsKHR* obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalMemoryFeatureFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalMemoryFeatureFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

typedef VkExternalMemoryProperties VkExternalMemoryPropertiesKHR;

typedef VkPhysicalDeviceExternalImageFormatInfo VkPhysicalDeviceExternalImageFormatInfoKHR;

typedef VkExternalImageFormatProperties VkExternalImageFormatPropertiesKHR;

typedef VkPhysicalDeviceExternalBufferInfo VkPhysicalDeviceExternalBufferInfoKHR;

typedef VkExternalBufferProperties VkExternalBufferPropertiesKHR;

typedef VkPhysicalDeviceIDProperties VkPhysicalDeviceIDPropertiesKHR;

typedef VkExternalMemoryImageCreateInfo VkExternalMemoryImageCreateInfoKHR;

typedef VkExternalMemoryBufferCreateInfo VkExternalMemoryBufferCreateInfoKHR;

typedef VkExportMemoryAllocateInfo VkExportMemoryAllocateInfoKHR;

static void print_VkImportMemoryFdInfoKHR(VkImportMemoryFdInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlagBits(obj.handleType, "handleType", 1);

    print_int(obj.fd, "fd", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImportMemoryFdInfoKHR(const VkImportMemoryFdInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlagBits(obj->handleType, "handleType", 1);

    print_int(obj->fd, "fd", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryFdPropertiesKHR(VkMemoryFdPropertiesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.memoryTypeBits, "memoryTypeBits", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryFdPropertiesKHR(const VkMemoryFdPropertiesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->memoryTypeBits, "memoryTypeBits", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryGetFdInfoKHR(VkMemoryGetFdInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkExternalMemoryHandleTypeFlagBits(obj.handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryGetFdInfoKHR(const VkMemoryGetFdInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkExternalMemoryHandleTypeFlagBits(obj->handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkExternalSemaphoreHandleTypeFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT"),
    std::make_pair(1ULL << 2, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"),
    std::make_pair(1ULL << 3, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"),
    std::make_pair(1ULL << 4, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT"),
    std::make_pair(1ULL << 7, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA"),
    std::make_pair(1ULL << 5, "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"),
};
static void print_VkExternalSemaphoreHandleTypeFlagBitsKHR(VkExternalSemaphoreHandleTypeFlagBitsKHR obj, const std::string& str,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalSemaphoreHandleTypeFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalSemaphoreHandleTypeFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkExternalSemaphoreHandleTypeFlagBitsKHR(const VkExternalSemaphoreHandleTypeFlagBitsKHR* obj,
                                                           const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalSemaphoreHandleTypeFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalSemaphoreHandleTypeFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkExternalSemaphoreFeatureFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT"),
};
static void print_VkExternalSemaphoreFeatureFlagBitsKHR(VkExternalSemaphoreFeatureFlagBitsKHR obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalSemaphoreFeatureFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalSemaphoreFeatureFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkExternalSemaphoreFeatureFlagBitsKHR(const VkExternalSemaphoreFeatureFlagBitsKHR* obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalSemaphoreFeatureFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalSemaphoreFeatureFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

typedef VkPhysicalDeviceExternalSemaphoreInfo VkPhysicalDeviceExternalSemaphoreInfoKHR;

typedef VkExternalSemaphoreProperties VkExternalSemaphorePropertiesKHR;

static std::map<uint64_t, std::string> VkSemaphoreImportFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT"),
};
static void print_VkSemaphoreImportFlagBitsKHR(VkSemaphoreImportFlagBitsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSemaphoreImportFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSemaphoreImportFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkSemaphoreImportFlagBitsKHR(const VkSemaphoreImportFlagBitsKHR* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSemaphoreImportFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSemaphoreImportFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

typedef VkExportSemaphoreCreateInfo VkExportSemaphoreCreateInfoKHR;

static void print_VkImportSemaphoreFdInfoKHR(VkImportSemaphoreFdInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "semaphore"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkSemaphoreImportFlags(obj.flags, "flags", 1);

    print_VkExternalSemaphoreHandleTypeFlagBits(obj.handleType, "handleType", 1);

    print_int(obj.fd, "fd", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImportSemaphoreFdInfoKHR(const VkImportSemaphoreFdInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "semaphore"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkSemaphoreImportFlags(obj->flags, "flags", 1);

    print_VkExternalSemaphoreHandleTypeFlagBits(obj->handleType, "handleType", 1);

    print_int(obj->fd, "fd", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSemaphoreGetFdInfoKHR(VkSemaphoreGetFdInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "semaphore"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkExternalSemaphoreHandleTypeFlagBits(obj.handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSemaphoreGetFdInfoKHR(const VkSemaphoreGetFdInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "semaphore"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkExternalSemaphoreHandleTypeFlagBits(obj->handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePushDescriptorProperties(VkPhysicalDevicePushDescriptorProperties obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxPushDescriptors, "maxPushDescriptors", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePushDescriptorProperties(const VkPhysicalDevicePushDescriptorProperties* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxPushDescriptors, "maxPushDescriptors", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDevicePushDescriptorProperties VkPhysicalDevicePushDescriptorPropertiesKHR;

typedef VkPhysicalDeviceShaderFloat16Int8Features VkPhysicalDeviceShaderFloat16Int8FeaturesKHR;

typedef VkPhysicalDeviceShaderFloat16Int8Features VkPhysicalDeviceFloat16Int8FeaturesKHR;

typedef VkPhysicalDevice16BitStorageFeatures VkPhysicalDevice16BitStorageFeaturesKHR;

static void print_VkRectLayerKHR(VkRectLayerKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"offset\": " << std::endl;
    { print_VkOffset2D(obj.offset, "offset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent2D(obj.extent, "extent", 1); }

    print_uint32_t(obj.layer, "layer", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRectLayerKHR(const VkRectLayerKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"offset\": " << std::endl;
    { print_VkOffset2D(obj->offset, "offset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent2D(obj->extent, "extent", 1); }

    print_uint32_t(obj->layer, "layer", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPresentRegionKHR(VkPresentRegionKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.rectangleCount, "rectangleCount", 1);

    PRINT_SPACE
    _OUT << "\"pRectangles\": " << std::endl;
    if (obj.pRectangles) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.rectangleCount; i++) {
            if (i + 1 == obj.rectangleCount)
                print_VkRectLayerKHR(obj.pRectangles[i], "pRectangles", 0);
            else
                print_VkRectLayerKHR(obj.pRectangles[i], "pRectangles", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPresentRegionKHR(const VkPresentRegionKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->rectangleCount, "rectangleCount", 1);

    PRINT_SPACE
    _OUT << "\"pRectangles\": " << std::endl;
    if (obj->pRectangles) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->rectangleCount; i++) {
            if (i + 1 == obj->rectangleCount)
                print_VkRectLayerKHR(obj->pRectangles[i], "pRectangles", 0);
            else
                print_VkRectLayerKHR(obj->pRectangles[i], "pRectangles", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPresentRegionsKHR(VkPresentRegionsKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj.pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.swapchainCount; i++) {
            if (i + 1 == obj.swapchainCount)
                print_VkPresentRegionKHR(obj.pRegions[i], "pRegions", 0);
            else
                print_VkPresentRegionKHR(obj.pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPresentRegionsKHR(const VkPresentRegionsKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj->pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->swapchainCount; i++) {
            if (i + 1 == obj->swapchainCount)
                print_VkPresentRegionKHR(obj->pRegions[i], "pRegions", 0);
            else
                print_VkPresentRegionKHR(obj->pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkDescriptorUpdateTemplateTypeKHR_map = {
    std::make_pair(0, "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"),
    std::make_pair(1, "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS"),
};
static void print_VkDescriptorUpdateTemplateTypeKHR(VkDescriptorUpdateTemplateTypeKHR obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorUpdateTemplateTypeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorUpdateTemplateTypeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkDescriptorUpdateTemplateTypeKHR(const VkDescriptorUpdateTemplateTypeKHR* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorUpdateTemplateTypeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorUpdateTemplateTypeKHR_map[*obj] << "\"" << std::endl;
}

typedef VkDescriptorUpdateTemplateEntry VkDescriptorUpdateTemplateEntryKHR;

typedef VkDescriptorUpdateTemplateCreateInfo VkDescriptorUpdateTemplateCreateInfoKHR;

typedef VkPhysicalDeviceImagelessFramebufferFeatures VkPhysicalDeviceImagelessFramebufferFeaturesKHR;

typedef VkFramebufferAttachmentsCreateInfo VkFramebufferAttachmentsCreateInfoKHR;

typedef VkFramebufferAttachmentImageInfo VkFramebufferAttachmentImageInfoKHR;

typedef VkRenderPassAttachmentBeginInfo VkRenderPassAttachmentBeginInfoKHR;

typedef VkRenderPassCreateInfo2 VkRenderPassCreateInfo2KHR;

typedef VkAttachmentDescription2 VkAttachmentDescription2KHR;

typedef VkAttachmentReference2 VkAttachmentReference2KHR;

typedef VkSubpassDescription2 VkSubpassDescription2KHR;

typedef VkSubpassDependency2 VkSubpassDependency2KHR;

typedef VkSubpassBeginInfo VkSubpassBeginInfoKHR;

typedef VkSubpassEndInfo VkSubpassEndInfoKHR;

static void print_VkSharedPresentSurfaceCapabilitiesKHR(VkSharedPresentSurfaceCapabilitiesKHR obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageUsageFlags(obj.sharedPresentSupportedUsageFlags, "sharedPresentSupportedUsageFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSharedPresentSurfaceCapabilitiesKHR(const VkSharedPresentSurfaceCapabilitiesKHR* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageUsageFlags(obj->sharedPresentSupportedUsageFlags, "sharedPresentSupportedUsageFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkExternalFenceHandleTypeFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT"),
    std::make_pair(1ULL << 2, "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"),
    std::make_pair(1ULL << 3, "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT"),
    std::make_pair(1ULL << 4, "VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"),
    std::make_pair(1ULL << 5, "VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV"),
    std::make_pair(1ULL << 4, "VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"),
    std::make_pair(1ULL << 5, "VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV"),
};
static void print_VkExternalFenceHandleTypeFlagBitsKHR(VkExternalFenceHandleTypeFlagBitsKHR obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalFenceHandleTypeFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalFenceHandleTypeFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkExternalFenceHandleTypeFlagBitsKHR(const VkExternalFenceHandleTypeFlagBitsKHR* obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalFenceHandleTypeFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalFenceHandleTypeFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkExternalFenceFeatureFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT"),
};
static void print_VkExternalFenceFeatureFlagBitsKHR(VkExternalFenceFeatureFlagBitsKHR obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalFenceFeatureFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalFenceFeatureFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkExternalFenceFeatureFlagBitsKHR(const VkExternalFenceFeatureFlagBitsKHR* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalFenceFeatureFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalFenceFeatureFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

typedef VkPhysicalDeviceExternalFenceInfo VkPhysicalDeviceExternalFenceInfoKHR;

typedef VkExternalFenceProperties VkExternalFencePropertiesKHR;

static std::map<uint64_t, std::string> VkFenceImportFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_FENCE_IMPORT_TEMPORARY_BIT"),
};
static void print_VkFenceImportFlagBitsKHR(VkFenceImportFlagBitsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFenceImportFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFenceImportFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkFenceImportFlagBitsKHR(const VkFenceImportFlagBitsKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFenceImportFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFenceImportFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

typedef VkExportFenceCreateInfo VkExportFenceCreateInfoKHR;

static void print_VkImportFenceFdInfoKHR(VkImportFenceFdInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "fence"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkFenceImportFlags(obj.flags, "flags", 1);

    print_VkExternalFenceHandleTypeFlagBits(obj.handleType, "handleType", 1);

    print_int(obj.fd, "fd", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImportFenceFdInfoKHR(const VkImportFenceFdInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "fence"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkFenceImportFlags(obj->flags, "flags", 1);

    print_VkExternalFenceHandleTypeFlagBits(obj->handleType, "handleType", 1);

    print_int(obj->fd, "fd", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkFenceGetFdInfoKHR(VkFenceGetFdInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "fence"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkExternalFenceHandleTypeFlagBits(obj.handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkFenceGetFdInfoKHR(const VkFenceGetFdInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "fence"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkExternalFenceHandleTypeFlagBits(obj->handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkPerformanceCounterUnitKHR_map = {
    std::make_pair(0, "VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR"),
    std::make_pair(1, "VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR"),
    std::make_pair(2, "VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR"),
    std::make_pair(3, "VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR"),
    std::make_pair(4, "VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR"),
    std::make_pair(5, "VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR"),
    std::make_pair(6, "VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR"),
    std::make_pair(7, "VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR"),
    std::make_pair(8, "VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR"),
    std::make_pair(9, "VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR"),
    std::make_pair(10, "VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR"),
};
static void print_VkPerformanceCounterUnitKHR(VkPerformanceCounterUnitKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceCounterUnitKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceCounterUnitKHR_map[obj] << "\"" << std::endl;
}
static void print_VkPerformanceCounterUnitKHR(const VkPerformanceCounterUnitKHR* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceCounterUnitKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceCounterUnitKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPerformanceCounterScopeKHR_map = {
    std::make_pair(0, "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR"),
    std::make_pair(1, "VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR"),
    std::make_pair(2, "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR"),
};
static void print_VkPerformanceCounterScopeKHR(VkPerformanceCounterScopeKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceCounterScopeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceCounterScopeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkPerformanceCounterScopeKHR(const VkPerformanceCounterScopeKHR* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceCounterScopeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceCounterScopeKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPerformanceCounterStorageKHR_map = {
    std::make_pair(0, "VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR"),
    std::make_pair(1, "VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR"),
    std::make_pair(2, "VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR"),
    std::make_pair(3, "VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR"),
    std::make_pair(4, "VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR"),
    std::make_pair(5, "VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR"),
};
static void print_VkPerformanceCounterStorageKHR(VkPerformanceCounterStorageKHR obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceCounterStorageKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceCounterStorageKHR_map[obj] << "\"" << std::endl;
}
static void print_VkPerformanceCounterStorageKHR(const VkPerformanceCounterStorageKHR* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceCounterStorageKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceCounterStorageKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPerformanceCounterDescriptionFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR"),
};
static void print_VkPerformanceCounterDescriptionFlagBitsKHR(VkPerformanceCounterDescriptionFlagBitsKHR obj, const std::string& str,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceCounterDescriptionFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceCounterDescriptionFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkPerformanceCounterDescriptionFlagBitsKHR(const VkPerformanceCounterDescriptionFlagBitsKHR* obj,
                                                             const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceCounterDescriptionFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceCounterDescriptionFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAcquireProfilingLockFlagBitsKHR_map = {};
static void print_VkAcquireProfilingLockFlagBitsKHR(VkAcquireProfilingLockFlagBitsKHR obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAcquireProfilingLockFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAcquireProfilingLockFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkAcquireProfilingLockFlagBitsKHR(const VkAcquireProfilingLockFlagBitsKHR* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAcquireProfilingLockFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAcquireProfilingLockFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkPerformanceCounterDescriptionFlagsKHR(VkPerformanceCounterDescriptionFlagsKHR obj, const std::string& str,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPerformanceCounterDescriptionFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkPerformanceCounterDescriptionFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkAcquireProfilingLockFlagsKHR(VkAcquireProfilingLockFlagsKHR obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkAcquireProfilingLockFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkAcquireProfilingLockFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDevicePerformanceQueryFeaturesKHR(VkPhysicalDevicePerformanceQueryFeaturesKHR obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.performanceCounterQueryPools, "performanceCounterQueryPools", 1);

    print_VkBool32(obj.performanceCounterMultipleQueryPools, "performanceCounterMultipleQueryPools", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePerformanceQueryFeaturesKHR(const VkPhysicalDevicePerformanceQueryFeaturesKHR* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->performanceCounterQueryPools, "performanceCounterQueryPools", 1);

    print_VkBool32(obj->performanceCounterMultipleQueryPools, "performanceCounterMultipleQueryPools", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePerformanceQueryPropertiesKHR(VkPhysicalDevicePerformanceQueryPropertiesKHR obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.allowCommandBufferQueryCopies, "allowCommandBufferQueryCopies", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePerformanceQueryPropertiesKHR(const VkPhysicalDevicePerformanceQueryPropertiesKHR* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->allowCommandBufferQueryCopies, "allowCommandBufferQueryCopies", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPerformanceCounterKHR(VkPerformanceCounterKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPerformanceCounterUnitKHR(obj.unit, "unit", 1);

    print_VkPerformanceCounterScopeKHR(obj.scope, "scope", 1);

    print_VkPerformanceCounterStorageKHR(obj.storage, "storage", 1);

    PRINT_SPACE
    _OUT << "\"uuid\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj.uuid[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPerformanceCounterKHR(const VkPerformanceCounterKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPerformanceCounterUnitKHR(obj->unit, "unit", 1);

    print_VkPerformanceCounterScopeKHR(obj->scope, "scope", 1);

    print_VkPerformanceCounterStorageKHR(obj->storage, "storage", 1);

    PRINT_SPACE
    _OUT << "\"uuid\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj->uuid[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPerformanceCounterDescriptionKHR(VkPerformanceCounterDescriptionKHR obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPerformanceCounterDescriptionFlagsKHR(obj.flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"name\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.name[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"category\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.category[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPerformanceCounterDescriptionKHR(const VkPerformanceCounterDescriptionKHR* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPerformanceCounterDescriptionFlagsKHR(obj->flags, "flags", 1);

    PRINT_SPACE
    _OUT << "\"name\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->name[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"category\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->category[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkQueryPoolPerformanceCreateInfoKHR(VkQueryPoolPerformanceCreateInfoKHR obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.queueFamilyIndex, "queueFamilyIndex", 1);

    print_uint32_t(obj.counterIndexCount, "counterIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pCounterIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pCounterIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.counterIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.counterIndexCount;
            print_uint32_t(obj.pCounterIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkQueryPoolPerformanceCreateInfoKHR(const VkQueryPoolPerformanceCreateInfoKHR* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->queueFamilyIndex, "queueFamilyIndex", 1);

    print_uint32_t(obj->counterIndexCount, "counterIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pCounterIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pCounterIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->counterIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->counterIndexCount;
            print_uint32_t(obj->pCounterIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPerformanceCounterResultKHR(VkPerformanceCounterResultKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_int32_t(obj.int32, "int32", 1);

    print_int64_t(obj.int64, "int64", 1);

    print_uint32_t(obj.uint32, "uint32", 1);

    print_uint64_t(obj.uint64, "uint64", 1);

    print_float(obj.float32, "float32", 1);

    print_double(obj.float64, "float64", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPerformanceCounterResultKHR(const VkPerformanceCounterResultKHR* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_int32_t(obj->int32, "int32", 1);

    print_int64_t(obj->int64, "int64", 1);

    print_uint32_t(obj->uint32, "uint32", 1);

    print_uint64_t(obj->uint64, "uint64", 1);

    print_float(obj->float32, "float32", 1);

    print_double(obj->float64, "float64", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAcquireProfilingLockInfoKHR(VkAcquireProfilingLockInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAcquireProfilingLockFlagsKHR(obj.flags, "flags", 1);

    print_uint64_t(obj.timeout, "timeout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAcquireProfilingLockInfoKHR(const VkAcquireProfilingLockInfoKHR* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAcquireProfilingLockFlagsKHR(obj->flags, "flags", 1);

    print_uint64_t(obj->timeout, "timeout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPerformanceQuerySubmitInfoKHR(VkPerformanceQuerySubmitInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.counterPassIndex, "counterPassIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPerformanceQuerySubmitInfoKHR(const VkPerformanceQuerySubmitInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->counterPassIndex, "counterPassIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkPointClippingBehaviorKHR_map = {
    std::make_pair(0, "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES"),
    std::make_pair(1, "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY"),
};
static void print_VkPointClippingBehaviorKHR(VkPointClippingBehaviorKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPointClippingBehaviorKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPointClippingBehaviorKHR_map[obj] << "\"" << std::endl;
}
static void print_VkPointClippingBehaviorKHR(const VkPointClippingBehaviorKHR* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPointClippingBehaviorKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPointClippingBehaviorKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkTessellationDomainOriginKHR_map = {
    std::make_pair(0, "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT"),
    std::make_pair(1, "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT"),
};
static void print_VkTessellationDomainOriginKHR(VkTessellationDomainOriginKHR obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkTessellationDomainOriginKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkTessellationDomainOriginKHR_map[obj] << "\"" << std::endl;
}
static void print_VkTessellationDomainOriginKHR(const VkTessellationDomainOriginKHR* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkTessellationDomainOriginKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkTessellationDomainOriginKHR_map[*obj] << "\"" << std::endl;
}

typedef VkPhysicalDevicePointClippingProperties VkPhysicalDevicePointClippingPropertiesKHR;

typedef VkRenderPassInputAttachmentAspectCreateInfo VkRenderPassInputAttachmentAspectCreateInfoKHR;

typedef VkInputAttachmentAspectReference VkInputAttachmentAspectReferenceKHR;

typedef VkImageViewUsageCreateInfo VkImageViewUsageCreateInfoKHR;

typedef VkPipelineTessellationDomainOriginStateCreateInfo VkPipelineTessellationDomainOriginStateCreateInfoKHR;

static void print_VkPhysicalDeviceSurfaceInfo2KHR(VkPhysicalDeviceSurfaceInfo2KHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "surface"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSurfaceInfo2KHR(const VkPhysicalDeviceSurfaceInfo2KHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "surface"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSurfaceCapabilities2KHR(VkSurfaceCapabilities2KHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"surfaceCapabilities\": " << std::endl;
    { print_VkSurfaceCapabilitiesKHR(obj.surfaceCapabilities, "surfaceCapabilities", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSurfaceCapabilities2KHR(const VkSurfaceCapabilities2KHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"surfaceCapabilities\": " << std::endl;
    { print_VkSurfaceCapabilitiesKHR(obj->surfaceCapabilities, "surfaceCapabilities", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSurfaceFormat2KHR(VkSurfaceFormat2KHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"surfaceFormat\": " << std::endl;
    { print_VkSurfaceFormatKHR(obj.surfaceFormat, "surfaceFormat", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSurfaceFormat2KHR(const VkSurfaceFormat2KHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"surfaceFormat\": " << std::endl;
    { print_VkSurfaceFormatKHR(obj->surfaceFormat, "surfaceFormat", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceVariablePointersFeatures VkPhysicalDeviceVariablePointerFeaturesKHR;

typedef VkPhysicalDeviceVariablePointersFeatures VkPhysicalDeviceVariablePointersFeaturesKHR;

static void print_VkDisplayProperties2KHR(VkDisplayProperties2KHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"displayProperties\": " << std::endl;
    { print_VkDisplayPropertiesKHR(obj.displayProperties, "displayProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayProperties2KHR(const VkDisplayProperties2KHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"displayProperties\": " << std::endl;
    { print_VkDisplayPropertiesKHR(obj->displayProperties, "displayProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayPlaneProperties2KHR(VkDisplayPlaneProperties2KHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"displayPlaneProperties\": " << std::endl;
    { print_VkDisplayPlanePropertiesKHR(obj.displayPlaneProperties, "displayPlaneProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayPlaneProperties2KHR(const VkDisplayPlaneProperties2KHR* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"displayPlaneProperties\": " << std::endl;
    { print_VkDisplayPlanePropertiesKHR(obj->displayPlaneProperties, "displayPlaneProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayModeProperties2KHR(VkDisplayModeProperties2KHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"displayModeProperties\": " << std::endl;
    { print_VkDisplayModePropertiesKHR(obj.displayModeProperties, "displayModeProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayModeProperties2KHR(const VkDisplayModeProperties2KHR* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"displayModeProperties\": " << std::endl;
    { print_VkDisplayModePropertiesKHR(obj->displayModeProperties, "displayModeProperties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayPlaneInfo2KHR(VkDisplayPlaneInfo2KHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "mode"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.planeIndex, "planeIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayPlaneInfo2KHR(const VkDisplayPlaneInfo2KHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "mode"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->planeIndex, "planeIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayPlaneCapabilities2KHR(VkDisplayPlaneCapabilities2KHR obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"capabilities\": " << std::endl;
    { print_VkDisplayPlaneCapabilitiesKHR(obj.capabilities, "capabilities", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayPlaneCapabilities2KHR(const VkDisplayPlaneCapabilities2KHR* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"capabilities\": " << std::endl;
    { print_VkDisplayPlaneCapabilitiesKHR(obj->capabilities, "capabilities", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkMemoryDedicatedRequirements VkMemoryDedicatedRequirementsKHR;

typedef VkMemoryDedicatedAllocateInfo VkMemoryDedicatedAllocateInfoKHR;

typedef VkBufferMemoryRequirementsInfo2 VkBufferMemoryRequirementsInfo2KHR;

typedef VkImageMemoryRequirementsInfo2 VkImageMemoryRequirementsInfo2KHR;

typedef VkImageSparseMemoryRequirementsInfo2 VkImageSparseMemoryRequirementsInfo2KHR;

typedef VkMemoryRequirements2 VkMemoryRequirements2KHR;

typedef VkSparseImageMemoryRequirements2 VkSparseImageMemoryRequirements2KHR;

typedef VkImageFormatListCreateInfo VkImageFormatListCreateInfoKHR;

static std::map<uint64_t, std::string> VkSamplerYcbcrModelConversionKHR_map = {
    std::make_pair(0, "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY"),
    std::make_pair(1, "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY"),
    std::make_pair(2, "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709"),
    std::make_pair(3, "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601"),
    std::make_pair(4, "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020"),
};
static void print_VkSamplerYcbcrModelConversionKHR(VkSamplerYcbcrModelConversionKHR obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerYcbcrModelConversionKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerYcbcrModelConversionKHR_map[obj] << "\"" << std::endl;
}
static void print_VkSamplerYcbcrModelConversionKHR(const VkSamplerYcbcrModelConversionKHR* obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerYcbcrModelConversionKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerYcbcrModelConversionKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSamplerYcbcrRangeKHR_map = {
    std::make_pair(0, "VK_SAMPLER_YCBCR_RANGE_ITU_FULL"),
    std::make_pair(1, "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW"),
};
static void print_VkSamplerYcbcrRangeKHR(VkSamplerYcbcrRangeKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerYcbcrRangeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerYcbcrRangeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkSamplerYcbcrRangeKHR(const VkSamplerYcbcrRangeKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerYcbcrRangeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerYcbcrRangeKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkChromaLocationKHR_map = {
    std::make_pair(0, "VK_CHROMA_LOCATION_COSITED_EVEN"),
    std::make_pair(1, "VK_CHROMA_LOCATION_MIDPOINT"),
};
static void print_VkChromaLocationKHR(VkChromaLocationKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkChromaLocationKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkChromaLocationKHR_map[obj] << "\"" << std::endl;
}
static void print_VkChromaLocationKHR(const VkChromaLocationKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkChromaLocationKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkChromaLocationKHR_map[*obj] << "\"" << std::endl;
}

typedef VkSamplerYcbcrConversionCreateInfo VkSamplerYcbcrConversionCreateInfoKHR;

typedef VkSamplerYcbcrConversionInfo VkSamplerYcbcrConversionInfoKHR;

typedef VkBindImagePlaneMemoryInfo VkBindImagePlaneMemoryInfoKHR;

typedef VkImagePlaneMemoryRequirementsInfo VkImagePlaneMemoryRequirementsInfoKHR;

typedef VkPhysicalDeviceSamplerYcbcrConversionFeatures VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR;

typedef VkSamplerYcbcrConversionImageFormatProperties VkSamplerYcbcrConversionImageFormatPropertiesKHR;

typedef VkBindBufferMemoryInfo VkBindBufferMemoryInfoKHR;

typedef VkBindImageMemoryInfo VkBindImageMemoryInfoKHR;

typedef VkPhysicalDeviceMaintenance3Properties VkPhysicalDeviceMaintenance3PropertiesKHR;

typedef VkDescriptorSetLayoutSupport VkDescriptorSetLayoutSupportKHR;

typedef VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR;

typedef VkPhysicalDevice8BitStorageFeatures VkPhysicalDevice8BitStorageFeaturesKHR;

typedef VkPhysicalDeviceShaderAtomicInt64Features VkPhysicalDeviceShaderAtomicInt64FeaturesKHR;

static void print_VkPhysicalDeviceShaderClockFeaturesKHR(VkPhysicalDeviceShaderClockFeaturesKHR obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderSubgroupClock, "shaderSubgroupClock", 1);

    print_VkBool32(obj.shaderDeviceClock, "shaderDeviceClock", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderClockFeaturesKHR(const VkPhysicalDeviceShaderClockFeaturesKHR* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderSubgroupClock, "shaderSubgroupClock", 1);

    print_VkBool32(obj->shaderDeviceClock, "shaderDeviceClock", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeH265ProfileInfoKHR(VkVideoDecodeH265ProfileInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH265ProfileIdc(obj.stdProfileIdc, "stdProfileIdc", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH265ProfileInfoKHR(const VkVideoDecodeH265ProfileInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH265ProfileIdc(obj->stdProfileIdc, "stdProfileIdc", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeH265CapabilitiesKHR(VkVideoDecodeH265CapabilitiesKHR obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH265LevelIdc(obj.maxLevelIdc, "maxLevelIdc", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH265CapabilitiesKHR(const VkVideoDecodeH265CapabilitiesKHR* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH265LevelIdc(obj->maxLevelIdc, "maxLevelIdc", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeH265SessionParametersAddInfoKHR(VkVideoDecodeH265SessionParametersAddInfoKHR obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.stdVPSCount, "stdVPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdVPSs\":" << std::endl;
    PRINT_SPACE
    if (obj.pStdVPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stdVPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.stdVPSCount;
            print_StdVideoH265VideoParameterSet(obj.pStdVPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.stdSPSCount, "stdSPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdSPSs\":" << std::endl;
    PRINT_SPACE
    if (obj.pStdSPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stdSPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.stdSPSCount;
            print_StdVideoH265SequenceParameterSet(obj.pStdSPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.stdPPSCount, "stdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdPPSs\":" << std::endl;
    PRINT_SPACE
    if (obj.pStdPPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stdPPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.stdPPSCount;
            print_StdVideoH265PictureParameterSet(obj.pStdPPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH265SessionParametersAddInfoKHR(const VkVideoDecodeH265SessionParametersAddInfoKHR* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->stdVPSCount, "stdVPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdVPSs\":" << std::endl;
    PRINT_SPACE
    if (obj->pStdVPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stdVPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->stdVPSCount;
            print_StdVideoH265VideoParameterSet(obj->pStdVPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->stdSPSCount, "stdSPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdSPSs\":" << std::endl;
    PRINT_SPACE
    if (obj->pStdSPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stdSPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->stdSPSCount;
            print_StdVideoH265SequenceParameterSet(obj->pStdSPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->stdPPSCount, "stdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdPPSs\":" << std::endl;
    PRINT_SPACE
    if (obj->pStdPPSs) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stdPPSCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->stdPPSCount;
            print_StdVideoH265PictureParameterSet(obj->pStdPPSs[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeH265SessionParametersCreateInfoKHR(VkVideoDecodeH265SessionParametersCreateInfoKHR obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxStdVPSCount, "maxStdVPSCount", 1);

    print_uint32_t(obj.maxStdSPSCount, "maxStdSPSCount", 1);

    print_uint32_t(obj.maxStdPPSCount, "maxStdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pParametersAddInfo\": " << std::endl;
    if (obj.pParametersAddInfo) {
        print_VkVideoDecodeH265SessionParametersAddInfoKHR(obj.pParametersAddInfo, "pParametersAddInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH265SessionParametersCreateInfoKHR(const VkVideoDecodeH265SessionParametersCreateInfoKHR* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxStdVPSCount, "maxStdVPSCount", 1);

    print_uint32_t(obj->maxStdSPSCount, "maxStdSPSCount", 1);

    print_uint32_t(obj->maxStdPPSCount, "maxStdPPSCount", 1);

    PRINT_SPACE
    _OUT << "\"pParametersAddInfo\": " << std::endl;
    if (obj->pParametersAddInfo) {
        print_VkVideoDecodeH265SessionParametersAddInfoKHR(obj->pParametersAddInfo, "pParametersAddInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeH265PictureInfoKHR(VkVideoDecodeH265PictureInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoDecodeH265PictureInfo(obj.pStdPictureInfo, "pStdPictureInfo", 1);

    print_uint32_t(obj.sliceSegmentCount, "sliceSegmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pSliceSegmentOffsets\":" << std::endl;
    PRINT_SPACE
    if (obj.pSliceSegmentOffsets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.sliceSegmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.sliceSegmentCount;
            print_uint32_t(obj.pSliceSegmentOffsets[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH265PictureInfoKHR(const VkVideoDecodeH265PictureInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoDecodeH265PictureInfo(obj->pStdPictureInfo, "pStdPictureInfo", 1);

    print_uint32_t(obj->sliceSegmentCount, "sliceSegmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pSliceSegmentOffsets\":" << std::endl;
    PRINT_SPACE
    if (obj->pSliceSegmentOffsets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->sliceSegmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->sliceSegmentCount;
            print_uint32_t(obj->pSliceSegmentOffsets[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeH265DpbSlotInfoKHR(VkVideoDecodeH265DpbSlotInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoDecodeH265ReferenceInfo(obj.pStdReferenceInfo, "pStdReferenceInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH265DpbSlotInfoKHR(const VkVideoDecodeH265DpbSlotInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoDecodeH265ReferenceInfo(obj->pStdReferenceInfo, "pStdReferenceInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkQueueGlobalPriority_map = {
    std::make_pair(128, "VK_QUEUE_GLOBAL_PRIORITY_LOW"),
    std::make_pair(256, "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM"),
    std::make_pair(512, "VK_QUEUE_GLOBAL_PRIORITY_HIGH"),
    std::make_pair(1024, "VK_QUEUE_GLOBAL_PRIORITY_REALTIME"),
};
static void print_VkQueueGlobalPriority(VkQueueGlobalPriority obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueueGlobalPriority_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueueGlobalPriority_map[obj] << "\"" << std::endl;
}
static void print_VkQueueGlobalPriority(const VkQueueGlobalPriority* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueueGlobalPriority_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueueGlobalPriority_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkQueueGlobalPriorityKHR_map = {
    std::make_pair(128, "VK_QUEUE_GLOBAL_PRIORITY_LOW"),
    std::make_pair(256, "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM"),
    std::make_pair(512, "VK_QUEUE_GLOBAL_PRIORITY_HIGH"),
    std::make_pair(1024, "VK_QUEUE_GLOBAL_PRIORITY_REALTIME"),
};
static void print_VkQueueGlobalPriorityKHR(VkQueueGlobalPriorityKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueueGlobalPriorityKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueueGlobalPriorityKHR_map[obj] << "\"" << std::endl;
}
static void print_VkQueueGlobalPriorityKHR(const VkQueueGlobalPriorityKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueueGlobalPriorityKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueueGlobalPriorityKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkDeviceQueueGlobalPriorityCreateInfo(VkDeviceQueueGlobalPriorityCreateInfo obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkQueueGlobalPriority(obj.globalPriority, "globalPriority", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceQueueGlobalPriorityCreateInfo(const VkDeviceQueueGlobalPriorityCreateInfo* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkQueueGlobalPriority(obj->globalPriority, "globalPriority", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkDeviceQueueGlobalPriorityCreateInfo VkDeviceQueueGlobalPriorityCreateInfoKHR;

static void print_VkPhysicalDeviceGlobalPriorityQueryFeatures(VkPhysicalDeviceGlobalPriorityQueryFeatures obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.globalPriorityQuery, "globalPriorityQuery", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceGlobalPriorityQueryFeatures(const VkPhysicalDeviceGlobalPriorityQueryFeatures* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->globalPriorityQuery, "globalPriorityQuery", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceGlobalPriorityQueryFeatures VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR;

static void print_VkQueueFamilyGlobalPriorityProperties(VkQueueFamilyGlobalPriorityProperties obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.priorityCount, "priorityCount", 1);

    PRINT_SPACE
    _OUT << "\"priorities\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_GLOBAL_PRIORITY_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_GLOBAL_PRIORITY_SIZE;
        print_VkQueueGlobalPriority(obj.priorities[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkQueueFamilyGlobalPriorityProperties(const VkQueueFamilyGlobalPriorityProperties* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->priorityCount, "priorityCount", 1);

    PRINT_SPACE
    _OUT << "\"priorities\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_GLOBAL_PRIORITY_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_GLOBAL_PRIORITY_SIZE;
        print_VkQueueGlobalPriority(obj->priorities[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkQueueFamilyGlobalPriorityProperties VkQueueFamilyGlobalPriorityPropertiesKHR;

static std::map<uint64_t, std::string> VkDriverIdKHR_map = {
    std::make_pair(1, "VK_DRIVER_ID_AMD_PROPRIETARY"),
    std::make_pair(2, "VK_DRIVER_ID_AMD_OPEN_SOURCE"),
    std::make_pair(3, "VK_DRIVER_ID_MESA_RADV"),
    std::make_pair(4, "VK_DRIVER_ID_NVIDIA_PROPRIETARY"),
    std::make_pair(5, "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS"),
    std::make_pair(6, "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA"),
    std::make_pair(7, "VK_DRIVER_ID_IMAGINATION_PROPRIETARY"),
    std::make_pair(8, "VK_DRIVER_ID_QUALCOMM_PROPRIETARY"),
    std::make_pair(9, "VK_DRIVER_ID_ARM_PROPRIETARY"),
    std::make_pair(10, "VK_DRIVER_ID_GOOGLE_SWIFTSHADER"),
    std::make_pair(11, "VK_DRIVER_ID_GGP_PROPRIETARY"),
    std::make_pair(12, "VK_DRIVER_ID_BROADCOM_PROPRIETARY"),
    std::make_pair(13, "VK_DRIVER_ID_MESA_LLVMPIPE"),
    std::make_pair(14, "VK_DRIVER_ID_MOLTENVK"),
    std::make_pair(15, "VK_DRIVER_ID_COREAVI_PROPRIETARY"),
    std::make_pair(16, "VK_DRIVER_ID_JUICE_PROPRIETARY"),
    std::make_pair(17, "VK_DRIVER_ID_VERISILICON_PROPRIETARY"),
    std::make_pair(18, "VK_DRIVER_ID_MESA_TURNIP"),
    std::make_pair(19, "VK_DRIVER_ID_MESA_V3DV"),
    std::make_pair(20, "VK_DRIVER_ID_MESA_PANVK"),
    std::make_pair(21, "VK_DRIVER_ID_SAMSUNG_PROPRIETARY"),
    std::make_pair(22, "VK_DRIVER_ID_MESA_VENUS"),
    std::make_pair(23, "VK_DRIVER_ID_MESA_DOZEN"),
    std::make_pair(24, "VK_DRIVER_ID_MESA_NVK"),
    std::make_pair(25, "VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA"),
    std::make_pair(26, "VK_DRIVER_ID_MESA_HONEYKRISP"),
    std::make_pair(27, "VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN"),
};
static void print_VkDriverIdKHR(VkDriverIdKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDriverIdKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDriverIdKHR_map[obj] << "\"" << std::endl;
}
static void print_VkDriverIdKHR(const VkDriverIdKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDriverIdKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDriverIdKHR_map[*obj] << "\"" << std::endl;
}

typedef VkConformanceVersion VkConformanceVersionKHR;

typedef VkPhysicalDeviceDriverProperties VkPhysicalDeviceDriverPropertiesKHR;

static std::map<uint64_t, std::string> VkShaderFloatControlsIndependenceKHR_map = {
    std::make_pair(0, "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY"),
    std::make_pair(1, "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL"),
    std::make_pair(2, "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE"),
};
static void print_VkShaderFloatControlsIndependenceKHR(VkShaderFloatControlsIndependenceKHR obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderFloatControlsIndependenceKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderFloatControlsIndependenceKHR_map[obj] << "\"" << std::endl;
}
static void print_VkShaderFloatControlsIndependenceKHR(const VkShaderFloatControlsIndependenceKHR* obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderFloatControlsIndependenceKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderFloatControlsIndependenceKHR_map[*obj] << "\"" << std::endl;
}

typedef VkPhysicalDeviceFloatControlsProperties VkPhysicalDeviceFloatControlsPropertiesKHR;

static std::map<uint64_t, std::string> VkResolveModeFlagBitsKHR_map = {
    std::make_pair(0, "VK_RESOLVE_MODE_NONE"),
    std::make_pair(1ULL << 0, "VK_RESOLVE_MODE_SAMPLE_ZERO_BIT"),
    std::make_pair(1ULL << 1, "VK_RESOLVE_MODE_AVERAGE_BIT"),
    std::make_pair(1ULL << 2, "VK_RESOLVE_MODE_MIN_BIT"),
    std::make_pair(1ULL << 3, "VK_RESOLVE_MODE_MAX_BIT"),
    std::make_pair(1ULL << 4, "VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID"),
};
static void print_VkResolveModeFlagBitsKHR(VkResolveModeFlagBitsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkResolveModeFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkResolveModeFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkResolveModeFlagBitsKHR(const VkResolveModeFlagBitsKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkResolveModeFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkResolveModeFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

typedef VkSubpassDescriptionDepthStencilResolve VkSubpassDescriptionDepthStencilResolveKHR;

typedef VkPhysicalDeviceDepthStencilResolveProperties VkPhysicalDeviceDepthStencilResolvePropertiesKHR;

static std::map<uint64_t, std::string> VkSemaphoreTypeKHR_map = {
    std::make_pair(0, "VK_SEMAPHORE_TYPE_BINARY"),
    std::make_pair(1, "VK_SEMAPHORE_TYPE_TIMELINE"),
};
static void print_VkSemaphoreTypeKHR(VkSemaphoreTypeKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSemaphoreTypeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSemaphoreTypeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkSemaphoreTypeKHR(const VkSemaphoreTypeKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSemaphoreTypeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSemaphoreTypeKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSemaphoreWaitFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_SEMAPHORE_WAIT_ANY_BIT"),
};
static void print_VkSemaphoreWaitFlagBitsKHR(VkSemaphoreWaitFlagBitsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSemaphoreWaitFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSemaphoreWaitFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkSemaphoreWaitFlagBitsKHR(const VkSemaphoreWaitFlagBitsKHR* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSemaphoreWaitFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSemaphoreWaitFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

typedef VkPhysicalDeviceTimelineSemaphoreFeatures VkPhysicalDeviceTimelineSemaphoreFeaturesKHR;

typedef VkPhysicalDeviceTimelineSemaphoreProperties VkPhysicalDeviceTimelineSemaphorePropertiesKHR;

typedef VkSemaphoreTypeCreateInfo VkSemaphoreTypeCreateInfoKHR;

typedef VkTimelineSemaphoreSubmitInfo VkTimelineSemaphoreSubmitInfoKHR;

typedef VkSemaphoreWaitInfo VkSemaphoreWaitInfoKHR;

typedef VkSemaphoreSignalInfo VkSemaphoreSignalInfoKHR;

typedef VkPhysicalDeviceVulkanMemoryModelFeatures VkPhysicalDeviceVulkanMemoryModelFeaturesKHR;

static void print_VkPhysicalDeviceShaderTerminateInvocationFeatures(VkPhysicalDeviceShaderTerminateInvocationFeatures obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderTerminateInvocation, "shaderTerminateInvocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderTerminateInvocationFeatures(const VkPhysicalDeviceShaderTerminateInvocationFeatures* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderTerminateInvocation, "shaderTerminateInvocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceShaderTerminateInvocationFeatures VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR;

static std::map<uint64_t, std::string> VkFragmentShadingRateCombinerOpKHR_map = {
    std::make_pair(0, "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR"),
    std::make_pair(1, "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR"),
    std::make_pair(2, "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR"),
    std::make_pair(3, "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR"),
    std::make_pair(4, "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR"),
};
static void print_VkFragmentShadingRateCombinerOpKHR(VkFragmentShadingRateCombinerOpKHR obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFragmentShadingRateCombinerOpKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFragmentShadingRateCombinerOpKHR_map[obj] << "\"" << std::endl;
}
static void print_VkFragmentShadingRateCombinerOpKHR(const VkFragmentShadingRateCombinerOpKHR* obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFragmentShadingRateCombinerOpKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFragmentShadingRateCombinerOpKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkFragmentShadingRateAttachmentInfoKHR(VkFragmentShadingRateAttachmentInfoKHR obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pFragmentShadingRateAttachment\": " << std::endl;
    if (obj.pFragmentShadingRateAttachment) {
        print_VkAttachmentReference2(obj.pFragmentShadingRateAttachment, "pFragmentShadingRateAttachment", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"shadingRateAttachmentTexelSize\": " << std::endl;
    { print_VkExtent2D(obj.shadingRateAttachmentTexelSize, "shadingRateAttachmentTexelSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkFragmentShadingRateAttachmentInfoKHR(const VkFragmentShadingRateAttachmentInfoKHR* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pFragmentShadingRateAttachment\": " << std::endl;
    if (obj->pFragmentShadingRateAttachment) {
        print_VkAttachmentReference2(obj->pFragmentShadingRateAttachment, "pFragmentShadingRateAttachment", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"shadingRateAttachmentTexelSize\": " << std::endl;
    { print_VkExtent2D(obj->shadingRateAttachmentTexelSize, "shadingRateAttachmentTexelSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineFragmentShadingRateStateCreateInfoKHR(VkPipelineFragmentShadingRateStateCreateInfoKHR obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"fragmentSize\": " << std::endl;
    { print_VkExtent2D(obj.fragmentSize, "fragmentSize", 1); }

    PRINT_SPACE
    _OUT << "\"combinerOps\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_VkFragmentShadingRateCombinerOpKHR(obj.combinerOps[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineFragmentShadingRateStateCreateInfoKHR(const VkPipelineFragmentShadingRateStateCreateInfoKHR* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"fragmentSize\": " << std::endl;
    { print_VkExtent2D(obj->fragmentSize, "fragmentSize", 1); }

    PRINT_SPACE
    _OUT << "\"combinerOps\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_VkFragmentShadingRateCombinerOpKHR(obj->combinerOps[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(VkPhysicalDeviceFragmentShadingRateFeaturesKHR obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.pipelineFragmentShadingRate, "pipelineFragmentShadingRate", 1);

    print_VkBool32(obj.primitiveFragmentShadingRate, "primitiveFragmentShadingRate", 1);

    print_VkBool32(obj.attachmentFragmentShadingRate, "attachmentFragmentShadingRate", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(const VkPhysicalDeviceFragmentShadingRateFeaturesKHR* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->pipelineFragmentShadingRate, "pipelineFragmentShadingRate", 1);

    print_VkBool32(obj->primitiveFragmentShadingRate, "primitiveFragmentShadingRate", 1);

    print_VkBool32(obj->attachmentFragmentShadingRate, "attachmentFragmentShadingRate", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(VkPhysicalDeviceFragmentShadingRatePropertiesKHR obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"minFragmentShadingRateAttachmentTexelSize\": " << std::endl;
    { print_VkExtent2D(obj.minFragmentShadingRateAttachmentTexelSize, "minFragmentShadingRateAttachmentTexelSize", 1); }

    PRINT_SPACE
    _OUT << "\"maxFragmentShadingRateAttachmentTexelSize\": " << std::endl;
    { print_VkExtent2D(obj.maxFragmentShadingRateAttachmentTexelSize, "maxFragmentShadingRateAttachmentTexelSize", 1); }

    print_uint32_t(obj.maxFragmentShadingRateAttachmentTexelSizeAspectRatio, "maxFragmentShadingRateAttachmentTexelSizeAspectRatio",
                   1);

    print_VkBool32(obj.primitiveFragmentShadingRateWithMultipleViewports, "primitiveFragmentShadingRateWithMultipleViewports", 1);

    print_VkBool32(obj.layeredShadingRateAttachments, "layeredShadingRateAttachments", 1);

    print_VkBool32(obj.fragmentShadingRateNonTrivialCombinerOps, "fragmentShadingRateNonTrivialCombinerOps", 1);

    PRINT_SPACE
    _OUT << "\"maxFragmentSize\": " << std::endl;
    { print_VkExtent2D(obj.maxFragmentSize, "maxFragmentSize", 1); }

    print_uint32_t(obj.maxFragmentSizeAspectRatio, "maxFragmentSizeAspectRatio", 1);

    print_uint32_t(obj.maxFragmentShadingRateCoverageSamples, "maxFragmentShadingRateCoverageSamples", 1);

    print_VkSampleCountFlagBits(obj.maxFragmentShadingRateRasterizationSamples, "maxFragmentShadingRateRasterizationSamples", 1);

    print_VkBool32(obj.fragmentShadingRateWithShaderDepthStencilWrites, "fragmentShadingRateWithShaderDepthStencilWrites", 1);

    print_VkBool32(obj.fragmentShadingRateWithSampleMask, "fragmentShadingRateWithSampleMask", 1);

    print_VkBool32(obj.fragmentShadingRateWithShaderSampleMask, "fragmentShadingRateWithShaderSampleMask", 1);

    print_VkBool32(obj.fragmentShadingRateWithConservativeRasterization, "fragmentShadingRateWithConservativeRasterization", 1);

    print_VkBool32(obj.fragmentShadingRateWithFragmentShaderInterlock, "fragmentShadingRateWithFragmentShaderInterlock", 1);

    print_VkBool32(obj.fragmentShadingRateWithCustomSampleLocations, "fragmentShadingRateWithCustomSampleLocations", 1);

    print_VkBool32(obj.fragmentShadingRateStrictMultiplyCombiner, "fragmentShadingRateStrictMultiplyCombiner", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(const VkPhysicalDeviceFragmentShadingRatePropertiesKHR* obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"minFragmentShadingRateAttachmentTexelSize\": " << std::endl;
    { print_VkExtent2D(obj->minFragmentShadingRateAttachmentTexelSize, "minFragmentShadingRateAttachmentTexelSize", 1); }

    PRINT_SPACE
    _OUT << "\"maxFragmentShadingRateAttachmentTexelSize\": " << std::endl;
    { print_VkExtent2D(obj->maxFragmentShadingRateAttachmentTexelSize, "maxFragmentShadingRateAttachmentTexelSize", 1); }

    print_uint32_t(obj->maxFragmentShadingRateAttachmentTexelSizeAspectRatio,
                   "maxFragmentShadingRateAttachmentTexelSizeAspectRatio", 1);

    print_VkBool32(obj->primitiveFragmentShadingRateWithMultipleViewports, "primitiveFragmentShadingRateWithMultipleViewports", 1);

    print_VkBool32(obj->layeredShadingRateAttachments, "layeredShadingRateAttachments", 1);

    print_VkBool32(obj->fragmentShadingRateNonTrivialCombinerOps, "fragmentShadingRateNonTrivialCombinerOps", 1);

    PRINT_SPACE
    _OUT << "\"maxFragmentSize\": " << std::endl;
    { print_VkExtent2D(obj->maxFragmentSize, "maxFragmentSize", 1); }

    print_uint32_t(obj->maxFragmentSizeAspectRatio, "maxFragmentSizeAspectRatio", 1);

    print_uint32_t(obj->maxFragmentShadingRateCoverageSamples, "maxFragmentShadingRateCoverageSamples", 1);

    print_VkSampleCountFlagBits(obj->maxFragmentShadingRateRasterizationSamples, "maxFragmentShadingRateRasterizationSamples", 1);

    print_VkBool32(obj->fragmentShadingRateWithShaderDepthStencilWrites, "fragmentShadingRateWithShaderDepthStencilWrites", 1);

    print_VkBool32(obj->fragmentShadingRateWithSampleMask, "fragmentShadingRateWithSampleMask", 1);

    print_VkBool32(obj->fragmentShadingRateWithShaderSampleMask, "fragmentShadingRateWithShaderSampleMask", 1);

    print_VkBool32(obj->fragmentShadingRateWithConservativeRasterization, "fragmentShadingRateWithConservativeRasterization", 1);

    print_VkBool32(obj->fragmentShadingRateWithFragmentShaderInterlock, "fragmentShadingRateWithFragmentShaderInterlock", 1);

    print_VkBool32(obj->fragmentShadingRateWithCustomSampleLocations, "fragmentShadingRateWithCustomSampleLocations", 1);

    print_VkBool32(obj->fragmentShadingRateStrictMultiplyCombiner, "fragmentShadingRateStrictMultiplyCombiner", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFragmentShadingRateKHR(VkPhysicalDeviceFragmentShadingRateKHR obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSampleCountFlags(obj.sampleCounts, "sampleCounts", 1);

    PRINT_SPACE
    _OUT << "\"fragmentSize\": " << std::endl;
    { print_VkExtent2D(obj.fragmentSize, "fragmentSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentShadingRateKHR(const VkPhysicalDeviceFragmentShadingRateKHR* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSampleCountFlags(obj->sampleCounts, "sampleCounts", 1);

    PRINT_SPACE
    _OUT << "\"fragmentSize\": " << std::endl;
    { print_VkExtent2D(obj->fragmentSize, "fragmentSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderingFragmentShadingRateAttachmentInfoKHR(VkRenderingFragmentShadingRateAttachmentInfoKHR obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.imageLayout, "imageLayout", 1);

    PRINT_SPACE
    _OUT << "\"shadingRateAttachmentTexelSize\": " << std::endl;
    { print_VkExtent2D(obj.shadingRateAttachmentTexelSize, "shadingRateAttachmentTexelSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderingFragmentShadingRateAttachmentInfoKHR(const VkRenderingFragmentShadingRateAttachmentInfoKHR* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->imageLayout, "imageLayout", 1);

    PRINT_SPACE
    _OUT << "\"shadingRateAttachmentTexelSize\": " << std::endl;
    { print_VkExtent2D(obj->shadingRateAttachmentTexelSize, "shadingRateAttachmentTexelSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(VkPhysicalDeviceDynamicRenderingLocalReadFeatures obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.dynamicRenderingLocalRead, "dynamicRenderingLocalRead", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(const VkPhysicalDeviceDynamicRenderingLocalReadFeatures* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->dynamicRenderingLocalRead, "dynamicRenderingLocalRead", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceDynamicRenderingLocalReadFeatures VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR;

static void print_VkRenderingAttachmentLocationInfo(VkRenderingAttachmentLocationInfo obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachmentLocations\":" << std::endl;
    PRINT_SPACE
    if (obj.pColorAttachmentLocations) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.colorAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.colorAttachmentCount;
            print_uint32_t(obj.pColorAttachmentLocations[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderingAttachmentLocationInfo(const VkRenderingAttachmentLocationInfo* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachmentLocations\":" << std::endl;
    PRINT_SPACE
    if (obj->pColorAttachmentLocations) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->colorAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->colorAttachmentCount;
            print_uint32_t(obj->pColorAttachmentLocations[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkRenderingAttachmentLocationInfo VkRenderingAttachmentLocationInfoKHR;

static void print_VkRenderingInputAttachmentIndexInfo(VkRenderingInputAttachmentIndexInfo obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachmentInputIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pColorAttachmentInputIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.colorAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.colorAttachmentCount;
            print_uint32_t(obj.pColorAttachmentInputIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.pDepthInputAttachmentIndex, "pDepthInputAttachmentIndex", 1);

    print_uint32_t(obj.pStencilInputAttachmentIndex, "pStencilInputAttachmentIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderingInputAttachmentIndexInfo(const VkRenderingInputAttachmentIndexInfo* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachmentInputIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pColorAttachmentInputIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->colorAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->colorAttachmentCount;
            print_uint32_t(obj->pColorAttachmentInputIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->pDepthInputAttachmentIndex, "pDepthInputAttachmentIndex", 1);

    print_uint32_t(obj->pStencilInputAttachmentIndex, "pStencilInputAttachmentIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkRenderingInputAttachmentIndexInfo VkRenderingInputAttachmentIndexInfoKHR;

static void print_VkPhysicalDeviceShaderQuadControlFeaturesKHR(VkPhysicalDeviceShaderQuadControlFeaturesKHR obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderQuadControl, "shaderQuadControl", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderQuadControlFeaturesKHR(const VkPhysicalDeviceShaderQuadControlFeaturesKHR* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderQuadControl, "shaderQuadControl", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSurfaceProtectedCapabilitiesKHR(VkSurfaceProtectedCapabilitiesKHR obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.supportsProtected, "supportsProtected", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSurfaceProtectedCapabilitiesKHR(const VkSurfaceProtectedCapabilitiesKHR* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->supportsProtected, "supportsProtected", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR;

typedef VkAttachmentReferenceStencilLayout VkAttachmentReferenceStencilLayoutKHR;

typedef VkAttachmentDescriptionStencilLayout VkAttachmentDescriptionStencilLayoutKHR;

static void print_VkPhysicalDevicePresentWaitFeaturesKHR(VkPhysicalDevicePresentWaitFeaturesKHR obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.presentWait, "presentWait", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePresentWaitFeaturesKHR(const VkPhysicalDevicePresentWaitFeaturesKHR* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->presentWait, "presentWait", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceUniformBufferStandardLayoutFeatures VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR;

typedef VkPhysicalDeviceBufferDeviceAddressFeatures VkPhysicalDeviceBufferDeviceAddressFeaturesKHR;

typedef VkBufferDeviceAddressInfo VkBufferDeviceAddressInfoKHR;

typedef VkBufferOpaqueCaptureAddressCreateInfo VkBufferOpaqueCaptureAddressCreateInfoKHR;

typedef VkMemoryOpaqueCaptureAddressAllocateInfo VkMemoryOpaqueCaptureAddressAllocateInfoKHR;

typedef VkDeviceMemoryOpaqueCaptureAddressInfo VkDeviceMemoryOpaqueCaptureAddressInfoKHR;

static void print_VkDeferredOperationKHR(VkDeferredOperationKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineExecutableStatisticFormatKHR_map = {
    std::make_pair(0, "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR"),
    std::make_pair(1, "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR"),
    std::make_pair(2, "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR"),
    std::make_pair(3, "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR"),
};
static void print_VkPipelineExecutableStatisticFormatKHR(VkPipelineExecutableStatisticFormatKHR obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineExecutableStatisticFormatKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineExecutableStatisticFormatKHR_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineExecutableStatisticFormatKHR(const VkPipelineExecutableStatisticFormatKHR* obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineExecutableStatisticFormatKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineExecutableStatisticFormatKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.pipelineExecutableInfo, "pipelineExecutableInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
    const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->pipelineExecutableInfo, "pipelineExecutableInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineInfoKHR(VkPipelineInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineInfoKHR(const VkPipelineInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineExecutablePropertiesKHR(VkPipelineExecutablePropertiesKHR obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj.stages, "stages", 1);

    PRINT_SPACE
    _OUT << "\"name\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.name[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.subgroupSize, "subgroupSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineExecutablePropertiesKHR(const VkPipelineExecutablePropertiesKHR* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj->stages, "stages", 1);

    PRINT_SPACE
    _OUT << "\"name\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->name[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->subgroupSize, "subgroupSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineExecutableInfoKHR(VkPipelineExecutableInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.executableIndex, "executableIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineExecutableInfoKHR(const VkPipelineExecutableInfoKHR* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->executableIndex, "executableIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineExecutableStatisticValueKHR(VkPipelineExecutableStatisticValueKHR obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkBool32(obj.b32, "b32", 1);

    print_int64_t(obj.i64, "i64", 1);

    print_uint64_t(obj.u64, "u64", 1);

    print_double(obj.f64, "f64", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineExecutableStatisticValueKHR(const VkPipelineExecutableStatisticValueKHR* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkBool32(obj->b32, "b32", 1);

    print_int64_t(obj->i64, "i64", 1);

    print_uint64_t(obj->u64, "u64", 1);

    print_double(obj->f64, "f64", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineExecutableStatisticKHR(VkPipelineExecutableStatisticKHR obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"name\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.name[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkPipelineExecutableStatisticFormatKHR(obj.format, "format", 1);

    print_VkPipelineExecutableStatisticValueKHR(obj.value, "value", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineExecutableStatisticKHR(const VkPipelineExecutableStatisticKHR* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"name\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->name[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkPipelineExecutableStatisticFormatKHR(obj->format, "format", 1);

    print_VkPipelineExecutableStatisticValueKHR(obj->value, "value", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineExecutableInternalRepresentationKHR(VkPipelineExecutableInternalRepresentationKHR obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"name\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.name[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkBool32(obj.isText, "isText", 1);

    print_size_t(obj.dataSize, "dataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineExecutableInternalRepresentationKHR(const VkPipelineExecutableInternalRepresentationKHR* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"name\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->name[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkBool32(obj->isText, "isText", 1);

    print_size_t(obj->dataSize, "dataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkMemoryUnmapFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_MEMORY_UNMAP_RESERVE_BIT_EXT"),
};
static void print_VkMemoryUnmapFlagBits(VkMemoryUnmapFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryUnmapFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryUnmapFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkMemoryUnmapFlagBits(const VkMemoryUnmapFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryUnmapFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryUnmapFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkMemoryUnmapFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_MEMORY_UNMAP_RESERVE_BIT_EXT"),
};
static void print_VkMemoryUnmapFlagBitsKHR(VkMemoryUnmapFlagBitsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryUnmapFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryUnmapFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkMemoryUnmapFlagBitsKHR(const VkMemoryUnmapFlagBitsKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryUnmapFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryUnmapFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkMemoryUnmapFlags(VkMemoryUnmapFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkMemoryUnmapFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkMemoryUnmapFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkMemoryMapInfo(VkMemoryMapInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMemoryMapFlags(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.offset, "offset", 1);

    print_VkDeviceSize(obj.size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryMapInfo(const VkMemoryMapInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMemoryMapFlags(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->offset, "offset", 1);

    print_VkDeviceSize(obj->size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkMemoryMapInfo VkMemoryMapInfoKHR;

static void print_VkMemoryUnmapInfo(VkMemoryUnmapInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMemoryUnmapFlags(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryUnmapInfo(const VkMemoryUnmapInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMemoryUnmapFlags(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkMemoryUnmapInfo VkMemoryUnmapInfoKHR;

static void print_VkPhysicalDeviceShaderIntegerDotProductFeatures(VkPhysicalDeviceShaderIntegerDotProductFeatures obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderIntegerDotProduct, "shaderIntegerDotProduct", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderIntegerDotProductFeatures(const VkPhysicalDeviceShaderIntegerDotProductFeatures* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderIntegerDotProduct, "shaderIntegerDotProduct", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceShaderIntegerDotProductFeatures VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR;

static void print_VkPhysicalDeviceShaderIntegerDotProductProperties(VkPhysicalDeviceShaderIntegerDotProductProperties obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.integerDotProduct8BitUnsignedAccelerated, "integerDotProduct8BitUnsignedAccelerated", 1);

    print_VkBool32(obj.integerDotProduct8BitSignedAccelerated, "integerDotProduct8BitSignedAccelerated", 1);

    print_VkBool32(obj.integerDotProduct8BitMixedSignednessAccelerated, "integerDotProduct8BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj.integerDotProduct4x8BitPackedUnsignedAccelerated, "integerDotProduct4x8BitPackedUnsignedAccelerated", 1);

    print_VkBool32(obj.integerDotProduct4x8BitPackedSignedAccelerated, "integerDotProduct4x8BitPackedSignedAccelerated", 1);

    print_VkBool32(obj.integerDotProduct4x8BitPackedMixedSignednessAccelerated,
                   "integerDotProduct4x8BitPackedMixedSignednessAccelerated", 1);

    print_VkBool32(obj.integerDotProduct16BitUnsignedAccelerated, "integerDotProduct16BitUnsignedAccelerated", 1);

    print_VkBool32(obj.integerDotProduct16BitSignedAccelerated, "integerDotProduct16BitSignedAccelerated", 1);

    print_VkBool32(obj.integerDotProduct16BitMixedSignednessAccelerated, "integerDotProduct16BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj.integerDotProduct32BitUnsignedAccelerated, "integerDotProduct32BitUnsignedAccelerated", 1);

    print_VkBool32(obj.integerDotProduct32BitSignedAccelerated, "integerDotProduct32BitSignedAccelerated", 1);

    print_VkBool32(obj.integerDotProduct32BitMixedSignednessAccelerated, "integerDotProduct32BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj.integerDotProduct64BitUnsignedAccelerated, "integerDotProduct64BitUnsignedAccelerated", 1);

    print_VkBool32(obj.integerDotProduct64BitSignedAccelerated, "integerDotProduct64BitSignedAccelerated", 1);

    print_VkBool32(obj.integerDotProduct64BitMixedSignednessAccelerated, "integerDotProduct64BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated,
                   "integerDotProductAccumulatingSaturating8BitUnsignedAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating8BitSignedAccelerated,
                   "integerDotProductAccumulatingSaturating8BitSignedAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated,
                   "integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated,
                   "integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated,
                   "integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated,
                   "integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated,
                   "integerDotProductAccumulatingSaturating16BitUnsignedAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating16BitSignedAccelerated,
                   "integerDotProductAccumulatingSaturating16BitSignedAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated,
                   "integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated,
                   "integerDotProductAccumulatingSaturating32BitUnsignedAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating32BitSignedAccelerated,
                   "integerDotProductAccumulatingSaturating32BitSignedAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated,
                   "integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated,
                   "integerDotProductAccumulatingSaturating64BitUnsignedAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating64BitSignedAccelerated,
                   "integerDotProductAccumulatingSaturating64BitSignedAccelerated", 1);

    print_VkBool32(obj.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated,
                   "integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderIntegerDotProductProperties(const VkPhysicalDeviceShaderIntegerDotProductProperties* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->integerDotProduct8BitUnsignedAccelerated, "integerDotProduct8BitUnsignedAccelerated", 1);

    print_VkBool32(obj->integerDotProduct8BitSignedAccelerated, "integerDotProduct8BitSignedAccelerated", 1);

    print_VkBool32(obj->integerDotProduct8BitMixedSignednessAccelerated, "integerDotProduct8BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj->integerDotProduct4x8BitPackedUnsignedAccelerated, "integerDotProduct4x8BitPackedUnsignedAccelerated", 1);

    print_VkBool32(obj->integerDotProduct4x8BitPackedSignedAccelerated, "integerDotProduct4x8BitPackedSignedAccelerated", 1);

    print_VkBool32(obj->integerDotProduct4x8BitPackedMixedSignednessAccelerated,
                   "integerDotProduct4x8BitPackedMixedSignednessAccelerated", 1);

    print_VkBool32(obj->integerDotProduct16BitUnsignedAccelerated, "integerDotProduct16BitUnsignedAccelerated", 1);

    print_VkBool32(obj->integerDotProduct16BitSignedAccelerated, "integerDotProduct16BitSignedAccelerated", 1);

    print_VkBool32(obj->integerDotProduct16BitMixedSignednessAccelerated, "integerDotProduct16BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj->integerDotProduct32BitUnsignedAccelerated, "integerDotProduct32BitUnsignedAccelerated", 1);

    print_VkBool32(obj->integerDotProduct32BitSignedAccelerated, "integerDotProduct32BitSignedAccelerated", 1);

    print_VkBool32(obj->integerDotProduct32BitMixedSignednessAccelerated, "integerDotProduct32BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj->integerDotProduct64BitUnsignedAccelerated, "integerDotProduct64BitUnsignedAccelerated", 1);

    print_VkBool32(obj->integerDotProduct64BitSignedAccelerated, "integerDotProduct64BitSignedAccelerated", 1);

    print_VkBool32(obj->integerDotProduct64BitMixedSignednessAccelerated, "integerDotProduct64BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated,
                   "integerDotProductAccumulatingSaturating8BitUnsignedAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating8BitSignedAccelerated,
                   "integerDotProductAccumulatingSaturating8BitSignedAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated,
                   "integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated,
                   "integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated,
                   "integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated,
                   "integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated,
                   "integerDotProductAccumulatingSaturating16BitUnsignedAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating16BitSignedAccelerated,
                   "integerDotProductAccumulatingSaturating16BitSignedAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated,
                   "integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated,
                   "integerDotProductAccumulatingSaturating32BitUnsignedAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating32BitSignedAccelerated,
                   "integerDotProductAccumulatingSaturating32BitSignedAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated,
                   "integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated,
                   "integerDotProductAccumulatingSaturating64BitUnsignedAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating64BitSignedAccelerated,
                   "integerDotProductAccumulatingSaturating64BitSignedAccelerated", 1);

    print_VkBool32(obj->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated,
                   "integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceShaderIntegerDotProductProperties VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR;

static void print_VkPipelineLibraryCreateInfoKHR(VkPipelineLibraryCreateInfoKHR obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.libraryCount, "libraryCount", 1);

    PRINT_SPACE
    _OUT << "\"pLibraries\":" << std::endl;
    PRINT_SPACE
    if (obj.pLibraries) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.libraryCount; i++) {
            std::stringstream tmp;
            tmp << "pLibraries"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.libraryCount;
            print_VkPipeline(obj.pLibraries[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineLibraryCreateInfoKHR(const VkPipelineLibraryCreateInfoKHR* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->libraryCount, "libraryCount", 1);

    PRINT_SPACE
    _OUT << "\"pLibraries\":" << std::endl;
    PRINT_SPACE
    if (obj->pLibraries) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->libraryCount; i++) {
            std::stringstream tmp;
            tmp << "pLibraries"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->libraryCount;
            print_VkPipeline(obj->pLibraries[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPresentIdKHR(VkPresentIdKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pPresentIds\":" << std::endl;
    PRINT_SPACE
    if (obj.pPresentIds) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.swapchainCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.swapchainCount;
            print_uint64_t(obj.pPresentIds[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPresentIdKHR(const VkPresentIdKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pPresentIds\":" << std::endl;
    PRINT_SPACE
    if (obj->pPresentIds) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->swapchainCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->swapchainCount;
            print_uint64_t(obj->pPresentIds[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePresentIdFeaturesKHR(VkPhysicalDevicePresentIdFeaturesKHR obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.presentId, "presentId", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePresentIdFeaturesKHR(const VkPhysicalDevicePresentIdFeaturesKHR* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->presentId, "presentId", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeFlagBitsKHR_map = {
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_RESERVED_2_BIT_KHR"),
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR"),
};
static void print_VkVideoEncodeFlagBitsKHR(VkVideoEncodeFlagBitsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeFlagBitsKHR(const VkVideoEncodeFlagBitsKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeCapabilityFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR"),
};
static void print_VkVideoEncodeCapabilityFlagBitsKHR(VkVideoEncodeCapabilityFlagBitsKHR obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeCapabilityFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeCapabilityFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeCapabilityFlagBitsKHR(const VkVideoEncodeCapabilityFlagBitsKHR* obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeCapabilityFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeCapabilityFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeRateControlModeFlagBitsKHR_map = {
    std::make_pair(0, "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR"),
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR"),
};
static void print_VkVideoEncodeRateControlModeFlagBitsKHR(VkVideoEncodeRateControlModeFlagBitsKHR obj, const std::string& str,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeRateControlModeFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeRateControlModeFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeRateControlModeFlagBitsKHR(const VkVideoEncodeRateControlModeFlagBitsKHR* obj,
                                                          const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeRateControlModeFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeRateControlModeFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeFeedbackFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR"),
};
static void print_VkVideoEncodeFeedbackFlagBitsKHR(VkVideoEncodeFeedbackFlagBitsKHR obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeFeedbackFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeFeedbackFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeFeedbackFlagBitsKHR(const VkVideoEncodeFeedbackFlagBitsKHR* obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeFeedbackFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeFeedbackFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeUsageFlagBitsKHR_map = {
    std::make_pair(0, "VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR"),
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR"),
};
static void print_VkVideoEncodeUsageFlagBitsKHR(VkVideoEncodeUsageFlagBitsKHR obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeUsageFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeUsageFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeUsageFlagBitsKHR(const VkVideoEncodeUsageFlagBitsKHR* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeUsageFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeUsageFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeContentFlagBitsKHR_map = {
    std::make_pair(0, "VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR"),
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR"),
};
static void print_VkVideoEncodeContentFlagBitsKHR(VkVideoEncodeContentFlagBitsKHR obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeContentFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeContentFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeContentFlagBitsKHR(const VkVideoEncodeContentFlagBitsKHR* obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeContentFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeContentFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeTuningModeKHR_map = {
    std::make_pair(0, "VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR"),
    std::make_pair(1, "VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR"),
    std::make_pair(2, "VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR"),
    std::make_pair(3, "VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR"),
    std::make_pair(4, "VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR"),
};
static void print_VkVideoEncodeTuningModeKHR(VkVideoEncodeTuningModeKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeTuningModeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeTuningModeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeTuningModeKHR(const VkVideoEncodeTuningModeKHR* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeTuningModeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeTuningModeKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkVideoEncodeFlagsKHR(VkVideoEncodeFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeCapabilityFlagsKHR(VkVideoEncodeCapabilityFlagsKHR obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeCapabilityFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeCapabilityFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeRateControlModeFlagsKHR(VkVideoEncodeRateControlModeFlagsKHR obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeRateControlModeFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeRateControlModeFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeFeedbackFlagsKHR(VkVideoEncodeFeedbackFlagsKHR obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeFeedbackFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeFeedbackFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeUsageFlagsKHR(VkVideoEncodeUsageFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeUsageFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeUsageFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeContentFlagsKHR(VkVideoEncodeContentFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeContentFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeContentFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeRateControlFlagsKHR(VkVideoEncodeRateControlFlagsKHR obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkVideoEncodeInfoKHR(VkVideoEncodeInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeFlagsKHR(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.dstBufferOffset, "dstBufferOffset", 1);

    print_VkDeviceSize(obj.dstBufferRange, "dstBufferRange", 1);

    PRINT_SPACE
    _OUT << "\"srcPictureResource\": " << std::endl;
    { print_VkVideoPictureResourceInfoKHR(obj.srcPictureResource, "srcPictureResource", 1); }

    PRINT_SPACE
    _OUT << "\"pSetupReferenceSlot\": " << std::endl;
    if (obj.pSetupReferenceSlot) {
        print_VkVideoReferenceSlotInfoKHR(obj.pSetupReferenceSlot, "pSetupReferenceSlot", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.referenceSlotCount, "referenceSlotCount", 1);

    PRINT_SPACE
    _OUT << "\"pReferenceSlots\": " << std::endl;
    if (obj.pReferenceSlots) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.referenceSlotCount; i++) {
            if (i + 1 == obj.referenceSlotCount)
                print_VkVideoReferenceSlotInfoKHR(obj.pReferenceSlots[i], "pReferenceSlots", 0);
            else
                print_VkVideoReferenceSlotInfoKHR(obj.pReferenceSlots[i], "pReferenceSlots", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.precedingExternallyEncodedBytes, "precedingExternallyEncodedBytes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeInfoKHR(const VkVideoEncodeInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeFlagsKHR(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->dstBufferOffset, "dstBufferOffset", 1);

    print_VkDeviceSize(obj->dstBufferRange, "dstBufferRange", 1);

    PRINT_SPACE
    _OUT << "\"srcPictureResource\": " << std::endl;
    { print_VkVideoPictureResourceInfoKHR(obj->srcPictureResource, "srcPictureResource", 1); }

    PRINT_SPACE
    _OUT << "\"pSetupReferenceSlot\": " << std::endl;
    if (obj->pSetupReferenceSlot) {
        print_VkVideoReferenceSlotInfoKHR(obj->pSetupReferenceSlot, "pSetupReferenceSlot", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->referenceSlotCount, "referenceSlotCount", 1);

    PRINT_SPACE
    _OUT << "\"pReferenceSlots\": " << std::endl;
    if (obj->pReferenceSlots) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->referenceSlotCount; i++) {
            if (i + 1 == obj->referenceSlotCount)
                print_VkVideoReferenceSlotInfoKHR(obj->pReferenceSlots[i], "pReferenceSlots", 0);
            else
                print_VkVideoReferenceSlotInfoKHR(obj->pReferenceSlots[i], "pReferenceSlots", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->precedingExternallyEncodedBytes, "precedingExternallyEncodedBytes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeCapabilitiesKHR(VkVideoEncodeCapabilitiesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeCapabilityFlagsKHR(obj.flags, "flags", 1);

    print_VkVideoEncodeRateControlModeFlagsKHR(obj.rateControlModes, "rateControlModes", 1);

    print_uint32_t(obj.maxRateControlLayers, "maxRateControlLayers", 1);

    print_uint64_t(obj.maxBitrate, "maxBitrate", 1);

    print_uint32_t(obj.maxQualityLevels, "maxQualityLevels", 1);

    PRINT_SPACE
    _OUT << "\"encodeInputPictureGranularity\": " << std::endl;
    { print_VkExtent2D(obj.encodeInputPictureGranularity, "encodeInputPictureGranularity", 1); }

    print_VkVideoEncodeFeedbackFlagsKHR(obj.supportedEncodeFeedbackFlags, "supportedEncodeFeedbackFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeCapabilitiesKHR(const VkVideoEncodeCapabilitiesKHR* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeCapabilityFlagsKHR(obj->flags, "flags", 1);

    print_VkVideoEncodeRateControlModeFlagsKHR(obj->rateControlModes, "rateControlModes", 1);

    print_uint32_t(obj->maxRateControlLayers, "maxRateControlLayers", 1);

    print_uint64_t(obj->maxBitrate, "maxBitrate", 1);

    print_uint32_t(obj->maxQualityLevels, "maxQualityLevels", 1);

    PRINT_SPACE
    _OUT << "\"encodeInputPictureGranularity\": " << std::endl;
    { print_VkExtent2D(obj->encodeInputPictureGranularity, "encodeInputPictureGranularity", 1); }

    print_VkVideoEncodeFeedbackFlagsKHR(obj->supportedEncodeFeedbackFlags, "supportedEncodeFeedbackFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(VkQueryPoolVideoEncodeFeedbackCreateInfoKHR obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeFeedbackFlagsKHR(obj.encodeFeedbackFlags, "encodeFeedbackFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeFeedbackFlagsKHR(obj->encodeFeedbackFlags, "encodeFeedbackFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeUsageInfoKHR(VkVideoEncodeUsageInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeUsageFlagsKHR(obj.videoUsageHints, "videoUsageHints", 1);

    print_VkVideoEncodeContentFlagsKHR(obj.videoContentHints, "videoContentHints", 1);

    print_VkVideoEncodeTuningModeKHR(obj.tuningMode, "tuningMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeUsageInfoKHR(const VkVideoEncodeUsageInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeUsageFlagsKHR(obj->videoUsageHints, "videoUsageHints", 1);

    print_VkVideoEncodeContentFlagsKHR(obj->videoContentHints, "videoContentHints", 1);

    print_VkVideoEncodeTuningModeKHR(obj->tuningMode, "tuningMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeRateControlLayerInfoKHR(VkVideoEncodeRateControlLayerInfoKHR obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.averageBitrate, "averageBitrate", 1);

    print_uint64_t(obj.maxBitrate, "maxBitrate", 1);

    print_uint32_t(obj.frameRateNumerator, "frameRateNumerator", 1);

    print_uint32_t(obj.frameRateDenominator, "frameRateDenominator", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeRateControlLayerInfoKHR(const VkVideoEncodeRateControlLayerInfoKHR* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->averageBitrate, "averageBitrate", 1);

    print_uint64_t(obj->maxBitrate, "maxBitrate", 1);

    print_uint32_t(obj->frameRateNumerator, "frameRateNumerator", 1);

    print_uint32_t(obj->frameRateDenominator, "frameRateDenominator", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeRateControlInfoKHR(VkVideoEncodeRateControlInfoKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeRateControlFlagsKHR(obj.flags, "flags", 1);

    print_VkVideoEncodeRateControlModeFlagBitsKHR(obj.rateControlMode, "rateControlMode", 1);

    print_uint32_t(obj.layerCount, "layerCount", 1);

    PRINT_SPACE
    _OUT << "\"pLayers\": " << std::endl;
    if (obj.pLayers) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.layerCount; i++) {
            if (i + 1 == obj.layerCount)
                print_VkVideoEncodeRateControlLayerInfoKHR(obj.pLayers[i], "pLayers", 0);
            else
                print_VkVideoEncodeRateControlLayerInfoKHR(obj.pLayers[i], "pLayers", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.virtualBufferSizeInMs, "virtualBufferSizeInMs", 1);

    print_uint32_t(obj.initialVirtualBufferSizeInMs, "initialVirtualBufferSizeInMs", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeRateControlInfoKHR(const VkVideoEncodeRateControlInfoKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeRateControlFlagsKHR(obj->flags, "flags", 1);

    print_VkVideoEncodeRateControlModeFlagBitsKHR(obj->rateControlMode, "rateControlMode", 1);

    print_uint32_t(obj->layerCount, "layerCount", 1);

    PRINT_SPACE
    _OUT << "\"pLayers\": " << std::endl;
    if (obj->pLayers) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->layerCount; i++) {
            if (i + 1 == obj->layerCount)
                print_VkVideoEncodeRateControlLayerInfoKHR(obj->pLayers[i], "pLayers", 0);
            else
                print_VkVideoEncodeRateControlLayerInfoKHR(obj->pLayers[i], "pLayers", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->virtualBufferSizeInMs, "virtualBufferSizeInMs", 1);

    print_uint32_t(obj->initialVirtualBufferSizeInMs, "initialVirtualBufferSizeInMs", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pVideoProfile\": " << std::endl;
    if (obj.pVideoProfile) {
        print_VkVideoProfileInfoKHR(obj.pVideoProfile, "pVideoProfile", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.qualityLevel, "qualityLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pVideoProfile\": " << std::endl;
    if (obj->pVideoProfile) {
        print_VkVideoProfileInfoKHR(obj->pVideoProfile, "pVideoProfile", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->qualityLevel, "qualityLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeQualityLevelPropertiesKHR(VkVideoEncodeQualityLevelPropertiesKHR obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeRateControlModeFlagBitsKHR(obj.preferredRateControlMode, "preferredRateControlMode", 1);

    print_uint32_t(obj.preferredRateControlLayerCount, "preferredRateControlLayerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeQualityLevelPropertiesKHR(const VkVideoEncodeQualityLevelPropertiesKHR* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeRateControlModeFlagBitsKHR(obj->preferredRateControlMode, "preferredRateControlMode", 1);

    print_uint32_t(obj->preferredRateControlLayerCount, "preferredRateControlLayerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeQualityLevelInfoKHR(VkVideoEncodeQualityLevelInfoKHR obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.qualityLevel, "qualityLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeQualityLevelInfoKHR(const VkVideoEncodeQualityLevelInfoKHR* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->qualityLevel, "qualityLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeSessionParametersGetInfoKHR(VkVideoEncodeSessionParametersGetInfoKHR obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "videoSessionParameters"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeSessionParametersGetInfoKHR(const VkVideoEncodeSessionParametersGetInfoKHR* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "videoSessionParameters"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeSessionParametersFeedbackInfoKHR(VkVideoEncodeSessionParametersFeedbackInfoKHR obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.hasOverrides, "hasOverrides", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeSessionParametersFeedbackInfoKHR(const VkVideoEncodeSessionParametersFeedbackInfoKHR* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->hasOverrides, "hasOverrides", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkFlags64(VkFlags64 obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "\"" << str << "\""
         << " : "
         << "\"" << obj << "\"" << (commaNeeded ? "," : "") << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineStageFlagBits2_map = {
    std::make_pair(0, "VK_PIPELINE_STAGE_2_NONE"),
    std::make_pair(1ULL << 0, "VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT"),
    std::make_pair(1ULL << 1, "VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT"),
    std::make_pair(1ULL << 2, "VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT"),
    std::make_pair(1ULL << 3, "VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT"),
    std::make_pair(1ULL << 4, "VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT"),
    std::make_pair(1ULL << 5, "VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT"),
    std::make_pair(1ULL << 6, "VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT"),
    std::make_pair(1ULL << 7, "VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT"),
    std::make_pair(1ULL << 8, "VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT"),
    std::make_pair(1ULL << 9, "VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT"),
    std::make_pair(1ULL << 10, "VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT"),
    std::make_pair(1ULL << 11, "VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT"),
    std::make_pair(1ULL << 12, "VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT"),
    std::make_pair(1ULL << 13, "VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT"),
    std::make_pair(1ULL << 14, "VK_PIPELINE_STAGE_2_HOST_BIT"),
    std::make_pair(1ULL << 15, "VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT"),
    std::make_pair(1ULL << 16, "VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT"),
    std::make_pair(1ULL << 32, "VK_PIPELINE_STAGE_2_COPY_BIT"),
    std::make_pair(1ULL << 33, "VK_PIPELINE_STAGE_2_RESOLVE_BIT"),
    std::make_pair(1ULL << 34, "VK_PIPELINE_STAGE_2_BLIT_BIT"),
    std::make_pair(1ULL << 35, "VK_PIPELINE_STAGE_2_CLEAR_BIT"),
    std::make_pair(1ULL << 36, "VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT"),
    std::make_pair(1ULL << 37, "VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT"),
    std::make_pair(1ULL << 38, "VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT"),
    std::make_pair(1ULL << 26, "VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR"),
    std::make_pair(1ULL << 27, "VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR"),
    std::make_pair(1ULL << 24, "VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT"),
    std::make_pair(1ULL << 18, "VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT"),
    std::make_pair(1ULL << 17, "VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT"),
    std::make_pair(1ULL << 22, "VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
    std::make_pair(1ULL << 25, "VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"),
    std::make_pair(1ULL << 21, "VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR"),
    std::make_pair(1ULL << 23, "VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT"),
    std::make_pair(1ULL << 19, "VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT"),
    std::make_pair(1ULL << 20, "VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT"),
    std::make_pair(1ULL << 39, "VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI"),
    std::make_pair(1ULL << 40, "VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI"),
    std::make_pair(1ULL << 28, "VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR"),
    std::make_pair(1ULL << 30, "VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT"),
    std::make_pair(1ULL << 41, "VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"),
    std::make_pair(1ULL << 43, "VK_PIPELINE_STAGE_2_RESERVED_43_BIT_ARM"),
    std::make_pair(1ULL << 29, "VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV"),
    std::make_pair(1ULL << 44, "VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV"),
    std::make_pair(1ULL << 42, "VK_PIPELINE_STAGE_2_RESERVED_42_BIT_EXT"),
    std::make_pair(1ULL << 46, "VK_PIPELINE_STAGE_2_RESERVED_46_BIT_NV"),
    std::make_pair(1ULL << 45, "VK_PIPELINE_STAGE_2_RESERVED_45_BIT_NV"),
};
static void print_VkPipelineStageFlagBits2(VkPipelineStageFlagBits2 obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineStageFlagBits2_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineStageFlagBits2_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineStageFlagBits2(const VkPipelineStageFlagBits2* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineStageFlagBits2_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineStageFlagBits2_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineStageFlagBits2KHR_map = {
    std::make_pair(0, "VK_PIPELINE_STAGE_2_NONE"),
    std::make_pair(1ULL << 0, "VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT"),
    std::make_pair(1ULL << 1, "VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT"),
    std::make_pair(1ULL << 2, "VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT"),
    std::make_pair(1ULL << 3, "VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT"),
    std::make_pair(1ULL << 4, "VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT"),
    std::make_pair(1ULL << 5, "VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT"),
    std::make_pair(1ULL << 6, "VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT"),
    std::make_pair(1ULL << 7, "VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT"),
    std::make_pair(1ULL << 8, "VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT"),
    std::make_pair(1ULL << 9, "VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT"),
    std::make_pair(1ULL << 10, "VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT"),
    std::make_pair(1ULL << 11, "VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT"),
    std::make_pair(1ULL << 12, "VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT"),
    std::make_pair(1ULL << 13, "VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT"),
    std::make_pair(1ULL << 14, "VK_PIPELINE_STAGE_2_HOST_BIT"),
    std::make_pair(1ULL << 15, "VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT"),
    std::make_pair(1ULL << 16, "VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT"),
    std::make_pair(1ULL << 32, "VK_PIPELINE_STAGE_2_COPY_BIT"),
    std::make_pair(1ULL << 33, "VK_PIPELINE_STAGE_2_RESOLVE_BIT"),
    std::make_pair(1ULL << 34, "VK_PIPELINE_STAGE_2_BLIT_BIT"),
    std::make_pair(1ULL << 35, "VK_PIPELINE_STAGE_2_CLEAR_BIT"),
    std::make_pair(1ULL << 36, "VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT"),
    std::make_pair(1ULL << 37, "VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT"),
    std::make_pair(1ULL << 38, "VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT"),
    std::make_pair(1ULL << 26, "VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR"),
    std::make_pair(1ULL << 27, "VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR"),
    std::make_pair(1ULL << 24, "VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT"),
    std::make_pair(1ULL << 18, "VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT"),
    std::make_pair(1ULL << 17, "VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT"),
    std::make_pair(1ULL << 22, "VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
    std::make_pair(1ULL << 25, "VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"),
    std::make_pair(1ULL << 21, "VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR"),
    std::make_pair(1ULL << 23, "VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT"),
    std::make_pair(1ULL << 19, "VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT"),
    std::make_pair(1ULL << 20, "VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT"),
    std::make_pair(1ULL << 39, "VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI"),
    std::make_pair(1ULL << 40, "VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI"),
    std::make_pair(1ULL << 28, "VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR"),
    std::make_pair(1ULL << 30, "VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT"),
    std::make_pair(1ULL << 41, "VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"),
    std::make_pair(1ULL << 43, "VK_PIPELINE_STAGE_2_RESERVED_43_BIT_ARM"),
    std::make_pair(1ULL << 29, "VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV"),
    std::make_pair(1ULL << 44, "VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV"),
    std::make_pair(1ULL << 42, "VK_PIPELINE_STAGE_2_RESERVED_42_BIT_EXT"),
    std::make_pair(1ULL << 46, "VK_PIPELINE_STAGE_2_RESERVED_46_BIT_NV"),
    std::make_pair(1ULL << 45, "VK_PIPELINE_STAGE_2_RESERVED_45_BIT_NV"),
};
static void print_VkPipelineStageFlagBits2KHR(VkPipelineStageFlagBits2KHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineStageFlagBits2KHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineStageFlagBits2KHR_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineStageFlagBits2KHR(const VkPipelineStageFlagBits2KHR* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineStageFlagBits2KHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineStageFlagBits2KHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAccessFlagBits2_map = {
    std::make_pair(0, "VK_ACCESS_2_NONE"),
    std::make_pair(1ULL << 0, "VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT"),
    std::make_pair(1ULL << 1, "VK_ACCESS_2_INDEX_READ_BIT"),
    std::make_pair(1ULL << 2, "VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT"),
    std::make_pair(1ULL << 3, "VK_ACCESS_2_UNIFORM_READ_BIT"),
    std::make_pair(1ULL << 4, "VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT"),
    std::make_pair(1ULL << 5, "VK_ACCESS_2_SHADER_READ_BIT"),
    std::make_pair(1ULL << 6, "VK_ACCESS_2_SHADER_WRITE_BIT"),
    std::make_pair(1ULL << 7, "VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT"),
    std::make_pair(1ULL << 8, "VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT"),
    std::make_pair(1ULL << 9, "VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT"),
    std::make_pair(1ULL << 10, "VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"),
    std::make_pair(1ULL << 11, "VK_ACCESS_2_TRANSFER_READ_BIT"),
    std::make_pair(1ULL << 12, "VK_ACCESS_2_TRANSFER_WRITE_BIT"),
    std::make_pair(1ULL << 13, "VK_ACCESS_2_HOST_READ_BIT"),
    std::make_pair(1ULL << 14, "VK_ACCESS_2_HOST_WRITE_BIT"),
    std::make_pair(1ULL << 15, "VK_ACCESS_2_MEMORY_READ_BIT"),
    std::make_pair(1ULL << 16, "VK_ACCESS_2_MEMORY_WRITE_BIT"),
    std::make_pair(1ULL << 32, "VK_ACCESS_2_SHADER_SAMPLED_READ_BIT"),
    std::make_pair(1ULL << 33, "VK_ACCESS_2_SHADER_STORAGE_READ_BIT"),
    std::make_pair(1ULL << 34, "VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT"),
    std::make_pair(1ULL << 35, "VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR"),
    std::make_pair(1ULL << 36, "VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR"),
    std::make_pair(1ULL << 57, "VK_ACCESS_2_RESERVED_57_BIT_KHR"),
    std::make_pair(1ULL << 58, "VK_ACCESS_2_RESERVED_58_BIT_KHR"),
    std::make_pair(1ULL << 59, "VK_ACCESS_2_RESERVED_59_BIT_KHR"),
    std::make_pair(1ULL << 46, "VK_ACCESS_2_RESERVED_46_BIT_INTEL"),
    std::make_pair(1ULL << 37, "VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR"),
    std::make_pair(1ULL << 38, "VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR"),
    std::make_pair(1ULL << 51, "VK_ACCESS_2_RESERVED_51_BIT_QCOM"),
    std::make_pair(1ULL << 52, "VK_ACCESS_2_RESERVED_52_BIT_QCOM"),
    std::make_pair(1ULL << 53, "VK_ACCESS_2_RESERVED_53_BIT_QCOM"),
    std::make_pair(1ULL << 54, "VK_ACCESS_2_RESERVED_54_BIT_QCOM"),
    std::make_pair(1ULL << 25, "VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT"),
    std::make_pair(1ULL << 26, "VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT"),
    std::make_pair(1ULL << 27, "VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT"),
    std::make_pair(1ULL << 20, "VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT"),
    std::make_pair(1ULL << 17, "VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT"),
    std::make_pair(1ULL << 18, "VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT"),
    std::make_pair(1ULL << 23, "VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"),
    std::make_pair(1ULL << 21, "VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR"),
    std::make_pair(1ULL << 22, "VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"),
    std::make_pair(1ULL << 24, "VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT"),
    std::make_pair(1ULL << 19, "VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"),
    std::make_pair(1ULL << 41, "VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT"),
    std::make_pair(1ULL << 39, "VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI"),
    std::make_pair(1ULL << 40, "VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR"),
    std::make_pair(1ULL << 44, "VK_ACCESS_2_MICROMAP_READ_BIT_EXT"),
    std::make_pair(1ULL << 45, "VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT"),
    std::make_pair(1ULL << 49, "VK_ACCESS_2_RESERVED_49_BIT_ARM"),
    std::make_pair(1ULL << 50, "VK_ACCESS_2_RESERVED_50_BIT_ARM"),
    std::make_pair(1ULL << 42, "VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV"),
    std::make_pair(1ULL << 43, "VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV"),
    std::make_pair(1ULL << 47, "VK_ACCESS_2_RESERVED_47_BIT_EXT"),
    std::make_pair(1ULL << 48, "VK_ACCESS_2_RESERVED_48_BIT_EXT"),
    std::make_pair(1ULL << 55, "VK_ACCESS_2_RESERVED_55_BIT_NV"),
    std::make_pair(1ULL << 56, "VK_ACCESS_2_RESERVED_56_BIT_NV"),
};
static void print_VkAccessFlagBits2(VkAccessFlagBits2 obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccessFlagBits2_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccessFlagBits2_map[obj] << "\"" << std::endl;
}
static void print_VkAccessFlagBits2(const VkAccessFlagBits2* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccessFlagBits2_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccessFlagBits2_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAccessFlagBits2KHR_map = {
    std::make_pair(0, "VK_ACCESS_2_NONE"),
    std::make_pair(1ULL << 0, "VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT"),
    std::make_pair(1ULL << 1, "VK_ACCESS_2_INDEX_READ_BIT"),
    std::make_pair(1ULL << 2, "VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT"),
    std::make_pair(1ULL << 3, "VK_ACCESS_2_UNIFORM_READ_BIT"),
    std::make_pair(1ULL << 4, "VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT"),
    std::make_pair(1ULL << 5, "VK_ACCESS_2_SHADER_READ_BIT"),
    std::make_pair(1ULL << 6, "VK_ACCESS_2_SHADER_WRITE_BIT"),
    std::make_pair(1ULL << 7, "VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT"),
    std::make_pair(1ULL << 8, "VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT"),
    std::make_pair(1ULL << 9, "VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT"),
    std::make_pair(1ULL << 10, "VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"),
    std::make_pair(1ULL << 11, "VK_ACCESS_2_TRANSFER_READ_BIT"),
    std::make_pair(1ULL << 12, "VK_ACCESS_2_TRANSFER_WRITE_BIT"),
    std::make_pair(1ULL << 13, "VK_ACCESS_2_HOST_READ_BIT"),
    std::make_pair(1ULL << 14, "VK_ACCESS_2_HOST_WRITE_BIT"),
    std::make_pair(1ULL << 15, "VK_ACCESS_2_MEMORY_READ_BIT"),
    std::make_pair(1ULL << 16, "VK_ACCESS_2_MEMORY_WRITE_BIT"),
    std::make_pair(1ULL << 32, "VK_ACCESS_2_SHADER_SAMPLED_READ_BIT"),
    std::make_pair(1ULL << 33, "VK_ACCESS_2_SHADER_STORAGE_READ_BIT"),
    std::make_pair(1ULL << 34, "VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT"),
    std::make_pair(1ULL << 35, "VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR"),
    std::make_pair(1ULL << 36, "VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR"),
    std::make_pair(1ULL << 57, "VK_ACCESS_2_RESERVED_57_BIT_KHR"),
    std::make_pair(1ULL << 58, "VK_ACCESS_2_RESERVED_58_BIT_KHR"),
    std::make_pair(1ULL << 59, "VK_ACCESS_2_RESERVED_59_BIT_KHR"),
    std::make_pair(1ULL << 46, "VK_ACCESS_2_RESERVED_46_BIT_INTEL"),
    std::make_pair(1ULL << 37, "VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR"),
    std::make_pair(1ULL << 38, "VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR"),
    std::make_pair(1ULL << 51, "VK_ACCESS_2_RESERVED_51_BIT_QCOM"),
    std::make_pair(1ULL << 52, "VK_ACCESS_2_RESERVED_52_BIT_QCOM"),
    std::make_pair(1ULL << 53, "VK_ACCESS_2_RESERVED_53_BIT_QCOM"),
    std::make_pair(1ULL << 54, "VK_ACCESS_2_RESERVED_54_BIT_QCOM"),
    std::make_pair(1ULL << 25, "VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT"),
    std::make_pair(1ULL << 26, "VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT"),
    std::make_pair(1ULL << 27, "VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT"),
    std::make_pair(1ULL << 20, "VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT"),
    std::make_pair(1ULL << 17, "VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT"),
    std::make_pair(1ULL << 18, "VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT"),
    std::make_pair(1ULL << 23, "VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"),
    std::make_pair(1ULL << 21, "VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR"),
    std::make_pair(1ULL << 22, "VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"),
    std::make_pair(1ULL << 24, "VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT"),
    std::make_pair(1ULL << 19, "VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"),
    std::make_pair(1ULL << 41, "VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT"),
    std::make_pair(1ULL << 39, "VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI"),
    std::make_pair(1ULL << 40, "VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR"),
    std::make_pair(1ULL << 44, "VK_ACCESS_2_MICROMAP_READ_BIT_EXT"),
    std::make_pair(1ULL << 45, "VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT"),
    std::make_pair(1ULL << 49, "VK_ACCESS_2_RESERVED_49_BIT_ARM"),
    std::make_pair(1ULL << 50, "VK_ACCESS_2_RESERVED_50_BIT_ARM"),
    std::make_pair(1ULL << 42, "VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV"),
    std::make_pair(1ULL << 43, "VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV"),
    std::make_pair(1ULL << 47, "VK_ACCESS_2_RESERVED_47_BIT_EXT"),
    std::make_pair(1ULL << 48, "VK_ACCESS_2_RESERVED_48_BIT_EXT"),
    std::make_pair(1ULL << 55, "VK_ACCESS_2_RESERVED_55_BIT_NV"),
    std::make_pair(1ULL << 56, "VK_ACCESS_2_RESERVED_56_BIT_NV"),
};
static void print_VkAccessFlagBits2KHR(VkAccessFlagBits2KHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccessFlagBits2KHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccessFlagBits2KHR_map[obj] << "\"" << std::endl;
}
static void print_VkAccessFlagBits2KHR(const VkAccessFlagBits2KHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccessFlagBits2KHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccessFlagBits2KHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSubmitFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_SUBMIT_PROTECTED_BIT"),
};
static void print_VkSubmitFlagBits(VkSubmitFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSubmitFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSubmitFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkSubmitFlagBits(const VkSubmitFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSubmitFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSubmitFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkSubmitFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_SUBMIT_PROTECTED_BIT"),
};
static void print_VkSubmitFlagBitsKHR(VkSubmitFlagBitsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSubmitFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSubmitFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkSubmitFlagBitsKHR(const VkSubmitFlagBitsKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSubmitFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSubmitFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkPipelineStageFlags2(VkPipelineStageFlags2 obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkAccessFlags2(VkAccessFlags2 obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkSubmitFlags(VkSubmitFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkSubmitFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkSubmitFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkMemoryBarrier2(VkMemoryBarrier2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlags2(obj.srcStageMask, "srcStageMask", 1);

    print_VkAccessFlags2(obj.srcAccessMask, "srcAccessMask", 1);

    print_VkPipelineStageFlags2(obj.dstStageMask, "dstStageMask", 1);

    print_VkAccessFlags2(obj.dstAccessMask, "dstAccessMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryBarrier2(const VkMemoryBarrier2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlags2(obj->srcStageMask, "srcStageMask", 1);

    print_VkAccessFlags2(obj->srcAccessMask, "srcAccessMask", 1);

    print_VkPipelineStageFlags2(obj->dstStageMask, "dstStageMask", 1);

    print_VkAccessFlags2(obj->dstAccessMask, "dstAccessMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkMemoryBarrier2 VkMemoryBarrier2KHR;

static void print_VkBufferMemoryBarrier2(VkBufferMemoryBarrier2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlags2(obj.srcStageMask, "srcStageMask", 1);

    print_VkAccessFlags2(obj.srcAccessMask, "srcAccessMask", 1);

    print_VkPipelineStageFlags2(obj.dstStageMask, "dstStageMask", 1);

    print_VkAccessFlags2(obj.dstAccessMask, "dstAccessMask", 1);

    print_uint32_t(obj.srcQueueFamilyIndex, "srcQueueFamilyIndex", 1);

    print_uint32_t(obj.dstQueueFamilyIndex, "dstQueueFamilyIndex", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.offset, "offset", 1);

    print_VkDeviceSize(obj.size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferMemoryBarrier2(const VkBufferMemoryBarrier2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlags2(obj->srcStageMask, "srcStageMask", 1);

    print_VkAccessFlags2(obj->srcAccessMask, "srcAccessMask", 1);

    print_VkPipelineStageFlags2(obj->dstStageMask, "dstStageMask", 1);

    print_VkAccessFlags2(obj->dstAccessMask, "dstAccessMask", 1);

    print_uint32_t(obj->srcQueueFamilyIndex, "srcQueueFamilyIndex", 1);

    print_uint32_t(obj->dstQueueFamilyIndex, "dstQueueFamilyIndex", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->offset, "offset", 1);

    print_VkDeviceSize(obj->size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkBufferMemoryBarrier2 VkBufferMemoryBarrier2KHR;

static void print_VkImageMemoryBarrier2(VkImageMemoryBarrier2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlags2(obj.srcStageMask, "srcStageMask", 1);

    print_VkAccessFlags2(obj.srcAccessMask, "srcAccessMask", 1);

    print_VkPipelineStageFlags2(obj.dstStageMask, "dstStageMask", 1);

    print_VkAccessFlags2(obj.dstAccessMask, "dstAccessMask", 1);

    print_VkImageLayout(obj.oldLayout, "oldLayout", 1);

    print_VkImageLayout(obj.newLayout, "newLayout", 1);

    print_uint32_t(obj.srcQueueFamilyIndex, "srcQueueFamilyIndex", 1);

    print_uint32_t(obj.dstQueueFamilyIndex, "dstQueueFamilyIndex", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"subresourceRange\": " << std::endl;
    { print_VkImageSubresourceRange(obj.subresourceRange, "subresourceRange", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageMemoryBarrier2(const VkImageMemoryBarrier2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlags2(obj->srcStageMask, "srcStageMask", 1);

    print_VkAccessFlags2(obj->srcAccessMask, "srcAccessMask", 1);

    print_VkPipelineStageFlags2(obj->dstStageMask, "dstStageMask", 1);

    print_VkAccessFlags2(obj->dstAccessMask, "dstAccessMask", 1);

    print_VkImageLayout(obj->oldLayout, "oldLayout", 1);

    print_VkImageLayout(obj->newLayout, "newLayout", 1);

    print_uint32_t(obj->srcQueueFamilyIndex, "srcQueueFamilyIndex", 1);

    print_uint32_t(obj->dstQueueFamilyIndex, "dstQueueFamilyIndex", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"subresourceRange\": " << std::endl;
    { print_VkImageSubresourceRange(obj->subresourceRange, "subresourceRange", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkImageMemoryBarrier2 VkImageMemoryBarrier2KHR;

static void print_VkDependencyInfo(VkDependencyInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDependencyFlags(obj.dependencyFlags, "dependencyFlags", 1);

    print_uint32_t(obj.memoryBarrierCount, "memoryBarrierCount", 1);

    PRINT_SPACE
    _OUT << "\"pMemoryBarriers\": " << std::endl;
    if (obj.pMemoryBarriers) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.memoryBarrierCount; i++) {
            if (i + 1 == obj.memoryBarrierCount)
                print_VkMemoryBarrier2(obj.pMemoryBarriers[i], "pMemoryBarriers", 0);
            else
                print_VkMemoryBarrier2(obj.pMemoryBarriers[i], "pMemoryBarriers", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.bufferMemoryBarrierCount, "bufferMemoryBarrierCount", 1);

    PRINT_SPACE
    _OUT << "\"pBufferMemoryBarriers\": " << std::endl;
    if (obj.pBufferMemoryBarriers) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.bufferMemoryBarrierCount; i++) {
            if (i + 1 == obj.bufferMemoryBarrierCount)
                print_VkBufferMemoryBarrier2(obj.pBufferMemoryBarriers[i], "pBufferMemoryBarriers", 0);
            else
                print_VkBufferMemoryBarrier2(obj.pBufferMemoryBarriers[i], "pBufferMemoryBarriers", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.imageMemoryBarrierCount, "imageMemoryBarrierCount", 1);

    PRINT_SPACE
    _OUT << "\"pImageMemoryBarriers\": " << std::endl;
    if (obj.pImageMemoryBarriers) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.imageMemoryBarrierCount; i++) {
            if (i + 1 == obj.imageMemoryBarrierCount)
                print_VkImageMemoryBarrier2(obj.pImageMemoryBarriers[i], "pImageMemoryBarriers", 0);
            else
                print_VkImageMemoryBarrier2(obj.pImageMemoryBarriers[i], "pImageMemoryBarriers", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDependencyInfo(const VkDependencyInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDependencyFlags(obj->dependencyFlags, "dependencyFlags", 1);

    print_uint32_t(obj->memoryBarrierCount, "memoryBarrierCount", 1);

    PRINT_SPACE
    _OUT << "\"pMemoryBarriers\": " << std::endl;
    if (obj->pMemoryBarriers) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->memoryBarrierCount; i++) {
            if (i + 1 == obj->memoryBarrierCount)
                print_VkMemoryBarrier2(obj->pMemoryBarriers[i], "pMemoryBarriers", 0);
            else
                print_VkMemoryBarrier2(obj->pMemoryBarriers[i], "pMemoryBarriers", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->bufferMemoryBarrierCount, "bufferMemoryBarrierCount", 1);

    PRINT_SPACE
    _OUT << "\"pBufferMemoryBarriers\": " << std::endl;
    if (obj->pBufferMemoryBarriers) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->bufferMemoryBarrierCount; i++) {
            if (i + 1 == obj->bufferMemoryBarrierCount)
                print_VkBufferMemoryBarrier2(obj->pBufferMemoryBarriers[i], "pBufferMemoryBarriers", 0);
            else
                print_VkBufferMemoryBarrier2(obj->pBufferMemoryBarriers[i], "pBufferMemoryBarriers", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->imageMemoryBarrierCount, "imageMemoryBarrierCount", 1);

    PRINT_SPACE
    _OUT << "\"pImageMemoryBarriers\": " << std::endl;
    if (obj->pImageMemoryBarriers) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->imageMemoryBarrierCount; i++) {
            if (i + 1 == obj->imageMemoryBarrierCount)
                print_VkImageMemoryBarrier2(obj->pImageMemoryBarriers[i], "pImageMemoryBarriers", 0);
            else
                print_VkImageMemoryBarrier2(obj->pImageMemoryBarriers[i], "pImageMemoryBarriers", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkDependencyInfo VkDependencyInfoKHR;

static void print_VkSemaphoreSubmitInfo(VkSemaphoreSubmitInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "semaphore"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint64_t(obj.value, "value", 1);

    print_VkPipelineStageFlags2(obj.stageMask, "stageMask", 1);

    print_uint32_t(obj.deviceIndex, "deviceIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSemaphoreSubmitInfo(const VkSemaphoreSubmitInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "semaphore"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint64_t(obj->value, "value", 1);

    print_VkPipelineStageFlags2(obj->stageMask, "stageMask", 1);

    print_uint32_t(obj->deviceIndex, "deviceIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCommandBufferSubmitInfo(VkCommandBufferSubmitInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "commandBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.deviceMask, "deviceMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCommandBufferSubmitInfo(const VkCommandBufferSubmitInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "commandBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->deviceMask, "deviceMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubmitInfo2(VkSubmitInfo2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSubmitFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.waitSemaphoreInfoCount, "waitSemaphoreInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pWaitSemaphoreInfos\": " << std::endl;
    if (obj.pWaitSemaphoreInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.waitSemaphoreInfoCount; i++) {
            if (i + 1 == obj.waitSemaphoreInfoCount)
                print_VkSemaphoreSubmitInfo(obj.pWaitSemaphoreInfos[i], "pWaitSemaphoreInfos", 0);
            else
                print_VkSemaphoreSubmitInfo(obj.pWaitSemaphoreInfos[i], "pWaitSemaphoreInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.commandBufferInfoCount, "commandBufferInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pCommandBufferInfos\": " << std::endl;
    if (obj.pCommandBufferInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.commandBufferInfoCount; i++) {
            if (i + 1 == obj.commandBufferInfoCount)
                print_VkCommandBufferSubmitInfo(obj.pCommandBufferInfos[i], "pCommandBufferInfos", 0);
            else
                print_VkCommandBufferSubmitInfo(obj.pCommandBufferInfos[i], "pCommandBufferInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.signalSemaphoreInfoCount, "signalSemaphoreInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pSignalSemaphoreInfos\": " << std::endl;
    if (obj.pSignalSemaphoreInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.signalSemaphoreInfoCount; i++) {
            if (i + 1 == obj.signalSemaphoreInfoCount)
                print_VkSemaphoreSubmitInfo(obj.pSignalSemaphoreInfos[i], "pSignalSemaphoreInfos", 0);
            else
                print_VkSemaphoreSubmitInfo(obj.pSignalSemaphoreInfos[i], "pSignalSemaphoreInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubmitInfo2(const VkSubmitInfo2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSubmitFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->waitSemaphoreInfoCount, "waitSemaphoreInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pWaitSemaphoreInfos\": " << std::endl;
    if (obj->pWaitSemaphoreInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->waitSemaphoreInfoCount; i++) {
            if (i + 1 == obj->waitSemaphoreInfoCount)
                print_VkSemaphoreSubmitInfo(obj->pWaitSemaphoreInfos[i], "pWaitSemaphoreInfos", 0);
            else
                print_VkSemaphoreSubmitInfo(obj->pWaitSemaphoreInfos[i], "pWaitSemaphoreInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->commandBufferInfoCount, "commandBufferInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pCommandBufferInfos\": " << std::endl;
    if (obj->pCommandBufferInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->commandBufferInfoCount; i++) {
            if (i + 1 == obj->commandBufferInfoCount)
                print_VkCommandBufferSubmitInfo(obj->pCommandBufferInfos[i], "pCommandBufferInfos", 0);
            else
                print_VkCommandBufferSubmitInfo(obj->pCommandBufferInfos[i], "pCommandBufferInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->signalSemaphoreInfoCount, "signalSemaphoreInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pSignalSemaphoreInfos\": " << std::endl;
    if (obj->pSignalSemaphoreInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->signalSemaphoreInfoCount; i++) {
            if (i + 1 == obj->signalSemaphoreInfoCount)
                print_VkSemaphoreSubmitInfo(obj->pSignalSemaphoreInfos[i], "pSignalSemaphoreInfos", 0);
            else
                print_VkSemaphoreSubmitInfo(obj->pSignalSemaphoreInfos[i], "pSignalSemaphoreInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkSubmitInfo2 VkSubmitInfo2KHR;

typedef VkSemaphoreSubmitInfo VkSemaphoreSubmitInfoKHR;

typedef VkCommandBufferSubmitInfo VkCommandBufferSubmitInfoKHR;

static void print_VkPhysicalDeviceSynchronization2Features(VkPhysicalDeviceSynchronization2Features obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.synchronization2, "synchronization2", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSynchronization2Features(const VkPhysicalDeviceSynchronization2Features* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->synchronization2, "synchronization2", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceSynchronization2Features VkPhysicalDeviceSynchronization2FeaturesKHR;

static void print_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.fragmentShaderBarycentric, "fragmentShaderBarycentric", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(
    const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->fragmentShaderBarycentric, "fragmentShaderBarycentric", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR obj,
                                                                         const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.triStripVertexOrderIndependentOfProvokingVertex, "triStripVertexOrderIndependentOfProvokingVertex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(
    const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->triStripVertexOrderIndependentOfProvokingVertex, "triStripVertexOrderIndependentOfProvokingVertex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(
    VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderSubgroupUniformControlFlow, "shaderSubgroupUniformControlFlow", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(
    const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderSubgroupUniformControlFlow, "shaderSubgroupUniformControlFlow", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderZeroInitializeWorkgroupMemory, "shaderZeroInitializeWorkgroupMemory", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(
    const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderZeroInitializeWorkgroupMemory, "shaderZeroInitializeWorkgroupMemory", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR;

static void print_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(
    VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.workgroupMemoryExplicitLayout, "workgroupMemoryExplicitLayout", 1);

    print_VkBool32(obj.workgroupMemoryExplicitLayoutScalarBlockLayout, "workgroupMemoryExplicitLayoutScalarBlockLayout", 1);

    print_VkBool32(obj.workgroupMemoryExplicitLayout8BitAccess, "workgroupMemoryExplicitLayout8BitAccess", 1);

    print_VkBool32(obj.workgroupMemoryExplicitLayout16BitAccess, "workgroupMemoryExplicitLayout16BitAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(
    const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->workgroupMemoryExplicitLayout, "workgroupMemoryExplicitLayout", 1);

    print_VkBool32(obj->workgroupMemoryExplicitLayoutScalarBlockLayout, "workgroupMemoryExplicitLayoutScalarBlockLayout", 1);

    print_VkBool32(obj->workgroupMemoryExplicitLayout8BitAccess, "workgroupMemoryExplicitLayout8BitAccess", 1);

    print_VkBool32(obj->workgroupMemoryExplicitLayout16BitAccess, "workgroupMemoryExplicitLayout16BitAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBufferCopy2(VkBufferCopy2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj.srcOffset, "srcOffset", 1);

    print_VkDeviceSize(obj.dstOffset, "dstOffset", 1);

    print_VkDeviceSize(obj.size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferCopy2(const VkBufferCopy2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj->srcOffset, "srcOffset", 1);

    print_VkDeviceSize(obj->dstOffset, "dstOffset", 1);

    print_VkDeviceSize(obj->size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCopyBufferInfo2(VkCopyBufferInfo2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj.pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.regionCount; i++) {
            if (i + 1 == obj.regionCount)
                print_VkBufferCopy2(obj.pRegions[i], "pRegions", 0);
            else
                print_VkBufferCopy2(obj.pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyBufferInfo2(const VkCopyBufferInfo2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj->pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->regionCount; i++) {
            if (i + 1 == obj->regionCount)
                print_VkBufferCopy2(obj->pRegions[i], "pRegions", 0);
            else
                print_VkBufferCopy2(obj->pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkCopyBufferInfo2 VkCopyBufferInfo2KHR;

static void print_VkImageCopy2(VkImageCopy2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"srcSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.srcSubresource, "srcSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"srcOffset\": " << std::endl;
    { print_VkOffset3D(obj.srcOffset, "srcOffset", 1); }

    PRINT_SPACE
    _OUT << "\"dstSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.dstSubresource, "dstSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"dstOffset\": " << std::endl;
    { print_VkOffset3D(obj.dstOffset, "dstOffset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent3D(obj.extent, "extent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageCopy2(const VkImageCopy2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"srcSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->srcSubresource, "srcSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"srcOffset\": " << std::endl;
    { print_VkOffset3D(obj->srcOffset, "srcOffset", 1); }

    PRINT_SPACE
    _OUT << "\"dstSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->dstSubresource, "dstSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"dstOffset\": " << std::endl;
    { print_VkOffset3D(obj->dstOffset, "dstOffset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent3D(obj->extent, "extent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCopyImageInfo2(VkCopyImageInfo2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.srcImageLayout, "srcImageLayout", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.dstImageLayout, "dstImageLayout", 1);

    print_uint32_t(obj.regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj.pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.regionCount; i++) {
            if (i + 1 == obj.regionCount)
                print_VkImageCopy2(obj.pRegions[i], "pRegions", 0);
            else
                print_VkImageCopy2(obj.pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyImageInfo2(const VkCopyImageInfo2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->srcImageLayout, "srcImageLayout", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->dstImageLayout, "dstImageLayout", 1);

    print_uint32_t(obj->regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj->pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->regionCount; i++) {
            if (i + 1 == obj->regionCount)
                print_VkImageCopy2(obj->pRegions[i], "pRegions", 0);
            else
                print_VkImageCopy2(obj->pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkCopyImageInfo2 VkCopyImageInfo2KHR;

static void print_VkBufferImageCopy2(VkBufferImageCopy2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj.bufferOffset, "bufferOffset", 1);

    print_uint32_t(obj.bufferRowLength, "bufferRowLength", 1);

    print_uint32_t(obj.bufferImageHeight, "bufferImageHeight", 1);

    PRINT_SPACE
    _OUT << "\"imageSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.imageSubresource, "imageSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"imageOffset\": " << std::endl;
    { print_VkOffset3D(obj.imageOffset, "imageOffset", 1); }

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent3D(obj.imageExtent, "imageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferImageCopy2(const VkBufferImageCopy2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj->bufferOffset, "bufferOffset", 1);

    print_uint32_t(obj->bufferRowLength, "bufferRowLength", 1);

    print_uint32_t(obj->bufferImageHeight, "bufferImageHeight", 1);

    PRINT_SPACE
    _OUT << "\"imageSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->imageSubresource, "imageSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"imageOffset\": " << std::endl;
    { print_VkOffset3D(obj->imageOffset, "imageOffset", 1); }

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent3D(obj->imageExtent, "imageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCopyBufferToImageInfo2(VkCopyBufferToImageInfo2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.dstImageLayout, "dstImageLayout", 1);

    print_uint32_t(obj.regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj.pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.regionCount; i++) {
            if (i + 1 == obj.regionCount)
                print_VkBufferImageCopy2(obj.pRegions[i], "pRegions", 0);
            else
                print_VkBufferImageCopy2(obj.pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyBufferToImageInfo2(const VkCopyBufferToImageInfo2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->dstImageLayout, "dstImageLayout", 1);

    print_uint32_t(obj->regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj->pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->regionCount; i++) {
            if (i + 1 == obj->regionCount)
                print_VkBufferImageCopy2(obj->pRegions[i], "pRegions", 0);
            else
                print_VkBufferImageCopy2(obj->pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkCopyBufferToImageInfo2 VkCopyBufferToImageInfo2KHR;

static void print_VkCopyImageToBufferInfo2(VkCopyImageToBufferInfo2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.srcImageLayout, "srcImageLayout", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj.pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.regionCount; i++) {
            if (i + 1 == obj.regionCount)
                print_VkBufferImageCopy2(obj.pRegions[i], "pRegions", 0);
            else
                print_VkBufferImageCopy2(obj.pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyImageToBufferInfo2(const VkCopyImageToBufferInfo2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->srcImageLayout, "srcImageLayout", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj->pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->regionCount; i++) {
            if (i + 1 == obj->regionCount)
                print_VkBufferImageCopy2(obj->pRegions[i], "pRegions", 0);
            else
                print_VkBufferImageCopy2(obj->pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkCopyImageToBufferInfo2 VkCopyImageToBufferInfo2KHR;

static void print_VkImageBlit2(VkImageBlit2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"srcSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.srcSubresource, "srcSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"srcOffsets\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_VkOffset3D(obj.srcOffsets[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"dstSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.dstSubresource, "dstSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"dstOffsets\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_VkOffset3D(obj.dstOffsets[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageBlit2(const VkImageBlit2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"srcSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->srcSubresource, "srcSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"srcOffsets\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_VkOffset3D(obj->srcOffsets[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"dstSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->dstSubresource, "dstSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"dstOffsets\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_VkOffset3D(obj->dstOffsets[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBlitImageInfo2(VkBlitImageInfo2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.srcImageLayout, "srcImageLayout", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.dstImageLayout, "dstImageLayout", 1);

    print_uint32_t(obj.regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj.pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.regionCount; i++) {
            if (i + 1 == obj.regionCount)
                print_VkImageBlit2(obj.pRegions[i], "pRegions", 0);
            else
                print_VkImageBlit2(obj.pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkFilter(obj.filter, "filter", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBlitImageInfo2(const VkBlitImageInfo2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->srcImageLayout, "srcImageLayout", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->dstImageLayout, "dstImageLayout", 1);

    print_uint32_t(obj->regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj->pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->regionCount; i++) {
            if (i + 1 == obj->regionCount)
                print_VkImageBlit2(obj->pRegions[i], "pRegions", 0);
            else
                print_VkImageBlit2(obj->pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkFilter(obj->filter, "filter", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkBlitImageInfo2 VkBlitImageInfo2KHR;

static void print_VkImageResolve2(VkImageResolve2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"srcSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.srcSubresource, "srcSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"srcOffset\": " << std::endl;
    { print_VkOffset3D(obj.srcOffset, "srcOffset", 1); }

    PRINT_SPACE
    _OUT << "\"dstSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.dstSubresource, "dstSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"dstOffset\": " << std::endl;
    { print_VkOffset3D(obj.dstOffset, "dstOffset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent3D(obj.extent, "extent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageResolve2(const VkImageResolve2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"srcSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->srcSubresource, "srcSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"srcOffset\": " << std::endl;
    { print_VkOffset3D(obj->srcOffset, "srcOffset", 1); }

    PRINT_SPACE
    _OUT << "\"dstSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->dstSubresource, "dstSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"dstOffset\": " << std::endl;
    { print_VkOffset3D(obj->dstOffset, "dstOffset", 1); }

    PRINT_SPACE
    _OUT << "\"extent\": " << std::endl;
    { print_VkExtent3D(obj->extent, "extent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkResolveImageInfo2(VkResolveImageInfo2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.srcImageLayout, "srcImageLayout", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.dstImageLayout, "dstImageLayout", 1);

    print_uint32_t(obj.regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj.pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.regionCount; i++) {
            if (i + 1 == obj.regionCount)
                print_VkImageResolve2(obj.pRegions[i], "pRegions", 0);
            else
                print_VkImageResolve2(obj.pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkResolveImageInfo2(const VkResolveImageInfo2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->srcImageLayout, "srcImageLayout", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->dstImageLayout, "dstImageLayout", 1);

    print_uint32_t(obj->regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj->pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->regionCount; i++) {
            if (i + 1 == obj->regionCount)
                print_VkImageResolve2(obj->pRegions[i], "pRegions", 0);
            else
                print_VkImageResolve2(obj->pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkResolveImageInfo2 VkResolveImageInfo2KHR;

typedef VkBufferCopy2 VkBufferCopy2KHR;

typedef VkImageCopy2 VkImageCopy2KHR;

typedef VkImageBlit2 VkImageBlit2KHR;

typedef VkBufferImageCopy2 VkBufferImageCopy2KHR;

typedef VkImageResolve2 VkImageResolve2KHR;

static std::map<uint64_t, std::string> VkFormatFeatureFlagBits2_map = {
    std::make_pair(1ULL << 0, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT"),
    std::make_pair(1ULL << 1, "VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT"),
    std::make_pair(1ULL << 2, "VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT"),
    std::make_pair(1ULL << 3, "VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT"),
    std::make_pair(1ULL << 4, "VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT"),
    std::make_pair(1ULL << 5, "VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"),
    std::make_pair(1ULL << 6, "VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT"),
    std::make_pair(1ULL << 7, "VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT"),
    std::make_pair(1ULL << 8, "VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT"),
    std::make_pair(1ULL << 9, "VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT"),
    std::make_pair(1ULL << 10, "VK_FORMAT_FEATURE_2_BLIT_SRC_BIT"),
    std::make_pair(1ULL << 11, "VK_FORMAT_FEATURE_2_BLIT_DST_BIT"),
    std::make_pair(1ULL << 12, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT"),
    std::make_pair(1ULL << 14, "VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT"),
    std::make_pair(1ULL << 15, "VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT"),
    std::make_pair(1ULL << 16, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT"),
    std::make_pair(1ULL << 17, "VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT"),
    std::make_pair(1ULL << 18, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"),
    std::make_pair(1ULL << 19, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"),
    std::make_pair(1ULL << 20, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"),
    std::make_pair(1ULL << 21, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"),
    std::make_pair(1ULL << 22, "VK_FORMAT_FEATURE_2_DISJOINT_BIT"),
    std::make_pair(1ULL << 23, "VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT"),
    std::make_pair(1ULL << 31, "VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT"),
    std::make_pair(1ULL << 32, "VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT"),
    std::make_pair(1ULL << 33, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT"),
    std::make_pair(1ULL << 13, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT"),
    std::make_pair(1ULL << 46, "VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT"),
    std::make_pair(1ULL << 25, "VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR"),
    std::make_pair(1ULL << 26, "VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR"),
    std::make_pair(1ULL << 29, "VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR"),
    std::make_pair(1ULL << 24, "VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT"),
    std::make_pair(1ULL << 30, "VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
    std::make_pair(1ULL << 44, "VK_FORMAT_FEATURE_2_RESERVED_44_BIT_EXT"),
    std::make_pair(1ULL << 45, "VK_FORMAT_FEATURE_2_RESERVED_45_BIT_EXT"),
    std::make_pair(1ULL << 27, "VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR"),
    std::make_pair(1ULL << 28, "VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR"),
    std::make_pair(1ULL << 51, "VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV"),
    std::make_pair(1ULL << 38, "VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV"),
    std::make_pair(1ULL << 34, "VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM"),
    std::make_pair(1ULL << 35, "VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM"),
    std::make_pair(1ULL << 36, "VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM"),
    std::make_pair(1ULL << 37, "VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM"),
    std::make_pair(1ULL << 47, "VK_FORMAT_FEATURE_2_RESERVED_47_BIT_ARM"),
    std::make_pair(1ULL << 39, "VK_FORMAT_FEATURE_2_RESERVED_39_BIT_EXT"),
    std::make_pair(1ULL << 40, "VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV"),
    std::make_pair(1ULL << 41, "VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV"),
    std::make_pair(1ULL << 42, "VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV"),
    std::make_pair(1ULL << 48, "VK_FORMAT_FEATURE_2_RESERVED_48_BIT_EXT"),
    std::make_pair(1ULL << 49, "VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR"),
    std::make_pair(1ULL << 50, "VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR"),
};
static void print_VkFormatFeatureFlagBits2(VkFormatFeatureFlagBits2 obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFormatFeatureFlagBits2_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFormatFeatureFlagBits2_map[obj] << "\"" << std::endl;
}
static void print_VkFormatFeatureFlagBits2(const VkFormatFeatureFlagBits2* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFormatFeatureFlagBits2_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFormatFeatureFlagBits2_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkFormatFeatureFlagBits2KHR_map = {
    std::make_pair(1ULL << 0, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT"),
    std::make_pair(1ULL << 1, "VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT"),
    std::make_pair(1ULL << 2, "VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT"),
    std::make_pair(1ULL << 3, "VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT"),
    std::make_pair(1ULL << 4, "VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT"),
    std::make_pair(1ULL << 5, "VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"),
    std::make_pair(1ULL << 6, "VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT"),
    std::make_pair(1ULL << 7, "VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT"),
    std::make_pair(1ULL << 8, "VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT"),
    std::make_pair(1ULL << 9, "VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT"),
    std::make_pair(1ULL << 10, "VK_FORMAT_FEATURE_2_BLIT_SRC_BIT"),
    std::make_pair(1ULL << 11, "VK_FORMAT_FEATURE_2_BLIT_DST_BIT"),
    std::make_pair(1ULL << 12, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT"),
    std::make_pair(1ULL << 14, "VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT"),
    std::make_pair(1ULL << 15, "VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT"),
    std::make_pair(1ULL << 16, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT"),
    std::make_pair(1ULL << 17, "VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT"),
    std::make_pair(1ULL << 18, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"),
    std::make_pair(1ULL << 19, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"),
    std::make_pair(1ULL << 20, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"),
    std::make_pair(1ULL << 21, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"),
    std::make_pair(1ULL << 22, "VK_FORMAT_FEATURE_2_DISJOINT_BIT"),
    std::make_pair(1ULL << 23, "VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT"),
    std::make_pair(1ULL << 31, "VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT"),
    std::make_pair(1ULL << 32, "VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT"),
    std::make_pair(1ULL << 33, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT"),
    std::make_pair(1ULL << 13, "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT"),
    std::make_pair(1ULL << 46, "VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT"),
    std::make_pair(1ULL << 25, "VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR"),
    std::make_pair(1ULL << 26, "VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR"),
    std::make_pair(1ULL << 29, "VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR"),
    std::make_pair(1ULL << 24, "VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT"),
    std::make_pair(1ULL << 30, "VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
    std::make_pair(1ULL << 44, "VK_FORMAT_FEATURE_2_RESERVED_44_BIT_EXT"),
    std::make_pair(1ULL << 45, "VK_FORMAT_FEATURE_2_RESERVED_45_BIT_EXT"),
    std::make_pair(1ULL << 27, "VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR"),
    std::make_pair(1ULL << 28, "VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR"),
    std::make_pair(1ULL << 51, "VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV"),
    std::make_pair(1ULL << 38, "VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV"),
    std::make_pair(1ULL << 34, "VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM"),
    std::make_pair(1ULL << 35, "VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM"),
    std::make_pair(1ULL << 36, "VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM"),
    std::make_pair(1ULL << 37, "VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM"),
    std::make_pair(1ULL << 47, "VK_FORMAT_FEATURE_2_RESERVED_47_BIT_ARM"),
    std::make_pair(1ULL << 39, "VK_FORMAT_FEATURE_2_RESERVED_39_BIT_EXT"),
    std::make_pair(1ULL << 40, "VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV"),
    std::make_pair(1ULL << 41, "VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV"),
    std::make_pair(1ULL << 42, "VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV"),
    std::make_pair(1ULL << 48, "VK_FORMAT_FEATURE_2_RESERVED_48_BIT_EXT"),
    std::make_pair(1ULL << 49, "VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR"),
    std::make_pair(1ULL << 50, "VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR"),
};
static void print_VkFormatFeatureFlagBits2KHR(VkFormatFeatureFlagBits2KHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFormatFeatureFlagBits2KHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFormatFeatureFlagBits2KHR_map[obj] << "\"" << std::endl;
}
static void print_VkFormatFeatureFlagBits2KHR(const VkFormatFeatureFlagBits2KHR* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFormatFeatureFlagBits2KHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFormatFeatureFlagBits2KHR_map[*obj] << "\"" << std::endl;
}

static void print_VkFormatFeatureFlags2(VkFormatFeatureFlags2 obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkFormatProperties3(VkFormatProperties3 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormatFeatureFlags2(obj.linearTilingFeatures, "linearTilingFeatures", 1);

    print_VkFormatFeatureFlags2(obj.optimalTilingFeatures, "optimalTilingFeatures", 1);

    print_VkFormatFeatureFlags2(obj.bufferFeatures, "bufferFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkFormatProperties3(const VkFormatProperties3* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormatFeatureFlags2(obj->linearTilingFeatures, "linearTilingFeatures", 1);

    print_VkFormatFeatureFlags2(obj->optimalTilingFeatures, "optimalTilingFeatures", 1);

    print_VkFormatFeatureFlags2(obj->bufferFeatures, "bufferFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkFormatProperties3 VkFormatProperties3KHR;

static void print_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.rayTracingMaintenance1, "rayTracingMaintenance1", 1);

    print_VkBool32(obj.rayTracingPipelineTraceRaysIndirect2, "rayTracingPipelineTraceRaysIndirect2", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->rayTracingMaintenance1, "rayTracingMaintenance1", 1);

    print_VkBool32(obj->rayTracingPipelineTraceRaysIndirect2, "rayTracingPipelineTraceRaysIndirect2", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkTraceRaysIndirectCommand2KHR(VkTraceRaysIndirectCommand2KHR obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.raygenShaderRecordAddress, "raygenShaderRecordAddress", 1);

    print_VkDeviceSize(obj.raygenShaderRecordSize, "raygenShaderRecordSize", 1);

    print_VkDeviceAddress(obj.missShaderBindingTableAddress, "missShaderBindingTableAddress", 1);

    print_VkDeviceSize(obj.missShaderBindingTableSize, "missShaderBindingTableSize", 1);

    print_VkDeviceSize(obj.missShaderBindingTableStride, "missShaderBindingTableStride", 1);

    print_VkDeviceAddress(obj.hitShaderBindingTableAddress, "hitShaderBindingTableAddress", 1);

    print_VkDeviceSize(obj.hitShaderBindingTableSize, "hitShaderBindingTableSize", 1);

    print_VkDeviceSize(obj.hitShaderBindingTableStride, "hitShaderBindingTableStride", 1);

    print_VkDeviceAddress(obj.callableShaderBindingTableAddress, "callableShaderBindingTableAddress", 1);

    print_VkDeviceSize(obj.callableShaderBindingTableSize, "callableShaderBindingTableSize", 1);

    print_VkDeviceSize(obj.callableShaderBindingTableStride, "callableShaderBindingTableStride", 1);

    print_uint32_t(obj.width, "width", 1);

    print_uint32_t(obj.height, "height", 1);

    print_uint32_t(obj.depth, "depth", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkTraceRaysIndirectCommand2KHR(const VkTraceRaysIndirectCommand2KHR* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->raygenShaderRecordAddress, "raygenShaderRecordAddress", 1);

    print_VkDeviceSize(obj->raygenShaderRecordSize, "raygenShaderRecordSize", 1);

    print_VkDeviceAddress(obj->missShaderBindingTableAddress, "missShaderBindingTableAddress", 1);

    print_VkDeviceSize(obj->missShaderBindingTableSize, "missShaderBindingTableSize", 1);

    print_VkDeviceSize(obj->missShaderBindingTableStride, "missShaderBindingTableStride", 1);

    print_VkDeviceAddress(obj->hitShaderBindingTableAddress, "hitShaderBindingTableAddress", 1);

    print_VkDeviceSize(obj->hitShaderBindingTableSize, "hitShaderBindingTableSize", 1);

    print_VkDeviceSize(obj->hitShaderBindingTableStride, "hitShaderBindingTableStride", 1);

    print_VkDeviceAddress(obj->callableShaderBindingTableAddress, "callableShaderBindingTableAddress", 1);

    print_VkDeviceSize(obj->callableShaderBindingTableSize, "callableShaderBindingTableSize", 1);

    print_VkDeviceSize(obj->callableShaderBindingTableStride, "callableShaderBindingTableStride", 1);

    print_uint32_t(obj->width, "width", 1);

    print_uint32_t(obj->height, "height", 1);

    print_uint32_t(obj->depth, "depth", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMaintenance4Features(VkPhysicalDeviceMaintenance4Features obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.maintenance4, "maintenance4", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMaintenance4Features(const VkPhysicalDeviceMaintenance4Features* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->maintenance4, "maintenance4", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceMaintenance4Features VkPhysicalDeviceMaintenance4FeaturesKHR;

static void print_VkPhysicalDeviceMaintenance4Properties(VkPhysicalDeviceMaintenance4Properties obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj.maxBufferSize, "maxBufferSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMaintenance4Properties(const VkPhysicalDeviceMaintenance4Properties* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj->maxBufferSize, "maxBufferSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceMaintenance4Properties VkPhysicalDeviceMaintenance4PropertiesKHR;

static void print_VkDeviceBufferMemoryRequirements(VkDeviceBufferMemoryRequirements obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pCreateInfo\": " << std::endl;
    if (obj.pCreateInfo) {
        print_VkBufferCreateInfo(obj.pCreateInfo, "pCreateInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceBufferMemoryRequirements(const VkDeviceBufferMemoryRequirements* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pCreateInfo\": " << std::endl;
    if (obj->pCreateInfo) {
        print_VkBufferCreateInfo(obj->pCreateInfo, "pCreateInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkDeviceBufferMemoryRequirements VkDeviceBufferMemoryRequirementsKHR;

static void print_VkDeviceImageMemoryRequirements(VkDeviceImageMemoryRequirements obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pCreateInfo\": " << std::endl;
    if (obj.pCreateInfo) {
        print_VkImageCreateInfo(obj.pCreateInfo, "pCreateInfo", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkImageAspectFlagBits(obj.planeAspect, "planeAspect", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceImageMemoryRequirements(const VkDeviceImageMemoryRequirements* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pCreateInfo\": " << std::endl;
    if (obj->pCreateInfo) {
        print_VkImageCreateInfo(obj->pCreateInfo, "pCreateInfo", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkImageAspectFlagBits(obj->planeAspect, "planeAspect", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkDeviceImageMemoryRequirements VkDeviceImageMemoryRequirementsKHR;

static void print_VkPhysicalDeviceShaderSubgroupRotateFeatures(VkPhysicalDeviceShaderSubgroupRotateFeatures obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderSubgroupRotate, "shaderSubgroupRotate", 1);

    print_VkBool32(obj.shaderSubgroupRotateClustered, "shaderSubgroupRotateClustered", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderSubgroupRotateFeatures(const VkPhysicalDeviceShaderSubgroupRotateFeatures* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderSubgroupRotate, "shaderSubgroupRotate", 1);

    print_VkBool32(obj->shaderSubgroupRotateClustered, "shaderSubgroupRotateClustered", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceShaderSubgroupRotateFeatures VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR;

static void print_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderMaximalReconvergence, "shaderMaximalReconvergence", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(
    const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderMaximalReconvergence, "shaderMaximalReconvergence", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineCreateFlagBits2_map = {
    std::make_pair(1ULL << 0, "VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT"),
    std::make_pair(1ULL << 1, "VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT"),
    std::make_pair(1ULL << 2, "VK_PIPELINE_CREATE_2_DERIVATIVE_BIT"),
    std::make_pair(1ULL << 3, "VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"),
    std::make_pair(1ULL << 4, "VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT"),
    std::make_pair(1ULL << 8, "VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT"),
    std::make_pair(1ULL << 9, "VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT"),
    std::make_pair(1ULL << 27, "VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT"),
    std::make_pair(1ULL << 30, "VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT"),
    std::make_pair(1ULL << 32, "VK_PIPELINE_CREATE_2_EXECUTION_GRAPH_BIT_AMDX"),
    std::make_pair(1ULL << 36, "VK_PIPELINE_CREATE_RESERVED_36_BIT_KHR"),
    std::make_pair(1ULL << 39, "VK_PIPELINE_CREATE_RESERVED_39_BIT_KHR"),
    std::make_pair(1ULL << 33, "VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV"),
    std::make_pair(1ULL << 34, "VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT"),
    std::make_pair(1ULL << 5, "VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV"),
    std::make_pair(1ULL << 6, "VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR"),
    std::make_pair(1ULL << 7, "VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR"),
    std::make_pair(1ULL << 10, "VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT"),
    std::make_pair(1ULL << 23, "VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT"),
    std::make_pair(1ULL << 11, "VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR"),
    std::make_pair(1ULL << 12, "VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR"),
    std::make_pair(1ULL << 13, "VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR"),
    std::make_pair(1ULL << 14, "VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR"),
    std::make_pair(1ULL << 15, "VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR"),
    std::make_pair(1ULL << 16, "VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR"),
    std::make_pair(1ULL << 17, "VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR"),
    std::make_pair(1ULL << 19, "VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR"),
    std::make_pair(1ULL << 18, "VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV"),
    std::make_pair(1ULL << 20, "VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV"),
    std::make_pair(1ULL << 21, "VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
    std::make_pair(1ULL << 22, "VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"),
    std::make_pair(1ULL << 24, "VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT"),
    std::make_pair(1ULL << 25, "VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"),
    std::make_pair(1ULL << 26, "VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"),
    std::make_pair(1ULL << 28, "VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV"),
    std::make_pair(1ULL << 29, "VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 37, "VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM"),
    std::make_pair(1ULL << 31, "VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR"),
    std::make_pair(1ULL << 38, "VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT"),
    std::make_pair(1ULL << 35, "VK_PIPELINE_CREATE_2_RESERVED_35_BIT_KHR"),
    std::make_pair(1ULL << 37, "VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM"),
};
static void print_VkPipelineCreateFlagBits2(VkPipelineCreateFlagBits2 obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCreateFlagBits2_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCreateFlagBits2_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineCreateFlagBits2(const VkPipelineCreateFlagBits2* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCreateFlagBits2_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCreateFlagBits2_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineCreateFlagBits2KHR_map = {
    std::make_pair(1ULL << 0, "VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT"),
    std::make_pair(1ULL << 1, "VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT"),
    std::make_pair(1ULL << 2, "VK_PIPELINE_CREATE_2_DERIVATIVE_BIT"),
    std::make_pair(1ULL << 3, "VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"),
    std::make_pair(1ULL << 4, "VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT"),
    std::make_pair(1ULL << 8, "VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT"),
    std::make_pair(1ULL << 9, "VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT"),
    std::make_pair(1ULL << 27, "VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT"),
    std::make_pair(1ULL << 30, "VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT"),
    std::make_pair(1ULL << 32, "VK_PIPELINE_CREATE_2_EXECUTION_GRAPH_BIT_AMDX"),
    std::make_pair(1ULL << 36, "VK_PIPELINE_CREATE_RESERVED_36_BIT_KHR"),
    std::make_pair(1ULL << 39, "VK_PIPELINE_CREATE_RESERVED_39_BIT_KHR"),
    std::make_pair(1ULL << 33, "VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV"),
    std::make_pair(1ULL << 34, "VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT"),
    std::make_pair(1ULL << 5, "VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV"),
    std::make_pair(1ULL << 6, "VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR"),
    std::make_pair(1ULL << 7, "VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR"),
    std::make_pair(1ULL << 10, "VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT"),
    std::make_pair(1ULL << 23, "VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT"),
    std::make_pair(1ULL << 11, "VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR"),
    std::make_pair(1ULL << 12, "VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR"),
    std::make_pair(1ULL << 13, "VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR"),
    std::make_pair(1ULL << 14, "VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR"),
    std::make_pair(1ULL << 15, "VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR"),
    std::make_pair(1ULL << 16, "VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR"),
    std::make_pair(1ULL << 17, "VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR"),
    std::make_pair(1ULL << 19, "VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR"),
    std::make_pair(1ULL << 18, "VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV"),
    std::make_pair(1ULL << 20, "VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV"),
    std::make_pair(1ULL << 21, "VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"),
    std::make_pair(1ULL << 22, "VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"),
    std::make_pair(1ULL << 24, "VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT"),
    std::make_pair(1ULL << 25, "VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"),
    std::make_pair(1ULL << 26, "VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"),
    std::make_pair(1ULL << 28, "VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV"),
    std::make_pair(1ULL << 29, "VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 37, "VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM"),
    std::make_pair(1ULL << 31, "VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR"),
    std::make_pair(1ULL << 38, "VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT"),
    std::make_pair(1ULL << 35, "VK_PIPELINE_CREATE_2_RESERVED_35_BIT_KHR"),
    std::make_pair(1ULL << 37, "VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM"),
};
static void print_VkPipelineCreateFlagBits2KHR(VkPipelineCreateFlagBits2KHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCreateFlagBits2KHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCreateFlagBits2KHR_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineCreateFlagBits2KHR(const VkPipelineCreateFlagBits2KHR* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCreateFlagBits2KHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCreateFlagBits2KHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkBufferUsageFlagBits2_map = {
    std::make_pair(1ULL << 0, "VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT"),
    std::make_pair(1ULL << 1, "VK_BUFFER_USAGE_2_TRANSFER_DST_BIT"),
    std::make_pair(1ULL << 2, "VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT"),
    std::make_pair(1ULL << 3, "VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT"),
    std::make_pair(1ULL << 4, "VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT"),
    std::make_pair(1ULL << 5, "VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT"),
    std::make_pair(1ULL << 6, "VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT"),
    std::make_pair(1ULL << 7, "VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT"),
    std::make_pair(1ULL << 8, "VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT"),
    std::make_pair(1ULL << 17, "VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT"),
    std::make_pair(1ULL << 25, "VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX"),
    std::make_pair(1ULL << 28, "VK_BUFFER_USAGE_2_RESERVED_28_BIT_KHR"),
    std::make_pair(1ULL << 9, "VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT"),
    std::make_pair(1ULL << 10, "VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR"),
    std::make_pair(1ULL << 11, "VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 12, "VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 13, "VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR"),
    std::make_pair(1ULL << 14, "VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR"),
    std::make_pair(1ULL << 15, "VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR"),
    std::make_pair(1ULL << 16, "VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR"),
    std::make_pair(1ULL << 19, "VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR"),
    std::make_pair(1ULL << 20, "VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR"),
    std::make_pair(1ULL << 21, "VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 22, "VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 26, "VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 23, "VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT"),
    std::make_pair(1ULL << 24, "VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT"),
    std::make_pair(1ULL << 27, "VK_BUFFER_USAGE_2_RESERVED_27_BIT_QCOM"),
    std::make_pair(1ULL << 32, "VK_BUFFER_USAGE_2_RESERVED_32_BIT_NV"),
    std::make_pair(1ULL << 31, "VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT"),
};
static void print_VkBufferUsageFlagBits2(VkBufferUsageFlagBits2 obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBufferUsageFlagBits2_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBufferUsageFlagBits2_map[obj] << "\"" << std::endl;
}
static void print_VkBufferUsageFlagBits2(const VkBufferUsageFlagBits2* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBufferUsageFlagBits2_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBufferUsageFlagBits2_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkBufferUsageFlagBits2KHR_map = {
    std::make_pair(1ULL << 0, "VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT"),
    std::make_pair(1ULL << 1, "VK_BUFFER_USAGE_2_TRANSFER_DST_BIT"),
    std::make_pair(1ULL << 2, "VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT"),
    std::make_pair(1ULL << 3, "VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT"),
    std::make_pair(1ULL << 4, "VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT"),
    std::make_pair(1ULL << 5, "VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT"),
    std::make_pair(1ULL << 6, "VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT"),
    std::make_pair(1ULL << 7, "VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT"),
    std::make_pair(1ULL << 8, "VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT"),
    std::make_pair(1ULL << 17, "VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT"),
    std::make_pair(1ULL << 25, "VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX"),
    std::make_pair(1ULL << 28, "VK_BUFFER_USAGE_2_RESERVED_28_BIT_KHR"),
    std::make_pair(1ULL << 9, "VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT"),
    std::make_pair(1ULL << 10, "VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR"),
    std::make_pair(1ULL << 11, "VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 12, "VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 13, "VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR"),
    std::make_pair(1ULL << 14, "VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR"),
    std::make_pair(1ULL << 15, "VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR"),
    std::make_pair(1ULL << 16, "VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR"),
    std::make_pair(1ULL << 19, "VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR"),
    std::make_pair(1ULL << 20, "VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR"),
    std::make_pair(1ULL << 21, "VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 22, "VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 26, "VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT"),
    std::make_pair(1ULL << 23, "VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT"),
    std::make_pair(1ULL << 24, "VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT"),
    std::make_pair(1ULL << 27, "VK_BUFFER_USAGE_2_RESERVED_27_BIT_QCOM"),
    std::make_pair(1ULL << 32, "VK_BUFFER_USAGE_2_RESERVED_32_BIT_NV"),
    std::make_pair(1ULL << 31, "VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT"),
};
static void print_VkBufferUsageFlagBits2KHR(VkBufferUsageFlagBits2KHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBufferUsageFlagBits2KHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBufferUsageFlagBits2KHR_map[obj] << "\"" << std::endl;
}
static void print_VkBufferUsageFlagBits2KHR(const VkBufferUsageFlagBits2KHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBufferUsageFlagBits2KHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBufferUsageFlagBits2KHR_map[*obj] << "\"" << std::endl;
}

static void print_VkPipelineCreateFlags2(VkPipelineCreateFlags2 obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkBufferUsageFlags2(VkBufferUsageFlags2 obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPhysicalDeviceMaintenance5Features(VkPhysicalDeviceMaintenance5Features obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.maintenance5, "maintenance5", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMaintenance5Features(const VkPhysicalDeviceMaintenance5Features* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->maintenance5, "maintenance5", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceMaintenance5Features VkPhysicalDeviceMaintenance5FeaturesKHR;

static void print_VkPhysicalDeviceMaintenance5Properties(VkPhysicalDeviceMaintenance5Properties obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.earlyFragmentMultisampleCoverageAfterSampleCounting, "earlyFragmentMultisampleCoverageAfterSampleCounting",
                   1);

    print_VkBool32(obj.earlyFragmentSampleMaskTestBeforeSampleCounting, "earlyFragmentSampleMaskTestBeforeSampleCounting", 1);

    print_VkBool32(obj.depthStencilSwizzleOneSupport, "depthStencilSwizzleOneSupport", 1);

    print_VkBool32(obj.polygonModePointSize, "polygonModePointSize", 1);

    print_VkBool32(obj.nonStrictSinglePixelWideLinesUseParallelogram, "nonStrictSinglePixelWideLinesUseParallelogram", 1);

    print_VkBool32(obj.nonStrictWideLinesUseParallelogram, "nonStrictWideLinesUseParallelogram", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMaintenance5Properties(const VkPhysicalDeviceMaintenance5Properties* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->earlyFragmentMultisampleCoverageAfterSampleCounting, "earlyFragmentMultisampleCoverageAfterSampleCounting",
                   1);

    print_VkBool32(obj->earlyFragmentSampleMaskTestBeforeSampleCounting, "earlyFragmentSampleMaskTestBeforeSampleCounting", 1);

    print_VkBool32(obj->depthStencilSwizzleOneSupport, "depthStencilSwizzleOneSupport", 1);

    print_VkBool32(obj->polygonModePointSize, "polygonModePointSize", 1);

    print_VkBool32(obj->nonStrictSinglePixelWideLinesUseParallelogram, "nonStrictSinglePixelWideLinesUseParallelogram", 1);

    print_VkBool32(obj->nonStrictWideLinesUseParallelogram, "nonStrictWideLinesUseParallelogram", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceMaintenance5Properties VkPhysicalDeviceMaintenance5PropertiesKHR;

static void print_VkRenderingAreaInfo(VkRenderingAreaInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.viewMask, "viewMask", 1);

    print_uint32_t(obj.colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachmentFormats\":" << std::endl;
    PRINT_SPACE
    if (obj.pColorAttachmentFormats) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.colorAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.colorAttachmentCount;
            print_VkFormat(obj.pColorAttachmentFormats[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj.depthAttachmentFormat, "depthAttachmentFormat", 1);

    print_VkFormat(obj.stencilAttachmentFormat, "stencilAttachmentFormat", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderingAreaInfo(const VkRenderingAreaInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->viewMask, "viewMask", 1);

    print_uint32_t(obj->colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachmentFormats\":" << std::endl;
    PRINT_SPACE
    if (obj->pColorAttachmentFormats) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->colorAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->colorAttachmentCount;
            print_VkFormat(obj->pColorAttachmentFormats[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj->depthAttachmentFormat, "depthAttachmentFormat", 1);

    print_VkFormat(obj->stencilAttachmentFormat, "stencilAttachmentFormat", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkRenderingAreaInfo VkRenderingAreaInfoKHR;

static void print_VkImageSubresource2(VkImageSubresource2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"imageSubresource\": " << std::endl;
    { print_VkImageSubresource(obj.imageSubresource, "imageSubresource", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageSubresource2(const VkImageSubresource2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"imageSubresource\": " << std::endl;
    { print_VkImageSubresource(obj->imageSubresource, "imageSubresource", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceImageSubresourceInfo(VkDeviceImageSubresourceInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pCreateInfo\": " << std::endl;
    if (obj.pCreateInfo) {
        print_VkImageCreateInfo(obj.pCreateInfo, "pCreateInfo", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pSubresource\": " << std::endl;
    if (obj.pSubresource) {
        print_VkImageSubresource2(obj.pSubresource, "pSubresource", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceImageSubresourceInfo(const VkDeviceImageSubresourceInfo* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pCreateInfo\": " << std::endl;
    if (obj->pCreateInfo) {
        print_VkImageCreateInfo(obj->pCreateInfo, "pCreateInfo", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pSubresource\": " << std::endl;
    if (obj->pSubresource) {
        print_VkImageSubresource2(obj->pSubresource, "pSubresource", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkDeviceImageSubresourceInfo VkDeviceImageSubresourceInfoKHR;

typedef VkImageSubresource2 VkImageSubresource2KHR;

static void print_VkSubresourceLayout2(VkSubresourceLayout2 obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"subresourceLayout\": " << std::endl;
    { print_VkSubresourceLayout(obj.subresourceLayout, "subresourceLayout", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubresourceLayout2(const VkSubresourceLayout2* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"subresourceLayout\": " << std::endl;
    { print_VkSubresourceLayout(obj->subresourceLayout, "subresourceLayout", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkSubresourceLayout2 VkSubresourceLayout2KHR;

static void print_VkPipelineCreateFlags2CreateInfo(VkPipelineCreateFlags2CreateInfo obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCreateFlags2(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineCreateFlags2CreateInfo(const VkPipelineCreateFlags2CreateInfo* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCreateFlags2(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPipelineCreateFlags2CreateInfo VkPipelineCreateFlags2CreateInfoKHR;

static void print_VkBufferUsageFlags2CreateInfo(VkBufferUsageFlags2CreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBufferUsageFlags2(obj.usage, "usage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferUsageFlags2CreateInfo(const VkBufferUsageFlags2CreateInfo* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBufferUsageFlags2(obj->usage, "usage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkBufferUsageFlags2CreateInfo VkBufferUsageFlags2CreateInfoKHR;

static void print_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.rayTracingPositionFetch, "rayTracingPositionFetch", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->rayTracingPositionFetch, "rayTracingPositionFetch", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineBinaryKHR(VkPipelineBinaryKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkPhysicalDevicePipelineBinaryFeaturesKHR(VkPhysicalDevicePipelineBinaryFeaturesKHR obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.pipelineBinaries, "pipelineBinaries", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePipelineBinaryFeaturesKHR(const VkPhysicalDevicePipelineBinaryFeaturesKHR* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->pipelineBinaries, "pipelineBinaries", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePipelineBinaryPropertiesKHR(VkPhysicalDevicePipelineBinaryPropertiesKHR obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.pipelineBinaryInternalCache, "pipelineBinaryInternalCache", 1);

    print_VkBool32(obj.pipelineBinaryInternalCacheControl, "pipelineBinaryInternalCacheControl", 1);

    print_VkBool32(obj.pipelineBinaryPrefersInternalCache, "pipelineBinaryPrefersInternalCache", 1);

    print_VkBool32(obj.pipelineBinaryPrecompiledInternalCache, "pipelineBinaryPrecompiledInternalCache", 1);

    print_VkBool32(obj.pipelineBinaryCompressedData, "pipelineBinaryCompressedData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePipelineBinaryPropertiesKHR(const VkPhysicalDevicePipelineBinaryPropertiesKHR* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->pipelineBinaryInternalCache, "pipelineBinaryInternalCache", 1);

    print_VkBool32(obj->pipelineBinaryInternalCacheControl, "pipelineBinaryInternalCacheControl", 1);

    print_VkBool32(obj->pipelineBinaryPrefersInternalCache, "pipelineBinaryPrefersInternalCache", 1);

    print_VkBool32(obj->pipelineBinaryPrecompiledInternalCache, "pipelineBinaryPrecompiledInternalCache", 1);

    print_VkBool32(obj->pipelineBinaryCompressedData, "pipelineBinaryCompressedData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDevicePipelineBinaryInternalCacheControlKHR(VkDevicePipelineBinaryInternalCacheControlKHR obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.disableInternalCache, "disableInternalCache", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDevicePipelineBinaryInternalCacheControlKHR(const VkDevicePipelineBinaryInternalCacheControlKHR* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->disableInternalCache, "disableInternalCache", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineBinaryKeyKHR(VkPipelineBinaryKeyKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.keySize, "keySize", 1);

    PRINT_SPACE
    _OUT << "\"key\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR;
        print_uint8_t(obj.key[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineBinaryKeyKHR(const VkPipelineBinaryKeyKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->keySize, "keySize", 1);

    PRINT_SPACE
    _OUT << "\"key\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR;
        print_uint8_t(obj->key[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineBinaryDataKHR(VkPipelineBinaryDataKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_size_t(obj.dataSize, "dataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineBinaryDataKHR(const VkPipelineBinaryDataKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_size_t(obj->dataSize, "dataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineBinaryKeysAndDataKHR(VkPipelineBinaryKeysAndDataKHR obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.binaryCount, "binaryCount", 1);

    PRINT_SPACE
    _OUT << "\"pPipelineBinaryKeys\": " << std::endl;
    if (obj.pPipelineBinaryKeys) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.binaryCount; i++) {
            if (i + 1 == obj.binaryCount)
                print_VkPipelineBinaryKeyKHR(obj.pPipelineBinaryKeys[i], "pPipelineBinaryKeys", 0);
            else
                print_VkPipelineBinaryKeyKHR(obj.pPipelineBinaryKeys[i], "pPipelineBinaryKeys", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pPipelineBinaryData\": " << std::endl;
    if (obj.pPipelineBinaryData) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.binaryCount; i++) {
            if (i + 1 == obj.binaryCount)
                print_VkPipelineBinaryDataKHR(obj.pPipelineBinaryData[i], "pPipelineBinaryData", 0);
            else
                print_VkPipelineBinaryDataKHR(obj.pPipelineBinaryData[i], "pPipelineBinaryData", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineBinaryKeysAndDataKHR(const VkPipelineBinaryKeysAndDataKHR* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->binaryCount, "binaryCount", 1);

    PRINT_SPACE
    _OUT << "\"pPipelineBinaryKeys\": " << std::endl;
    if (obj->pPipelineBinaryKeys) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->binaryCount; i++) {
            if (i + 1 == obj->binaryCount)
                print_VkPipelineBinaryKeyKHR(obj->pPipelineBinaryKeys[i], "pPipelineBinaryKeys", 0);
            else
                print_VkPipelineBinaryKeyKHR(obj->pPipelineBinaryKeys[i], "pPipelineBinaryKeys", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pPipelineBinaryData\": " << std::endl;
    if (obj->pPipelineBinaryData) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->binaryCount; i++) {
            if (i + 1 == obj->binaryCount)
                print_VkPipelineBinaryDataKHR(obj->pPipelineBinaryData[i], "pPipelineBinaryData", 0);
            else
                print_VkPipelineBinaryDataKHR(obj->pPipelineBinaryData[i], "pPipelineBinaryData", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineCreateInfoKHR(VkPipelineCreateInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineCreateInfoKHR(const VkPipelineCreateInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineBinaryCreateInfoKHR(VkPipelineBinaryCreateInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pKeysAndDataInfo\": " << std::endl;
    if (obj.pKeysAndDataInfo) {
        print_VkPipelineBinaryKeysAndDataKHR(obj.pKeysAndDataInfo, "pKeysAndDataInfo", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"pPipelineCreateInfo\": " << std::endl;
    if (obj.pPipelineCreateInfo) {
        print_VkPipelineCreateInfoKHR(obj.pPipelineCreateInfo, "pPipelineCreateInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineBinaryCreateInfoKHR(const VkPipelineBinaryCreateInfoKHR* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pKeysAndDataInfo\": " << std::endl;
    if (obj->pKeysAndDataInfo) {
        print_VkPipelineBinaryKeysAndDataKHR(obj->pKeysAndDataInfo, "pKeysAndDataInfo", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"pPipelineCreateInfo\": " << std::endl;
    if (obj->pPipelineCreateInfo) {
        print_VkPipelineCreateInfoKHR(obj->pPipelineCreateInfo, "pPipelineCreateInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineBinaryInfoKHR(VkPipelineBinaryInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.binaryCount, "binaryCount", 1);

    PRINT_SPACE
    _OUT << "\"pPipelineBinaries\":" << std::endl;
    PRINT_SPACE
    if (obj.pPipelineBinaries) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.binaryCount; i++) {
            std::stringstream tmp;
            tmp << "pPipelineBinaries"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.binaryCount;
            print_VkPipelineBinaryKHR(obj.pPipelineBinaries[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineBinaryInfoKHR(const VkPipelineBinaryInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->binaryCount, "binaryCount", 1);

    PRINT_SPACE
    _OUT << "\"pPipelineBinaries\":" << std::endl;
    PRINT_SPACE
    if (obj->pPipelineBinaries) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->binaryCount; i++) {
            std::stringstream tmp;
            tmp << "pPipelineBinaries"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->binaryCount;
            print_VkPipelineBinaryKHR(obj->pPipelineBinaries[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkReleaseCapturedPipelineDataInfoKHR(VkReleaseCapturedPipelineDataInfoKHR obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkReleaseCapturedPipelineDataInfoKHR(const VkReleaseCapturedPipelineDataInfoKHR* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineBinaryDataInfoKHR(VkPipelineBinaryDataInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipelineBinary"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineBinaryDataInfoKHR(const VkPipelineBinaryDataInfoKHR* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipelineBinary"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineBinaryHandlesInfoKHR(VkPipelineBinaryHandlesInfoKHR obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.pipelineBinaryCount, "pipelineBinaryCount", 1);

    PRINT_SPACE
    _OUT << "\"pPipelineBinaries\":" << std::endl;
    PRINT_SPACE
    if (obj.pPipelineBinaries) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.pipelineBinaryCount; i++) {
            std::stringstream tmp;
            tmp << "pPipelineBinaries"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.pipelineBinaryCount;
            print_VkPipelineBinaryKHR(obj.pPipelineBinaries[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineBinaryHandlesInfoKHR(const VkPipelineBinaryHandlesInfoKHR* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->pipelineBinaryCount, "pipelineBinaryCount", 1);

    PRINT_SPACE
    _OUT << "\"pPipelineBinaries\":" << std::endl;
    PRINT_SPACE
    if (obj->pPipelineBinaries) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->pipelineBinaryCount; i++) {
            std::stringstream tmp;
            tmp << "pPipelineBinaries"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->pipelineBinaryCount;
            print_VkPipelineBinaryKHR(obj->pPipelineBinaries[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkComponentTypeKHR_map = {
    std::make_pair(0, "VK_COMPONENT_TYPE_FLOAT16_KHR"),
    std::make_pair(1, "VK_COMPONENT_TYPE_FLOAT32_KHR"),
    std::make_pair(2, "VK_COMPONENT_TYPE_FLOAT64_KHR"),
    std::make_pair(3, "VK_COMPONENT_TYPE_SINT8_KHR"),
    std::make_pair(4, "VK_COMPONENT_TYPE_SINT16_KHR"),
    std::make_pair(5, "VK_COMPONENT_TYPE_SINT32_KHR"),
    std::make_pair(6, "VK_COMPONENT_TYPE_SINT64_KHR"),
    std::make_pair(7, "VK_COMPONENT_TYPE_UINT8_KHR"),
    std::make_pair(8, "VK_COMPONENT_TYPE_UINT16_KHR"),
    std::make_pair(9, "VK_COMPONENT_TYPE_UINT32_KHR"),
    std::make_pair(10, "VK_COMPONENT_TYPE_UINT64_KHR"),
    std::make_pair(1000491000, "VK_COMPONENT_TYPE_SINT8_PACKED_NV"),
    std::make_pair(1000491001, "VK_COMPONENT_TYPE_UINT8_PACKED_NV"),
    std::make_pair(1000491002, "VK_COMPONENT_TYPE_FLOAT_E4M3_NV"),
    std::make_pair(1000491003, "VK_COMPONENT_TYPE_FLOAT_E5M2_NV"),
};
static void print_VkComponentTypeKHR(VkComponentTypeKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkComponentTypeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkComponentTypeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkComponentTypeKHR(const VkComponentTypeKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkComponentTypeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkComponentTypeKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkScopeKHR_map = {
    std::make_pair(1, "VK_SCOPE_DEVICE_KHR"),
    std::make_pair(2, "VK_SCOPE_WORKGROUP_KHR"),
    std::make_pair(3, "VK_SCOPE_SUBGROUP_KHR"),
    std::make_pair(5, "VK_SCOPE_QUEUE_FAMILY_KHR"),
};
static void print_VkScopeKHR(VkScopeKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkScopeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkScopeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkScopeKHR(const VkScopeKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkScopeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkScopeKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkCooperativeMatrixPropertiesKHR(VkCooperativeMatrixPropertiesKHR obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.MSize, "MSize", 1);

    print_uint32_t(obj.NSize, "NSize", 1);

    print_uint32_t(obj.KSize, "KSize", 1);

    print_VkComponentTypeKHR(obj.AType, "AType", 1);

    print_VkComponentTypeKHR(obj.BType, "BType", 1);

    print_VkComponentTypeKHR(obj.CType, "CType", 1);

    print_VkComponentTypeKHR(obj.ResultType, "ResultType", 1);

    print_VkBool32(obj.saturatingAccumulation, "saturatingAccumulation", 1);

    print_VkScopeKHR(obj.scope, "scope", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCooperativeMatrixPropertiesKHR(const VkCooperativeMatrixPropertiesKHR* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->MSize, "MSize", 1);

    print_uint32_t(obj->NSize, "NSize", 1);

    print_uint32_t(obj->KSize, "KSize", 1);

    print_VkComponentTypeKHR(obj->AType, "AType", 1);

    print_VkComponentTypeKHR(obj->BType, "BType", 1);

    print_VkComponentTypeKHR(obj->CType, "CType", 1);

    print_VkComponentTypeKHR(obj->ResultType, "ResultType", 1);

    print_VkBool32(obj->saturatingAccumulation, "saturatingAccumulation", 1);

    print_VkScopeKHR(obj->scope, "scope", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(VkPhysicalDeviceCooperativeMatrixFeaturesKHR obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.cooperativeMatrix, "cooperativeMatrix", 1);

    print_VkBool32(obj.cooperativeMatrixRobustBufferAccess, "cooperativeMatrixRobustBufferAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(const VkPhysicalDeviceCooperativeMatrixFeaturesKHR* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->cooperativeMatrix, "cooperativeMatrix", 1);

    print_VkBool32(obj->cooperativeMatrixRobustBufferAccess, "cooperativeMatrixRobustBufferAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDeviceCooperativeMatrixPropertiesKHR obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj.cooperativeMatrixSupportedStages, "cooperativeMatrixSupportedStages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(const VkPhysicalDeviceCooperativeMatrixPropertiesKHR* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj->cooperativeMatrixSupportedStages, "cooperativeMatrixSupportedStages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.computeDerivativeGroupQuads, "computeDerivativeGroupQuads", 1);

    print_VkBool32(obj.computeDerivativeGroupLinear, "computeDerivativeGroupLinear", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(
    const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->computeDerivativeGroupQuads, "computeDerivativeGroupQuads", 1);

    print_VkBool32(obj->computeDerivativeGroupLinear, "computeDerivativeGroupLinear", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.meshAndTaskShaderDerivatives, "meshAndTaskShaderDerivatives", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(
    const VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->meshAndTaskShaderDerivatives, "meshAndTaskShaderDerivatives", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeAV1ProfileInfoKHR(VkVideoDecodeAV1ProfileInfoKHR obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoAV1Profile(obj.stdProfile, "stdProfile", 1);

    print_VkBool32(obj.filmGrainSupport, "filmGrainSupport", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeAV1ProfileInfoKHR(const VkVideoDecodeAV1ProfileInfoKHR* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoAV1Profile(obj->stdProfile, "stdProfile", 1);

    print_VkBool32(obj->filmGrainSupport, "filmGrainSupport", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeAV1CapabilitiesKHR(VkVideoDecodeAV1CapabilitiesKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoAV1Level(obj.maxLevel, "maxLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeAV1CapabilitiesKHR(const VkVideoDecodeAV1CapabilitiesKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoAV1Level(obj->maxLevel, "maxLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeAV1SessionParametersCreateInfoKHR(VkVideoDecodeAV1SessionParametersCreateInfoKHR obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoAV1SequenceHeader(obj.pStdSequenceHeader, "pStdSequenceHeader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeAV1SessionParametersCreateInfoKHR(const VkVideoDecodeAV1SessionParametersCreateInfoKHR* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoAV1SequenceHeader(obj->pStdSequenceHeader, "pStdSequenceHeader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeAV1PictureInfoKHR(VkVideoDecodeAV1PictureInfoKHR obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoDecodeAV1PictureInfo(obj.pStdPictureInfo, "pStdPictureInfo", 1);

    PRINT_SPACE
    _OUT << "\"referenceNameSlotIndices\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR;
        print_int32_t(obj.referenceNameSlotIndices[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.frameHeaderOffset, "frameHeaderOffset", 1);

    print_uint32_t(obj.tileCount, "tileCount", 1);

    PRINT_SPACE
    _OUT << "\"pTileOffsets\":" << std::endl;
    PRINT_SPACE
    if (obj.pTileOffsets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.tileCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.tileCount;
            print_uint32_t(obj.pTileOffsets[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pTileSizes\":" << std::endl;
    PRINT_SPACE
    if (obj.pTileSizes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.tileCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.tileCount;
            print_uint32_t(obj.pTileSizes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeAV1PictureInfoKHR(const VkVideoDecodeAV1PictureInfoKHR* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoDecodeAV1PictureInfo(obj->pStdPictureInfo, "pStdPictureInfo", 1);

    PRINT_SPACE
    _OUT << "\"referenceNameSlotIndices\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR;
        print_int32_t(obj->referenceNameSlotIndices[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->frameHeaderOffset, "frameHeaderOffset", 1);

    print_uint32_t(obj->tileCount, "tileCount", 1);

    PRINT_SPACE
    _OUT << "\"pTileOffsets\":" << std::endl;
    PRINT_SPACE
    if (obj->pTileOffsets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->tileCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->tileCount;
            print_uint32_t(obj->pTileOffsets[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pTileSizes\":" << std::endl;
    PRINT_SPACE
    if (obj->pTileSizes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->tileCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->tileCount;
            print_uint32_t(obj->pTileSizes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeAV1DpbSlotInfoKHR(VkVideoDecodeAV1DpbSlotInfoKHR obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoDecodeAV1ReferenceInfo(obj.pStdReferenceInfo, "pStdReferenceInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeAV1DpbSlotInfoKHR(const VkVideoDecodeAV1DpbSlotInfoKHR* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoDecodeAV1ReferenceInfo(obj->pStdReferenceInfo, "pStdReferenceInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeAV1PredictionModeKHR_map = {
    std::make_pair(0, "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR"),
    std::make_pair(1, "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR"),
    std::make_pair(2, "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR"),
    std::make_pair(3, "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR"),
};
static void print_VkVideoEncodeAV1PredictionModeKHR(VkVideoEncodeAV1PredictionModeKHR obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeAV1PredictionModeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeAV1PredictionModeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeAV1PredictionModeKHR(const VkVideoEncodeAV1PredictionModeKHR* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeAV1PredictionModeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeAV1PredictionModeKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeAV1RateControlGroupKHR_map = {
    std::make_pair(0, "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR"),
    std::make_pair(1, "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR"),
    std::make_pair(2, "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR"),
};
static void print_VkVideoEncodeAV1RateControlGroupKHR(VkVideoEncodeAV1RateControlGroupKHR obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeAV1RateControlGroupKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeAV1RateControlGroupKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeAV1RateControlGroupKHR(const VkVideoEncodeAV1RateControlGroupKHR* obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeAV1RateControlGroupKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeAV1RateControlGroupKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeAV1CapabilityFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR"),
    std::make_pair(1ULL << 5, "VK_VIDEO_ENCODE_AV1_CAPABILITY_RESERVED_5_BIT_KHR"),
};
static void print_VkVideoEncodeAV1CapabilityFlagBitsKHR(VkVideoEncodeAV1CapabilityFlagBitsKHR obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeAV1CapabilityFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeAV1CapabilityFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeAV1CapabilityFlagBitsKHR(const VkVideoEncodeAV1CapabilityFlagBitsKHR* obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeAV1CapabilityFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeAV1CapabilityFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeAV1StdFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR"),
};
static void print_VkVideoEncodeAV1StdFlagBitsKHR(VkVideoEncodeAV1StdFlagBitsKHR obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeAV1StdFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeAV1StdFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeAV1StdFlagBitsKHR(const VkVideoEncodeAV1StdFlagBitsKHR* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeAV1StdFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeAV1StdFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeAV1SuperblockSizeFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR"),
};
static void print_VkVideoEncodeAV1SuperblockSizeFlagBitsKHR(VkVideoEncodeAV1SuperblockSizeFlagBitsKHR obj, const std::string& str,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeAV1SuperblockSizeFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeAV1SuperblockSizeFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeAV1SuperblockSizeFlagBitsKHR(const VkVideoEncodeAV1SuperblockSizeFlagBitsKHR* obj,
                                                            const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeAV1SuperblockSizeFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeAV1SuperblockSizeFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkVideoEncodeAV1RateControlFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR"),
};
static void print_VkVideoEncodeAV1RateControlFlagBitsKHR(VkVideoEncodeAV1RateControlFlagBitsKHR obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeAV1RateControlFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeAV1RateControlFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkVideoEncodeAV1RateControlFlagBitsKHR(const VkVideoEncodeAV1RateControlFlagBitsKHR* obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkVideoEncodeAV1RateControlFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkVideoEncodeAV1RateControlFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkVideoEncodeAV1CapabilityFlagsKHR(VkVideoEncodeAV1CapabilityFlagsKHR obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeAV1CapabilityFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeAV1CapabilityFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeAV1StdFlagsKHR(VkVideoEncodeAV1StdFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeAV1StdFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeAV1StdFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeAV1SuperblockSizeFlagsKHR(VkVideoEncodeAV1SuperblockSizeFlagsKHR obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeAV1SuperblockSizeFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeAV1SuperblockSizeFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkVideoEncodeAV1RateControlFlagsKHR(VkVideoEncodeAV1RateControlFlagsKHR obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkVideoEncodeAV1RateControlFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkVideoEncodeAV1RateControlFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(VkPhysicalDeviceVideoEncodeAV1FeaturesKHR obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.videoEncodeAV1, "videoEncodeAV1", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->videoEncodeAV1, "videoEncodeAV1", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeAV1CapabilitiesKHR(VkVideoEncodeAV1CapabilitiesKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeAV1CapabilityFlagsKHR(obj.flags, "flags", 1);

    print_StdVideoAV1Level(obj.maxLevel, "maxLevel", 1);

    PRINT_SPACE
    _OUT << "\"codedPictureAlignment\": " << std::endl;
    { print_VkExtent2D(obj.codedPictureAlignment, "codedPictureAlignment", 1); }

    PRINT_SPACE
    _OUT << "\"maxTiles\": " << std::endl;
    { print_VkExtent2D(obj.maxTiles, "maxTiles", 1); }

    PRINT_SPACE
    _OUT << "\"minTileSize\": " << std::endl;
    { print_VkExtent2D(obj.minTileSize, "minTileSize", 1); }

    PRINT_SPACE
    _OUT << "\"maxTileSize\": " << std::endl;
    { print_VkExtent2D(obj.maxTileSize, "maxTileSize", 1); }

    print_VkVideoEncodeAV1SuperblockSizeFlagsKHR(obj.superblockSizes, "superblockSizes", 1);

    print_uint32_t(obj.maxSingleReferenceCount, "maxSingleReferenceCount", 1);

    print_uint32_t(obj.singleReferenceNameMask, "singleReferenceNameMask", 1);

    print_uint32_t(obj.maxUnidirectionalCompoundReferenceCount, "maxUnidirectionalCompoundReferenceCount", 1);

    print_uint32_t(obj.maxUnidirectionalCompoundGroup1ReferenceCount, "maxUnidirectionalCompoundGroup1ReferenceCount", 1);

    print_uint32_t(obj.unidirectionalCompoundReferenceNameMask, "unidirectionalCompoundReferenceNameMask", 1);

    print_uint32_t(obj.maxBidirectionalCompoundReferenceCount, "maxBidirectionalCompoundReferenceCount", 1);

    print_uint32_t(obj.maxBidirectionalCompoundGroup1ReferenceCount, "maxBidirectionalCompoundGroup1ReferenceCount", 1);

    print_uint32_t(obj.maxBidirectionalCompoundGroup2ReferenceCount, "maxBidirectionalCompoundGroup2ReferenceCount", 1);

    print_uint32_t(obj.bidirectionalCompoundReferenceNameMask, "bidirectionalCompoundReferenceNameMask", 1);

    print_uint32_t(obj.maxTemporalLayerCount, "maxTemporalLayerCount", 1);

    print_uint32_t(obj.maxSpatialLayerCount, "maxSpatialLayerCount", 1);

    print_uint32_t(obj.maxOperatingPoints, "maxOperatingPoints", 1);

    print_uint32_t(obj.minQIndex, "minQIndex", 1);

    print_uint32_t(obj.maxQIndex, "maxQIndex", 1);

    print_VkBool32(obj.prefersGopRemainingFrames, "prefersGopRemainingFrames", 1);

    print_VkBool32(obj.requiresGopRemainingFrames, "requiresGopRemainingFrames", 1);

    print_VkVideoEncodeAV1StdFlagsKHR(obj.stdSyntaxFlags, "stdSyntaxFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeAV1CapabilitiesKHR(const VkVideoEncodeAV1CapabilitiesKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeAV1CapabilityFlagsKHR(obj->flags, "flags", 1);

    print_StdVideoAV1Level(obj->maxLevel, "maxLevel", 1);

    PRINT_SPACE
    _OUT << "\"codedPictureAlignment\": " << std::endl;
    { print_VkExtent2D(obj->codedPictureAlignment, "codedPictureAlignment", 1); }

    PRINT_SPACE
    _OUT << "\"maxTiles\": " << std::endl;
    { print_VkExtent2D(obj->maxTiles, "maxTiles", 1); }

    PRINT_SPACE
    _OUT << "\"minTileSize\": " << std::endl;
    { print_VkExtent2D(obj->minTileSize, "minTileSize", 1); }

    PRINT_SPACE
    _OUT << "\"maxTileSize\": " << std::endl;
    { print_VkExtent2D(obj->maxTileSize, "maxTileSize", 1); }

    print_VkVideoEncodeAV1SuperblockSizeFlagsKHR(obj->superblockSizes, "superblockSizes", 1);

    print_uint32_t(obj->maxSingleReferenceCount, "maxSingleReferenceCount", 1);

    print_uint32_t(obj->singleReferenceNameMask, "singleReferenceNameMask", 1);

    print_uint32_t(obj->maxUnidirectionalCompoundReferenceCount, "maxUnidirectionalCompoundReferenceCount", 1);

    print_uint32_t(obj->maxUnidirectionalCompoundGroup1ReferenceCount, "maxUnidirectionalCompoundGroup1ReferenceCount", 1);

    print_uint32_t(obj->unidirectionalCompoundReferenceNameMask, "unidirectionalCompoundReferenceNameMask", 1);

    print_uint32_t(obj->maxBidirectionalCompoundReferenceCount, "maxBidirectionalCompoundReferenceCount", 1);

    print_uint32_t(obj->maxBidirectionalCompoundGroup1ReferenceCount, "maxBidirectionalCompoundGroup1ReferenceCount", 1);

    print_uint32_t(obj->maxBidirectionalCompoundGroup2ReferenceCount, "maxBidirectionalCompoundGroup2ReferenceCount", 1);

    print_uint32_t(obj->bidirectionalCompoundReferenceNameMask, "bidirectionalCompoundReferenceNameMask", 1);

    print_uint32_t(obj->maxTemporalLayerCount, "maxTemporalLayerCount", 1);

    print_uint32_t(obj->maxSpatialLayerCount, "maxSpatialLayerCount", 1);

    print_uint32_t(obj->maxOperatingPoints, "maxOperatingPoints", 1);

    print_uint32_t(obj->minQIndex, "minQIndex", 1);

    print_uint32_t(obj->maxQIndex, "maxQIndex", 1);

    print_VkBool32(obj->prefersGopRemainingFrames, "prefersGopRemainingFrames", 1);

    print_VkBool32(obj->requiresGopRemainingFrames, "requiresGopRemainingFrames", 1);

    print_VkVideoEncodeAV1StdFlagsKHR(obj->stdSyntaxFlags, "stdSyntaxFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeAV1QIndexKHR(VkVideoEncodeAV1QIndexKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.intraQIndex, "intraQIndex", 1);

    print_uint32_t(obj.predictiveQIndex, "predictiveQIndex", 1);

    print_uint32_t(obj.bipredictiveQIndex, "bipredictiveQIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeAV1QIndexKHR(const VkVideoEncodeAV1QIndexKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->intraQIndex, "intraQIndex", 1);

    print_uint32_t(obj->predictiveQIndex, "predictiveQIndex", 1);

    print_uint32_t(obj->bipredictiveQIndex, "bipredictiveQIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeAV1QualityLevelPropertiesKHR(VkVideoEncodeAV1QualityLevelPropertiesKHR obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeAV1RateControlFlagsKHR(obj.preferredRateControlFlags, "preferredRateControlFlags", 1);

    print_uint32_t(obj.preferredGopFrameCount, "preferredGopFrameCount", 1);

    print_uint32_t(obj.preferredKeyFramePeriod, "preferredKeyFramePeriod", 1);

    print_uint32_t(obj.preferredConsecutiveBipredictiveFrameCount, "preferredConsecutiveBipredictiveFrameCount", 1);

    print_uint32_t(obj.preferredTemporalLayerCount, "preferredTemporalLayerCount", 1);

    PRINT_SPACE
    _OUT << "\"preferredConstantQIndex\": " << std::endl;
    { print_VkVideoEncodeAV1QIndexKHR(obj.preferredConstantQIndex, "preferredConstantQIndex", 1); }

    print_uint32_t(obj.preferredMaxSingleReferenceCount, "preferredMaxSingleReferenceCount", 1);

    print_uint32_t(obj.preferredSingleReferenceNameMask, "preferredSingleReferenceNameMask", 1);

    print_uint32_t(obj.preferredMaxUnidirectionalCompoundReferenceCount, "preferredMaxUnidirectionalCompoundReferenceCount", 1);

    print_uint32_t(obj.preferredMaxUnidirectionalCompoundGroup1ReferenceCount,
                   "preferredMaxUnidirectionalCompoundGroup1ReferenceCount", 1);

    print_uint32_t(obj.preferredUnidirectionalCompoundReferenceNameMask, "preferredUnidirectionalCompoundReferenceNameMask", 1);

    print_uint32_t(obj.preferredMaxBidirectionalCompoundReferenceCount, "preferredMaxBidirectionalCompoundReferenceCount", 1);

    print_uint32_t(obj.preferredMaxBidirectionalCompoundGroup1ReferenceCount,
                   "preferredMaxBidirectionalCompoundGroup1ReferenceCount", 1);

    print_uint32_t(obj.preferredMaxBidirectionalCompoundGroup2ReferenceCount,
                   "preferredMaxBidirectionalCompoundGroup2ReferenceCount", 1);

    print_uint32_t(obj.preferredBidirectionalCompoundReferenceNameMask, "preferredBidirectionalCompoundReferenceNameMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeAV1QualityLevelPropertiesKHR(const VkVideoEncodeAV1QualityLevelPropertiesKHR* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeAV1RateControlFlagsKHR(obj->preferredRateControlFlags, "preferredRateControlFlags", 1);

    print_uint32_t(obj->preferredGopFrameCount, "preferredGopFrameCount", 1);

    print_uint32_t(obj->preferredKeyFramePeriod, "preferredKeyFramePeriod", 1);

    print_uint32_t(obj->preferredConsecutiveBipredictiveFrameCount, "preferredConsecutiveBipredictiveFrameCount", 1);

    print_uint32_t(obj->preferredTemporalLayerCount, "preferredTemporalLayerCount", 1);

    PRINT_SPACE
    _OUT << "\"preferredConstantQIndex\": " << std::endl;
    { print_VkVideoEncodeAV1QIndexKHR(obj->preferredConstantQIndex, "preferredConstantQIndex", 1); }

    print_uint32_t(obj->preferredMaxSingleReferenceCount, "preferredMaxSingleReferenceCount", 1);

    print_uint32_t(obj->preferredSingleReferenceNameMask, "preferredSingleReferenceNameMask", 1);

    print_uint32_t(obj->preferredMaxUnidirectionalCompoundReferenceCount, "preferredMaxUnidirectionalCompoundReferenceCount", 1);

    print_uint32_t(obj->preferredMaxUnidirectionalCompoundGroup1ReferenceCount,
                   "preferredMaxUnidirectionalCompoundGroup1ReferenceCount", 1);

    print_uint32_t(obj->preferredUnidirectionalCompoundReferenceNameMask, "preferredUnidirectionalCompoundReferenceNameMask", 1);

    print_uint32_t(obj->preferredMaxBidirectionalCompoundReferenceCount, "preferredMaxBidirectionalCompoundReferenceCount", 1);

    print_uint32_t(obj->preferredMaxBidirectionalCompoundGroup1ReferenceCount,
                   "preferredMaxBidirectionalCompoundGroup1ReferenceCount", 1);

    print_uint32_t(obj->preferredMaxBidirectionalCompoundGroup2ReferenceCount,
                   "preferredMaxBidirectionalCompoundGroup2ReferenceCount", 1);

    print_uint32_t(obj->preferredBidirectionalCompoundReferenceNameMask, "preferredBidirectionalCompoundReferenceNameMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeAV1SessionCreateInfoKHR(VkVideoEncodeAV1SessionCreateInfoKHR obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.useMaxLevel, "useMaxLevel", 1);

    print_StdVideoAV1Level(obj.maxLevel, "maxLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeAV1SessionCreateInfoKHR(const VkVideoEncodeAV1SessionCreateInfoKHR* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->useMaxLevel, "useMaxLevel", 1);

    print_StdVideoAV1Level(obj->maxLevel, "maxLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeAV1SessionParametersCreateInfoKHR(VkVideoEncodeAV1SessionParametersCreateInfoKHR obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoAV1SequenceHeader(obj.pStdSequenceHeader, "pStdSequenceHeader", 1);

    print_StdVideoEncodeAV1DecoderModelInfo(obj.pStdDecoderModelInfo, "pStdDecoderModelInfo", 1);

    print_uint32_t(obj.stdOperatingPointCount, "stdOperatingPointCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdOperatingPoints\":" << std::endl;
    PRINT_SPACE
    if (obj.pStdOperatingPoints) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stdOperatingPointCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.stdOperatingPointCount;
            print_StdVideoEncodeAV1OperatingPointInfo(obj.pStdOperatingPoints[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeAV1SessionParametersCreateInfoKHR(const VkVideoEncodeAV1SessionParametersCreateInfoKHR* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoAV1SequenceHeader(obj->pStdSequenceHeader, "pStdSequenceHeader", 1);

    print_StdVideoEncodeAV1DecoderModelInfo(obj->pStdDecoderModelInfo, "pStdDecoderModelInfo", 1);

    print_uint32_t(obj->stdOperatingPointCount, "stdOperatingPointCount", 1);

    PRINT_SPACE
    _OUT << "\"pStdOperatingPoints\":" << std::endl;
    PRINT_SPACE
    if (obj->pStdOperatingPoints) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stdOperatingPointCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->stdOperatingPointCount;
            print_StdVideoEncodeAV1OperatingPointInfo(obj->pStdOperatingPoints[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeAV1PictureInfoKHR(VkVideoEncodeAV1PictureInfoKHR obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeAV1PredictionModeKHR(obj.predictionMode, "predictionMode", 1);

    print_VkVideoEncodeAV1RateControlGroupKHR(obj.rateControlGroup, "rateControlGroup", 1);

    print_uint32_t(obj.constantQIndex, "constantQIndex", 1);

    print_StdVideoEncodeAV1PictureInfo(obj.pStdPictureInfo, "pStdPictureInfo", 1);

    PRINT_SPACE
    _OUT << "\"referenceNameSlotIndices\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR;
        print_int32_t(obj.referenceNameSlotIndices[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkBool32(obj.primaryReferenceCdfOnly, "primaryReferenceCdfOnly", 1);

    print_VkBool32(obj.generateObuExtensionHeader, "generateObuExtensionHeader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeAV1PictureInfoKHR(const VkVideoEncodeAV1PictureInfoKHR* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeAV1PredictionModeKHR(obj->predictionMode, "predictionMode", 1);

    print_VkVideoEncodeAV1RateControlGroupKHR(obj->rateControlGroup, "rateControlGroup", 1);

    print_uint32_t(obj->constantQIndex, "constantQIndex", 1);

    print_StdVideoEncodeAV1PictureInfo(obj->pStdPictureInfo, "pStdPictureInfo", 1);

    PRINT_SPACE
    _OUT << "\"referenceNameSlotIndices\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR;
        print_int32_t(obj->referenceNameSlotIndices[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkBool32(obj->primaryReferenceCdfOnly, "primaryReferenceCdfOnly", 1);

    print_VkBool32(obj->generateObuExtensionHeader, "generateObuExtensionHeader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeAV1DpbSlotInfoKHR(VkVideoEncodeAV1DpbSlotInfoKHR obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoEncodeAV1ReferenceInfo(obj.pStdReferenceInfo, "pStdReferenceInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeAV1DpbSlotInfoKHR(const VkVideoEncodeAV1DpbSlotInfoKHR* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoEncodeAV1ReferenceInfo(obj->pStdReferenceInfo, "pStdReferenceInfo", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeAV1ProfileInfoKHR(VkVideoEncodeAV1ProfileInfoKHR obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoAV1Profile(obj.stdProfile, "stdProfile", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeAV1ProfileInfoKHR(const VkVideoEncodeAV1ProfileInfoKHR* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoAV1Profile(obj->stdProfile, "stdProfile", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeAV1FrameSizeKHR(VkVideoEncodeAV1FrameSizeKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.intraFrameSize, "intraFrameSize", 1);

    print_uint32_t(obj.predictiveFrameSize, "predictiveFrameSize", 1);

    print_uint32_t(obj.bipredictiveFrameSize, "bipredictiveFrameSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeAV1FrameSizeKHR(const VkVideoEncodeAV1FrameSizeKHR* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->intraFrameSize, "intraFrameSize", 1);

    print_uint32_t(obj->predictiveFrameSize, "predictiveFrameSize", 1);

    print_uint32_t(obj->bipredictiveFrameSize, "bipredictiveFrameSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeAV1GopRemainingFrameInfoKHR(VkVideoEncodeAV1GopRemainingFrameInfoKHR obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.useGopRemainingFrames, "useGopRemainingFrames", 1);

    print_uint32_t(obj.gopRemainingIntra, "gopRemainingIntra", 1);

    print_uint32_t(obj.gopRemainingPredictive, "gopRemainingPredictive", 1);

    print_uint32_t(obj.gopRemainingBipredictive, "gopRemainingBipredictive", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeAV1GopRemainingFrameInfoKHR(const VkVideoEncodeAV1GopRemainingFrameInfoKHR* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->useGopRemainingFrames, "useGopRemainingFrames", 1);

    print_uint32_t(obj->gopRemainingIntra, "gopRemainingIntra", 1);

    print_uint32_t(obj->gopRemainingPredictive, "gopRemainingPredictive", 1);

    print_uint32_t(obj->gopRemainingBipredictive, "gopRemainingBipredictive", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeAV1RateControlInfoKHR(VkVideoEncodeAV1RateControlInfoKHR obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeAV1RateControlFlagsKHR(obj.flags, "flags", 1);

    print_uint32_t(obj.gopFrameCount, "gopFrameCount", 1);

    print_uint32_t(obj.keyFramePeriod, "keyFramePeriod", 1);

    print_uint32_t(obj.consecutiveBipredictiveFrameCount, "consecutiveBipredictiveFrameCount", 1);

    print_uint32_t(obj.temporalLayerCount, "temporalLayerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeAV1RateControlInfoKHR(const VkVideoEncodeAV1RateControlInfoKHR* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeAV1RateControlFlagsKHR(obj->flags, "flags", 1);

    print_uint32_t(obj->gopFrameCount, "gopFrameCount", 1);

    print_uint32_t(obj->keyFramePeriod, "keyFramePeriod", 1);

    print_uint32_t(obj->consecutiveBipredictiveFrameCount, "consecutiveBipredictiveFrameCount", 1);

    print_uint32_t(obj->temporalLayerCount, "temporalLayerCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeAV1RateControlLayerInfoKHR(VkVideoEncodeAV1RateControlLayerInfoKHR obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.useMinQIndex, "useMinQIndex", 1);

    PRINT_SPACE
    _OUT << "\"minQIndex\": " << std::endl;
    { print_VkVideoEncodeAV1QIndexKHR(obj.minQIndex, "minQIndex", 1); }

    print_VkBool32(obj.useMaxQIndex, "useMaxQIndex", 1);

    PRINT_SPACE
    _OUT << "\"maxQIndex\": " << std::endl;
    { print_VkVideoEncodeAV1QIndexKHR(obj.maxQIndex, "maxQIndex", 1); }

    print_VkBool32(obj.useMaxFrameSize, "useMaxFrameSize", 1);

    PRINT_SPACE
    _OUT << "\"maxFrameSize\": " << std::endl;
    { print_VkVideoEncodeAV1FrameSizeKHR(obj.maxFrameSize, "maxFrameSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeAV1RateControlLayerInfoKHR(const VkVideoEncodeAV1RateControlLayerInfoKHR* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->useMinQIndex, "useMinQIndex", 1);

    PRINT_SPACE
    _OUT << "\"minQIndex\": " << std::endl;
    { print_VkVideoEncodeAV1QIndexKHR(obj->minQIndex, "minQIndex", 1); }

    print_VkBool32(obj->useMaxQIndex, "useMaxQIndex", 1);

    PRINT_SPACE
    _OUT << "\"maxQIndex\": " << std::endl;
    { print_VkVideoEncodeAV1QIndexKHR(obj->maxQIndex, "maxQIndex", 1); }

    print_VkBool32(obj->useMaxFrameSize, "useMaxFrameSize", 1);

    PRINT_SPACE
    _OUT << "\"maxFrameSize\": " << std::endl;
    { print_VkVideoEncodeAV1FrameSizeKHR(obj->maxFrameSize, "maxFrameSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(VkPhysicalDeviceVideoMaintenance1FeaturesKHR obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.videoMaintenance1, "videoMaintenance1", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(const VkPhysicalDeviceVideoMaintenance1FeaturesKHR* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->videoMaintenance1, "videoMaintenance1", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoInlineQueryInfoKHR(VkVideoInlineQueryInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "queryPool"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.firstQuery, "firstQuery", 1);

    print_uint32_t(obj.queryCount, "queryCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoInlineQueryInfoKHR(const VkVideoInlineQueryInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "queryPool"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->firstQuery, "firstQuery", 1);

    print_uint32_t(obj->queryCount, "queryCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceVertexAttributeDivisorProperties(VkPhysicalDeviceVertexAttributeDivisorProperties obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxVertexAttribDivisor, "maxVertexAttribDivisor", 1);

    print_VkBool32(obj.supportsNonZeroFirstInstance, "supportsNonZeroFirstInstance", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVertexAttributeDivisorProperties(const VkPhysicalDeviceVertexAttributeDivisorProperties* obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxVertexAttribDivisor, "maxVertexAttribDivisor", 1);

    print_VkBool32(obj->supportsNonZeroFirstInstance, "supportsNonZeroFirstInstance", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceVertexAttributeDivisorProperties VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR;

static void print_VkVertexInputBindingDivisorDescription(VkVertexInputBindingDivisorDescription obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.binding, "binding", 1);

    print_uint32_t(obj.divisor, "divisor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVertexInputBindingDivisorDescription(const VkVertexInputBindingDivisorDescription* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->binding, "binding", 1);

    print_uint32_t(obj->divisor, "divisor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkVertexInputBindingDivisorDescription VkVertexInputBindingDivisorDescriptionKHR;

static void print_VkPipelineVertexInputDivisorStateCreateInfo(VkPipelineVertexInputDivisorStateCreateInfo obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.vertexBindingDivisorCount, "vertexBindingDivisorCount", 1);

    PRINT_SPACE
    _OUT << "\"pVertexBindingDivisors\": " << std::endl;
    if (obj.pVertexBindingDivisors) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.vertexBindingDivisorCount; i++) {
            if (i + 1 == obj.vertexBindingDivisorCount)
                print_VkVertexInputBindingDivisorDescription(obj.pVertexBindingDivisors[i], "pVertexBindingDivisors", 0);
            else
                print_VkVertexInputBindingDivisorDescription(obj.pVertexBindingDivisors[i], "pVertexBindingDivisors", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineVertexInputDivisorStateCreateInfo(const VkPipelineVertexInputDivisorStateCreateInfo* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->vertexBindingDivisorCount, "vertexBindingDivisorCount", 1);

    PRINT_SPACE
    _OUT << "\"pVertexBindingDivisors\": " << std::endl;
    if (obj->pVertexBindingDivisors) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->vertexBindingDivisorCount; i++) {
            if (i + 1 == obj->vertexBindingDivisorCount)
                print_VkVertexInputBindingDivisorDescription(obj->pVertexBindingDivisors[i], "pVertexBindingDivisors", 0);
            else
                print_VkVertexInputBindingDivisorDescription(obj->pVertexBindingDivisors[i], "pVertexBindingDivisors", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPipelineVertexInputDivisorStateCreateInfo VkPipelineVertexInputDivisorStateCreateInfoKHR;

static void print_VkPhysicalDeviceVertexAttributeDivisorFeatures(VkPhysicalDeviceVertexAttributeDivisorFeatures obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.vertexAttributeInstanceRateDivisor, "vertexAttributeInstanceRateDivisor", 1);

    print_VkBool32(obj.vertexAttributeInstanceRateZeroDivisor, "vertexAttributeInstanceRateZeroDivisor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVertexAttributeDivisorFeatures(const VkPhysicalDeviceVertexAttributeDivisorFeatures* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->vertexAttributeInstanceRateDivisor, "vertexAttributeInstanceRateDivisor", 1);

    print_VkBool32(obj->vertexAttributeInstanceRateZeroDivisor, "vertexAttributeInstanceRateZeroDivisor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceVertexAttributeDivisorFeatures VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR;

static void print_VkPhysicalDeviceShaderFloatControls2Features(VkPhysicalDeviceShaderFloatControls2Features obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderFloatControls2, "shaderFloatControls2", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderFloatControls2Features(const VkPhysicalDeviceShaderFloatControls2Features* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderFloatControls2, "shaderFloatControls2", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceShaderFloatControls2Features VkPhysicalDeviceShaderFloatControls2FeaturesKHR;

static void print_VkPhysicalDeviceIndexTypeUint8Features(VkPhysicalDeviceIndexTypeUint8Features obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.indexTypeUint8, "indexTypeUint8", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceIndexTypeUint8Features(const VkPhysicalDeviceIndexTypeUint8Features* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->indexTypeUint8, "indexTypeUint8", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceIndexTypeUint8Features VkPhysicalDeviceIndexTypeUint8FeaturesKHR;

static std::map<uint64_t, std::string> VkLineRasterizationMode_map = {
    std::make_pair(0, "VK_LINE_RASTERIZATION_MODE_DEFAULT"),
    std::make_pair(1, "VK_LINE_RASTERIZATION_MODE_RECTANGULAR"),
    std::make_pair(2, "VK_LINE_RASTERIZATION_MODE_BRESENHAM"),
    std::make_pair(3, "VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH"),
};
static void print_VkLineRasterizationMode(VkLineRasterizationMode obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLineRasterizationMode_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLineRasterizationMode_map[obj] << "\"" << std::endl;
}
static void print_VkLineRasterizationMode(const VkLineRasterizationMode* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLineRasterizationMode_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLineRasterizationMode_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkLineRasterizationModeKHR_map = {
    std::make_pair(0, "VK_LINE_RASTERIZATION_MODE_DEFAULT"),
    std::make_pair(1, "VK_LINE_RASTERIZATION_MODE_RECTANGULAR"),
    std::make_pair(2, "VK_LINE_RASTERIZATION_MODE_BRESENHAM"),
    std::make_pair(3, "VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH"),
};
static void print_VkLineRasterizationModeKHR(VkLineRasterizationModeKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLineRasterizationModeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLineRasterizationModeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkLineRasterizationModeKHR(const VkLineRasterizationModeKHR* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLineRasterizationModeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLineRasterizationModeKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceLineRasterizationFeatures(VkPhysicalDeviceLineRasterizationFeatures obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.rectangularLines, "rectangularLines", 1);

    print_VkBool32(obj.bresenhamLines, "bresenhamLines", 1);

    print_VkBool32(obj.smoothLines, "smoothLines", 1);

    print_VkBool32(obj.stippledRectangularLines, "stippledRectangularLines", 1);

    print_VkBool32(obj.stippledBresenhamLines, "stippledBresenhamLines", 1);

    print_VkBool32(obj.stippledSmoothLines, "stippledSmoothLines", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceLineRasterizationFeatures(const VkPhysicalDeviceLineRasterizationFeatures* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->rectangularLines, "rectangularLines", 1);

    print_VkBool32(obj->bresenhamLines, "bresenhamLines", 1);

    print_VkBool32(obj->smoothLines, "smoothLines", 1);

    print_VkBool32(obj->stippledRectangularLines, "stippledRectangularLines", 1);

    print_VkBool32(obj->stippledBresenhamLines, "stippledBresenhamLines", 1);

    print_VkBool32(obj->stippledSmoothLines, "stippledSmoothLines", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceLineRasterizationFeatures VkPhysicalDeviceLineRasterizationFeaturesKHR;

static void print_VkPhysicalDeviceLineRasterizationProperties(VkPhysicalDeviceLineRasterizationProperties obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.lineSubPixelPrecisionBits, "lineSubPixelPrecisionBits", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceLineRasterizationProperties(const VkPhysicalDeviceLineRasterizationProperties* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->lineSubPixelPrecisionBits, "lineSubPixelPrecisionBits", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceLineRasterizationProperties VkPhysicalDeviceLineRasterizationPropertiesKHR;

static void print_VkPipelineRasterizationLineStateCreateInfo(VkPipelineRasterizationLineStateCreateInfo obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkLineRasterizationMode(obj.lineRasterizationMode, "lineRasterizationMode", 1);

    print_VkBool32(obj.stippledLineEnable, "stippledLineEnable", 1);

    print_uint32_t(obj.lineStippleFactor, "lineStippleFactor", 1);

    print_uint16_t(obj.lineStipplePattern, "lineStipplePattern", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineRasterizationLineStateCreateInfo(const VkPipelineRasterizationLineStateCreateInfo* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkLineRasterizationMode(obj->lineRasterizationMode, "lineRasterizationMode", 1);

    print_VkBool32(obj->stippledLineEnable, "stippledLineEnable", 1);

    print_uint32_t(obj->lineStippleFactor, "lineStippleFactor", 1);

    print_uint16_t(obj->lineStipplePattern, "lineStipplePattern", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPipelineRasterizationLineStateCreateInfo VkPipelineRasterizationLineStateCreateInfoKHR;

static std::map<uint64_t, std::string> VkTimeDomainKHR_map = {
    std::make_pair(0, "VK_TIME_DOMAIN_DEVICE_KHR"),
    std::make_pair(1, "VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR"),
    std::make_pair(2, "VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR"),
    std::make_pair(3, "VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR"),
};
static void print_VkTimeDomainKHR(VkTimeDomainKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkTimeDomainKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkTimeDomainKHR_map[obj] << "\"" << std::endl;
}
static void print_VkTimeDomainKHR(const VkTimeDomainKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkTimeDomainKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkTimeDomainKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkCalibratedTimestampInfoKHR(VkCalibratedTimestampInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkTimeDomainKHR(obj.timeDomain, "timeDomain", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCalibratedTimestampInfoKHR(const VkCalibratedTimestampInfoKHR* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkTimeDomainKHR(obj->timeDomain, "timeDomain", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderExpectAssumeFeatures(VkPhysicalDeviceShaderExpectAssumeFeatures obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderExpectAssume, "shaderExpectAssume", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderExpectAssumeFeatures(const VkPhysicalDeviceShaderExpectAssumeFeatures* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderExpectAssume, "shaderExpectAssume", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceShaderExpectAssumeFeatures VkPhysicalDeviceShaderExpectAssumeFeaturesKHR;

static void print_VkPhysicalDeviceMaintenance6Features(VkPhysicalDeviceMaintenance6Features obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.maintenance6, "maintenance6", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMaintenance6Features(const VkPhysicalDeviceMaintenance6Features* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->maintenance6, "maintenance6", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceMaintenance6Features VkPhysicalDeviceMaintenance6FeaturesKHR;

static void print_VkPhysicalDeviceMaintenance6Properties(VkPhysicalDeviceMaintenance6Properties obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.blockTexelViewCompatibleMultipleLayers, "blockTexelViewCompatibleMultipleLayers", 1);

    print_uint32_t(obj.maxCombinedImageSamplerDescriptorCount, "maxCombinedImageSamplerDescriptorCount", 1);

    print_VkBool32(obj.fragmentShadingRateClampCombinerInputs, "fragmentShadingRateClampCombinerInputs", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMaintenance6Properties(const VkPhysicalDeviceMaintenance6Properties* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->blockTexelViewCompatibleMultipleLayers, "blockTexelViewCompatibleMultipleLayers", 1);

    print_uint32_t(obj->maxCombinedImageSamplerDescriptorCount, "maxCombinedImageSamplerDescriptorCount", 1);

    print_VkBool32(obj->fragmentShadingRateClampCombinerInputs, "fragmentShadingRateClampCombinerInputs", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceMaintenance6Properties VkPhysicalDeviceMaintenance6PropertiesKHR;

static void print_VkBindMemoryStatus(VkBindMemoryStatus obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkResult(obj.pResult, "pResult", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindMemoryStatus(const VkBindMemoryStatus* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkResult(obj->pResult, "pResult", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkBindMemoryStatus VkBindMemoryStatusKHR;

static void print_VkBindDescriptorSetsInfo(VkBindDescriptorSetsInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj.stageFlags, "stageFlags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.firstSet, "firstSet", 1);

    print_uint32_t(obj.descriptorSetCount, "descriptorSetCount", 1);

    PRINT_SPACE
    _OUT << "\"pDescriptorSets\":" << std::endl;
    PRINT_SPACE
    if (obj.pDescriptorSets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.descriptorSetCount; i++) {
            std::stringstream tmp;
            tmp << "pDescriptorSets"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.descriptorSetCount;
            print_VkDescriptorSet(obj.pDescriptorSets[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.dynamicOffsetCount, "dynamicOffsetCount", 1);

    PRINT_SPACE
    _OUT << "\"pDynamicOffsets\":" << std::endl;
    PRINT_SPACE
    if (obj.pDynamicOffsets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.dynamicOffsetCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.dynamicOffsetCount;
            print_uint32_t(obj.pDynamicOffsets[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindDescriptorSetsInfo(const VkBindDescriptorSetsInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj->stageFlags, "stageFlags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->firstSet, "firstSet", 1);

    print_uint32_t(obj->descriptorSetCount, "descriptorSetCount", 1);

    PRINT_SPACE
    _OUT << "\"pDescriptorSets\":" << std::endl;
    PRINT_SPACE
    if (obj->pDescriptorSets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->descriptorSetCount; i++) {
            std::stringstream tmp;
            tmp << "pDescriptorSets"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->descriptorSetCount;
            print_VkDescriptorSet(obj->pDescriptorSets[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->dynamicOffsetCount, "dynamicOffsetCount", 1);

    PRINT_SPACE
    _OUT << "\"pDynamicOffsets\":" << std::endl;
    PRINT_SPACE
    if (obj->pDynamicOffsets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->dynamicOffsetCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->dynamicOffsetCount;
            print_uint32_t(obj->pDynamicOffsets[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkBindDescriptorSetsInfo VkBindDescriptorSetsInfoKHR;

static void print_VkPushConstantsInfo(VkPushConstantsInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkShaderStageFlags(obj.stageFlags, "stageFlags", 1);

    print_uint32_t(obj.offset, "offset", 1);

    print_uint32_t(obj.size, "size", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPushConstantsInfo(const VkPushConstantsInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkShaderStageFlags(obj->stageFlags, "stageFlags", 1);

    print_uint32_t(obj->offset, "offset", 1);

    print_uint32_t(obj->size, "size", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPushConstantsInfo VkPushConstantsInfoKHR;

static void print_VkPushDescriptorSetInfo(VkPushDescriptorSetInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj.stageFlags, "stageFlags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.set, "set", 1);

    print_uint32_t(obj.descriptorWriteCount, "descriptorWriteCount", 1);

    PRINT_SPACE
    _OUT << "\"pDescriptorWrites\": " << std::endl;
    if (obj.pDescriptorWrites) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.descriptorWriteCount; i++) {
            if (i + 1 == obj.descriptorWriteCount)
                print_VkWriteDescriptorSet(obj.pDescriptorWrites[i], "pDescriptorWrites", 0);
            else
                print_VkWriteDescriptorSet(obj.pDescriptorWrites[i], "pDescriptorWrites", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPushDescriptorSetInfo(const VkPushDescriptorSetInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj->stageFlags, "stageFlags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->set, "set", 1);

    print_uint32_t(obj->descriptorWriteCount, "descriptorWriteCount", 1);

    PRINT_SPACE
    _OUT << "\"pDescriptorWrites\": " << std::endl;
    if (obj->pDescriptorWrites) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->descriptorWriteCount; i++) {
            if (i + 1 == obj->descriptorWriteCount)
                print_VkWriteDescriptorSet(obj->pDescriptorWrites[i], "pDescriptorWrites", 0);
            else
                print_VkWriteDescriptorSet(obj->pDescriptorWrites[i], "pDescriptorWrites", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPushDescriptorSetInfo VkPushDescriptorSetInfoKHR;

static void print_VkPushDescriptorSetWithTemplateInfo(VkPushDescriptorSetWithTemplateInfo obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "descriptorUpdateTemplate"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.set, "set", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPushDescriptorSetWithTemplateInfo(const VkPushDescriptorSetWithTemplateInfo* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "descriptorUpdateTemplate"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->set, "set", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPushDescriptorSetWithTemplateInfo VkPushDescriptorSetWithTemplateInfoKHR;

static void print_VkSetDescriptorBufferOffsetsInfoEXT(VkSetDescriptorBufferOffsetsInfoEXT obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj.stageFlags, "stageFlags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.firstSet, "firstSet", 1);

    print_uint32_t(obj.setCount, "setCount", 1);

    PRINT_SPACE
    _OUT << "\"pBufferIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pBufferIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.setCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.setCount;
            print_uint32_t(obj.pBufferIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pOffsets\":" << std::endl;
    PRINT_SPACE
    if (obj.pOffsets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.setCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.setCount;
            print_VkDeviceSize(obj.pOffsets[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSetDescriptorBufferOffsetsInfoEXT(const VkSetDescriptorBufferOffsetsInfoEXT* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj->stageFlags, "stageFlags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->firstSet, "firstSet", 1);

    print_uint32_t(obj->setCount, "setCount", 1);

    PRINT_SPACE
    _OUT << "\"pBufferIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pBufferIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->setCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->setCount;
            print_uint32_t(obj->pBufferIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pOffsets\":" << std::endl;
    PRINT_SPACE
    if (obj->pOffsets) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->setCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->setCount;
            print_VkDeviceSize(obj->pOffsets[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindDescriptorBufferEmbeddedSamplersInfoEXT(VkBindDescriptorBufferEmbeddedSamplersInfoEXT obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj.stageFlags, "stageFlags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.set, "set", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindDescriptorBufferEmbeddedSamplersInfoEXT(const VkBindDescriptorBufferEmbeddedSamplersInfoEXT* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj->stageFlags, "stageFlags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->set, "set", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeQuantizationMapCapabilitiesKHR(VkVideoEncodeQuantizationMapCapabilitiesKHR obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"maxQuantizationMapExtent\": " << std::endl;
    { print_VkExtent2D(obj.maxQuantizationMapExtent, "maxQuantizationMapExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeQuantizationMapCapabilitiesKHR(const VkVideoEncodeQuantizationMapCapabilitiesKHR* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"maxQuantizationMapExtent\": " << std::endl;
    { print_VkExtent2D(obj->maxQuantizationMapExtent, "maxQuantizationMapExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoFormatQuantizationMapPropertiesKHR(VkVideoFormatQuantizationMapPropertiesKHR obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"quantizationMapTexelSize\": " << std::endl;
    { print_VkExtent2D(obj.quantizationMapTexelSize, "quantizationMapTexelSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoFormatQuantizationMapPropertiesKHR(const VkVideoFormatQuantizationMapPropertiesKHR* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"quantizationMapTexelSize\": " << std::endl;
    { print_VkExtent2D(obj->quantizationMapTexelSize, "quantizationMapTexelSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeQuantizationMapInfoKHR(VkVideoEncodeQuantizationMapInfoKHR obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "quantizationMap"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"quantizationMapExtent\": " << std::endl;
    { print_VkExtent2D(obj.quantizationMapExtent, "quantizationMapExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeQuantizationMapInfoKHR(const VkVideoEncodeQuantizationMapInfoKHR* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "quantizationMap"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"quantizationMapExtent\": " << std::endl;
    { print_VkExtent2D(obj->quantizationMapExtent, "quantizationMapExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(
    VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"quantizationMapTexelSize\": " << std::endl;
    { print_VkExtent2D(obj.quantizationMapTexelSize, "quantizationMapTexelSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(
    const VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"quantizationMapTexelSize\": " << std::endl;
    { print_VkExtent2D(obj->quantizationMapTexelSize, "quantizationMapTexelSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.videoEncodeQuantizationMap, "videoEncodeQuantizationMap", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(
    const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->videoEncodeQuantizationMap, "videoEncodeQuantizationMap", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH264QuantizationMapCapabilitiesKHR(VkVideoEncodeH264QuantizationMapCapabilitiesKHR obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_int32_t(obj.minQpDelta, "minQpDelta", 1);

    print_int32_t(obj.maxQpDelta, "maxQpDelta", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH264QuantizationMapCapabilitiesKHR(const VkVideoEncodeH264QuantizationMapCapabilitiesKHR* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_int32_t(obj->minQpDelta, "minQpDelta", 1);

    print_int32_t(obj->maxQpDelta, "maxQpDelta", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeH265QuantizationMapCapabilitiesKHR(VkVideoEncodeH265QuantizationMapCapabilitiesKHR obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_int32_t(obj.minQpDelta, "minQpDelta", 1);

    print_int32_t(obj.maxQpDelta, "maxQpDelta", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeH265QuantizationMapCapabilitiesKHR(const VkVideoEncodeH265QuantizationMapCapabilitiesKHR* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_int32_t(obj->minQpDelta, "minQpDelta", 1);

    print_int32_t(obj->maxQpDelta, "maxQpDelta", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoFormatH265QuantizationMapPropertiesKHR(VkVideoFormatH265QuantizationMapPropertiesKHR obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH265CtbSizeFlagsKHR(obj.compatibleCtbSizes, "compatibleCtbSizes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoFormatH265QuantizationMapPropertiesKHR(const VkVideoFormatH265QuantizationMapPropertiesKHR* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeH265CtbSizeFlagsKHR(obj->compatibleCtbSizes, "compatibleCtbSizes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(VkVideoEncodeAV1QuantizationMapCapabilitiesKHR obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_int32_t(obj.minQIndexDelta, "minQIndexDelta", 1);

    print_int32_t(obj.maxQIndexDelta, "maxQIndexDelta", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(const VkVideoEncodeAV1QuantizationMapCapabilitiesKHR* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_int32_t(obj->minQIndexDelta, "minQIndexDelta", 1);

    print_int32_t(obj->maxQIndexDelta, "maxQIndexDelta", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoFormatAV1QuantizationMapPropertiesKHR(VkVideoFormatAV1QuantizationMapPropertiesKHR obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeAV1SuperblockSizeFlagsKHR(obj.compatibleSuperblockSizes, "compatibleSuperblockSizes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoFormatAV1QuantizationMapPropertiesKHR(const VkVideoFormatAV1QuantizationMapPropertiesKHR* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkVideoEncodeAV1SuperblockSizeFlagsKHR(obj->compatibleSuperblockSizes, "compatibleSuperblockSizes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(
    VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderRelaxedExtendedInstruction, "shaderRelaxedExtendedInstruction", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(
    const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderRelaxedExtendedInstruction, "shaderRelaxedExtendedInstruction", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkPhysicalDeviceLayeredApiKHR_map = {
    std::make_pair(0, "VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR"),
    std::make_pair(1, "VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR"),
    std::make_pair(2, "VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR"),
    std::make_pair(3, "VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR"),
    std::make_pair(4, "VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR"),
};
static void print_VkPhysicalDeviceLayeredApiKHR(VkPhysicalDeviceLayeredApiKHR obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPhysicalDeviceLayeredApiKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPhysicalDeviceLayeredApiKHR_map[obj] << "\"" << std::endl;
}
static void print_VkPhysicalDeviceLayeredApiKHR(const VkPhysicalDeviceLayeredApiKHR* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPhysicalDeviceLayeredApiKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPhysicalDeviceLayeredApiKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceMaintenance7FeaturesKHR(VkPhysicalDeviceMaintenance7FeaturesKHR obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.maintenance7, "maintenance7", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMaintenance7FeaturesKHR(const VkPhysicalDeviceMaintenance7FeaturesKHR* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->maintenance7, "maintenance7", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMaintenance7PropertiesKHR(VkPhysicalDeviceMaintenance7PropertiesKHR obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.robustFragmentShadingRateAttachmentAccess, "robustFragmentShadingRateAttachmentAccess", 1);

    print_VkBool32(obj.separateDepthStencilAttachmentAccess, "separateDepthStencilAttachmentAccess", 1);

    print_uint32_t(obj.maxDescriptorSetTotalUniformBuffersDynamic, "maxDescriptorSetTotalUniformBuffersDynamic", 1);

    print_uint32_t(obj.maxDescriptorSetTotalStorageBuffersDynamic, "maxDescriptorSetTotalStorageBuffersDynamic", 1);

    print_uint32_t(obj.maxDescriptorSetTotalBuffersDynamic, "maxDescriptorSetTotalBuffersDynamic", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic,
                   "maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic,
                   "maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindTotalBuffersDynamic, "maxDescriptorSetUpdateAfterBindTotalBuffersDynamic", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMaintenance7PropertiesKHR(const VkPhysicalDeviceMaintenance7PropertiesKHR* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->robustFragmentShadingRateAttachmentAccess, "robustFragmentShadingRateAttachmentAccess", 1);

    print_VkBool32(obj->separateDepthStencilAttachmentAccess, "separateDepthStencilAttachmentAccess", 1);

    print_uint32_t(obj->maxDescriptorSetTotalUniformBuffersDynamic, "maxDescriptorSetTotalUniformBuffersDynamic", 1);

    print_uint32_t(obj->maxDescriptorSetTotalStorageBuffersDynamic, "maxDescriptorSetTotalStorageBuffersDynamic", 1);

    print_uint32_t(obj->maxDescriptorSetTotalBuffersDynamic, "maxDescriptorSetTotalBuffersDynamic", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic,
                   "maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic,
                   "maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindTotalBuffersDynamic, "maxDescriptorSetUpdateAfterBindTotalBuffersDynamic",
                   0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceLayeredApiPropertiesKHR(VkPhysicalDeviceLayeredApiPropertiesKHR obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.vendorID, "vendorID", 1);

    print_uint32_t(obj.deviceID, "deviceID", 1);

    print_VkPhysicalDeviceLayeredApiKHR(obj.layeredAPI, "layeredAPI", 1);

    PRINT_SPACE
    _OUT << "\"deviceName\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_PHYSICAL_DEVICE_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_PHYSICAL_DEVICE_NAME_SIZE;
        print_char(obj.deviceName[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceLayeredApiPropertiesKHR(const VkPhysicalDeviceLayeredApiPropertiesKHR* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->vendorID, "vendorID", 1);

    print_uint32_t(obj->deviceID, "deviceID", 1);

    print_VkPhysicalDeviceLayeredApiKHR(obj->layeredAPI, "layeredAPI", 1);

    PRINT_SPACE
    _OUT << "\"deviceName\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_PHYSICAL_DEVICE_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_PHYSICAL_DEVICE_NAME_SIZE;
        print_char(obj->deviceName[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceLayeredApiPropertiesListKHR(VkPhysicalDeviceLayeredApiPropertiesListKHR obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.layeredApiCount, "layeredApiCount", 1);

    PRINT_SPACE
    _OUT << "\"pLayeredApis\": " << std::endl;
    if (obj.pLayeredApis) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.layeredApiCount; i++) {
            if (i + 1 == obj.layeredApiCount)
                print_VkPhysicalDeviceLayeredApiPropertiesKHR(obj.pLayeredApis[i], "pLayeredApis", 0);
            else
                print_VkPhysicalDeviceLayeredApiPropertiesKHR(obj.pLayeredApis[i], "pLayeredApis", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceLayeredApiPropertiesListKHR(const VkPhysicalDeviceLayeredApiPropertiesListKHR* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->layeredApiCount, "layeredApiCount", 1);

    PRINT_SPACE
    _OUT << "\"pLayeredApis\": " << std::endl;
    if (obj->pLayeredApis) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->layeredApiCount; i++) {
            if (i + 1 == obj->layeredApiCount)
                print_VkPhysicalDeviceLayeredApiPropertiesKHR(obj->pLayeredApis[i], "pLayeredApis", 0);
            else
                print_VkPhysicalDeviceLayeredApiPropertiesKHR(obj->pLayeredApis[i], "pLayeredApis", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(VkPhysicalDeviceLayeredApiVulkanPropertiesKHR obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"properties\": " << std::endl;
    { print_VkPhysicalDeviceProperties2(obj.properties, "properties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(const VkPhysicalDeviceLayeredApiVulkanPropertiesKHR* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"properties\": " << std::endl;
    { print_VkPhysicalDeviceProperties2(obj->properties, "properties", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkAccessFlagBits3KHR_map = {
    std::make_pair(0, "VK_ACCESS_3_NONE_KHR"),
};
static void print_VkAccessFlagBits3KHR(VkAccessFlagBits3KHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccessFlagBits3KHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccessFlagBits3KHR_map[obj] << "\"" << std::endl;
}
static void print_VkAccessFlagBits3KHR(const VkAccessFlagBits3KHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccessFlagBits3KHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccessFlagBits3KHR_map[*obj] << "\"" << std::endl;
}

static void print_VkAccessFlags3KHR(VkAccessFlags3KHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPhysicalDeviceMaintenance8FeaturesKHR(VkPhysicalDeviceMaintenance8FeaturesKHR obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.maintenance8, "maintenance8", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMaintenance8FeaturesKHR(const VkPhysicalDeviceMaintenance8FeaturesKHR* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->maintenance8, "maintenance8", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryBarrierAccessFlags3KHR(VkMemoryBarrierAccessFlags3KHR obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccessFlags3KHR(obj.srcAccessMask3, "srcAccessMask3", 1);

    print_VkAccessFlags3KHR(obj.dstAccessMask3, "dstAccessMask3", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryBarrierAccessFlags3KHR(const VkMemoryBarrierAccessFlags3KHR* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccessFlags3KHR(obj->srcAccessMask3, "srcAccessMask3", 1);

    print_VkAccessFlags3KHR(obj->dstAccessMask3, "dstAccessMask3", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(VkPhysicalDeviceVideoMaintenance2FeaturesKHR obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.videoMaintenance2, "videoMaintenance2", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(const VkPhysicalDeviceVideoMaintenance2FeaturesKHR* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->videoMaintenance2, "videoMaintenance2", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeH264InlineSessionParametersInfoKHR(VkVideoDecodeH264InlineSessionParametersInfoKHR obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH264SequenceParameterSet(obj.pStdSPS, "pStdSPS", 1);

    print_StdVideoH264PictureParameterSet(obj.pStdPPS, "pStdPPS", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH264InlineSessionParametersInfoKHR(const VkVideoDecodeH264InlineSessionParametersInfoKHR* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH264SequenceParameterSet(obj->pStdSPS, "pStdSPS", 1);

    print_StdVideoH264PictureParameterSet(obj->pStdPPS, "pStdPPS", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeH265InlineSessionParametersInfoKHR(VkVideoDecodeH265InlineSessionParametersInfoKHR obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH265VideoParameterSet(obj.pStdVPS, "pStdVPS", 1);

    print_StdVideoH265SequenceParameterSet(obj.pStdSPS, "pStdSPS", 1);

    print_StdVideoH265PictureParameterSet(obj.pStdPPS, "pStdPPS", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeH265InlineSessionParametersInfoKHR(const VkVideoDecodeH265InlineSessionParametersInfoKHR* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoH265VideoParameterSet(obj->pStdVPS, "pStdVPS", 1);

    print_StdVideoH265SequenceParameterSet(obj->pStdSPS, "pStdSPS", 1);

    print_StdVideoH265PictureParameterSet(obj->pStdPPS, "pStdPPS", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVideoDecodeAV1InlineSessionParametersInfoKHR(VkVideoDecodeAV1InlineSessionParametersInfoKHR obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoAV1SequenceHeader(obj.pStdSequenceHeader, "pStdSequenceHeader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVideoDecodeAV1InlineSessionParametersInfoKHR(const VkVideoDecodeAV1InlineSessionParametersInfoKHR* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_StdVideoAV1SequenceHeader(obj->pStdSequenceHeader, "pStdSequenceHeader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(VkPhysicalDeviceDepthClampZeroOneFeaturesKHR obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.depthClampZeroOne, "depthClampZeroOne", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->depthClampZeroOne, "depthClampZeroOne", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDebugReportCallbackEXT(VkDebugReportCallbackEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDebugReportFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_DEBUG_REPORT_INFORMATION_BIT_EXT"),
    std::make_pair(1ULL << 1, "VK_DEBUG_REPORT_WARNING_BIT_EXT"),
    std::make_pair(1ULL << 2, "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"),
    std::make_pair(1ULL << 3, "VK_DEBUG_REPORT_ERROR_BIT_EXT"),
    std::make_pair(1ULL << 4, "VK_DEBUG_REPORT_DEBUG_BIT_EXT"),
};
static void print_VkDebugReportFlagBitsEXT(VkDebugReportFlagBitsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDebugReportFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDebugReportFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDebugReportFlagBitsEXT(const VkDebugReportFlagBitsEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDebugReportFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDebugReportFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDebugReportObjectTypeEXT_map = {
    std::make_pair(0, "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"),
    std::make_pair(1, "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"),
    std::make_pair(2, "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"),
    std::make_pair(3, "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"),
    std::make_pair(4, "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"),
    std::make_pair(5, "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"),
    std::make_pair(6, "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"),
    std::make_pair(7, "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"),
    std::make_pair(8, "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"),
    std::make_pair(9, "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"),
    std::make_pair(10, "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"),
    std::make_pair(11, "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"),
    std::make_pair(12, "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"),
    std::make_pair(13, "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"),
    std::make_pair(14, "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"),
    std::make_pair(15, "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"),
    std::make_pair(16, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"),
    std::make_pair(17, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"),
    std::make_pair(18, "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"),
    std::make_pair(19, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"),
    std::make_pair(20, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"),
    std::make_pair(21, "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"),
    std::make_pair(22, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"),
    std::make_pair(23, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"),
    std::make_pair(24, "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"),
    std::make_pair(25, "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"),
    std::make_pair(26, "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"),
    std::make_pair(27, "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"),
    std::make_pair(28, "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT"),
    std::make_pair(29, "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT"),
    std::make_pair(30, "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT"),
    std::make_pair(33, "VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT"),
    std::make_pair(1000156000, "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"),
    std::make_pair(1000085000, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT"),
    std::make_pair(1000029000, "VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT"),
    std::make_pair(1000029001, "VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT"),
    std::make_pair(1000150000, "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT"),
    std::make_pair(1000156000, "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"),
    std::make_pair(1000165000, "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT"),
    std::make_pair(1000307000, "VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT"),
    std::make_pair(1000307001, "VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT"),
    std::make_pair(1000366000, "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT"),
};
static void print_VkDebugReportObjectTypeEXT(VkDebugReportObjectTypeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDebugReportObjectTypeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDebugReportObjectTypeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDebugReportObjectTypeEXT(const VkDebugReportObjectTypeEXT* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDebugReportObjectTypeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDebugReportObjectTypeEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkDebugReportFlagsEXT(VkDebugReportFlagsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkDebugReportFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkDebugReportFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkDebugReportCallbackCreateInfoEXT(VkDebugReportCallbackCreateInfoEXT obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDebugReportFlagsEXT(obj.flags, "flags", 1);

    /** Note: Ignoring function pointer (PFN_vkDebugReportCallbackEXT). **/

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDebugReportCallbackCreateInfoEXT(const VkDebugReportCallbackCreateInfoEXT* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDebugReportFlagsEXT(obj->flags, "flags", 1);

    /** Note: Ignoring function pointer (PFN_vkDebugReportCallbackEXT). **/

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkRasterizationOrderAMD_map = {
    std::make_pair(0, "VK_RASTERIZATION_ORDER_STRICT_AMD"),
    std::make_pair(1, "VK_RASTERIZATION_ORDER_RELAXED_AMD"),
};
static void print_VkRasterizationOrderAMD(VkRasterizationOrderAMD obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRasterizationOrderAMD_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRasterizationOrderAMD_map[obj] << "\"" << std::endl;
}
static void print_VkRasterizationOrderAMD(const VkRasterizationOrderAMD* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRasterizationOrderAMD_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRasterizationOrderAMD_map[*obj] << "\"" << std::endl;
}

static void print_VkPipelineRasterizationStateRasterizationOrderAMD(VkPipelineRasterizationStateRasterizationOrderAMD obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRasterizationOrderAMD(obj.rasterizationOrder, "rasterizationOrder", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineRasterizationStateRasterizationOrderAMD(const VkPipelineRasterizationStateRasterizationOrderAMD* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRasterizationOrderAMD(obj->rasterizationOrder, "rasterizationOrder", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDebugMarkerObjectNameInfoEXT(VkDebugMarkerObjectNameInfoEXT obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDebugReportObjectTypeEXT(obj.objectType, "objectType", 1);

    print_uint64_t(obj.object, "object", 1);

    print_char(obj.pObjectName, "pObjectName", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDebugMarkerObjectNameInfoEXT(const VkDebugMarkerObjectNameInfoEXT* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDebugReportObjectTypeEXT(obj->objectType, "objectType", 1);

    print_uint64_t(obj->object, "object", 1);

    print_char(obj->pObjectName, "pObjectName", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDebugMarkerObjectTagInfoEXT(VkDebugMarkerObjectTagInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDebugReportObjectTypeEXT(obj.objectType, "objectType", 1);

    print_uint64_t(obj.object, "object", 1);

    print_uint64_t(obj.tagName, "tagName", 1);

    print_size_t(obj.tagSize, "tagSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDebugMarkerObjectTagInfoEXT(const VkDebugMarkerObjectTagInfoEXT* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDebugReportObjectTypeEXT(obj->objectType, "objectType", 1);

    print_uint64_t(obj->object, "object", 1);

    print_uint64_t(obj->tagName, "tagName", 1);

    print_size_t(obj->tagSize, "tagSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDebugMarkerMarkerInfoEXT(VkDebugMarkerMarkerInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_char(obj.pMarkerName, "pMarkerName", 1);

    PRINT_SPACE
    _OUT << "\"color\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 4; i++) {
        bool isCommaNeeded = (i + 1) != 4;
        print_float(obj.color[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDebugMarkerMarkerInfoEXT(const VkDebugMarkerMarkerInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_char(obj->pMarkerName, "pMarkerName", 1);

    PRINT_SPACE
    _OUT << "\"color\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 4; i++) {
        bool isCommaNeeded = (i + 1) != 4;
        print_float(obj->color[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDedicatedAllocationImageCreateInfoNV(VkDedicatedAllocationImageCreateInfoNV obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.dedicatedAllocation, "dedicatedAllocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDedicatedAllocationImageCreateInfoNV(const VkDedicatedAllocationImageCreateInfoNV* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->dedicatedAllocation, "dedicatedAllocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDedicatedAllocationBufferCreateInfoNV(VkDedicatedAllocationBufferCreateInfoNV obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.dedicatedAllocation, "dedicatedAllocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDedicatedAllocationBufferCreateInfoNV(const VkDedicatedAllocationBufferCreateInfoNV* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->dedicatedAllocation, "dedicatedAllocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDedicatedAllocationMemoryAllocateInfoNV(VkDedicatedAllocationMemoryAllocateInfoNV obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDedicatedAllocationMemoryAllocateInfoNV(const VkDedicatedAllocationMemoryAllocateInfoNV* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineRasterizationStateStreamCreateFlagsEXT(VkPipelineRasterizationStateStreamCreateFlagsEXT obj,
                                                                   const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPhysicalDeviceTransformFeedbackFeaturesEXT(VkPhysicalDeviceTransformFeedbackFeaturesEXT obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.transformFeedback, "transformFeedback", 1);

    print_VkBool32(obj.geometryStreams, "geometryStreams", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceTransformFeedbackFeaturesEXT(const VkPhysicalDeviceTransformFeedbackFeaturesEXT* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->transformFeedback, "transformFeedback", 1);

    print_VkBool32(obj->geometryStreams, "geometryStreams", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceTransformFeedbackPropertiesEXT(VkPhysicalDeviceTransformFeedbackPropertiesEXT obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxTransformFeedbackStreams, "maxTransformFeedbackStreams", 1);

    print_uint32_t(obj.maxTransformFeedbackBuffers, "maxTransformFeedbackBuffers", 1);

    print_VkDeviceSize(obj.maxTransformFeedbackBufferSize, "maxTransformFeedbackBufferSize", 1);

    print_uint32_t(obj.maxTransformFeedbackStreamDataSize, "maxTransformFeedbackStreamDataSize", 1);

    print_uint32_t(obj.maxTransformFeedbackBufferDataSize, "maxTransformFeedbackBufferDataSize", 1);

    print_uint32_t(obj.maxTransformFeedbackBufferDataStride, "maxTransformFeedbackBufferDataStride", 1);

    print_VkBool32(obj.transformFeedbackQueries, "transformFeedbackQueries", 1);

    print_VkBool32(obj.transformFeedbackStreamsLinesTriangles, "transformFeedbackStreamsLinesTriangles", 1);

    print_VkBool32(obj.transformFeedbackRasterizationStreamSelect, "transformFeedbackRasterizationStreamSelect", 1);

    print_VkBool32(obj.transformFeedbackDraw, "transformFeedbackDraw", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceTransformFeedbackPropertiesEXT(const VkPhysicalDeviceTransformFeedbackPropertiesEXT* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxTransformFeedbackStreams, "maxTransformFeedbackStreams", 1);

    print_uint32_t(obj->maxTransformFeedbackBuffers, "maxTransformFeedbackBuffers", 1);

    print_VkDeviceSize(obj->maxTransformFeedbackBufferSize, "maxTransformFeedbackBufferSize", 1);

    print_uint32_t(obj->maxTransformFeedbackStreamDataSize, "maxTransformFeedbackStreamDataSize", 1);

    print_uint32_t(obj->maxTransformFeedbackBufferDataSize, "maxTransformFeedbackBufferDataSize", 1);

    print_uint32_t(obj->maxTransformFeedbackBufferDataStride, "maxTransformFeedbackBufferDataStride", 1);

    print_VkBool32(obj->transformFeedbackQueries, "transformFeedbackQueries", 1);

    print_VkBool32(obj->transformFeedbackStreamsLinesTriangles, "transformFeedbackStreamsLinesTriangles", 1);

    print_VkBool32(obj->transformFeedbackRasterizationStreamSelect, "transformFeedbackRasterizationStreamSelect", 1);

    print_VkBool32(obj->transformFeedbackDraw, "transformFeedbackDraw", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineRasterizationStateStreamCreateInfoEXT(VkPipelineRasterizationStateStreamCreateInfoEXT obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineRasterizationStateStreamCreateFlagsEXT(obj.flags, "flags", 1);

    print_uint32_t(obj.rasterizationStream, "rasterizationStream", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineRasterizationStateStreamCreateInfoEXT(const VkPipelineRasterizationStateStreamCreateInfoEXT* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineRasterizationStateStreamCreateFlagsEXT(obj->flags, "flags", 1);

    print_uint32_t(obj->rasterizationStream, "rasterizationStream", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCuModuleNVX(VkCuModuleNVX obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkCuFunctionNVX(VkCuFunctionNVX obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkCuModuleCreateInfoNVX(VkCuModuleCreateInfoNVX obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_size_t(obj.dataSize, "dataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCuModuleCreateInfoNVX(const VkCuModuleCreateInfoNVX* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_size_t(obj->dataSize, "dataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCuModuleTexturingModeCreateInfoNVX(VkCuModuleTexturingModeCreateInfoNVX obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.use64bitTexturing, "use64bitTexturing", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCuModuleTexturingModeCreateInfoNVX(const VkCuModuleTexturingModeCreateInfoNVX* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->use64bitTexturing, "use64bitTexturing", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCuFunctionCreateInfoNVX(VkCuFunctionCreateInfoNVX obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "module"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_char(obj.pName, "pName", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCuFunctionCreateInfoNVX(const VkCuFunctionCreateInfoNVX* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "module"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_char(obj->pName, "pName", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCuLaunchInfoNVX(VkCuLaunchInfoNVX obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "function"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.gridDimX, "gridDimX", 1);

    print_uint32_t(obj.gridDimY, "gridDimY", 1);

    print_uint32_t(obj.gridDimZ, "gridDimZ", 1);

    print_uint32_t(obj.blockDimX, "blockDimX", 1);

    print_uint32_t(obj.blockDimY, "blockDimY", 1);

    print_uint32_t(obj.blockDimZ, "blockDimZ", 1);

    print_uint32_t(obj.sharedMemBytes, "sharedMemBytes", 1);

    print_size_t(obj.paramCount, "paramCount", 1);

    /** Note: Ignoring void* data. **/

    print_size_t(obj.extraCount, "extraCount", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCuLaunchInfoNVX(const VkCuLaunchInfoNVX* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "function"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->gridDimX, "gridDimX", 1);

    print_uint32_t(obj->gridDimY, "gridDimY", 1);

    print_uint32_t(obj->gridDimZ, "gridDimZ", 1);

    print_uint32_t(obj->blockDimX, "blockDimX", 1);

    print_uint32_t(obj->blockDimY, "blockDimY", 1);

    print_uint32_t(obj->blockDimZ, "blockDimZ", 1);

    print_uint32_t(obj->sharedMemBytes, "sharedMemBytes", 1);

    print_size_t(obj->paramCount, "paramCount", 1);

    /** Note: Ignoring void* data. **/

    print_size_t(obj->extraCount, "extraCount", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageViewHandleInfoNVX(VkImageViewHandleInfoNVX obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDescriptorType(obj.descriptorType, "descriptorType", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "sampler"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageViewHandleInfoNVX(const VkImageViewHandleInfoNVX* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDescriptorType(obj->descriptorType, "descriptorType", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "sampler"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageViewAddressPropertiesNVX(VkImageViewAddressPropertiesNVX obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceAddress(obj.deviceAddress, "deviceAddress", 1);

    print_VkDeviceSize(obj.size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageViewAddressPropertiesNVX(const VkImageViewAddressPropertiesNVX* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceAddress(obj->deviceAddress, "deviceAddress", 1);

    print_VkDeviceSize(obj->size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkTextureLODGatherFormatPropertiesAMD(VkTextureLODGatherFormatPropertiesAMD obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.supportsTextureGatherLODBiasAMD, "supportsTextureGatherLODBiasAMD", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkTextureLODGatherFormatPropertiesAMD(const VkTextureLODGatherFormatPropertiesAMD* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->supportsTextureGatherLODBiasAMD, "supportsTextureGatherLODBiasAMD", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkShaderInfoTypeAMD_map = {
    std::make_pair(0, "VK_SHADER_INFO_TYPE_STATISTICS_AMD"),
    std::make_pair(1, "VK_SHADER_INFO_TYPE_BINARY_AMD"),
    std::make_pair(2, "VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD"),
};
static void print_VkShaderInfoTypeAMD(VkShaderInfoTypeAMD obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderInfoTypeAMD_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderInfoTypeAMD_map[obj] << "\"" << std::endl;
}
static void print_VkShaderInfoTypeAMD(const VkShaderInfoTypeAMD* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderInfoTypeAMD_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderInfoTypeAMD_map[*obj] << "\"" << std::endl;
}

static void print_VkShaderResourceUsageAMD(VkShaderResourceUsageAMD obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.numUsedVgprs, "numUsedVgprs", 1);

    print_uint32_t(obj.numUsedSgprs, "numUsedSgprs", 1);

    print_uint32_t(obj.ldsSizePerLocalWorkGroup, "ldsSizePerLocalWorkGroup", 1);

    print_size_t(obj.ldsUsageSizeInBytes, "ldsUsageSizeInBytes", 1);

    print_size_t(obj.scratchMemUsageInBytes, "scratchMemUsageInBytes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkShaderResourceUsageAMD(const VkShaderResourceUsageAMD* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->numUsedVgprs, "numUsedVgprs", 1);

    print_uint32_t(obj->numUsedSgprs, "numUsedSgprs", 1);

    print_uint32_t(obj->ldsSizePerLocalWorkGroup, "ldsSizePerLocalWorkGroup", 1);

    print_size_t(obj->ldsUsageSizeInBytes, "ldsUsageSizeInBytes", 1);

    print_size_t(obj->scratchMemUsageInBytes, "scratchMemUsageInBytes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkShaderStatisticsInfoAMD(VkShaderStatisticsInfoAMD obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkShaderStageFlags(obj.shaderStageMask, "shaderStageMask", 1);

    PRINT_SPACE
    _OUT << "\"resourceUsage\": " << std::endl;
    { print_VkShaderResourceUsageAMD(obj.resourceUsage, "resourceUsage", 1); }

    print_uint32_t(obj.numPhysicalVgprs, "numPhysicalVgprs", 1);

    print_uint32_t(obj.numPhysicalSgprs, "numPhysicalSgprs", 1);

    print_uint32_t(obj.numAvailableVgprs, "numAvailableVgprs", 1);

    print_uint32_t(obj.numAvailableSgprs, "numAvailableSgprs", 1);

    PRINT_SPACE
    _OUT << "\"computeWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj.computeWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkShaderStatisticsInfoAMD(const VkShaderStatisticsInfoAMD* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkShaderStageFlags(obj->shaderStageMask, "shaderStageMask", 1);

    PRINT_SPACE
    _OUT << "\"resourceUsage\": " << std::endl;
    { print_VkShaderResourceUsageAMD(obj->resourceUsage, "resourceUsage", 1); }

    print_uint32_t(obj->numPhysicalVgprs, "numPhysicalVgprs", 1);

    print_uint32_t(obj->numPhysicalSgprs, "numPhysicalSgprs", 1);

    print_uint32_t(obj->numAvailableVgprs, "numAvailableVgprs", 1);

    print_uint32_t(obj->numAvailableSgprs, "numAvailableSgprs", 1);

    PRINT_SPACE
    _OUT << "\"computeWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj->computeWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCornerSampledImageFeaturesNV(VkPhysicalDeviceCornerSampledImageFeaturesNV obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.cornerSampledImage, "cornerSampledImage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCornerSampledImageFeaturesNV(const VkPhysicalDeviceCornerSampledImageFeaturesNV* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->cornerSampledImage, "cornerSampledImage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkExternalMemoryHandleTypeFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"),
    std::make_pair(1ULL << 2, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"),
    std::make_pair(1ULL << 3, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"),
};
static void print_VkExternalMemoryHandleTypeFlagBitsNV(VkExternalMemoryHandleTypeFlagBitsNV obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalMemoryHandleTypeFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalMemoryHandleTypeFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkExternalMemoryHandleTypeFlagBitsNV(const VkExternalMemoryHandleTypeFlagBitsNV* obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalMemoryHandleTypeFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalMemoryHandleTypeFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkExternalMemoryFeatureFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV"),
    std::make_pair(1ULL << 1, "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV"),
    std::make_pair(1ULL << 2, "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV"),
};
static void print_VkExternalMemoryFeatureFlagBitsNV(VkExternalMemoryFeatureFlagBitsNV obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalMemoryFeatureFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalMemoryFeatureFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkExternalMemoryFeatureFlagBitsNV(const VkExternalMemoryFeatureFlagBitsNV* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkExternalMemoryFeatureFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkExternalMemoryFeatureFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static void print_VkExternalMemoryHandleTypeFlagsNV(VkExternalMemoryHandleTypeFlagsNV obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkExternalMemoryHandleTypeFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkExternalMemoryHandleTypeFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkExternalMemoryFeatureFlagsNV(VkExternalMemoryFeatureFlagsNV obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkExternalMemoryFeatureFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkExternalMemoryFeatureFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkExternalImageFormatPropertiesNV(VkExternalImageFormatPropertiesNV obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"imageFormatProperties\": " << std::endl;
    { print_VkImageFormatProperties(obj.imageFormatProperties, "imageFormatProperties", 1); }

    print_VkExternalMemoryFeatureFlagsNV(obj.externalMemoryFeatures, "externalMemoryFeatures", 1);

    print_VkExternalMemoryHandleTypeFlagsNV(obj.exportFromImportedHandleTypes, "exportFromImportedHandleTypes", 1);

    print_VkExternalMemoryHandleTypeFlagsNV(obj.compatibleHandleTypes, "compatibleHandleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExternalImageFormatPropertiesNV(const VkExternalImageFormatPropertiesNV* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"imageFormatProperties\": " << std::endl;
    { print_VkImageFormatProperties(obj->imageFormatProperties, "imageFormatProperties", 1); }

    print_VkExternalMemoryFeatureFlagsNV(obj->externalMemoryFeatures, "externalMemoryFeatures", 1);

    print_VkExternalMemoryHandleTypeFlagsNV(obj->exportFromImportedHandleTypes, "exportFromImportedHandleTypes", 1);

    print_VkExternalMemoryHandleTypeFlagsNV(obj->compatibleHandleTypes, "compatibleHandleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExternalMemoryImageCreateInfoNV(VkExternalMemoryImageCreateInfoNV obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlagsNV(obj.handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExternalMemoryImageCreateInfoNV(const VkExternalMemoryImageCreateInfoNV* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlagsNV(obj->handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExportMemoryAllocateInfoNV(VkExportMemoryAllocateInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlagsNV(obj.handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExportMemoryAllocateInfoNV(const VkExportMemoryAllocateInfoNV* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlagsNV(obj->handleTypes, "handleTypes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkValidationCheckEXT_map = {
    std::make_pair(0, "VK_VALIDATION_CHECK_ALL_EXT"),
    std::make_pair(1, "VK_VALIDATION_CHECK_SHADERS_EXT"),
};
static void print_VkValidationCheckEXT(VkValidationCheckEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkValidationCheckEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkValidationCheckEXT_map[obj] << "\"" << std::endl;
}
static void print_VkValidationCheckEXT(const VkValidationCheckEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkValidationCheckEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkValidationCheckEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkValidationFlagsEXT(VkValidationFlagsEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.disabledValidationCheckCount, "disabledValidationCheckCount", 1);

    PRINT_SPACE
    _OUT << "\"pDisabledValidationChecks\":" << std::endl;
    PRINT_SPACE
    if (obj.pDisabledValidationChecks) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.disabledValidationCheckCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.disabledValidationCheckCount;
            print_VkValidationCheckEXT(obj.pDisabledValidationChecks[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkValidationFlagsEXT(const VkValidationFlagsEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->disabledValidationCheckCount, "disabledValidationCheckCount", 1);

    PRINT_SPACE
    _OUT << "\"pDisabledValidationChecks\":" << std::endl;
    PRINT_SPACE
    if (obj->pDisabledValidationChecks) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->disabledValidationCheckCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->disabledValidationCheckCount;
            print_VkValidationCheckEXT(obj->pDisabledValidationChecks[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(VkPhysicalDeviceTextureCompressionASTCHDRFeatures obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.textureCompressionASTC_HDR, "textureCompressionASTC_HDR", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(const VkPhysicalDeviceTextureCompressionASTCHDRFeatures* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->textureCompressionASTC_HDR, "textureCompressionASTC_HDR", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceTextureCompressionASTCHDRFeatures VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT;

static void print_VkImageViewASTCDecodeModeEXT(VkImageViewASTCDecodeModeEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj.decodeMode, "decodeMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageViewASTCDecodeModeEXT(const VkImageViewASTCDecodeModeEXT* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj->decodeMode, "decodeMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceASTCDecodeFeaturesEXT(VkPhysicalDeviceASTCDecodeFeaturesEXT obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.decodeModeSharedExponent, "decodeModeSharedExponent", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceASTCDecodeFeaturesEXT(const VkPhysicalDeviceASTCDecodeFeaturesEXT* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->decodeModeSharedExponent, "decodeModeSharedExponent", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineRobustnessBufferBehavior_map = {
    std::make_pair(0, "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT"),
    std::make_pair(1, "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED"),
    std::make_pair(2, "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS"),
    std::make_pair(3, "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2"),
};
static void print_VkPipelineRobustnessBufferBehavior(VkPipelineRobustnessBufferBehavior obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineRobustnessBufferBehavior_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineRobustnessBufferBehavior_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineRobustnessBufferBehavior(const VkPipelineRobustnessBufferBehavior* obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineRobustnessBufferBehavior_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineRobustnessBufferBehavior_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineRobustnessImageBehavior_map = {
    std::make_pair(0, "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT"),
    std::make_pair(1, "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED"),
    std::make_pair(2, "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS"),
    std::make_pair(3, "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2"),
};
static void print_VkPipelineRobustnessImageBehavior(VkPipelineRobustnessImageBehavior obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineRobustnessImageBehavior_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineRobustnessImageBehavior_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineRobustnessImageBehavior(const VkPipelineRobustnessImageBehavior* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineRobustnessImageBehavior_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineRobustnessImageBehavior_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineRobustnessBufferBehaviorEXT_map = {
    std::make_pair(0, "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT"),
    std::make_pair(1, "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED"),
    std::make_pair(2, "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS"),
    std::make_pair(3, "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2"),
};
static void print_VkPipelineRobustnessBufferBehaviorEXT(VkPipelineRobustnessBufferBehaviorEXT obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineRobustnessBufferBehaviorEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineRobustnessBufferBehaviorEXT_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineRobustnessBufferBehaviorEXT(const VkPipelineRobustnessBufferBehaviorEXT* obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineRobustnessBufferBehaviorEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineRobustnessBufferBehaviorEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineRobustnessImageBehaviorEXT_map = {
    std::make_pair(0, "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT"),
    std::make_pair(1, "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED"),
    std::make_pair(2, "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS"),
    std::make_pair(3, "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2"),
};
static void print_VkPipelineRobustnessImageBehaviorEXT(VkPipelineRobustnessImageBehaviorEXT obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineRobustnessImageBehaviorEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineRobustnessImageBehaviorEXT_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineRobustnessImageBehaviorEXT(const VkPipelineRobustnessImageBehaviorEXT* obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineRobustnessImageBehaviorEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineRobustnessImageBehaviorEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDevicePipelineRobustnessFeatures(VkPhysicalDevicePipelineRobustnessFeatures obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.pipelineRobustness, "pipelineRobustness", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePipelineRobustnessFeatures(const VkPhysicalDevicePipelineRobustnessFeatures* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->pipelineRobustness, "pipelineRobustness", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDevicePipelineRobustnessFeatures VkPhysicalDevicePipelineRobustnessFeaturesEXT;

static void print_VkPhysicalDevicePipelineRobustnessProperties(VkPhysicalDevicePipelineRobustnessProperties obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineRobustnessBufferBehavior(obj.defaultRobustnessStorageBuffers, "defaultRobustnessStorageBuffers", 1);

    print_VkPipelineRobustnessBufferBehavior(obj.defaultRobustnessUniformBuffers, "defaultRobustnessUniformBuffers", 1);

    print_VkPipelineRobustnessBufferBehavior(obj.defaultRobustnessVertexInputs, "defaultRobustnessVertexInputs", 1);

    print_VkPipelineRobustnessImageBehavior(obj.defaultRobustnessImages, "defaultRobustnessImages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePipelineRobustnessProperties(const VkPhysicalDevicePipelineRobustnessProperties* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineRobustnessBufferBehavior(obj->defaultRobustnessStorageBuffers, "defaultRobustnessStorageBuffers", 1);

    print_VkPipelineRobustnessBufferBehavior(obj->defaultRobustnessUniformBuffers, "defaultRobustnessUniformBuffers", 1);

    print_VkPipelineRobustnessBufferBehavior(obj->defaultRobustnessVertexInputs, "defaultRobustnessVertexInputs", 1);

    print_VkPipelineRobustnessImageBehavior(obj->defaultRobustnessImages, "defaultRobustnessImages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDevicePipelineRobustnessProperties VkPhysicalDevicePipelineRobustnessPropertiesEXT;

static void print_VkPipelineRobustnessCreateInfo(VkPipelineRobustnessCreateInfo obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineRobustnessBufferBehavior(obj.storageBuffers, "storageBuffers", 1);

    print_VkPipelineRobustnessBufferBehavior(obj.uniformBuffers, "uniformBuffers", 1);

    print_VkPipelineRobustnessBufferBehavior(obj.vertexInputs, "vertexInputs", 1);

    print_VkPipelineRobustnessImageBehavior(obj.images, "images", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineRobustnessCreateInfo(const VkPipelineRobustnessCreateInfo* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineRobustnessBufferBehavior(obj->storageBuffers, "storageBuffers", 1);

    print_VkPipelineRobustnessBufferBehavior(obj->uniformBuffers, "uniformBuffers", 1);

    print_VkPipelineRobustnessBufferBehavior(obj->vertexInputs, "vertexInputs", 1);

    print_VkPipelineRobustnessImageBehavior(obj->images, "images", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPipelineRobustnessCreateInfo VkPipelineRobustnessCreateInfoEXT;

static std::map<uint64_t, std::string> VkConditionalRenderingFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT"),
};
static void print_VkConditionalRenderingFlagBitsEXT(VkConditionalRenderingFlagBitsEXT obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkConditionalRenderingFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkConditionalRenderingFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkConditionalRenderingFlagBitsEXT(const VkConditionalRenderingFlagBitsEXT* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkConditionalRenderingFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkConditionalRenderingFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkConditionalRenderingFlagsEXT(VkConditionalRenderingFlagsEXT obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkConditionalRenderingFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkConditionalRenderingFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkConditionalRenderingBeginInfoEXT(VkConditionalRenderingBeginInfoEXT obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.offset, "offset", 1);

    print_VkConditionalRenderingFlagsEXT(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkConditionalRenderingBeginInfoEXT(const VkConditionalRenderingBeginInfoEXT* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->offset, "offset", 1);

    print_VkConditionalRenderingFlagsEXT(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceConditionalRenderingFeaturesEXT(VkPhysicalDeviceConditionalRenderingFeaturesEXT obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.conditionalRendering, "conditionalRendering", 1);

    print_VkBool32(obj.inheritedConditionalRendering, "inheritedConditionalRendering", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceConditionalRenderingFeaturesEXT(const VkPhysicalDeviceConditionalRenderingFeaturesEXT* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->conditionalRendering, "conditionalRendering", 1);

    print_VkBool32(obj->inheritedConditionalRendering, "inheritedConditionalRendering", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCommandBufferInheritanceConditionalRenderingInfoEXT(VkCommandBufferInheritanceConditionalRenderingInfoEXT obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.conditionalRenderingEnable, "conditionalRenderingEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->conditionalRenderingEnable, "conditionalRenderingEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkViewportWScalingNV(VkViewportWScalingNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj.xcoeff, "xcoeff", 1);

    print_float(obj.ycoeff, "ycoeff", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkViewportWScalingNV(const VkViewportWScalingNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj->xcoeff, "xcoeff", 1);

    print_float(obj->ycoeff, "ycoeff", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineViewportWScalingStateCreateInfoNV(VkPipelineViewportWScalingStateCreateInfoNV obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.viewportWScalingEnable, "viewportWScalingEnable", 1);

    print_uint32_t(obj.viewportCount, "viewportCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewportWScalings\": " << std::endl;
    if (obj.pViewportWScalings) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.viewportCount; i++) {
            if (i + 1 == obj.viewportCount)
                print_VkViewportWScalingNV(obj.pViewportWScalings[i], "pViewportWScalings", 0);
            else
                print_VkViewportWScalingNV(obj.pViewportWScalings[i], "pViewportWScalings", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineViewportWScalingStateCreateInfoNV(const VkPipelineViewportWScalingStateCreateInfoNV* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->viewportWScalingEnable, "viewportWScalingEnable", 1);

    print_uint32_t(obj->viewportCount, "viewportCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewportWScalings\": " << std::endl;
    if (obj->pViewportWScalings) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->viewportCount; i++) {
            if (i + 1 == obj->viewportCount)
                print_VkViewportWScalingNV(obj->pViewportWScalings[i], "pViewportWScalings", 0);
            else
                print_VkViewportWScalingNV(obj->pViewportWScalings[i], "pViewportWScalings", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkSurfaceCounterFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_SURFACE_COUNTER_VBLANK_BIT_EXT"),
};
static void print_VkSurfaceCounterFlagBitsEXT(VkSurfaceCounterFlagBitsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSurfaceCounterFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSurfaceCounterFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkSurfaceCounterFlagBitsEXT(const VkSurfaceCounterFlagBitsEXT* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSurfaceCounterFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSurfaceCounterFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkSurfaceCounterFlagsEXT(VkSurfaceCounterFlagsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkSurfaceCounterFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkSurfaceCounterFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkSurfaceCapabilities2EXT(VkSurfaceCapabilities2EXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.minImageCount, "minImageCount", 1);

    print_uint32_t(obj.maxImageCount, "maxImageCount", 1);

    PRINT_SPACE
    _OUT << "\"currentExtent\": " << std::endl;
    { print_VkExtent2D(obj.currentExtent, "currentExtent", 1); }

    PRINT_SPACE
    _OUT << "\"minImageExtent\": " << std::endl;
    { print_VkExtent2D(obj.minImageExtent, "minImageExtent", 1); }

    PRINT_SPACE
    _OUT << "\"maxImageExtent\": " << std::endl;
    { print_VkExtent2D(obj.maxImageExtent, "maxImageExtent", 1); }

    print_uint32_t(obj.maxImageArrayLayers, "maxImageArrayLayers", 1);

    print_VkSurfaceTransformFlagsKHR(obj.supportedTransforms, "supportedTransforms", 1);

    print_VkSurfaceTransformFlagBitsKHR(obj.currentTransform, "currentTransform", 1);

    print_VkCompositeAlphaFlagsKHR(obj.supportedCompositeAlpha, "supportedCompositeAlpha", 1);

    print_VkImageUsageFlags(obj.supportedUsageFlags, "supportedUsageFlags", 1);

    print_VkSurfaceCounterFlagsEXT(obj.supportedSurfaceCounters, "supportedSurfaceCounters", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSurfaceCapabilities2EXT(const VkSurfaceCapabilities2EXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->minImageCount, "minImageCount", 1);

    print_uint32_t(obj->maxImageCount, "maxImageCount", 1);

    PRINT_SPACE
    _OUT << "\"currentExtent\": " << std::endl;
    { print_VkExtent2D(obj->currentExtent, "currentExtent", 1); }

    PRINT_SPACE
    _OUT << "\"minImageExtent\": " << std::endl;
    { print_VkExtent2D(obj->minImageExtent, "minImageExtent", 1); }

    PRINT_SPACE
    _OUT << "\"maxImageExtent\": " << std::endl;
    { print_VkExtent2D(obj->maxImageExtent, "maxImageExtent", 1); }

    print_uint32_t(obj->maxImageArrayLayers, "maxImageArrayLayers", 1);

    print_VkSurfaceTransformFlagsKHR(obj->supportedTransforms, "supportedTransforms", 1);

    print_VkSurfaceTransformFlagBitsKHR(obj->currentTransform, "currentTransform", 1);

    print_VkCompositeAlphaFlagsKHR(obj->supportedCompositeAlpha, "supportedCompositeAlpha", 1);

    print_VkImageUsageFlags(obj->supportedUsageFlags, "supportedUsageFlags", 1);

    print_VkSurfaceCounterFlagsEXT(obj->supportedSurfaceCounters, "supportedSurfaceCounters", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkDisplayPowerStateEXT_map = {
    std::make_pair(0, "VK_DISPLAY_POWER_STATE_OFF_EXT"),
    std::make_pair(1, "VK_DISPLAY_POWER_STATE_SUSPEND_EXT"),
    std::make_pair(2, "VK_DISPLAY_POWER_STATE_ON_EXT"),
};
static void print_VkDisplayPowerStateEXT(VkDisplayPowerStateEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDisplayPowerStateEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDisplayPowerStateEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDisplayPowerStateEXT(const VkDisplayPowerStateEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDisplayPowerStateEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDisplayPowerStateEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDeviceEventTypeEXT_map = {
    std::make_pair(0, "VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT"),
};
static void print_VkDeviceEventTypeEXT(VkDeviceEventTypeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceEventTypeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceEventTypeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDeviceEventTypeEXT(const VkDeviceEventTypeEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceEventTypeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceEventTypeEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDisplayEventTypeEXT_map = {
    std::make_pair(0, "VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT"),
};
static void print_VkDisplayEventTypeEXT(VkDisplayEventTypeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDisplayEventTypeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDisplayEventTypeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDisplayEventTypeEXT(const VkDisplayEventTypeEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDisplayEventTypeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDisplayEventTypeEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkDisplayPowerInfoEXT(VkDisplayPowerInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDisplayPowerStateEXT(obj.powerState, "powerState", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayPowerInfoEXT(const VkDisplayPowerInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDisplayPowerStateEXT(obj->powerState, "powerState", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceEventInfoEXT(VkDeviceEventInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceEventTypeEXT(obj.deviceEvent, "deviceEvent", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceEventInfoEXT(const VkDeviceEventInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceEventTypeEXT(obj->deviceEvent, "deviceEvent", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayEventInfoEXT(VkDisplayEventInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDisplayEventTypeEXT(obj.displayEvent, "displayEvent", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayEventInfoEXT(const VkDisplayEventInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDisplayEventTypeEXT(obj->displayEvent, "displayEvent", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSwapchainCounterCreateInfoEXT(VkSwapchainCounterCreateInfoEXT obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSurfaceCounterFlagsEXT(obj.surfaceCounters, "surfaceCounters", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSwapchainCounterCreateInfoEXT(const VkSwapchainCounterCreateInfoEXT* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSurfaceCounterFlagsEXT(obj->surfaceCounters, "surfaceCounters", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRefreshCycleDurationGOOGLE(VkRefreshCycleDurationGOOGLE obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint64_t(obj.refreshDuration, "refreshDuration", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRefreshCycleDurationGOOGLE(const VkRefreshCycleDurationGOOGLE* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint64_t(obj->refreshDuration, "refreshDuration", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPastPresentationTimingGOOGLE(VkPastPresentationTimingGOOGLE obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.presentID, "presentID", 1);

    print_uint64_t(obj.desiredPresentTime, "desiredPresentTime", 1);

    print_uint64_t(obj.actualPresentTime, "actualPresentTime", 1);

    print_uint64_t(obj.earliestPresentTime, "earliestPresentTime", 1);

    print_uint64_t(obj.presentMargin, "presentMargin", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPastPresentationTimingGOOGLE(const VkPastPresentationTimingGOOGLE* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->presentID, "presentID", 1);

    print_uint64_t(obj->desiredPresentTime, "desiredPresentTime", 1);

    print_uint64_t(obj->actualPresentTime, "actualPresentTime", 1);

    print_uint64_t(obj->earliestPresentTime, "earliestPresentTime", 1);

    print_uint64_t(obj->presentMargin, "presentMargin", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPresentTimeGOOGLE(VkPresentTimeGOOGLE obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.presentID, "presentID", 1);

    print_uint64_t(obj.desiredPresentTime, "desiredPresentTime", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPresentTimeGOOGLE(const VkPresentTimeGOOGLE* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->presentID, "presentID", 1);

    print_uint64_t(obj->desiredPresentTime, "desiredPresentTime", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPresentTimesInfoGOOGLE(VkPresentTimesInfoGOOGLE obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pTimes\": " << std::endl;
    if (obj.pTimes) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.swapchainCount; i++) {
            if (i + 1 == obj.swapchainCount)
                print_VkPresentTimeGOOGLE(obj.pTimes[i], "pTimes", 0);
            else
                print_VkPresentTimeGOOGLE(obj.pTimes[i], "pTimes", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPresentTimesInfoGOOGLE(const VkPresentTimesInfoGOOGLE* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pTimes\": " << std::endl;
    if (obj->pTimes) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->swapchainCount; i++) {
            if (i + 1 == obj->swapchainCount)
                print_VkPresentTimeGOOGLE(obj->pTimes[i], "pTimes", 0);
            else
                print_VkPresentTimeGOOGLE(obj->pTimes[i], "pTimes", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.perViewPositionAllComponents, "perViewPositionAllComponents", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->perViewPositionAllComponents, "perViewPositionAllComponents", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMultiviewPerViewAttributesInfoNVX(VkMultiviewPerViewAttributesInfoNVX obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.perViewAttributes, "perViewAttributes", 1);

    print_VkBool32(obj.perViewAttributesPositionXOnly, "perViewAttributesPositionXOnly", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMultiviewPerViewAttributesInfoNVX(const VkMultiviewPerViewAttributesInfoNVX* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->perViewAttributes, "perViewAttributes", 1);

    print_VkBool32(obj->perViewAttributesPositionXOnly, "perViewAttributesPositionXOnly", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkViewportCoordinateSwizzleNV_map = {
    std::make_pair(0, "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV"),
    std::make_pair(1, "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV"),
    std::make_pair(2, "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV"),
    std::make_pair(3, "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV"),
    std::make_pair(4, "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV"),
    std::make_pair(5, "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV"),
    std::make_pair(6, "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV"),
    std::make_pair(7, "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV"),
};
static void print_VkViewportCoordinateSwizzleNV(VkViewportCoordinateSwizzleNV obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkViewportCoordinateSwizzleNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkViewportCoordinateSwizzleNV_map[obj] << "\"" << std::endl;
}
static void print_VkViewportCoordinateSwizzleNV(const VkViewportCoordinateSwizzleNV* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkViewportCoordinateSwizzleNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkViewportCoordinateSwizzleNV_map[*obj] << "\"" << std::endl;
}

static void print_VkPipelineViewportSwizzleStateCreateFlagsNV(VkPipelineViewportSwizzleStateCreateFlagsNV obj,
                                                              const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkViewportSwizzleNV(VkViewportSwizzleNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkViewportCoordinateSwizzleNV(obj.x, "x", 1);

    print_VkViewportCoordinateSwizzleNV(obj.y, "y", 1);

    print_VkViewportCoordinateSwizzleNV(obj.z, "z", 1);

    print_VkViewportCoordinateSwizzleNV(obj.w, "w", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkViewportSwizzleNV(const VkViewportSwizzleNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkViewportCoordinateSwizzleNV(obj->x, "x", 1);

    print_VkViewportCoordinateSwizzleNV(obj->y, "y", 1);

    print_VkViewportCoordinateSwizzleNV(obj->z, "z", 1);

    print_VkViewportCoordinateSwizzleNV(obj->w, "w", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineViewportSwizzleStateCreateInfoNV(VkPipelineViewportSwizzleStateCreateInfoNV obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineViewportSwizzleStateCreateFlagsNV(obj.flags, "flags", 1);

    print_uint32_t(obj.viewportCount, "viewportCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewportSwizzles\": " << std::endl;
    if (obj.pViewportSwizzles) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.viewportCount; i++) {
            if (i + 1 == obj.viewportCount)
                print_VkViewportSwizzleNV(obj.pViewportSwizzles[i], "pViewportSwizzles", 0);
            else
                print_VkViewportSwizzleNV(obj.pViewportSwizzles[i], "pViewportSwizzles", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineViewportSwizzleStateCreateInfoNV(const VkPipelineViewportSwizzleStateCreateInfoNV* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineViewportSwizzleStateCreateFlagsNV(obj->flags, "flags", 1);

    print_uint32_t(obj->viewportCount, "viewportCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewportSwizzles\": " << std::endl;
    if (obj->pViewportSwizzles) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->viewportCount; i++) {
            if (i + 1 == obj->viewportCount)
                print_VkViewportSwizzleNV(obj->pViewportSwizzles[i], "pViewportSwizzles", 0);
            else
                print_VkViewportSwizzleNV(obj->pViewportSwizzles[i], "pViewportSwizzles", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkDiscardRectangleModeEXT_map = {
    std::make_pair(0, "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT"),
    std::make_pair(1, "VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT"),
};
static void print_VkDiscardRectangleModeEXT(VkDiscardRectangleModeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDiscardRectangleModeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDiscardRectangleModeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDiscardRectangleModeEXT(const VkDiscardRectangleModeEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDiscardRectangleModeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDiscardRectangleModeEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkPipelineDiscardRectangleStateCreateFlagsEXT(VkPipelineDiscardRectangleStateCreateFlagsEXT obj,
                                                                const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPhysicalDeviceDiscardRectanglePropertiesEXT(VkPhysicalDeviceDiscardRectanglePropertiesEXT obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxDiscardRectangles, "maxDiscardRectangles", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDiscardRectanglePropertiesEXT(const VkPhysicalDeviceDiscardRectanglePropertiesEXT* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxDiscardRectangles, "maxDiscardRectangles", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineDiscardRectangleStateCreateInfoEXT(VkPipelineDiscardRectangleStateCreateInfoEXT obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineDiscardRectangleStateCreateFlagsEXT(obj.flags, "flags", 1);

    print_VkDiscardRectangleModeEXT(obj.discardRectangleMode, "discardRectangleMode", 1);

    print_uint32_t(obj.discardRectangleCount, "discardRectangleCount", 1);

    PRINT_SPACE
    _OUT << "\"pDiscardRectangles\": " << std::endl;
    if (obj.pDiscardRectangles) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.discardRectangleCount; i++) {
            if (i + 1 == obj.discardRectangleCount)
                print_VkRect2D(obj.pDiscardRectangles[i], "pDiscardRectangles", 0);
            else
                print_VkRect2D(obj.pDiscardRectangles[i], "pDiscardRectangles", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineDiscardRectangleStateCreateInfoEXT(const VkPipelineDiscardRectangleStateCreateInfoEXT* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineDiscardRectangleStateCreateFlagsEXT(obj->flags, "flags", 1);

    print_VkDiscardRectangleModeEXT(obj->discardRectangleMode, "discardRectangleMode", 1);

    print_uint32_t(obj->discardRectangleCount, "discardRectangleCount", 1);

    PRINT_SPACE
    _OUT << "\"pDiscardRectangles\": " << std::endl;
    if (obj->pDiscardRectangles) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->discardRectangleCount; i++) {
            if (i + 1 == obj->discardRectangleCount)
                print_VkRect2D(obj->pDiscardRectangles[i], "pDiscardRectangles", 0);
            else
                print_VkRect2D(obj->pDiscardRectangles[i], "pDiscardRectangles", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkConservativeRasterizationModeEXT_map = {
    std::make_pair(0, "VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT"),
    std::make_pair(1, "VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT"),
    std::make_pair(2, "VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT"),
};
static void print_VkConservativeRasterizationModeEXT(VkConservativeRasterizationModeEXT obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkConservativeRasterizationModeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkConservativeRasterizationModeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkConservativeRasterizationModeEXT(const VkConservativeRasterizationModeEXT* obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkConservativeRasterizationModeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkConservativeRasterizationModeEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkPipelineRasterizationConservativeStateCreateFlagsEXT(VkPipelineRasterizationConservativeStateCreateFlagsEXT obj,
                                                                         const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(VkPhysicalDeviceConservativeRasterizationPropertiesEXT obj,
                                                                         const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_float(obj.primitiveOverestimationSize, "primitiveOverestimationSize", 1);

    print_float(obj.maxExtraPrimitiveOverestimationSize, "maxExtraPrimitiveOverestimationSize", 1);

    print_float(obj.extraPrimitiveOverestimationSizeGranularity, "extraPrimitiveOverestimationSizeGranularity", 1);

    print_VkBool32(obj.primitiveUnderestimation, "primitiveUnderestimation", 1);

    print_VkBool32(obj.conservativePointAndLineRasterization, "conservativePointAndLineRasterization", 1);

    print_VkBool32(obj.degenerateTrianglesRasterized, "degenerateTrianglesRasterized", 1);

    print_VkBool32(obj.degenerateLinesRasterized, "degenerateLinesRasterized", 1);

    print_VkBool32(obj.fullyCoveredFragmentShaderInputVariable, "fullyCoveredFragmentShaderInputVariable", 1);

    print_VkBool32(obj.conservativeRasterizationPostDepthCoverage, "conservativeRasterizationPostDepthCoverage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_float(obj->primitiveOverestimationSize, "primitiveOverestimationSize", 1);

    print_float(obj->maxExtraPrimitiveOverestimationSize, "maxExtraPrimitiveOverestimationSize", 1);

    print_float(obj->extraPrimitiveOverestimationSizeGranularity, "extraPrimitiveOverestimationSizeGranularity", 1);

    print_VkBool32(obj->primitiveUnderestimation, "primitiveUnderestimation", 1);

    print_VkBool32(obj->conservativePointAndLineRasterization, "conservativePointAndLineRasterization", 1);

    print_VkBool32(obj->degenerateTrianglesRasterized, "degenerateTrianglesRasterized", 1);

    print_VkBool32(obj->degenerateLinesRasterized, "degenerateLinesRasterized", 1);

    print_VkBool32(obj->fullyCoveredFragmentShaderInputVariable, "fullyCoveredFragmentShaderInputVariable", 1);

    print_VkBool32(obj->conservativeRasterizationPostDepthCoverage, "conservativeRasterizationPostDepthCoverage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineRasterizationConservativeStateCreateInfoEXT(VkPipelineRasterizationConservativeStateCreateInfoEXT obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineRasterizationConservativeStateCreateFlagsEXT(obj.flags, "flags", 1);

    print_VkConservativeRasterizationModeEXT(obj.conservativeRasterizationMode, "conservativeRasterizationMode", 1);

    print_float(obj.extraPrimitiveOverestimationSize, "extraPrimitiveOverestimationSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineRasterizationConservativeStateCreateFlagsEXT(obj->flags, "flags", 1);

    print_VkConservativeRasterizationModeEXT(obj->conservativeRasterizationMode, "conservativeRasterizationMode", 1);

    print_float(obj->extraPrimitiveOverestimationSize, "extraPrimitiveOverestimationSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineRasterizationDepthClipStateCreateFlagsEXT(VkPipelineRasterizationDepthClipStateCreateFlagsEXT obj,
                                                                      const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPhysicalDeviceDepthClipEnableFeaturesEXT(VkPhysicalDeviceDepthClipEnableFeaturesEXT obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.depthClipEnable, "depthClipEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDepthClipEnableFeaturesEXT(const VkPhysicalDeviceDepthClipEnableFeaturesEXT* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->depthClipEnable, "depthClipEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineRasterizationDepthClipStateCreateInfoEXT(VkPipelineRasterizationDepthClipStateCreateInfoEXT obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineRasterizationDepthClipStateCreateFlagsEXT(obj.flags, "flags", 1);

    print_VkBool32(obj.depthClipEnable, "depthClipEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineRasterizationDepthClipStateCreateInfoEXT(const VkPipelineRasterizationDepthClipStateCreateInfoEXT* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineRasterizationDepthClipStateCreateFlagsEXT(obj->flags, "flags", 1);

    print_VkBool32(obj->depthClipEnable, "depthClipEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkXYColorEXT(VkXYColorEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj.x, "x", 1);

    print_float(obj.y, "y", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkXYColorEXT(const VkXYColorEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj->x, "x", 1);

    print_float(obj->y, "y", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkHdrMetadataEXT(VkHdrMetadataEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"displayPrimaryRed\": " << std::endl;
    { print_VkXYColorEXT(obj.displayPrimaryRed, "displayPrimaryRed", 1); }

    PRINT_SPACE
    _OUT << "\"displayPrimaryGreen\": " << std::endl;
    { print_VkXYColorEXT(obj.displayPrimaryGreen, "displayPrimaryGreen", 1); }

    PRINT_SPACE
    _OUT << "\"displayPrimaryBlue\": " << std::endl;
    { print_VkXYColorEXT(obj.displayPrimaryBlue, "displayPrimaryBlue", 1); }

    PRINT_SPACE
    _OUT << "\"whitePoint\": " << std::endl;
    { print_VkXYColorEXT(obj.whitePoint, "whitePoint", 1); }

    print_float(obj.maxLuminance, "maxLuminance", 1);

    print_float(obj.minLuminance, "minLuminance", 1);

    print_float(obj.maxContentLightLevel, "maxContentLightLevel", 1);

    print_float(obj.maxFrameAverageLightLevel, "maxFrameAverageLightLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkHdrMetadataEXT(const VkHdrMetadataEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"displayPrimaryRed\": " << std::endl;
    { print_VkXYColorEXT(obj->displayPrimaryRed, "displayPrimaryRed", 1); }

    PRINT_SPACE
    _OUT << "\"displayPrimaryGreen\": " << std::endl;
    { print_VkXYColorEXT(obj->displayPrimaryGreen, "displayPrimaryGreen", 1); }

    PRINT_SPACE
    _OUT << "\"displayPrimaryBlue\": " << std::endl;
    { print_VkXYColorEXT(obj->displayPrimaryBlue, "displayPrimaryBlue", 1); }

    PRINT_SPACE
    _OUT << "\"whitePoint\": " << std::endl;
    { print_VkXYColorEXT(obj->whitePoint, "whitePoint", 1); }

    print_float(obj->maxLuminance, "maxLuminance", 1);

    print_float(obj->minLuminance, "minLuminance", 1);

    print_float(obj->maxContentLightLevel, "maxContentLightLevel", 1);

    print_float(obj->maxFrameAverageLightLevel, "maxFrameAverageLightLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.relaxedLineRasterization, "relaxedLineRasterization", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(
    const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->relaxedLineRasterization, "relaxedLineRasterization", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDebugUtilsMessengerEXT(VkDebugUtilsMessengerEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDebugUtilsMessageSeverityFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT"),
    std::make_pair(1ULL << 4, "VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT"),
    std::make_pair(1ULL << 8, "VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT"),
    std::make_pair(1ULL << 12, "VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT"),
};
static void print_VkDebugUtilsMessageSeverityFlagBitsEXT(VkDebugUtilsMessageSeverityFlagBitsEXT obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDebugUtilsMessageSeverityFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDebugUtilsMessageSeverityFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDebugUtilsMessageSeverityFlagBitsEXT(const VkDebugUtilsMessageSeverityFlagBitsEXT* obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDebugUtilsMessageSeverityFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDebugUtilsMessageSeverityFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDebugUtilsMessageTypeFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT"),
    std::make_pair(1ULL << 1, "VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT"),
    std::make_pair(1ULL << 2, "VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT"),
    std::make_pair(1ULL << 3, "VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT"),
};
static void print_VkDebugUtilsMessageTypeFlagBitsEXT(VkDebugUtilsMessageTypeFlagBitsEXT obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDebugUtilsMessageTypeFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDebugUtilsMessageTypeFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDebugUtilsMessageTypeFlagBitsEXT(const VkDebugUtilsMessageTypeFlagBitsEXT* obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDebugUtilsMessageTypeFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDebugUtilsMessageTypeFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkDebugUtilsMessengerCallbackDataFlagsEXT(VkDebugUtilsMessengerCallbackDataFlagsEXT obj, const std::string& str,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkDebugUtilsMessageTypeFlagsEXT(VkDebugUtilsMessageTypeFlagsEXT obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkDebugUtilsMessageTypeFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkDebugUtilsMessageTypeFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkDebugUtilsMessageSeverityFlagsEXT(VkDebugUtilsMessageSeverityFlagsEXT obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkDebugUtilsMessageSeverityFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkDebugUtilsMessageSeverityFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkDebugUtilsMessengerCreateFlagsEXT(VkDebugUtilsMessengerCreateFlagsEXT obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkDebugUtilsLabelEXT(VkDebugUtilsLabelEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_char(obj.pLabelName, "pLabelName", 1);

    PRINT_SPACE
    _OUT << "\"color\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 4; i++) {
        bool isCommaNeeded = (i + 1) != 4;
        print_float(obj.color[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDebugUtilsLabelEXT(const VkDebugUtilsLabelEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_char(obj->pLabelName, "pLabelName", 1);

    PRINT_SPACE
    _OUT << "\"color\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 4; i++) {
        bool isCommaNeeded = (i + 1) != 4;
        print_float(obj->color[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDebugUtilsObjectNameInfoEXT(VkDebugUtilsObjectNameInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkObjectType(obj.objectType, "objectType", 1);

    print_uint64_t(obj.objectHandle, "objectHandle", 1);

    print_char(obj.pObjectName, "pObjectName", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDebugUtilsObjectNameInfoEXT(const VkDebugUtilsObjectNameInfoEXT* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkObjectType(obj->objectType, "objectType", 1);

    print_uint64_t(obj->objectHandle, "objectHandle", 1);

    print_char(obj->pObjectName, "pObjectName", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDebugUtilsMessengerCallbackDataEXT(VkDebugUtilsMessengerCallbackDataEXT obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDebugUtilsMessengerCallbackDataFlagsEXT(obj.flags, "flags", 1);

    print_char(obj.pMessageIdName, "pMessageIdName", 1);

    print_int32_t(obj.messageIdNumber, "messageIdNumber", 1);

    print_char(obj.pMessage, "pMessage", 1);

    print_uint32_t(obj.queueLabelCount, "queueLabelCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueueLabels\": " << std::endl;
    if (obj.pQueueLabels) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.queueLabelCount; i++) {
            if (i + 1 == obj.queueLabelCount)
                print_VkDebugUtilsLabelEXT(obj.pQueueLabels[i], "pQueueLabels", 0);
            else
                print_VkDebugUtilsLabelEXT(obj.pQueueLabels[i], "pQueueLabels", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.cmdBufLabelCount, "cmdBufLabelCount", 1);

    PRINT_SPACE
    _OUT << "\"pCmdBufLabels\": " << std::endl;
    if (obj.pCmdBufLabels) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.cmdBufLabelCount; i++) {
            if (i + 1 == obj.cmdBufLabelCount)
                print_VkDebugUtilsLabelEXT(obj.pCmdBufLabels[i], "pCmdBufLabels", 0);
            else
                print_VkDebugUtilsLabelEXT(obj.pCmdBufLabels[i], "pCmdBufLabels", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.objectCount, "objectCount", 1);

    PRINT_SPACE
    _OUT << "\"pObjects\": " << std::endl;
    if (obj.pObjects) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.objectCount; i++) {
            if (i + 1 == obj.objectCount)
                print_VkDebugUtilsObjectNameInfoEXT(obj.pObjects[i], "pObjects", 0);
            else
                print_VkDebugUtilsObjectNameInfoEXT(obj.pObjects[i], "pObjects", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDebugUtilsMessengerCallbackDataEXT(const VkDebugUtilsMessengerCallbackDataEXT* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDebugUtilsMessengerCallbackDataFlagsEXT(obj->flags, "flags", 1);

    print_char(obj->pMessageIdName, "pMessageIdName", 1);

    print_int32_t(obj->messageIdNumber, "messageIdNumber", 1);

    print_char(obj->pMessage, "pMessage", 1);

    print_uint32_t(obj->queueLabelCount, "queueLabelCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueueLabels\": " << std::endl;
    if (obj->pQueueLabels) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->queueLabelCount; i++) {
            if (i + 1 == obj->queueLabelCount)
                print_VkDebugUtilsLabelEXT(obj->pQueueLabels[i], "pQueueLabels", 0);
            else
                print_VkDebugUtilsLabelEXT(obj->pQueueLabels[i], "pQueueLabels", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->cmdBufLabelCount, "cmdBufLabelCount", 1);

    PRINT_SPACE
    _OUT << "\"pCmdBufLabels\": " << std::endl;
    if (obj->pCmdBufLabels) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->cmdBufLabelCount; i++) {
            if (i + 1 == obj->cmdBufLabelCount)
                print_VkDebugUtilsLabelEXT(obj->pCmdBufLabels[i], "pCmdBufLabels", 0);
            else
                print_VkDebugUtilsLabelEXT(obj->pCmdBufLabels[i], "pCmdBufLabels", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->objectCount, "objectCount", 1);

    PRINT_SPACE
    _OUT << "\"pObjects\": " << std::endl;
    if (obj->pObjects) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->objectCount; i++) {
            if (i + 1 == obj->objectCount)
                print_VkDebugUtilsObjectNameInfoEXT(obj->pObjects[i], "pObjects", 0);
            else
                print_VkDebugUtilsObjectNameInfoEXT(obj->pObjects[i], "pObjects", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDebugUtilsMessengerCreateInfoEXT(VkDebugUtilsMessengerCreateInfoEXT obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDebugUtilsMessengerCreateFlagsEXT(obj.flags, "flags", 1);

    print_VkDebugUtilsMessageSeverityFlagsEXT(obj.messageSeverity, "messageSeverity", 1);

    print_VkDebugUtilsMessageTypeFlagsEXT(obj.messageType, "messageType", 1);

    /** Note: Ignoring function pointer (PFN_vkDebugUtilsMessengerCallbackEXT). **/

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDebugUtilsMessengerCreateInfoEXT(const VkDebugUtilsMessengerCreateInfoEXT* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDebugUtilsMessengerCreateFlagsEXT(obj->flags, "flags", 1);

    print_VkDebugUtilsMessageSeverityFlagsEXT(obj->messageSeverity, "messageSeverity", 1);

    print_VkDebugUtilsMessageTypeFlagsEXT(obj->messageType, "messageType", 1);

    /** Note: Ignoring function pointer (PFN_vkDebugUtilsMessengerCallbackEXT). **/

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDebugUtilsObjectTagInfoEXT(VkDebugUtilsObjectTagInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkObjectType(obj.objectType, "objectType", 1);

    print_uint64_t(obj.objectHandle, "objectHandle", 1);

    print_uint64_t(obj.tagName, "tagName", 1);

    print_size_t(obj.tagSize, "tagSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDebugUtilsObjectTagInfoEXT(const VkDebugUtilsObjectTagInfoEXT* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkObjectType(obj->objectType, "objectType", 1);

    print_uint64_t(obj->objectHandle, "objectHandle", 1);

    print_uint64_t(obj->tagName, "tagName", 1);

    print_size_t(obj->tagSize, "tagSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkSamplerReductionModeEXT_map = {
    std::make_pair(0, "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE"),
    std::make_pair(1, "VK_SAMPLER_REDUCTION_MODE_MIN"),
    std::make_pair(2, "VK_SAMPLER_REDUCTION_MODE_MAX"),
    std::make_pair(1000521000, "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM"),
};
static void print_VkSamplerReductionModeEXT(VkSamplerReductionModeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerReductionModeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerReductionModeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkSamplerReductionModeEXT(const VkSamplerReductionModeEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSamplerReductionModeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSamplerReductionModeEXT_map[*obj] << "\"" << std::endl;
}

typedef VkSamplerReductionModeCreateInfo VkSamplerReductionModeCreateInfoEXT;

typedef VkPhysicalDeviceSamplerFilterMinmaxProperties VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT;

static void print_VkAttachmentSampleCountInfoAMD(VkAttachmentSampleCountInfoAMD obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachmentSamples\":" << std::endl;
    PRINT_SPACE
    if (obj.pColorAttachmentSamples) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.colorAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.colorAttachmentCount;
            print_VkSampleCountFlagBits(obj.pColorAttachmentSamples[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSampleCountFlagBits(obj.depthStencilAttachmentSamples, "depthStencilAttachmentSamples", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAttachmentSampleCountInfoAMD(const VkAttachmentSampleCountInfoAMD* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->colorAttachmentCount, "colorAttachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorAttachmentSamples\":" << std::endl;
    PRINT_SPACE
    if (obj->pColorAttachmentSamples) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->colorAttachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->colorAttachmentCount;
            print_VkSampleCountFlagBits(obj->pColorAttachmentSamples[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSampleCountFlagBits(obj->depthStencilAttachmentSamples, "depthStencilAttachmentSamples", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceInlineUniformBlockFeatures(VkPhysicalDeviceInlineUniformBlockFeatures obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.inlineUniformBlock, "inlineUniformBlock", 1);

    print_VkBool32(obj.descriptorBindingInlineUniformBlockUpdateAfterBind, "descriptorBindingInlineUniformBlockUpdateAfterBind", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceInlineUniformBlockFeatures(const VkPhysicalDeviceInlineUniformBlockFeatures* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->inlineUniformBlock, "inlineUniformBlock", 1);

    print_VkBool32(obj->descriptorBindingInlineUniformBlockUpdateAfterBind, "descriptorBindingInlineUniformBlockUpdateAfterBind",
                   0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceInlineUniformBlockFeatures VkPhysicalDeviceInlineUniformBlockFeaturesEXT;

static void print_VkPhysicalDeviceInlineUniformBlockProperties(VkPhysicalDeviceInlineUniformBlockProperties obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxInlineUniformBlockSize, "maxInlineUniformBlockSize", 1);

    print_uint32_t(obj.maxPerStageDescriptorInlineUniformBlocks, "maxPerStageDescriptorInlineUniformBlocks", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks,
                   "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks", 1);

    print_uint32_t(obj.maxDescriptorSetInlineUniformBlocks, "maxDescriptorSetInlineUniformBlocks", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindInlineUniformBlocks, "maxDescriptorSetUpdateAfterBindInlineUniformBlocks", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceInlineUniformBlockProperties(const VkPhysicalDeviceInlineUniformBlockProperties* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxInlineUniformBlockSize, "maxInlineUniformBlockSize", 1);

    print_uint32_t(obj->maxPerStageDescriptorInlineUniformBlocks, "maxPerStageDescriptorInlineUniformBlocks", 1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks,
                   "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks", 1);

    print_uint32_t(obj->maxDescriptorSetInlineUniformBlocks, "maxDescriptorSetInlineUniformBlocks", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindInlineUniformBlocks, "maxDescriptorSetUpdateAfterBindInlineUniformBlocks",
                   0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceInlineUniformBlockProperties VkPhysicalDeviceInlineUniformBlockPropertiesEXT;

static void print_VkWriteDescriptorSetInlineUniformBlock(VkWriteDescriptorSetInlineUniformBlock obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.dataSize, "dataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkWriteDescriptorSetInlineUniformBlock(const VkWriteDescriptorSetInlineUniformBlock* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->dataSize, "dataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkWriteDescriptorSetInlineUniformBlock VkWriteDescriptorSetInlineUniformBlockEXT;

static void print_VkDescriptorPoolInlineUniformBlockCreateInfo(VkDescriptorPoolInlineUniformBlockCreateInfo obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxInlineUniformBlockBindings, "maxInlineUniformBlockBindings", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorPoolInlineUniformBlockCreateInfo(const VkDescriptorPoolInlineUniformBlockCreateInfo* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxInlineUniformBlockBindings, "maxInlineUniformBlockBindings", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkDescriptorPoolInlineUniformBlockCreateInfo VkDescriptorPoolInlineUniformBlockCreateInfoEXT;

static void print_VkSampleLocationEXT(VkSampleLocationEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj.x, "x", 1);

    print_float(obj.y, "y", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSampleLocationEXT(const VkSampleLocationEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj->x, "x", 1);

    print_float(obj->y, "y", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSampleLocationsInfoEXT(VkSampleLocationsInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSampleCountFlagBits(obj.sampleLocationsPerPixel, "sampleLocationsPerPixel", 1);

    PRINT_SPACE
    _OUT << "\"sampleLocationGridSize\": " << std::endl;
    { print_VkExtent2D(obj.sampleLocationGridSize, "sampleLocationGridSize", 1); }

    print_uint32_t(obj.sampleLocationsCount, "sampleLocationsCount", 1);

    PRINT_SPACE
    _OUT << "\"pSampleLocations\": " << std::endl;
    if (obj.pSampleLocations) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.sampleLocationsCount; i++) {
            if (i + 1 == obj.sampleLocationsCount)
                print_VkSampleLocationEXT(obj.pSampleLocations[i], "pSampleLocations", 0);
            else
                print_VkSampleLocationEXT(obj.pSampleLocations[i], "pSampleLocations", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSampleLocationsInfoEXT(const VkSampleLocationsInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSampleCountFlagBits(obj->sampleLocationsPerPixel, "sampleLocationsPerPixel", 1);

    PRINT_SPACE
    _OUT << "\"sampleLocationGridSize\": " << std::endl;
    { print_VkExtent2D(obj->sampleLocationGridSize, "sampleLocationGridSize", 1); }

    print_uint32_t(obj->sampleLocationsCount, "sampleLocationsCount", 1);

    PRINT_SPACE
    _OUT << "\"pSampleLocations\": " << std::endl;
    if (obj->pSampleLocations) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->sampleLocationsCount; i++) {
            if (i + 1 == obj->sampleLocationsCount)
                print_VkSampleLocationEXT(obj->pSampleLocations[i], "pSampleLocations", 0);
            else
                print_VkSampleLocationEXT(obj->pSampleLocations[i], "pSampleLocations", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAttachmentSampleLocationsEXT(VkAttachmentSampleLocationsEXT obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.attachmentIndex, "attachmentIndex", 1);

    PRINT_SPACE
    _OUT << "\"sampleLocationsInfo\": " << std::endl;
    { print_VkSampleLocationsInfoEXT(obj.sampleLocationsInfo, "sampleLocationsInfo", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAttachmentSampleLocationsEXT(const VkAttachmentSampleLocationsEXT* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->attachmentIndex, "attachmentIndex", 1);

    PRINT_SPACE
    _OUT << "\"sampleLocationsInfo\": " << std::endl;
    { print_VkSampleLocationsInfoEXT(obj->sampleLocationsInfo, "sampleLocationsInfo", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubpassSampleLocationsEXT(VkSubpassSampleLocationsEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.subpassIndex, "subpassIndex", 1);

    PRINT_SPACE
    _OUT << "\"sampleLocationsInfo\": " << std::endl;
    { print_VkSampleLocationsInfoEXT(obj.sampleLocationsInfo, "sampleLocationsInfo", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubpassSampleLocationsEXT(const VkSubpassSampleLocationsEXT* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->subpassIndex, "subpassIndex", 1);

    PRINT_SPACE
    _OUT << "\"sampleLocationsInfo\": " << std::endl;
    { print_VkSampleLocationsInfoEXT(obj->sampleLocationsInfo, "sampleLocationsInfo", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassSampleLocationsBeginInfoEXT(VkRenderPassSampleLocationsBeginInfoEXT obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.attachmentInitialSampleLocationsCount, "attachmentInitialSampleLocationsCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachmentInitialSampleLocations\": " << std::endl;
    if (obj.pAttachmentInitialSampleLocations) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.attachmentInitialSampleLocationsCount; i++) {
            if (i + 1 == obj.attachmentInitialSampleLocationsCount)
                print_VkAttachmentSampleLocationsEXT(obj.pAttachmentInitialSampleLocations[i], "pAttachmentInitialSampleLocations",
                                                     0);
            else
                print_VkAttachmentSampleLocationsEXT(obj.pAttachmentInitialSampleLocations[i], "pAttachmentInitialSampleLocations",
                                                     1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.postSubpassSampleLocationsCount, "postSubpassSampleLocationsCount", 1);

    PRINT_SPACE
    _OUT << "\"pPostSubpassSampleLocations\": " << std::endl;
    if (obj.pPostSubpassSampleLocations) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.postSubpassSampleLocationsCount; i++) {
            if (i + 1 == obj.postSubpassSampleLocationsCount)
                print_VkSubpassSampleLocationsEXT(obj.pPostSubpassSampleLocations[i], "pPostSubpassSampleLocations", 0);
            else
                print_VkSubpassSampleLocationsEXT(obj.pPostSubpassSampleLocations[i], "pPostSubpassSampleLocations", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassSampleLocationsBeginInfoEXT(const VkRenderPassSampleLocationsBeginInfoEXT* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->attachmentInitialSampleLocationsCount, "attachmentInitialSampleLocationsCount", 1);

    PRINT_SPACE
    _OUT << "\"pAttachmentInitialSampleLocations\": " << std::endl;
    if (obj->pAttachmentInitialSampleLocations) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->attachmentInitialSampleLocationsCount; i++) {
            if (i + 1 == obj->attachmentInitialSampleLocationsCount)
                print_VkAttachmentSampleLocationsEXT(obj->pAttachmentInitialSampleLocations[i], "pAttachmentInitialSampleLocations",
                                                     0);
            else
                print_VkAttachmentSampleLocationsEXT(obj->pAttachmentInitialSampleLocations[i], "pAttachmentInitialSampleLocations",
                                                     1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->postSubpassSampleLocationsCount, "postSubpassSampleLocationsCount", 1);

    PRINT_SPACE
    _OUT << "\"pPostSubpassSampleLocations\": " << std::endl;
    if (obj->pPostSubpassSampleLocations) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->postSubpassSampleLocationsCount; i++) {
            if (i + 1 == obj->postSubpassSampleLocationsCount)
                print_VkSubpassSampleLocationsEXT(obj->pPostSubpassSampleLocations[i], "pPostSubpassSampleLocations", 0);
            else
                print_VkSubpassSampleLocationsEXT(obj->pPostSubpassSampleLocations[i], "pPostSubpassSampleLocations", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineSampleLocationsStateCreateInfoEXT(VkPipelineSampleLocationsStateCreateInfoEXT obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.sampleLocationsEnable, "sampleLocationsEnable", 1);

    PRINT_SPACE
    _OUT << "\"sampleLocationsInfo\": " << std::endl;
    { print_VkSampleLocationsInfoEXT(obj.sampleLocationsInfo, "sampleLocationsInfo", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineSampleLocationsStateCreateInfoEXT(const VkPipelineSampleLocationsStateCreateInfoEXT* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->sampleLocationsEnable, "sampleLocationsEnable", 1);

    PRINT_SPACE
    _OUT << "\"sampleLocationsInfo\": " << std::endl;
    { print_VkSampleLocationsInfoEXT(obj->sampleLocationsInfo, "sampleLocationsInfo", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceSampleLocationsPropertiesEXT(VkPhysicalDeviceSampleLocationsPropertiesEXT obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSampleCountFlags(obj.sampleLocationSampleCounts, "sampleLocationSampleCounts", 1);

    PRINT_SPACE
    _OUT << "\"maxSampleLocationGridSize\": " << std::endl;
    { print_VkExtent2D(obj.maxSampleLocationGridSize, "maxSampleLocationGridSize", 1); }

    PRINT_SPACE
    _OUT << "\"sampleLocationCoordinateRange\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_float(obj.sampleLocationCoordinateRange[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.sampleLocationSubPixelBits, "sampleLocationSubPixelBits", 1);

    print_VkBool32(obj.variableSampleLocations, "variableSampleLocations", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSampleLocationsPropertiesEXT(const VkPhysicalDeviceSampleLocationsPropertiesEXT* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSampleCountFlags(obj->sampleLocationSampleCounts, "sampleLocationSampleCounts", 1);

    PRINT_SPACE
    _OUT << "\"maxSampleLocationGridSize\": " << std::endl;
    { print_VkExtent2D(obj->maxSampleLocationGridSize, "maxSampleLocationGridSize", 1); }

    PRINT_SPACE
    _OUT << "\"sampleLocationCoordinateRange\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_float(obj->sampleLocationCoordinateRange[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->sampleLocationSubPixelBits, "sampleLocationSubPixelBits", 1);

    print_VkBool32(obj->variableSampleLocations, "variableSampleLocations", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMultisamplePropertiesEXT(VkMultisamplePropertiesEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"maxSampleLocationGridSize\": " << std::endl;
    { print_VkExtent2D(obj.maxSampleLocationGridSize, "maxSampleLocationGridSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMultisamplePropertiesEXT(const VkMultisamplePropertiesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"maxSampleLocationGridSize\": " << std::endl;
    { print_VkExtent2D(obj->maxSampleLocationGridSize, "maxSampleLocationGridSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkBlendOverlapEXT_map = {
    std::make_pair(0, "VK_BLEND_OVERLAP_UNCORRELATED_EXT"),
    std::make_pair(1, "VK_BLEND_OVERLAP_DISJOINT_EXT"),
    std::make_pair(2, "VK_BLEND_OVERLAP_CONJOINT_EXT"),
};
static void print_VkBlendOverlapEXT(VkBlendOverlapEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBlendOverlapEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBlendOverlapEXT_map[obj] << "\"" << std::endl;
}
static void print_VkBlendOverlapEXT(const VkBlendOverlapEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBlendOverlapEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBlendOverlapEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.advancedBlendCoherentOperations, "advancedBlendCoherentOperations", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->advancedBlendCoherentOperations, "advancedBlendCoherentOperations", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.advancedBlendMaxColorAttachments, "advancedBlendMaxColorAttachments", 1);

    print_VkBool32(obj.advancedBlendIndependentBlend, "advancedBlendIndependentBlend", 1);

    print_VkBool32(obj.advancedBlendNonPremultipliedSrcColor, "advancedBlendNonPremultipliedSrcColor", 1);

    print_VkBool32(obj.advancedBlendNonPremultipliedDstColor, "advancedBlendNonPremultipliedDstColor", 1);

    print_VkBool32(obj.advancedBlendCorrelatedOverlap, "advancedBlendCorrelatedOverlap", 1);

    print_VkBool32(obj.advancedBlendAllOperations, "advancedBlendAllOperations", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->advancedBlendMaxColorAttachments, "advancedBlendMaxColorAttachments", 1);

    print_VkBool32(obj->advancedBlendIndependentBlend, "advancedBlendIndependentBlend", 1);

    print_VkBool32(obj->advancedBlendNonPremultipliedSrcColor, "advancedBlendNonPremultipliedSrcColor", 1);

    print_VkBool32(obj->advancedBlendNonPremultipliedDstColor, "advancedBlendNonPremultipliedDstColor", 1);

    print_VkBool32(obj->advancedBlendCorrelatedOverlap, "advancedBlendCorrelatedOverlap", 1);

    print_VkBool32(obj->advancedBlendAllOperations, "advancedBlendAllOperations", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineColorBlendAdvancedStateCreateInfoEXT(VkPipelineColorBlendAdvancedStateCreateInfoEXT obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.srcPremultiplied, "srcPremultiplied", 1);

    print_VkBool32(obj.dstPremultiplied, "dstPremultiplied", 1);

    print_VkBlendOverlapEXT(obj.blendOverlap, "blendOverlap", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineColorBlendAdvancedStateCreateInfoEXT(const VkPipelineColorBlendAdvancedStateCreateInfoEXT* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->srcPremultiplied, "srcPremultiplied", 1);

    print_VkBool32(obj->dstPremultiplied, "dstPremultiplied", 1);

    print_VkBlendOverlapEXT(obj->blendOverlap, "blendOverlap", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineCoverageToColorStateCreateFlagsNV(VkPipelineCoverageToColorStateCreateFlagsNV obj,
                                                              const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPipelineCoverageToColorStateCreateInfoNV(VkPipelineCoverageToColorStateCreateInfoNV obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCoverageToColorStateCreateFlagsNV(obj.flags, "flags", 1);

    print_VkBool32(obj.coverageToColorEnable, "coverageToColorEnable", 1);

    print_uint32_t(obj.coverageToColorLocation, "coverageToColorLocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineCoverageToColorStateCreateInfoNV(const VkPipelineCoverageToColorStateCreateInfoNV* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCoverageToColorStateCreateFlagsNV(obj->flags, "flags", 1);

    print_VkBool32(obj->coverageToColorEnable, "coverageToColorEnable", 1);

    print_uint32_t(obj->coverageToColorLocation, "coverageToColorLocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkCoverageModulationModeNV_map = {
    std::make_pair(0, "VK_COVERAGE_MODULATION_MODE_NONE_NV"),
    std::make_pair(1, "VK_COVERAGE_MODULATION_MODE_RGB_NV"),
    std::make_pair(2, "VK_COVERAGE_MODULATION_MODE_ALPHA_NV"),
    std::make_pair(3, "VK_COVERAGE_MODULATION_MODE_RGBA_NV"),
};
static void print_VkCoverageModulationModeNV(VkCoverageModulationModeNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCoverageModulationModeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCoverageModulationModeNV_map[obj] << "\"" << std::endl;
}
static void print_VkCoverageModulationModeNV(const VkCoverageModulationModeNV* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCoverageModulationModeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCoverageModulationModeNV_map[*obj] << "\"" << std::endl;
}

static void print_VkPipelineCoverageModulationStateCreateFlagsNV(VkPipelineCoverageModulationStateCreateFlagsNV obj,
                                                                 const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPipelineCoverageModulationStateCreateInfoNV(VkPipelineCoverageModulationStateCreateInfoNV obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCoverageModulationStateCreateFlagsNV(obj.flags, "flags", 1);

    print_VkCoverageModulationModeNV(obj.coverageModulationMode, "coverageModulationMode", 1);

    print_VkBool32(obj.coverageModulationTableEnable, "coverageModulationTableEnable", 1);

    print_uint32_t(obj.coverageModulationTableCount, "coverageModulationTableCount", 1);

    PRINT_SPACE
    _OUT << "\"pCoverageModulationTable\":" << std::endl;
    PRINT_SPACE
    if (obj.pCoverageModulationTable) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.coverageModulationTableCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.coverageModulationTableCount;
            print_float(obj.pCoverageModulationTable[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineCoverageModulationStateCreateInfoNV(const VkPipelineCoverageModulationStateCreateInfoNV* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCoverageModulationStateCreateFlagsNV(obj->flags, "flags", 1);

    print_VkCoverageModulationModeNV(obj->coverageModulationMode, "coverageModulationMode", 1);

    print_VkBool32(obj->coverageModulationTableEnable, "coverageModulationTableEnable", 1);

    print_uint32_t(obj->coverageModulationTableCount, "coverageModulationTableCount", 1);

    PRINT_SPACE
    _OUT << "\"pCoverageModulationTable\":" << std::endl;
    PRINT_SPACE
    if (obj->pCoverageModulationTable) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->coverageModulationTableCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->coverageModulationTableCount;
            print_float(obj->pCoverageModulationTable[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkAttachmentSampleCountInfoAMD VkAttachmentSampleCountInfoNV;

static void print_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.shaderSMCount, "shaderSMCount", 1);

    print_uint32_t(obj.shaderWarpsPerSM, "shaderWarpsPerSM", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->shaderSMCount, "shaderSMCount", 1);

    print_uint32_t(obj->shaderWarpsPerSM, "shaderWarpsPerSM", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderSMBuiltins, "shaderSMBuiltins", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderSMBuiltins, "shaderSMBuiltins", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDrmFormatModifierPropertiesEXT(VkDrmFormatModifierPropertiesEXT obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint64_t(obj.drmFormatModifier, "drmFormatModifier", 1);

    print_uint32_t(obj.drmFormatModifierPlaneCount, "drmFormatModifierPlaneCount", 1);

    print_VkFormatFeatureFlags(obj.drmFormatModifierTilingFeatures, "drmFormatModifierTilingFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDrmFormatModifierPropertiesEXT(const VkDrmFormatModifierPropertiesEXT* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint64_t(obj->drmFormatModifier, "drmFormatModifier", 1);

    print_uint32_t(obj->drmFormatModifierPlaneCount, "drmFormatModifierPlaneCount", 1);

    print_VkFormatFeatureFlags(obj->drmFormatModifierTilingFeatures, "drmFormatModifierTilingFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDrmFormatModifierPropertiesListEXT(VkDrmFormatModifierPropertiesListEXT obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.drmFormatModifierCount, "drmFormatModifierCount", 1);

    PRINT_SPACE
    _OUT << "\"pDrmFormatModifierProperties\": " << std::endl;
    if (obj.pDrmFormatModifierProperties) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.drmFormatModifierCount; i++) {
            if (i + 1 == obj.drmFormatModifierCount)
                print_VkDrmFormatModifierPropertiesEXT(obj.pDrmFormatModifierProperties[i], "pDrmFormatModifierProperties", 0);
            else
                print_VkDrmFormatModifierPropertiesEXT(obj.pDrmFormatModifierProperties[i], "pDrmFormatModifierProperties", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDrmFormatModifierPropertiesListEXT(const VkDrmFormatModifierPropertiesListEXT* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->drmFormatModifierCount, "drmFormatModifierCount", 1);

    PRINT_SPACE
    _OUT << "\"pDrmFormatModifierProperties\": " << std::endl;
    if (obj->pDrmFormatModifierProperties) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->drmFormatModifierCount; i++) {
            if (i + 1 == obj->drmFormatModifierCount)
                print_VkDrmFormatModifierPropertiesEXT(obj->pDrmFormatModifierProperties[i], "pDrmFormatModifierProperties", 0);
            else
                print_VkDrmFormatModifierPropertiesEXT(obj->pDrmFormatModifierProperties[i], "pDrmFormatModifierProperties", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(VkPhysicalDeviceImageDrmFormatModifierInfoEXT obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.drmFormatModifier, "drmFormatModifier", 1);

    print_VkSharingMode(obj.sharingMode, "sharingMode", 1);

    print_uint32_t(obj.queueFamilyIndexCount, "queueFamilyIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueueFamilyIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pQueueFamilyIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.queueFamilyIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.queueFamilyIndexCount;
            print_uint32_t(obj.pQueueFamilyIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(const VkPhysicalDeviceImageDrmFormatModifierInfoEXT* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->drmFormatModifier, "drmFormatModifier", 1);

    print_VkSharingMode(obj->sharingMode, "sharingMode", 1);

    print_uint32_t(obj->queueFamilyIndexCount, "queueFamilyIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pQueueFamilyIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pQueueFamilyIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->queueFamilyIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->queueFamilyIndexCount;
            print_uint32_t(obj->pQueueFamilyIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageDrmFormatModifierListCreateInfoEXT(VkImageDrmFormatModifierListCreateInfoEXT obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.drmFormatModifierCount, "drmFormatModifierCount", 1);

    PRINT_SPACE
    _OUT << "\"pDrmFormatModifiers\":" << std::endl;
    PRINT_SPACE
    if (obj.pDrmFormatModifiers) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.drmFormatModifierCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.drmFormatModifierCount;
            print_uint64_t(obj.pDrmFormatModifiers[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageDrmFormatModifierListCreateInfoEXT(const VkImageDrmFormatModifierListCreateInfoEXT* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->drmFormatModifierCount, "drmFormatModifierCount", 1);

    PRINT_SPACE
    _OUT << "\"pDrmFormatModifiers\":" << std::endl;
    PRINT_SPACE
    if (obj->pDrmFormatModifiers) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->drmFormatModifierCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->drmFormatModifierCount;
            print_uint64_t(obj->pDrmFormatModifiers[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageDrmFormatModifierExplicitCreateInfoEXT(VkImageDrmFormatModifierExplicitCreateInfoEXT obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.drmFormatModifier, "drmFormatModifier", 1);

    print_uint32_t(obj.drmFormatModifierPlaneCount, "drmFormatModifierPlaneCount", 1);

    PRINT_SPACE
    _OUT << "\"pPlaneLayouts\": " << std::endl;
    if (obj.pPlaneLayouts) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.drmFormatModifierPlaneCount; i++) {
            if (i + 1 == obj.drmFormatModifierPlaneCount)
                print_VkSubresourceLayout(obj.pPlaneLayouts[i], "pPlaneLayouts", 0);
            else
                print_VkSubresourceLayout(obj.pPlaneLayouts[i], "pPlaneLayouts", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageDrmFormatModifierExplicitCreateInfoEXT(const VkImageDrmFormatModifierExplicitCreateInfoEXT* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->drmFormatModifier, "drmFormatModifier", 1);

    print_uint32_t(obj->drmFormatModifierPlaneCount, "drmFormatModifierPlaneCount", 1);

    PRINT_SPACE
    _OUT << "\"pPlaneLayouts\": " << std::endl;
    if (obj->pPlaneLayouts) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->drmFormatModifierPlaneCount; i++) {
            if (i + 1 == obj->drmFormatModifierPlaneCount)
                print_VkSubresourceLayout(obj->pPlaneLayouts[i], "pPlaneLayouts", 0);
            else
                print_VkSubresourceLayout(obj->pPlaneLayouts[i], "pPlaneLayouts", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageDrmFormatModifierPropertiesEXT(VkImageDrmFormatModifierPropertiesEXT obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.drmFormatModifier, "drmFormatModifier", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageDrmFormatModifierPropertiesEXT(const VkImageDrmFormatModifierPropertiesEXT* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->drmFormatModifier, "drmFormatModifier", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDrmFormatModifierProperties2EXT(VkDrmFormatModifierProperties2EXT obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint64_t(obj.drmFormatModifier, "drmFormatModifier", 1);

    print_uint32_t(obj.drmFormatModifierPlaneCount, "drmFormatModifierPlaneCount", 1);

    print_VkFormatFeatureFlags2(obj.drmFormatModifierTilingFeatures, "drmFormatModifierTilingFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDrmFormatModifierProperties2EXT(const VkDrmFormatModifierProperties2EXT* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint64_t(obj->drmFormatModifier, "drmFormatModifier", 1);

    print_uint32_t(obj->drmFormatModifierPlaneCount, "drmFormatModifierPlaneCount", 1);

    print_VkFormatFeatureFlags2(obj->drmFormatModifierTilingFeatures, "drmFormatModifierTilingFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDrmFormatModifierPropertiesList2EXT(VkDrmFormatModifierPropertiesList2EXT obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.drmFormatModifierCount, "drmFormatModifierCount", 1);

    PRINT_SPACE
    _OUT << "\"pDrmFormatModifierProperties\": " << std::endl;
    if (obj.pDrmFormatModifierProperties) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.drmFormatModifierCount; i++) {
            if (i + 1 == obj.drmFormatModifierCount)
                print_VkDrmFormatModifierProperties2EXT(obj.pDrmFormatModifierProperties[i], "pDrmFormatModifierProperties", 0);
            else
                print_VkDrmFormatModifierProperties2EXT(obj.pDrmFormatModifierProperties[i], "pDrmFormatModifierProperties", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDrmFormatModifierPropertiesList2EXT(const VkDrmFormatModifierPropertiesList2EXT* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->drmFormatModifierCount, "drmFormatModifierCount", 1);

    PRINT_SPACE
    _OUT << "\"pDrmFormatModifierProperties\": " << std::endl;
    if (obj->pDrmFormatModifierProperties) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->drmFormatModifierCount; i++) {
            if (i + 1 == obj->drmFormatModifierCount)
                print_VkDrmFormatModifierProperties2EXT(obj->pDrmFormatModifierProperties[i], "pDrmFormatModifierProperties", 0);
            else
                print_VkDrmFormatModifierProperties2EXT(obj->pDrmFormatModifierProperties[i], "pDrmFormatModifierProperties", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkValidationCacheEXT(VkValidationCacheEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkValidationCacheHeaderVersionEXT_map = {
    std::make_pair(1, "VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT"),
};
static void print_VkValidationCacheHeaderVersionEXT(VkValidationCacheHeaderVersionEXT obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkValidationCacheHeaderVersionEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkValidationCacheHeaderVersionEXT_map[obj] << "\"" << std::endl;
}
static void print_VkValidationCacheHeaderVersionEXT(const VkValidationCacheHeaderVersionEXT* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkValidationCacheHeaderVersionEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkValidationCacheHeaderVersionEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkValidationCacheCreateFlagsEXT(VkValidationCacheCreateFlagsEXT obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkValidationCacheCreateInfoEXT(VkValidationCacheCreateInfoEXT obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkValidationCacheCreateFlagsEXT(obj.flags, "flags", 1);

    print_size_t(obj.initialDataSize, "initialDataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkValidationCacheCreateInfoEXT(const VkValidationCacheCreateInfoEXT* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkValidationCacheCreateFlagsEXT(obj->flags, "flags", 1);

    print_size_t(obj->initialDataSize, "initialDataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkShaderModuleValidationCacheCreateInfoEXT(VkShaderModuleValidationCacheCreateInfoEXT obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "validationCache"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkShaderModuleValidationCacheCreateInfoEXT(const VkShaderModuleValidationCacheCreateInfoEXT* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "validationCache"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkDescriptorBindingFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT"),
    std::make_pair(1ULL << 1, "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT"),
    std::make_pair(1ULL << 2, "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT"),
    std::make_pair(1ULL << 3, "VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT"),
    std::make_pair(1ULL << 4, "VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM"),
};
static void print_VkDescriptorBindingFlagBitsEXT(VkDescriptorBindingFlagBitsEXT obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorBindingFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorBindingFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDescriptorBindingFlagBitsEXT(const VkDescriptorBindingFlagBitsEXT* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDescriptorBindingFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDescriptorBindingFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

typedef VkDescriptorSetLayoutBindingFlagsCreateInfo VkDescriptorSetLayoutBindingFlagsCreateInfoEXT;

typedef VkPhysicalDeviceDescriptorIndexingFeatures VkPhysicalDeviceDescriptorIndexingFeaturesEXT;

typedef VkPhysicalDeviceDescriptorIndexingProperties VkPhysicalDeviceDescriptorIndexingPropertiesEXT;

typedef VkDescriptorSetVariableDescriptorCountAllocateInfo VkDescriptorSetVariableDescriptorCountAllocateInfoEXT;

typedef VkDescriptorSetVariableDescriptorCountLayoutSupport VkDescriptorSetVariableDescriptorCountLayoutSupportEXT;

static std::map<uint64_t, std::string> VkShadingRatePaletteEntryNV_map = {
    std::make_pair(0, "VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV"),
    std::make_pair(1, "VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV"),
    std::make_pair(2, "VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV"),
    std::make_pair(3, "VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV"),
    std::make_pair(4, "VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV"),
    std::make_pair(5, "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV"),
    std::make_pair(6, "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV"),
    std::make_pair(7, "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV"),
    std::make_pair(8, "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV"),
    std::make_pair(9, "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV"),
    std::make_pair(10, "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV"),
    std::make_pair(11, "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV"),
};
static void print_VkShadingRatePaletteEntryNV(VkShadingRatePaletteEntryNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShadingRatePaletteEntryNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShadingRatePaletteEntryNV_map[obj] << "\"" << std::endl;
}
static void print_VkShadingRatePaletteEntryNV(const VkShadingRatePaletteEntryNV* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShadingRatePaletteEntryNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShadingRatePaletteEntryNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkCoarseSampleOrderTypeNV_map = {
    std::make_pair(0, "VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV"),
    std::make_pair(1, "VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV"),
    std::make_pair(2, "VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV"),
    std::make_pair(3, "VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV"),
};
static void print_VkCoarseSampleOrderTypeNV(VkCoarseSampleOrderTypeNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCoarseSampleOrderTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCoarseSampleOrderTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkCoarseSampleOrderTypeNV(const VkCoarseSampleOrderTypeNV* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCoarseSampleOrderTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCoarseSampleOrderTypeNV_map[*obj] << "\"" << std::endl;
}

static void print_VkShadingRatePaletteNV(VkShadingRatePaletteNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.shadingRatePaletteEntryCount, "shadingRatePaletteEntryCount", 1);

    PRINT_SPACE
    _OUT << "\"pShadingRatePaletteEntries\":" << std::endl;
    PRINT_SPACE
    if (obj.pShadingRatePaletteEntries) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.shadingRatePaletteEntryCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.shadingRatePaletteEntryCount;
            print_VkShadingRatePaletteEntryNV(obj.pShadingRatePaletteEntries[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkShadingRatePaletteNV(const VkShadingRatePaletteNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->shadingRatePaletteEntryCount, "shadingRatePaletteEntryCount", 1);

    PRINT_SPACE
    _OUT << "\"pShadingRatePaletteEntries\":" << std::endl;
    PRINT_SPACE
    if (obj->pShadingRatePaletteEntries) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->shadingRatePaletteEntryCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->shadingRatePaletteEntryCount;
            print_VkShadingRatePaletteEntryNV(obj->pShadingRatePaletteEntries[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineViewportShadingRateImageStateCreateInfoNV(VkPipelineViewportShadingRateImageStateCreateInfoNV obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shadingRateImageEnable, "shadingRateImageEnable", 1);

    print_uint32_t(obj.viewportCount, "viewportCount", 1);

    PRINT_SPACE
    _OUT << "\"pShadingRatePalettes\": " << std::endl;
    if (obj.pShadingRatePalettes) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.viewportCount; i++) {
            if (i + 1 == obj.viewportCount)
                print_VkShadingRatePaletteNV(obj.pShadingRatePalettes[i], "pShadingRatePalettes", 0);
            else
                print_VkShadingRatePaletteNV(obj.pShadingRatePalettes[i], "pShadingRatePalettes", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineViewportShadingRateImageStateCreateInfoNV(
    const VkPipelineViewportShadingRateImageStateCreateInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shadingRateImageEnable, "shadingRateImageEnable", 1);

    print_uint32_t(obj->viewportCount, "viewportCount", 1);

    PRINT_SPACE
    _OUT << "\"pShadingRatePalettes\": " << std::endl;
    if (obj->pShadingRatePalettes) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->viewportCount; i++) {
            if (i + 1 == obj->viewportCount)
                print_VkShadingRatePaletteNV(obj->pShadingRatePalettes[i], "pShadingRatePalettes", 0);
            else
                print_VkShadingRatePaletteNV(obj->pShadingRatePalettes[i], "pShadingRatePalettes", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShadingRateImageFeaturesNV(VkPhysicalDeviceShadingRateImageFeaturesNV obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shadingRateImage, "shadingRateImage", 1);

    print_VkBool32(obj.shadingRateCoarseSampleOrder, "shadingRateCoarseSampleOrder", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShadingRateImageFeaturesNV(const VkPhysicalDeviceShadingRateImageFeaturesNV* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shadingRateImage, "shadingRateImage", 1);

    print_VkBool32(obj->shadingRateCoarseSampleOrder, "shadingRateCoarseSampleOrder", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShadingRateImagePropertiesNV(VkPhysicalDeviceShadingRateImagePropertiesNV obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"shadingRateTexelSize\": " << std::endl;
    { print_VkExtent2D(obj.shadingRateTexelSize, "shadingRateTexelSize", 1); }

    print_uint32_t(obj.shadingRatePaletteSize, "shadingRatePaletteSize", 1);

    print_uint32_t(obj.shadingRateMaxCoarseSamples, "shadingRateMaxCoarseSamples", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShadingRateImagePropertiesNV(const VkPhysicalDeviceShadingRateImagePropertiesNV* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"shadingRateTexelSize\": " << std::endl;
    { print_VkExtent2D(obj->shadingRateTexelSize, "shadingRateTexelSize", 1); }

    print_uint32_t(obj->shadingRatePaletteSize, "shadingRatePaletteSize", 1);

    print_uint32_t(obj->shadingRateMaxCoarseSamples, "shadingRateMaxCoarseSamples", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCoarseSampleLocationNV(VkCoarseSampleLocationNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.pixelX, "pixelX", 1);

    print_uint32_t(obj.pixelY, "pixelY", 1);

    print_uint32_t(obj.sample, "sample", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCoarseSampleLocationNV(const VkCoarseSampleLocationNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->pixelX, "pixelX", 1);

    print_uint32_t(obj->pixelY, "pixelY", 1);

    print_uint32_t(obj->sample, "sample", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCoarseSampleOrderCustomNV(VkCoarseSampleOrderCustomNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkShadingRatePaletteEntryNV(obj.shadingRate, "shadingRate", 1);

    print_uint32_t(obj.sampleCount, "sampleCount", 1);

    print_uint32_t(obj.sampleLocationCount, "sampleLocationCount", 1);

    PRINT_SPACE
    _OUT << "\"pSampleLocations\": " << std::endl;
    if (obj.pSampleLocations) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.sampleLocationCount; i++) {
            if (i + 1 == obj.sampleLocationCount)
                print_VkCoarseSampleLocationNV(obj.pSampleLocations[i], "pSampleLocations", 0);
            else
                print_VkCoarseSampleLocationNV(obj.pSampleLocations[i], "pSampleLocations", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCoarseSampleOrderCustomNV(const VkCoarseSampleOrderCustomNV* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkShadingRatePaletteEntryNV(obj->shadingRate, "shadingRate", 1);

    print_uint32_t(obj->sampleCount, "sampleCount", 1);

    print_uint32_t(obj->sampleLocationCount, "sampleLocationCount", 1);

    PRINT_SPACE
    _OUT << "\"pSampleLocations\": " << std::endl;
    if (obj->pSampleLocations) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->sampleLocationCount; i++) {
            if (i + 1 == obj->sampleLocationCount)
                print_VkCoarseSampleLocationNV(obj->pSampleLocations[i], "pSampleLocations", 0);
            else
                print_VkCoarseSampleLocationNV(obj->pSampleLocations[i], "pSampleLocations", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkCoarseSampleOrderTypeNV(obj.sampleOrderType, "sampleOrderType", 1);

    print_uint32_t(obj.customSampleOrderCount, "customSampleOrderCount", 1);

    PRINT_SPACE
    _OUT << "\"pCustomSampleOrders\": " << std::endl;
    if (obj.pCustomSampleOrders) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.customSampleOrderCount; i++) {
            if (i + 1 == obj.customSampleOrderCount)
                print_VkCoarseSampleOrderCustomNV(obj.pCustomSampleOrders[i], "pCustomSampleOrders", 0);
            else
                print_VkCoarseSampleOrderCustomNV(obj.pCustomSampleOrders[i], "pCustomSampleOrders", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
    const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkCoarseSampleOrderTypeNV(obj->sampleOrderType, "sampleOrderType", 1);

    print_uint32_t(obj->customSampleOrderCount, "customSampleOrderCount", 1);

    PRINT_SPACE
    _OUT << "\"pCustomSampleOrders\": " << std::endl;
    if (obj->pCustomSampleOrders) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->customSampleOrderCount; i++) {
            if (i + 1 == obj->customSampleOrderCount)
                print_VkCoarseSampleOrderCustomNV(obj->pCustomSampleOrders[i], "pCustomSampleOrders", 0);
            else
                print_VkCoarseSampleOrderCustomNV(obj->pCustomSampleOrders[i], "pCustomSampleOrders", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureNV(VkAccelerationStructureNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkRayTracingShaderGroupTypeKHR_map = {
    std::make_pair(0, "VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR"),
    std::make_pair(1, "VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR"),
    std::make_pair(2, "VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR"),
};
static void print_VkRayTracingShaderGroupTypeKHR(VkRayTracingShaderGroupTypeKHR obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRayTracingShaderGroupTypeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRayTracingShaderGroupTypeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkRayTracingShaderGroupTypeKHR(const VkRayTracingShaderGroupTypeKHR* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRayTracingShaderGroupTypeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRayTracingShaderGroupTypeKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkRayTracingShaderGroupTypeNV_map = {
    std::make_pair(0, "VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR"),
    std::make_pair(1, "VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR"),
    std::make_pair(2, "VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR"),
};
static void print_VkRayTracingShaderGroupTypeNV(VkRayTracingShaderGroupTypeNV obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRayTracingShaderGroupTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRayTracingShaderGroupTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkRayTracingShaderGroupTypeNV(const VkRayTracingShaderGroupTypeNV* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRayTracingShaderGroupTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRayTracingShaderGroupTypeNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkGeometryTypeKHR_map = {
    std::make_pair(0, "VK_GEOMETRY_TYPE_TRIANGLES_KHR"),
    std::make_pair(1, "VK_GEOMETRY_TYPE_AABBS_KHR"),
    std::make_pair(2, "VK_GEOMETRY_TYPE_INSTANCES_KHR"),
    std::make_pair(1000429004, "VK_GEOMETRY_TYPE_SPHERES_NV"),
    std::make_pair(1000429005, "VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV"),
};
static void print_VkGeometryTypeKHR(VkGeometryTypeKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGeometryTypeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGeometryTypeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkGeometryTypeKHR(const VkGeometryTypeKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGeometryTypeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGeometryTypeKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkGeometryTypeNV_map = {
    std::make_pair(0, "VK_GEOMETRY_TYPE_TRIANGLES_KHR"),
    std::make_pair(1, "VK_GEOMETRY_TYPE_AABBS_KHR"),
    std::make_pair(2, "VK_GEOMETRY_TYPE_INSTANCES_KHR"),
    std::make_pair(1000429004, "VK_GEOMETRY_TYPE_SPHERES_NV"),
    std::make_pair(1000429005, "VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV"),
};
static void print_VkGeometryTypeNV(VkGeometryTypeNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGeometryTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGeometryTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkGeometryTypeNV(const VkGeometryTypeNV* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGeometryTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGeometryTypeNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAccelerationStructureTypeKHR_map = {
    std::make_pair(0, "VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR"),
    std::make_pair(1, "VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR"),
    std::make_pair(2, "VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR"),
};
static void print_VkAccelerationStructureTypeKHR(VkAccelerationStructureTypeKHR obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureTypeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureTypeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkAccelerationStructureTypeKHR(const VkAccelerationStructureTypeKHR* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureTypeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureTypeKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAccelerationStructureTypeNV_map = {
    std::make_pair(0, "VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR"),
    std::make_pair(1, "VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR"),
    std::make_pair(2, "VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR"),
};
static void print_VkAccelerationStructureTypeNV(VkAccelerationStructureTypeNV obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkAccelerationStructureTypeNV(const VkAccelerationStructureTypeNV* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureTypeNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkGeometryFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_GEOMETRY_OPAQUE_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR"),
};
static void print_VkGeometryFlagBitsKHR(VkGeometryFlagBitsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGeometryFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGeometryFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkGeometryFlagBitsKHR(const VkGeometryFlagBitsKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGeometryFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGeometryFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkGeometryFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_GEOMETRY_OPAQUE_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR"),
};
static void print_VkGeometryFlagBitsNV(VkGeometryFlagBitsNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGeometryFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGeometryFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkGeometryFlagBitsNV(const VkGeometryFlagBitsNV* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGeometryFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGeometryFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkGeometryInstanceFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT"),
    std::make_pair(1ULL << 5, "VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT"),
};
static void print_VkGeometryInstanceFlagBitsKHR(VkGeometryInstanceFlagBitsKHR obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGeometryInstanceFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGeometryInstanceFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkGeometryInstanceFlagBitsKHR(const VkGeometryInstanceFlagBitsKHR* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGeometryInstanceFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGeometryInstanceFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkGeometryInstanceFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT"),
    std::make_pair(1ULL << 5, "VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT"),
};
static void print_VkGeometryInstanceFlagBitsNV(VkGeometryInstanceFlagBitsNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGeometryInstanceFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGeometryInstanceFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkGeometryInstanceFlagBitsNV(const VkGeometryInstanceFlagBitsNV* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGeometryInstanceFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGeometryInstanceFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkBuildAccelerationStructureFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR"),
    std::make_pair(1ULL << 5, "VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV"),
    std::make_pair(1ULL << 6, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT"),
    std::make_pair(1ULL << 7, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT"),
    std::make_pair(1ULL << 8, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT"),
    std::make_pair(1ULL << 9, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV"),
    std::make_pair(1ULL << 11, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR"),
};
static void print_VkBuildAccelerationStructureFlagBitsKHR(VkBuildAccelerationStructureFlagBitsKHR obj, const std::string& str,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBuildAccelerationStructureFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBuildAccelerationStructureFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkBuildAccelerationStructureFlagBitsKHR(const VkBuildAccelerationStructureFlagBitsKHR* obj,
                                                          const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBuildAccelerationStructureFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBuildAccelerationStructureFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkBuildAccelerationStructureFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR"),
    std::make_pair(1ULL << 2, "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR"),
    std::make_pair(1ULL << 4, "VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR"),
    std::make_pair(1ULL << 5, "VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV"),
    std::make_pair(1ULL << 6, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT"),
    std::make_pair(1ULL << 7, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT"),
    std::make_pair(1ULL << 8, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT"),
    std::make_pair(1ULL << 9, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV"),
    std::make_pair(1ULL << 11, "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR"),
};
static void print_VkBuildAccelerationStructureFlagBitsNV(VkBuildAccelerationStructureFlagBitsNV obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBuildAccelerationStructureFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBuildAccelerationStructureFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkBuildAccelerationStructureFlagBitsNV(const VkBuildAccelerationStructureFlagBitsNV* obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBuildAccelerationStructureFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBuildAccelerationStructureFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkCopyAccelerationStructureModeKHR_map = {
    std::make_pair(0, "VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR"),
    std::make_pair(1, "VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR"),
    std::make_pair(2, "VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR"),
    std::make_pair(3, "VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR"),
};
static void print_VkCopyAccelerationStructureModeKHR(VkCopyAccelerationStructureModeKHR obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCopyAccelerationStructureModeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCopyAccelerationStructureModeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkCopyAccelerationStructureModeKHR(const VkCopyAccelerationStructureModeKHR* obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCopyAccelerationStructureModeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCopyAccelerationStructureModeKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkCopyAccelerationStructureModeNV_map = {
    std::make_pair(0, "VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR"),
    std::make_pair(1, "VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR"),
    std::make_pair(2, "VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR"),
    std::make_pair(3, "VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR"),
};
static void print_VkCopyAccelerationStructureModeNV(VkCopyAccelerationStructureModeNV obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCopyAccelerationStructureModeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCopyAccelerationStructureModeNV_map[obj] << "\"" << std::endl;
}
static void print_VkCopyAccelerationStructureModeNV(const VkCopyAccelerationStructureModeNV* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCopyAccelerationStructureModeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCopyAccelerationStructureModeNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAccelerationStructureMemoryRequirementsTypeNV_map = {
    std::make_pair(0, "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV"),
    std::make_pair(1, "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV"),
    std::make_pair(2, "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV"),
};
static void print_VkAccelerationStructureMemoryRequirementsTypeNV(VkAccelerationStructureMemoryRequirementsTypeNV obj,
                                                                  const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureMemoryRequirementsTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureMemoryRequirementsTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkAccelerationStructureMemoryRequirementsTypeNV(const VkAccelerationStructureMemoryRequirementsTypeNV* obj,
                                                                  const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureMemoryRequirementsTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureMemoryRequirementsTypeNV_map[*obj] << "\"" << std::endl;
}

static void print_VkGeometryFlagsKHR(VkGeometryFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkGeometryFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkGeometryFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkGeometryInstanceFlagsKHR(VkGeometryInstanceFlagsKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkGeometryInstanceFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkGeometryInstanceFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkBuildAccelerationStructureFlagsKHR(VkBuildAccelerationStructureFlagsKHR obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkBuildAccelerationStructureFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkBuildAccelerationStructureFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkRayTracingShaderGroupCreateInfoNV(VkRayTracingShaderGroupCreateInfoNV obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRayTracingShaderGroupTypeKHR(obj.type, "type", 1);

    print_uint32_t(obj.generalShader, "generalShader", 1);

    print_uint32_t(obj.closestHitShader, "closestHitShader", 1);

    print_uint32_t(obj.anyHitShader, "anyHitShader", 1);

    print_uint32_t(obj.intersectionShader, "intersectionShader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRayTracingShaderGroupCreateInfoNV(const VkRayTracingShaderGroupCreateInfoNV* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRayTracingShaderGroupTypeKHR(obj->type, "type", 1);

    print_uint32_t(obj->generalShader, "generalShader", 1);

    print_uint32_t(obj->closestHitShader, "closestHitShader", 1);

    print_uint32_t(obj->anyHitShader, "anyHitShader", 1);

    print_uint32_t(obj->intersectionShader, "intersectionShader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRayTracingPipelineCreateInfoNV(VkRayTracingPipelineCreateInfoNV obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.stageCount, "stageCount", 1);

    PRINT_SPACE
    _OUT << "\"pStages\": " << std::endl;
    if (obj.pStages) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stageCount; i++) {
            if (i + 1 == obj.stageCount)
                print_VkPipelineShaderStageCreateInfo(obj.pStages[i], "pStages", 0);
            else
                print_VkPipelineShaderStageCreateInfo(obj.pStages[i], "pStages", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.groupCount, "groupCount", 1);

    PRINT_SPACE
    _OUT << "\"pGroups\": " << std::endl;
    if (obj.pGroups) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.groupCount; i++) {
            if (i + 1 == obj.groupCount)
                print_VkRayTracingShaderGroupCreateInfoNV(obj.pGroups[i], "pGroups", 0);
            else
                print_VkRayTracingShaderGroupCreateInfoNV(obj.pGroups[i], "pGroups", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.maxRecursionDepth, "maxRecursionDepth", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "basePipelineHandle"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_int32_t(obj.basePipelineIndex, "basePipelineIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRayTracingPipelineCreateInfoNV(const VkRayTracingPipelineCreateInfoNV* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->stageCount, "stageCount", 1);

    PRINT_SPACE
    _OUT << "\"pStages\": " << std::endl;
    if (obj->pStages) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stageCount; i++) {
            if (i + 1 == obj->stageCount)
                print_VkPipelineShaderStageCreateInfo(obj->pStages[i], "pStages", 0);
            else
                print_VkPipelineShaderStageCreateInfo(obj->pStages[i], "pStages", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->groupCount, "groupCount", 1);

    PRINT_SPACE
    _OUT << "\"pGroups\": " << std::endl;
    if (obj->pGroups) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->groupCount; i++) {
            if (i + 1 == obj->groupCount)
                print_VkRayTracingShaderGroupCreateInfoNV(obj->pGroups[i], "pGroups", 0);
            else
                print_VkRayTracingShaderGroupCreateInfoNV(obj->pGroups[i], "pGroups", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->maxRecursionDepth, "maxRecursionDepth", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "basePipelineHandle"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_int32_t(obj->basePipelineIndex, "basePipelineIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGeometryTrianglesNV(VkGeometryTrianglesNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "vertexData"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.vertexOffset, "vertexOffset", 1);

    print_uint32_t(obj.vertexCount, "vertexCount", 1);

    print_VkDeviceSize(obj.vertexStride, "vertexStride", 1);

    print_VkFormat(obj.vertexFormat, "vertexFormat", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indexData"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.indexOffset, "indexOffset", 1);

    print_uint32_t(obj.indexCount, "indexCount", 1);

    print_VkIndexType(obj.indexType, "indexType", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "transformData"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.transformOffset, "transformOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGeometryTrianglesNV(const VkGeometryTrianglesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "vertexData"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->vertexOffset, "vertexOffset", 1);

    print_uint32_t(obj->vertexCount, "vertexCount", 1);

    print_VkDeviceSize(obj->vertexStride, "vertexStride", 1);

    print_VkFormat(obj->vertexFormat, "vertexFormat", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indexData"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->indexOffset, "indexOffset", 1);

    print_uint32_t(obj->indexCount, "indexCount", 1);

    print_VkIndexType(obj->indexType, "indexType", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "transformData"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->transformOffset, "transformOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGeometryAABBNV(VkGeometryAABBNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "aabbData"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.numAABBs, "numAABBs", 1);

    print_uint32_t(obj.stride, "stride", 1);

    print_VkDeviceSize(obj.offset, "offset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGeometryAABBNV(const VkGeometryAABBNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "aabbData"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->numAABBs, "numAABBs", 1);

    print_uint32_t(obj->stride, "stride", 1);

    print_VkDeviceSize(obj->offset, "offset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGeometryDataNV(VkGeometryDataNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"triangles\": " << std::endl;
    { print_VkGeometryTrianglesNV(obj.triangles, "triangles", 1); }

    PRINT_SPACE
    _OUT << "\"aabbs\": " << std::endl;
    { print_VkGeometryAABBNV(obj.aabbs, "aabbs", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGeometryDataNV(const VkGeometryDataNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"triangles\": " << std::endl;
    { print_VkGeometryTrianglesNV(obj->triangles, "triangles", 1); }

    PRINT_SPACE
    _OUT << "\"aabbs\": " << std::endl;
    { print_VkGeometryAABBNV(obj->aabbs, "aabbs", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGeometryNV(VkGeometryNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkGeometryTypeKHR(obj.geometryType, "geometryType", 1);

    PRINT_SPACE
    _OUT << "\"geometry\": " << std::endl;
    { print_VkGeometryDataNV(obj.geometry, "geometry", 1); }

    print_VkGeometryFlagsKHR(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGeometryNV(const VkGeometryNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkGeometryTypeKHR(obj->geometryType, "geometryType", 1);

    PRINT_SPACE
    _OUT << "\"geometry\": " << std::endl;
    { print_VkGeometryDataNV(obj->geometry, "geometry", 1); }

    print_VkGeometryFlagsKHR(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureInfoNV(VkAccelerationStructureInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccelerationStructureTypeNV(obj.type, "type", 1);

    print_VkBuildAccelerationStructureFlagsNV(obj.flags, "flags", 1);

    print_uint32_t(obj.instanceCount, "instanceCount", 1);

    print_uint32_t(obj.geometryCount, "geometryCount", 1);

    PRINT_SPACE
    _OUT << "\"pGeometries\": " << std::endl;
    if (obj.pGeometries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.geometryCount; i++) {
            if (i + 1 == obj.geometryCount)
                print_VkGeometryNV(obj.pGeometries[i], "pGeometries", 0);
            else
                print_VkGeometryNV(obj.pGeometries[i], "pGeometries", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureInfoNV(const VkAccelerationStructureInfoNV* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccelerationStructureTypeNV(obj->type, "type", 1);

    print_VkBuildAccelerationStructureFlagsNV(obj->flags, "flags", 1);

    print_uint32_t(obj->instanceCount, "instanceCount", 1);

    print_uint32_t(obj->geometryCount, "geometryCount", 1);

    PRINT_SPACE
    _OUT << "\"pGeometries\": " << std::endl;
    if (obj->pGeometries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->geometryCount; i++) {
            if (i + 1 == obj->geometryCount)
                print_VkGeometryNV(obj->pGeometries[i], "pGeometries", 0);
            else
                print_VkGeometryNV(obj->pGeometries[i], "pGeometries", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureCreateInfoNV(VkAccelerationStructureCreateInfoNV obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj.compactedSize, "compactedSize", 1);

    PRINT_SPACE
    _OUT << "\"info\": " << std::endl;
    { print_VkAccelerationStructureInfoNV(obj.info, "info", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureCreateInfoNV(const VkAccelerationStructureCreateInfoNV* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj->compactedSize, "compactedSize", 1);

    PRINT_SPACE
    _OUT << "\"info\": " << std::endl;
    { print_VkAccelerationStructureInfoNV(obj->info, "info", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindAccelerationStructureMemoryInfoNV(VkBindAccelerationStructureMemoryInfoNV obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "accelerationStructure"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.memoryOffset, "memoryOffset", 1);

    print_uint32_t(obj.deviceIndexCount, "deviceIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pDeviceIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pDeviceIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.deviceIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.deviceIndexCount;
            print_uint32_t(obj.pDeviceIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindAccelerationStructureMemoryInfoNV(const VkBindAccelerationStructureMemoryInfoNV* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "accelerationStructure"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->memoryOffset, "memoryOffset", 1);

    print_uint32_t(obj->deviceIndexCount, "deviceIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pDeviceIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pDeviceIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->deviceIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->deviceIndexCount;
            print_uint32_t(obj->pDeviceIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkWriteDescriptorSetAccelerationStructureNV(VkWriteDescriptorSetAccelerationStructureNV obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.accelerationStructureCount, "accelerationStructureCount", 1);

    PRINT_SPACE
    _OUT << "\"pAccelerationStructures\":" << std::endl;
    PRINT_SPACE
    if (obj.pAccelerationStructures) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.accelerationStructureCount; i++) {
            std::stringstream tmp;
            tmp << "pAccelerationStructures"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.accelerationStructureCount;
            print_VkAccelerationStructureNV(obj.pAccelerationStructures[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkWriteDescriptorSetAccelerationStructureNV(const VkWriteDescriptorSetAccelerationStructureNV* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->accelerationStructureCount, "accelerationStructureCount", 1);

    PRINT_SPACE
    _OUT << "\"pAccelerationStructures\":" << std::endl;
    PRINT_SPACE
    if (obj->pAccelerationStructures) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->accelerationStructureCount; i++) {
            std::stringstream tmp;
            tmp << "pAccelerationStructures"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->accelerationStructureCount;
            print_VkAccelerationStructureNV(obj->pAccelerationStructures[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureMemoryRequirementsInfoNV(VkAccelerationStructureMemoryRequirementsInfoNV obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccelerationStructureMemoryRequirementsTypeNV(obj.type, "type", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "accelerationStructure"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureMemoryRequirementsInfoNV(const VkAccelerationStructureMemoryRequirementsInfoNV* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccelerationStructureMemoryRequirementsTypeNV(obj->type, "type", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "accelerationStructure"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRayTracingPropertiesNV(VkPhysicalDeviceRayTracingPropertiesNV obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.shaderGroupHandleSize, "shaderGroupHandleSize", 1);

    print_uint32_t(obj.maxRecursionDepth, "maxRecursionDepth", 1);

    print_uint32_t(obj.maxShaderGroupStride, "maxShaderGroupStride", 1);

    print_uint32_t(obj.shaderGroupBaseAlignment, "shaderGroupBaseAlignment", 1);

    print_uint64_t(obj.maxGeometryCount, "maxGeometryCount", 1);

    print_uint64_t(obj.maxInstanceCount, "maxInstanceCount", 1);

    print_uint64_t(obj.maxTriangleCount, "maxTriangleCount", 1);

    print_uint32_t(obj.maxDescriptorSetAccelerationStructures, "maxDescriptorSetAccelerationStructures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRayTracingPropertiesNV(const VkPhysicalDeviceRayTracingPropertiesNV* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->shaderGroupHandleSize, "shaderGroupHandleSize", 1);

    print_uint32_t(obj->maxRecursionDepth, "maxRecursionDepth", 1);

    print_uint32_t(obj->maxShaderGroupStride, "maxShaderGroupStride", 1);

    print_uint32_t(obj->shaderGroupBaseAlignment, "shaderGroupBaseAlignment", 1);

    print_uint64_t(obj->maxGeometryCount, "maxGeometryCount", 1);

    print_uint64_t(obj->maxInstanceCount, "maxInstanceCount", 1);

    print_uint64_t(obj->maxTriangleCount, "maxTriangleCount", 1);

    print_uint32_t(obj->maxDescriptorSetAccelerationStructures, "maxDescriptorSetAccelerationStructures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkTransformMatrixKHR(VkTransformMatrixKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"matrix\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_float(obj.matrix[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkTransformMatrixKHR(const VkTransformMatrixKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"matrix\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_float(obj->matrix[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkTransformMatrixKHR VkTransformMatrixNV;

static void print_VkAabbPositionsKHR(VkAabbPositionsKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj.minX, "minX", 1);

    print_float(obj.minY, "minY", 1);

    print_float(obj.minZ, "minZ", 1);

    print_float(obj.maxX, "maxX", 1);

    print_float(obj.maxY, "maxY", 1);

    print_float(obj.maxZ, "maxZ", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAabbPositionsKHR(const VkAabbPositionsKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj->minX, "minX", 1);

    print_float(obj->minY, "minY", 1);

    print_float(obj->minZ, "minZ", 1);

    print_float(obj->maxX, "maxX", 1);

    print_float(obj->maxY, "maxY", 1);

    print_float(obj->maxZ, "maxZ", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkAabbPositionsKHR VkAabbPositionsNV;

static void print_VkAccelerationStructureInstanceKHR(VkAccelerationStructureInstanceKHR obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"transform\": " << std::endl;
    { print_VkTransformMatrixKHR(obj.transform, "transform", 1); }

    print_uint32_t(obj.instanceCustomIndex, "instanceCustomIndex", 1);

    print_uint32_t(obj.mask, "mask", 1);

    print_uint32_t(obj.instanceShaderBindingTableRecordOffset, "instanceShaderBindingTableRecordOffset", 1);

    print_VkGeometryInstanceFlagsKHR(obj.flags, "flags", 1);

    print_uint64_t(obj.accelerationStructureReference, "accelerationStructureReference", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureInstanceKHR(const VkAccelerationStructureInstanceKHR* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"transform\": " << std::endl;
    { print_VkTransformMatrixKHR(obj->transform, "transform", 1); }

    print_uint32_t(obj->instanceCustomIndex, "instanceCustomIndex", 1);

    print_uint32_t(obj->mask, "mask", 1);

    print_uint32_t(obj->instanceShaderBindingTableRecordOffset, "instanceShaderBindingTableRecordOffset", 1);

    print_VkGeometryInstanceFlagsKHR(obj->flags, "flags", 1);

    print_uint64_t(obj->accelerationStructureReference, "accelerationStructureReference", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkAccelerationStructureInstanceKHR VkAccelerationStructureInstanceNV;

static void print_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.representativeFragmentTest, "representativeFragmentTest", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
    const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->representativeFragmentTest, "representativeFragmentTest", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(VkPipelineRepresentativeFragmentTestStateCreateInfoNV obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.representativeFragmentTestEnable, "representativeFragmentTestEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
    const VkPipelineRepresentativeFragmentTestStateCreateInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->representativeFragmentTestEnable, "representativeFragmentTestEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceImageViewImageFormatInfoEXT(VkPhysicalDeviceImageViewImageFormatInfoEXT obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageViewType(obj.imageViewType, "imageViewType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageViewImageFormatInfoEXT(const VkPhysicalDeviceImageViewImageFormatInfoEXT* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageViewType(obj->imageViewType, "imageViewType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkFilterCubicImageViewImageFormatPropertiesEXT(VkFilterCubicImageViewImageFormatPropertiesEXT obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.filterCubic, "filterCubic", 1);

    print_VkBool32(obj.filterCubicMinmax, "filterCubicMinmax", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkFilterCubicImageViewImageFormatPropertiesEXT(const VkFilterCubicImageViewImageFormatPropertiesEXT* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->filterCubic, "filterCubic", 1);

    print_VkBool32(obj->filterCubicMinmax, "filterCubicMinmax", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkQueueGlobalPriorityEXT_map = {
    std::make_pair(128, "VK_QUEUE_GLOBAL_PRIORITY_LOW"),
    std::make_pair(256, "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM"),
    std::make_pair(512, "VK_QUEUE_GLOBAL_PRIORITY_HIGH"),
    std::make_pair(1024, "VK_QUEUE_GLOBAL_PRIORITY_REALTIME"),
};
static void print_VkQueueGlobalPriorityEXT(VkQueueGlobalPriorityEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueueGlobalPriorityEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueueGlobalPriorityEXT_map[obj] << "\"" << std::endl;
}
static void print_VkQueueGlobalPriorityEXT(const VkQueueGlobalPriorityEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueueGlobalPriorityEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueueGlobalPriorityEXT_map[*obj] << "\"" << std::endl;
}

typedef VkDeviceQueueGlobalPriorityCreateInfo VkDeviceQueueGlobalPriorityCreateInfoEXT;

static void print_VkImportMemoryHostPointerInfoEXT(VkImportMemoryHostPointerInfoEXT obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlagBits(obj.handleType, "handleType", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImportMemoryHostPointerInfoEXT(const VkImportMemoryHostPointerInfoEXT* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlagBits(obj->handleType, "handleType", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryHostPointerPropertiesEXT(VkMemoryHostPointerPropertiesEXT obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.memoryTypeBits, "memoryTypeBits", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryHostPointerPropertiesEXT(const VkMemoryHostPointerPropertiesEXT* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->memoryTypeBits, "memoryTypeBits", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(VkPhysicalDeviceExternalMemoryHostPropertiesEXT obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj.minImportedHostPointerAlignment, "minImportedHostPointerAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj->minImportedHostPointerAlignment, "minImportedHostPointerAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineCompilerControlFlagBitsAMD_map = {};
static void print_VkPipelineCompilerControlFlagBitsAMD(VkPipelineCompilerControlFlagBitsAMD obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCompilerControlFlagBitsAMD_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCompilerControlFlagBitsAMD_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineCompilerControlFlagBitsAMD(const VkPipelineCompilerControlFlagBitsAMD* obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCompilerControlFlagBitsAMD_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCompilerControlFlagBitsAMD_map[*obj] << "\"" << std::endl;
}

static void print_VkPipelineCompilerControlFlagsAMD(VkPipelineCompilerControlFlagsAMD obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPipelineCompilerControlFlagBitsAMD_map[1ULL << i] << " | ";
            else
                _OUT << VkPipelineCompilerControlFlagBitsAMD_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPipelineCompilerControlCreateInfoAMD(VkPipelineCompilerControlCreateInfoAMD obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCompilerControlFlagsAMD(obj.compilerControlFlags, "compilerControlFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineCompilerControlCreateInfoAMD(const VkPipelineCompilerControlCreateInfoAMD* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCompilerControlFlagsAMD(obj->compilerControlFlags, "compilerControlFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkTimeDomainEXT_map = {
    std::make_pair(0, "VK_TIME_DOMAIN_DEVICE_KHR"),
    std::make_pair(1, "VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR"),
    std::make_pair(2, "VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR"),
    std::make_pair(3, "VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR"),
};
static void print_VkTimeDomainEXT(VkTimeDomainEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkTimeDomainEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkTimeDomainEXT_map[obj] << "\"" << std::endl;
}
static void print_VkTimeDomainEXT(const VkTimeDomainEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkTimeDomainEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkTimeDomainEXT_map[*obj] << "\"" << std::endl;
}

typedef VkCalibratedTimestampInfoKHR VkCalibratedTimestampInfoEXT;

static void print_VkPhysicalDeviceShaderCorePropertiesAMD(VkPhysicalDeviceShaderCorePropertiesAMD obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.shaderEngineCount, "shaderEngineCount", 1);

    print_uint32_t(obj.shaderArraysPerEngineCount, "shaderArraysPerEngineCount", 1);

    print_uint32_t(obj.computeUnitsPerShaderArray, "computeUnitsPerShaderArray", 1);

    print_uint32_t(obj.simdPerComputeUnit, "simdPerComputeUnit", 1);

    print_uint32_t(obj.wavefrontsPerSimd, "wavefrontsPerSimd", 1);

    print_uint32_t(obj.wavefrontSize, "wavefrontSize", 1);

    print_uint32_t(obj.sgprsPerSimd, "sgprsPerSimd", 1);

    print_uint32_t(obj.minSgprAllocation, "minSgprAllocation", 1);

    print_uint32_t(obj.maxSgprAllocation, "maxSgprAllocation", 1);

    print_uint32_t(obj.sgprAllocationGranularity, "sgprAllocationGranularity", 1);

    print_uint32_t(obj.vgprsPerSimd, "vgprsPerSimd", 1);

    print_uint32_t(obj.minVgprAllocation, "minVgprAllocation", 1);

    print_uint32_t(obj.maxVgprAllocation, "maxVgprAllocation", 1);

    print_uint32_t(obj.vgprAllocationGranularity, "vgprAllocationGranularity", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderCorePropertiesAMD(const VkPhysicalDeviceShaderCorePropertiesAMD* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->shaderEngineCount, "shaderEngineCount", 1);

    print_uint32_t(obj->shaderArraysPerEngineCount, "shaderArraysPerEngineCount", 1);

    print_uint32_t(obj->computeUnitsPerShaderArray, "computeUnitsPerShaderArray", 1);

    print_uint32_t(obj->simdPerComputeUnit, "simdPerComputeUnit", 1);

    print_uint32_t(obj->wavefrontsPerSimd, "wavefrontsPerSimd", 1);

    print_uint32_t(obj->wavefrontSize, "wavefrontSize", 1);

    print_uint32_t(obj->sgprsPerSimd, "sgprsPerSimd", 1);

    print_uint32_t(obj->minSgprAllocation, "minSgprAllocation", 1);

    print_uint32_t(obj->maxSgprAllocation, "maxSgprAllocation", 1);

    print_uint32_t(obj->sgprAllocationGranularity, "sgprAllocationGranularity", 1);

    print_uint32_t(obj->vgprsPerSimd, "vgprsPerSimd", 1);

    print_uint32_t(obj->minVgprAllocation, "minVgprAllocation", 1);

    print_uint32_t(obj->maxVgprAllocation, "maxVgprAllocation", 1);

    print_uint32_t(obj->vgprAllocationGranularity, "vgprAllocationGranularity", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkMemoryOverallocationBehaviorAMD_map = {
    std::make_pair(0, "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD"),
    std::make_pair(1, "VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD"),
    std::make_pair(2, "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD"),
};
static void print_VkMemoryOverallocationBehaviorAMD(VkMemoryOverallocationBehaviorAMD obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryOverallocationBehaviorAMD_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryOverallocationBehaviorAMD_map[obj] << "\"" << std::endl;
}
static void print_VkMemoryOverallocationBehaviorAMD(const VkMemoryOverallocationBehaviorAMD* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryOverallocationBehaviorAMD_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryOverallocationBehaviorAMD_map[*obj] << "\"" << std::endl;
}

static void print_VkDeviceMemoryOverallocationCreateInfoAMD(VkDeviceMemoryOverallocationCreateInfoAMD obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMemoryOverallocationBehaviorAMD(obj.overallocationBehavior, "overallocationBehavior", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceMemoryOverallocationCreateInfoAMD(const VkDeviceMemoryOverallocationCreateInfoAMD* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMemoryOverallocationBehaviorAMD(obj->overallocationBehavior, "overallocationBehavior", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxVertexAttribDivisor, "maxVertexAttribDivisor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxVertexAttribDivisor, "maxVertexAttribDivisor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkVertexInputBindingDivisorDescription VkVertexInputBindingDivisorDescriptionEXT;

typedef VkPipelineVertexInputDivisorStateCreateInfo VkPipelineVertexInputDivisorStateCreateInfoEXT;

typedef VkPhysicalDeviceVertexAttributeDivisorFeatures VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT;

static std::map<uint64_t, std::string> VkPipelineCreationFeedbackFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT"),
    std::make_pair(1ULL << 1, "VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT"),
    std::make_pair(1ULL << 2, "VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT"),
};
static void print_VkPipelineCreationFeedbackFlagBits(VkPipelineCreationFeedbackFlagBits obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCreationFeedbackFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCreationFeedbackFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineCreationFeedbackFlagBits(const VkPipelineCreationFeedbackFlagBits* obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCreationFeedbackFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCreationFeedbackFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPipelineCreationFeedbackFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT"),
    std::make_pair(1ULL << 1, "VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT"),
    std::make_pair(1ULL << 2, "VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT"),
};
static void print_VkPipelineCreationFeedbackFlagBitsEXT(VkPipelineCreationFeedbackFlagBitsEXT obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCreationFeedbackFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCreationFeedbackFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkPipelineCreationFeedbackFlagBitsEXT(const VkPipelineCreationFeedbackFlagBitsEXT* obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPipelineCreationFeedbackFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPipelineCreationFeedbackFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkPipelineCreationFeedbackFlags(VkPipelineCreationFeedbackFlags obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPipelineCreationFeedbackFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkPipelineCreationFeedbackFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPipelineCreationFeedback(VkPipelineCreationFeedback obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkPipelineCreationFeedbackFlags(obj.flags, "flags", 1);

    print_uint64_t(obj.duration, "duration", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineCreationFeedback(const VkPipelineCreationFeedback* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkPipelineCreationFeedbackFlags(obj->flags, "flags", 1);

    print_uint64_t(obj->duration, "duration", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineCreationFeedbackCreateInfo(VkPipelineCreationFeedbackCreateInfo obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pPipelineCreationFeedback\": " << std::endl;
    if (obj.pPipelineCreationFeedback) {
        print_VkPipelineCreationFeedback(obj.pPipelineCreationFeedback, "pPipelineCreationFeedback", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.pipelineStageCreationFeedbackCount, "pipelineStageCreationFeedbackCount", 1);

    PRINT_SPACE
    _OUT << "\"pPipelineStageCreationFeedbacks\": " << std::endl;
    if (obj.pPipelineStageCreationFeedbacks) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.pipelineStageCreationFeedbackCount; i++) {
            if (i + 1 == obj.pipelineStageCreationFeedbackCount)
                print_VkPipelineCreationFeedback(obj.pPipelineStageCreationFeedbacks[i], "pPipelineStageCreationFeedbacks", 0);
            else
                print_VkPipelineCreationFeedback(obj.pPipelineStageCreationFeedbacks[i], "pPipelineStageCreationFeedbacks", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineCreationFeedbackCreateInfo(const VkPipelineCreationFeedbackCreateInfo* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pPipelineCreationFeedback\": " << std::endl;
    if (obj->pPipelineCreationFeedback) {
        print_VkPipelineCreationFeedback(obj->pPipelineCreationFeedback, "pPipelineCreationFeedback", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->pipelineStageCreationFeedbackCount, "pipelineStageCreationFeedbackCount", 1);

    PRINT_SPACE
    _OUT << "\"pPipelineStageCreationFeedbacks\": " << std::endl;
    if (obj->pPipelineStageCreationFeedbacks) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->pipelineStageCreationFeedbackCount; i++) {
            if (i + 1 == obj->pipelineStageCreationFeedbackCount)
                print_VkPipelineCreationFeedback(obj->pPipelineStageCreationFeedbacks[i], "pPipelineStageCreationFeedbacks", 0);
            else
                print_VkPipelineCreationFeedback(obj->pPipelineStageCreationFeedbacks[i], "pPipelineStageCreationFeedbacks", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPipelineCreationFeedbackCreateInfo VkPipelineCreationFeedbackCreateInfoEXT;

typedef VkPipelineCreationFeedback VkPipelineCreationFeedbackEXT;

typedef VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR VkPhysicalDeviceComputeShaderDerivativesFeaturesNV;

static void print_VkPhysicalDeviceMeshShaderFeaturesNV(VkPhysicalDeviceMeshShaderFeaturesNV obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.taskShader, "taskShader", 1);

    print_VkBool32(obj.meshShader, "meshShader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMeshShaderFeaturesNV(const VkPhysicalDeviceMeshShaderFeaturesNV* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->taskShader, "taskShader", 1);

    print_VkBool32(obj->meshShader, "meshShader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMeshShaderPropertiesNV(VkPhysicalDeviceMeshShaderPropertiesNV obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxDrawMeshTasksCount, "maxDrawMeshTasksCount", 1);

    print_uint32_t(obj.maxTaskWorkGroupInvocations, "maxTaskWorkGroupInvocations", 1);

    PRINT_SPACE
    _OUT << "\"maxTaskWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj.maxTaskWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.maxTaskTotalMemorySize, "maxTaskTotalMemorySize", 1);

    print_uint32_t(obj.maxTaskOutputCount, "maxTaskOutputCount", 1);

    print_uint32_t(obj.maxMeshWorkGroupInvocations, "maxMeshWorkGroupInvocations", 1);

    PRINT_SPACE
    _OUT << "\"maxMeshWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj.maxMeshWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.maxMeshTotalMemorySize, "maxMeshTotalMemorySize", 1);

    print_uint32_t(obj.maxMeshOutputVertices, "maxMeshOutputVertices", 1);

    print_uint32_t(obj.maxMeshOutputPrimitives, "maxMeshOutputPrimitives", 1);

    print_uint32_t(obj.maxMeshMultiviewViewCount, "maxMeshMultiviewViewCount", 1);

    print_uint32_t(obj.meshOutputPerVertexGranularity, "meshOutputPerVertexGranularity", 1);

    print_uint32_t(obj.meshOutputPerPrimitiveGranularity, "meshOutputPerPrimitiveGranularity", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMeshShaderPropertiesNV(const VkPhysicalDeviceMeshShaderPropertiesNV* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxDrawMeshTasksCount, "maxDrawMeshTasksCount", 1);

    print_uint32_t(obj->maxTaskWorkGroupInvocations, "maxTaskWorkGroupInvocations", 1);

    PRINT_SPACE
    _OUT << "\"maxTaskWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj->maxTaskWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->maxTaskTotalMemorySize, "maxTaskTotalMemorySize", 1);

    print_uint32_t(obj->maxTaskOutputCount, "maxTaskOutputCount", 1);

    print_uint32_t(obj->maxMeshWorkGroupInvocations, "maxMeshWorkGroupInvocations", 1);

    PRINT_SPACE
    _OUT << "\"maxMeshWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj->maxMeshWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->maxMeshTotalMemorySize, "maxMeshTotalMemorySize", 1);

    print_uint32_t(obj->maxMeshOutputVertices, "maxMeshOutputVertices", 1);

    print_uint32_t(obj->maxMeshOutputPrimitives, "maxMeshOutputPrimitives", 1);

    print_uint32_t(obj->maxMeshMultiviewViewCount, "maxMeshMultiviewViewCount", 1);

    print_uint32_t(obj->meshOutputPerVertexGranularity, "meshOutputPerVertexGranularity", 1);

    print_uint32_t(obj->meshOutputPerPrimitiveGranularity, "meshOutputPerPrimitiveGranularity", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDrawMeshTasksIndirectCommandNV(VkDrawMeshTasksIndirectCommandNV obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.taskCount, "taskCount", 1);

    print_uint32_t(obj.firstTask, "firstTask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDrawMeshTasksIndirectCommandNV(const VkDrawMeshTasksIndirectCommandNV* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->taskCount, "taskCount", 1);

    print_uint32_t(obj->firstTask, "firstTask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV;

static void print_VkPhysicalDeviceShaderImageFootprintFeaturesNV(VkPhysicalDeviceShaderImageFootprintFeaturesNV obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.imageFootprint, "imageFootprint", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderImageFootprintFeaturesNV(const VkPhysicalDeviceShaderImageFootprintFeaturesNV* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->imageFootprint, "imageFootprint", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineViewportExclusiveScissorStateCreateInfoNV(VkPipelineViewportExclusiveScissorStateCreateInfoNV obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.exclusiveScissorCount, "exclusiveScissorCount", 1);

    PRINT_SPACE
    _OUT << "\"pExclusiveScissors\": " << std::endl;
    if (obj.pExclusiveScissors) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.exclusiveScissorCount; i++) {
            if (i + 1 == obj.exclusiveScissorCount)
                print_VkRect2D(obj.pExclusiveScissors[i], "pExclusiveScissors", 0);
            else
                print_VkRect2D(obj.pExclusiveScissors[i], "pExclusiveScissors", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineViewportExclusiveScissorStateCreateInfoNV(
    const VkPipelineViewportExclusiveScissorStateCreateInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->exclusiveScissorCount, "exclusiveScissorCount", 1);

    PRINT_SPACE
    _OUT << "\"pExclusiveScissors\": " << std::endl;
    if (obj->pExclusiveScissors) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->exclusiveScissorCount; i++) {
            if (i + 1 == obj->exclusiveScissorCount)
                print_VkRect2D(obj->pExclusiveScissors[i], "pExclusiveScissors", 0);
            else
                print_VkRect2D(obj->pExclusiveScissors[i], "pExclusiveScissors", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceExclusiveScissorFeaturesNV(VkPhysicalDeviceExclusiveScissorFeaturesNV obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.exclusiveScissor, "exclusiveScissor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceExclusiveScissorFeaturesNV(const VkPhysicalDeviceExclusiveScissorFeaturesNV* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->exclusiveScissor, "exclusiveScissor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkQueueFamilyCheckpointPropertiesNV(VkQueueFamilyCheckpointPropertiesNV obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlags(obj.checkpointExecutionStageMask, "checkpointExecutionStageMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkQueueFamilyCheckpointPropertiesNV(const VkQueueFamilyCheckpointPropertiesNV* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlags(obj->checkpointExecutionStageMask, "checkpointExecutionStageMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCheckpointDataNV(VkCheckpointDataNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlagBits(obj.stage, "stage", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCheckpointDataNV(const VkCheckpointDataNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlagBits(obj->stage, "stage", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkQueueFamilyCheckpointProperties2NV(VkQueueFamilyCheckpointProperties2NV obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlags2(obj.checkpointExecutionStageMask, "checkpointExecutionStageMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkQueueFamilyCheckpointProperties2NV(const VkQueueFamilyCheckpointProperties2NV* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlags2(obj->checkpointExecutionStageMask, "checkpointExecutionStageMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCheckpointData2NV(VkCheckpointData2NV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlags2(obj.stage, "stage", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCheckpointData2NV(const VkCheckpointData2NV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineStageFlags2(obj->stage, "stage", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderIntegerFunctions2, "shaderIntegerFunctions2", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
    const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderIntegerFunctions2, "shaderIntegerFunctions2", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPerformanceConfigurationINTEL(VkPerformanceConfigurationINTEL obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPerformanceConfigurationTypeINTEL_map = {
    std::make_pair(0, "VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL"),
};
static void print_VkPerformanceConfigurationTypeINTEL(VkPerformanceConfigurationTypeINTEL obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceConfigurationTypeINTEL_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceConfigurationTypeINTEL_map[obj] << "\"" << std::endl;
}
static void print_VkPerformanceConfigurationTypeINTEL(const VkPerformanceConfigurationTypeINTEL* obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceConfigurationTypeINTEL_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceConfigurationTypeINTEL_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkQueryPoolSamplingModeINTEL_map = {
    std::make_pair(0, "VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL"),
};
static void print_VkQueryPoolSamplingModeINTEL(VkQueryPoolSamplingModeINTEL obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueryPoolSamplingModeINTEL_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueryPoolSamplingModeINTEL_map[obj] << "\"" << std::endl;
}
static void print_VkQueryPoolSamplingModeINTEL(const VkQueryPoolSamplingModeINTEL* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkQueryPoolSamplingModeINTEL_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkQueryPoolSamplingModeINTEL_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPerformanceOverrideTypeINTEL_map = {
    std::make_pair(0, "VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL"),
    std::make_pair(1, "VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL"),
};
static void print_VkPerformanceOverrideTypeINTEL(VkPerformanceOverrideTypeINTEL obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceOverrideTypeINTEL_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceOverrideTypeINTEL_map[obj] << "\"" << std::endl;
}
static void print_VkPerformanceOverrideTypeINTEL(const VkPerformanceOverrideTypeINTEL* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceOverrideTypeINTEL_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceOverrideTypeINTEL_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPerformanceParameterTypeINTEL_map = {
    std::make_pair(0, "VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL"),
    std::make_pair(1, "VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL"),
};
static void print_VkPerformanceParameterTypeINTEL(VkPerformanceParameterTypeINTEL obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceParameterTypeINTEL_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceParameterTypeINTEL_map[obj] << "\"" << std::endl;
}
static void print_VkPerformanceParameterTypeINTEL(const VkPerformanceParameterTypeINTEL* obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceParameterTypeINTEL_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceParameterTypeINTEL_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPerformanceValueTypeINTEL_map = {
    std::make_pair(0, "VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL"), std::make_pair(1, "VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL"),
    std::make_pair(2, "VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL"),  std::make_pair(3, "VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL"),
    std::make_pair(4, "VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL"),
};
static void print_VkPerformanceValueTypeINTEL(VkPerformanceValueTypeINTEL obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceValueTypeINTEL_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceValueTypeINTEL_map[obj] << "\"" << std::endl;
}
static void print_VkPerformanceValueTypeINTEL(const VkPerformanceValueTypeINTEL* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPerformanceValueTypeINTEL_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPerformanceValueTypeINTEL_map[*obj] << "\"" << std::endl;
}

static void print_VkPerformanceValueDataINTEL(VkPerformanceValueDataINTEL obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.value32, "value32", 1);

    print_uint64_t(obj.value64, "value64", 1);

    print_float(obj.valueFloat, "valueFloat", 1);

    print_VkBool32(obj.valueBool, "valueBool", 1);

    print_char(obj.valueString, "valueString", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPerformanceValueDataINTEL(const VkPerformanceValueDataINTEL* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->value32, "value32", 1);

    print_uint64_t(obj->value64, "value64", 1);

    print_float(obj->valueFloat, "valueFloat", 1);

    print_VkBool32(obj->valueBool, "valueBool", 1);

    print_char(obj->valueString, "valueString", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPerformanceValueINTEL(VkPerformanceValueINTEL obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkPerformanceValueTypeINTEL(obj.type, "type", 1);

    print_VkPerformanceValueDataINTEL(obj.data, "data", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPerformanceValueINTEL(const VkPerformanceValueINTEL* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkPerformanceValueTypeINTEL(obj->type, "type", 1);

    print_VkPerformanceValueDataINTEL(obj->data, "data", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkInitializePerformanceApiInfoINTEL(VkInitializePerformanceApiInfoINTEL obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkInitializePerformanceApiInfoINTEL(const VkInitializePerformanceApiInfoINTEL* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkQueryPoolPerformanceQueryCreateInfoINTEL(VkQueryPoolPerformanceQueryCreateInfoINTEL obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkQueryPoolSamplingModeINTEL(obj.performanceCountersSampling, "performanceCountersSampling", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkQueryPoolPerformanceQueryCreateInfoINTEL(const VkQueryPoolPerformanceQueryCreateInfoINTEL* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkQueryPoolSamplingModeINTEL(obj->performanceCountersSampling, "performanceCountersSampling", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkQueryPoolPerformanceQueryCreateInfoINTEL VkQueryPoolCreateInfoINTEL;

static void print_VkPerformanceMarkerInfoINTEL(VkPerformanceMarkerInfoINTEL obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.marker, "marker", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPerformanceMarkerInfoINTEL(const VkPerformanceMarkerInfoINTEL* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->marker, "marker", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPerformanceStreamMarkerInfoINTEL(VkPerformanceStreamMarkerInfoINTEL obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.marker, "marker", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPerformanceStreamMarkerInfoINTEL(const VkPerformanceStreamMarkerInfoINTEL* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->marker, "marker", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPerformanceOverrideInfoINTEL(VkPerformanceOverrideInfoINTEL obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPerformanceOverrideTypeINTEL(obj.type, "type", 1);

    print_VkBool32(obj.enable, "enable", 1);

    print_uint64_t(obj.parameter, "parameter", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPerformanceOverrideInfoINTEL(const VkPerformanceOverrideInfoINTEL* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPerformanceOverrideTypeINTEL(obj->type, "type", 1);

    print_VkBool32(obj->enable, "enable", 1);

    print_uint64_t(obj->parameter, "parameter", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPerformanceConfigurationAcquireInfoINTEL(VkPerformanceConfigurationAcquireInfoINTEL obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPerformanceConfigurationTypeINTEL(obj.type, "type", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPerformanceConfigurationAcquireInfoINTEL(const VkPerformanceConfigurationAcquireInfoINTEL* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPerformanceConfigurationTypeINTEL(obj->type, "type", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePCIBusInfoPropertiesEXT(VkPhysicalDevicePCIBusInfoPropertiesEXT obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.pciDomain, "pciDomain", 1);

    print_uint32_t(obj.pciBus, "pciBus", 1);

    print_uint32_t(obj.pciDevice, "pciDevice", 1);

    print_uint32_t(obj.pciFunction, "pciFunction", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePCIBusInfoPropertiesEXT(const VkPhysicalDevicePCIBusInfoPropertiesEXT* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->pciDomain, "pciDomain", 1);

    print_uint32_t(obj->pciBus, "pciBus", 1);

    print_uint32_t(obj->pciDevice, "pciDevice", 1);

    print_uint32_t(obj->pciFunction, "pciFunction", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayNativeHdrSurfaceCapabilitiesAMD(VkDisplayNativeHdrSurfaceCapabilitiesAMD obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.localDimmingSupport, "localDimmingSupport", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayNativeHdrSurfaceCapabilitiesAMD(const VkDisplayNativeHdrSurfaceCapabilitiesAMD* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->localDimmingSupport, "localDimmingSupport", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSwapchainDisplayNativeHdrCreateInfoAMD(VkSwapchainDisplayNativeHdrCreateInfoAMD obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.localDimmingEnable, "localDimmingEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSwapchainDisplayNativeHdrCreateInfoAMD(const VkSwapchainDisplayNativeHdrCreateInfoAMD* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->localDimmingEnable, "localDimmingEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(VkPhysicalDeviceFragmentDensityMapFeaturesEXT obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.fragmentDensityMap, "fragmentDensityMap", 1);

    print_VkBool32(obj.fragmentDensityMapDynamic, "fragmentDensityMapDynamic", 1);

    print_VkBool32(obj.fragmentDensityMapNonSubsampledImages, "fragmentDensityMapNonSubsampledImages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(const VkPhysicalDeviceFragmentDensityMapFeaturesEXT* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->fragmentDensityMap, "fragmentDensityMap", 1);

    print_VkBool32(obj->fragmentDensityMapDynamic, "fragmentDensityMapDynamic", 1);

    print_VkBool32(obj->fragmentDensityMapNonSubsampledImages, "fragmentDensityMapNonSubsampledImages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(VkPhysicalDeviceFragmentDensityMapPropertiesEXT obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"minFragmentDensityTexelSize\": " << std::endl;
    { print_VkExtent2D(obj.minFragmentDensityTexelSize, "minFragmentDensityTexelSize", 1); }

    PRINT_SPACE
    _OUT << "\"maxFragmentDensityTexelSize\": " << std::endl;
    { print_VkExtent2D(obj.maxFragmentDensityTexelSize, "maxFragmentDensityTexelSize", 1); }

    print_VkBool32(obj.fragmentDensityInvocations, "fragmentDensityInvocations", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(const VkPhysicalDeviceFragmentDensityMapPropertiesEXT* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"minFragmentDensityTexelSize\": " << std::endl;
    { print_VkExtent2D(obj->minFragmentDensityTexelSize, "minFragmentDensityTexelSize", 1); }

    PRINT_SPACE
    _OUT << "\"maxFragmentDensityTexelSize\": " << std::endl;
    { print_VkExtent2D(obj->maxFragmentDensityTexelSize, "maxFragmentDensityTexelSize", 1); }

    print_VkBool32(obj->fragmentDensityInvocations, "fragmentDensityInvocations", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassFragmentDensityMapCreateInfoEXT(VkRenderPassFragmentDensityMapCreateInfoEXT obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"fragmentDensityMapAttachment\": " << std::endl;
    { print_VkAttachmentReference(obj.fragmentDensityMapAttachment, "fragmentDensityMapAttachment", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassFragmentDensityMapCreateInfoEXT(const VkRenderPassFragmentDensityMapCreateInfoEXT* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"fragmentDensityMapAttachment\": " << std::endl;
    { print_VkAttachmentReference(obj->fragmentDensityMapAttachment, "fragmentDensityMapAttachment", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderingFragmentDensityMapAttachmentInfoEXT(VkRenderingFragmentDensityMapAttachmentInfoEXT obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.imageLayout, "imageLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderingFragmentDensityMapAttachmentInfoEXT(const VkRenderingFragmentDensityMapAttachmentInfoEXT* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->imageLayout, "imageLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceScalarBlockLayoutFeatures VkPhysicalDeviceScalarBlockLayoutFeaturesEXT;

static void print_VkPhysicalDeviceSubgroupSizeControlFeatures(VkPhysicalDeviceSubgroupSizeControlFeatures obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.subgroupSizeControl, "subgroupSizeControl", 1);

    print_VkBool32(obj.computeFullSubgroups, "computeFullSubgroups", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSubgroupSizeControlFeatures(const VkPhysicalDeviceSubgroupSizeControlFeatures* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->subgroupSizeControl, "subgroupSizeControl", 1);

    print_VkBool32(obj->computeFullSubgroups, "computeFullSubgroups", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceSubgroupSizeControlFeatures VkPhysicalDeviceSubgroupSizeControlFeaturesEXT;

static void print_VkPhysicalDeviceSubgroupSizeControlProperties(VkPhysicalDeviceSubgroupSizeControlProperties obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.minSubgroupSize, "minSubgroupSize", 1);

    print_uint32_t(obj.maxSubgroupSize, "maxSubgroupSize", 1);

    print_uint32_t(obj.maxComputeWorkgroupSubgroups, "maxComputeWorkgroupSubgroups", 1);

    print_VkShaderStageFlags(obj.requiredSubgroupSizeStages, "requiredSubgroupSizeStages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSubgroupSizeControlProperties(const VkPhysicalDeviceSubgroupSizeControlProperties* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->minSubgroupSize, "minSubgroupSize", 1);

    print_uint32_t(obj->maxSubgroupSize, "maxSubgroupSize", 1);

    print_uint32_t(obj->maxComputeWorkgroupSubgroups, "maxComputeWorkgroupSubgroups", 1);

    print_VkShaderStageFlags(obj->requiredSubgroupSizeStages, "requiredSubgroupSizeStages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceSubgroupSizeControlProperties VkPhysicalDeviceSubgroupSizeControlPropertiesEXT;

static void print_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.requiredSubgroupSize, "requiredSubgroupSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(
    const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->requiredSubgroupSize, "requiredSubgroupSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPipelineShaderStageRequiredSubgroupSizeCreateInfo VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT;

static std::map<uint64_t, std::string> VkShaderCorePropertiesFlagBitsAMD_map = {};
static void print_VkShaderCorePropertiesFlagBitsAMD(VkShaderCorePropertiesFlagBitsAMD obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderCorePropertiesFlagBitsAMD_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderCorePropertiesFlagBitsAMD_map[obj] << "\"" << std::endl;
}
static void print_VkShaderCorePropertiesFlagBitsAMD(const VkShaderCorePropertiesFlagBitsAMD* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderCorePropertiesFlagBitsAMD_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderCorePropertiesFlagBitsAMD_map[*obj] << "\"" << std::endl;
}

static void print_VkShaderCorePropertiesFlagsAMD(VkShaderCorePropertiesFlagsAMD obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkShaderCorePropertiesFlagBitsAMD_map[1ULL << i] << " | ";
            else
                _OUT << VkShaderCorePropertiesFlagBitsAMD_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceShaderCoreProperties2AMD(VkPhysicalDeviceShaderCoreProperties2AMD obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderCorePropertiesFlagsAMD(obj.shaderCoreFeatures, "shaderCoreFeatures", 1);

    print_uint32_t(obj.activeComputeUnitCount, "activeComputeUnitCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderCoreProperties2AMD(const VkPhysicalDeviceShaderCoreProperties2AMD* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderCorePropertiesFlagsAMD(obj->shaderCoreFeatures, "shaderCoreFeatures", 1);

    print_uint32_t(obj->activeComputeUnitCount, "activeComputeUnitCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCoherentMemoryFeaturesAMD(VkPhysicalDeviceCoherentMemoryFeaturesAMD obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.deviceCoherentMemory, "deviceCoherentMemory", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCoherentMemoryFeaturesAMD(const VkPhysicalDeviceCoherentMemoryFeaturesAMD* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->deviceCoherentMemory, "deviceCoherentMemory", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderImageInt64Atomics, "shaderImageInt64Atomics", 1);

    print_VkBool32(obj.sparseImageInt64Atomics, "sparseImageInt64Atomics", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderImageInt64Atomics, "shaderImageInt64Atomics", 1);

    print_VkBool32(obj->sparseImageInt64Atomics, "sparseImageInt64Atomics", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMemoryBudgetPropertiesEXT(VkPhysicalDeviceMemoryBudgetPropertiesEXT obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"heapBudget\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_MEMORY_HEAPS; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_MEMORY_HEAPS;
        print_VkDeviceSize(obj.heapBudget[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"heapUsage\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_MEMORY_HEAPS; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_MEMORY_HEAPS;
        print_VkDeviceSize(obj.heapUsage[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMemoryBudgetPropertiesEXT(const VkPhysicalDeviceMemoryBudgetPropertiesEXT* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"heapBudget\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_MEMORY_HEAPS; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_MEMORY_HEAPS;
        print_VkDeviceSize(obj->heapBudget[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"heapUsage\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_MEMORY_HEAPS; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_MEMORY_HEAPS;
        print_VkDeviceSize(obj->heapUsage[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMemoryPriorityFeaturesEXT(VkPhysicalDeviceMemoryPriorityFeaturesEXT obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.memoryPriority, "memoryPriority", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMemoryPriorityFeaturesEXT(const VkPhysicalDeviceMemoryPriorityFeaturesEXT* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->memoryPriority, "memoryPriority", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryPriorityAllocateInfoEXT(VkMemoryPriorityAllocateInfoEXT obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_float(obj.priority, "priority", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryPriorityAllocateInfoEXT(const VkMemoryPriorityAllocateInfoEXT* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_float(obj->priority, "priority", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.dedicatedAllocationImageAliasing, "dedicatedAllocationImageAliasing", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
    const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->dedicatedAllocationImageAliasing, "dedicatedAllocationImageAliasing", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.bufferDeviceAddress, "bufferDeviceAddress", 1);

    print_VkBool32(obj.bufferDeviceAddressCaptureReplay, "bufferDeviceAddressCaptureReplay", 1);

    print_VkBool32(obj.bufferDeviceAddressMultiDevice, "bufferDeviceAddressMultiDevice", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->bufferDeviceAddress, "bufferDeviceAddress", 1);

    print_VkBool32(obj->bufferDeviceAddressCaptureReplay, "bufferDeviceAddressCaptureReplay", 1);

    print_VkBool32(obj->bufferDeviceAddressMultiDevice, "bufferDeviceAddressMultiDevice", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceBufferDeviceAddressFeaturesEXT VkPhysicalDeviceBufferAddressFeaturesEXT;

typedef VkBufferDeviceAddressInfo VkBufferDeviceAddressInfoEXT;

static void print_VkBufferDeviceAddressCreateInfoEXT(VkBufferDeviceAddressCreateInfoEXT obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceAddress(obj.deviceAddress, "deviceAddress", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferDeviceAddressCreateInfoEXT(const VkBufferDeviceAddressCreateInfoEXT* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceAddress(obj->deviceAddress, "deviceAddress", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkToolPurposeFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_TOOL_PURPOSE_VALIDATION_BIT"),
    std::make_pair(1ULL << 1, "VK_TOOL_PURPOSE_PROFILING_BIT"),
    std::make_pair(1ULL << 2, "VK_TOOL_PURPOSE_TRACING_BIT"),
    std::make_pair(1ULL << 3, "VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT"),
    std::make_pair(1ULL << 4, "VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT"),
    std::make_pair(1ULL << 5, "VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT"),
    std::make_pair(1ULL << 6, "VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT"),
    std::make_pair(1ULL << 5, "VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT"),
    std::make_pair(1ULL << 6, "VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT"),
};
static void print_VkToolPurposeFlagBits(VkToolPurposeFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkToolPurposeFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkToolPurposeFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkToolPurposeFlagBits(const VkToolPurposeFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkToolPurposeFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkToolPurposeFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkToolPurposeFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_TOOL_PURPOSE_VALIDATION_BIT"),
    std::make_pair(1ULL << 1, "VK_TOOL_PURPOSE_PROFILING_BIT"),
    std::make_pair(1ULL << 2, "VK_TOOL_PURPOSE_TRACING_BIT"),
    std::make_pair(1ULL << 3, "VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT"),
    std::make_pair(1ULL << 4, "VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT"),
    std::make_pair(1ULL << 5, "VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT"),
    std::make_pair(1ULL << 6, "VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT"),
    std::make_pair(1ULL << 5, "VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT"),
    std::make_pair(1ULL << 6, "VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT"),
};
static void print_VkToolPurposeFlagBitsEXT(VkToolPurposeFlagBitsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkToolPurposeFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkToolPurposeFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkToolPurposeFlagBitsEXT(const VkToolPurposeFlagBitsEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkToolPurposeFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkToolPurposeFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkToolPurposeFlags(VkToolPurposeFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkToolPurposeFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkToolPurposeFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceToolProperties(VkPhysicalDeviceToolProperties obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"name\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_EXTENSION_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_EXTENSION_NAME_SIZE;
        print_char(obj.name[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"version\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_EXTENSION_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_EXTENSION_NAME_SIZE;
        print_char(obj.version[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkToolPurposeFlags(obj.purposes, "purposes", 1);

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"layer\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_EXTENSION_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_EXTENSION_NAME_SIZE;
        print_char(obj.layer[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceToolProperties(const VkPhysicalDeviceToolProperties* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"name\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_EXTENSION_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_EXTENSION_NAME_SIZE;
        print_char(obj->name[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"version\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_EXTENSION_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_EXTENSION_NAME_SIZE;
        print_char(obj->version[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkToolPurposeFlags(obj->purposes, "purposes", 1);

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"layer\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_EXTENSION_NAME_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_EXTENSION_NAME_SIZE;
        print_char(obj->layer[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceToolProperties VkPhysicalDeviceToolPropertiesEXT;

typedef VkImageStencilUsageCreateInfo VkImageStencilUsageCreateInfoEXT;

static std::map<uint64_t, std::string> VkValidationFeatureEnableEXT_map = {
    std::make_pair(0, "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT"),
    std::make_pair(1, "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT"),
    std::make_pair(2, "VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT"),
    std::make_pair(3, "VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT"),
    std::make_pair(4, "VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT"),
};
static void print_VkValidationFeatureEnableEXT(VkValidationFeatureEnableEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkValidationFeatureEnableEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkValidationFeatureEnableEXT_map[obj] << "\"" << std::endl;
}
static void print_VkValidationFeatureEnableEXT(const VkValidationFeatureEnableEXT* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkValidationFeatureEnableEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkValidationFeatureEnableEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkValidationFeatureDisableEXT_map = {
    std::make_pair(0, "VK_VALIDATION_FEATURE_DISABLE_ALL_EXT"),
    std::make_pair(1, "VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT"),
    std::make_pair(2, "VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT"),
    std::make_pair(3, "VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT"),
    std::make_pair(4, "VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT"),
    std::make_pair(5, "VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT"),
    std::make_pair(6, "VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT"),
    std::make_pair(7, "VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT"),
};
static void print_VkValidationFeatureDisableEXT(VkValidationFeatureDisableEXT obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkValidationFeatureDisableEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkValidationFeatureDisableEXT_map[obj] << "\"" << std::endl;
}
static void print_VkValidationFeatureDisableEXT(const VkValidationFeatureDisableEXT* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkValidationFeatureDisableEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkValidationFeatureDisableEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkValidationFeaturesEXT(VkValidationFeaturesEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.enabledValidationFeatureCount, "enabledValidationFeatureCount", 1);

    PRINT_SPACE
    _OUT << "\"pEnabledValidationFeatures\":" << std::endl;
    PRINT_SPACE
    if (obj.pEnabledValidationFeatures) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.enabledValidationFeatureCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.enabledValidationFeatureCount;
            print_VkValidationFeatureEnableEXT(obj.pEnabledValidationFeatures[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.disabledValidationFeatureCount, "disabledValidationFeatureCount", 1);

    PRINT_SPACE
    _OUT << "\"pDisabledValidationFeatures\":" << std::endl;
    PRINT_SPACE
    if (obj.pDisabledValidationFeatures) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.disabledValidationFeatureCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.disabledValidationFeatureCount;
            print_VkValidationFeatureDisableEXT(obj.pDisabledValidationFeatures[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkValidationFeaturesEXT(const VkValidationFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->enabledValidationFeatureCount, "enabledValidationFeatureCount", 1);

    PRINT_SPACE
    _OUT << "\"pEnabledValidationFeatures\":" << std::endl;
    PRINT_SPACE
    if (obj->pEnabledValidationFeatures) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->enabledValidationFeatureCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->enabledValidationFeatureCount;
            print_VkValidationFeatureEnableEXT(obj->pEnabledValidationFeatures[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->disabledValidationFeatureCount, "disabledValidationFeatureCount", 1);

    PRINT_SPACE
    _OUT << "\"pDisabledValidationFeatures\":" << std::endl;
    PRINT_SPACE
    if (obj->pDisabledValidationFeatures) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->disabledValidationFeatureCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->disabledValidationFeatureCount;
            print_VkValidationFeatureDisableEXT(obj->pDisabledValidationFeatures[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkComponentTypeNV_map = {
    std::make_pair(0, "VK_COMPONENT_TYPE_FLOAT16_KHR"),
    std::make_pair(1, "VK_COMPONENT_TYPE_FLOAT32_KHR"),
    std::make_pair(2, "VK_COMPONENT_TYPE_FLOAT64_KHR"),
    std::make_pair(3, "VK_COMPONENT_TYPE_SINT8_KHR"),
    std::make_pair(4, "VK_COMPONENT_TYPE_SINT16_KHR"),
    std::make_pair(5, "VK_COMPONENT_TYPE_SINT32_KHR"),
    std::make_pair(6, "VK_COMPONENT_TYPE_SINT64_KHR"),
    std::make_pair(7, "VK_COMPONENT_TYPE_UINT8_KHR"),
    std::make_pair(8, "VK_COMPONENT_TYPE_UINT16_KHR"),
    std::make_pair(9, "VK_COMPONENT_TYPE_UINT32_KHR"),
    std::make_pair(10, "VK_COMPONENT_TYPE_UINT64_KHR"),
    std::make_pair(1000491000, "VK_COMPONENT_TYPE_SINT8_PACKED_NV"),
    std::make_pair(1000491001, "VK_COMPONENT_TYPE_UINT8_PACKED_NV"),
    std::make_pair(1000491002, "VK_COMPONENT_TYPE_FLOAT_E4M3_NV"),
    std::make_pair(1000491003, "VK_COMPONENT_TYPE_FLOAT_E5M2_NV"),
};
static void print_VkComponentTypeNV(VkComponentTypeNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkComponentTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkComponentTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkComponentTypeNV(const VkComponentTypeNV* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkComponentTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkComponentTypeNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkScopeNV_map = {
    std::make_pair(1, "VK_SCOPE_DEVICE_KHR"),
    std::make_pair(2, "VK_SCOPE_WORKGROUP_KHR"),
    std::make_pair(3, "VK_SCOPE_SUBGROUP_KHR"),
    std::make_pair(5, "VK_SCOPE_QUEUE_FAMILY_KHR"),
};
static void print_VkScopeNV(VkScopeNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkScopeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkScopeNV_map[obj] << "\"" << std::endl;
}
static void print_VkScopeNV(const VkScopeNV* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkScopeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkScopeNV_map[*obj] << "\"" << std::endl;
}

static void print_VkCooperativeMatrixPropertiesNV(VkCooperativeMatrixPropertiesNV obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.MSize, "MSize", 1);

    print_uint32_t(obj.NSize, "NSize", 1);

    print_uint32_t(obj.KSize, "KSize", 1);

    print_VkComponentTypeNV(obj.AType, "AType", 1);

    print_VkComponentTypeNV(obj.BType, "BType", 1);

    print_VkComponentTypeNV(obj.CType, "CType", 1);

    print_VkComponentTypeNV(obj.DType, "DType", 1);

    print_VkScopeNV(obj.scope, "scope", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCooperativeMatrixPropertiesNV(const VkCooperativeMatrixPropertiesNV* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->MSize, "MSize", 1);

    print_uint32_t(obj->NSize, "NSize", 1);

    print_uint32_t(obj->KSize, "KSize", 1);

    print_VkComponentTypeNV(obj->AType, "AType", 1);

    print_VkComponentTypeNV(obj->BType, "BType", 1);

    print_VkComponentTypeNV(obj->CType, "CType", 1);

    print_VkComponentTypeNV(obj->DType, "DType", 1);

    print_VkScopeNV(obj->scope, "scope", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCooperativeMatrixFeaturesNV(VkPhysicalDeviceCooperativeMatrixFeaturesNV obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.cooperativeMatrix, "cooperativeMatrix", 1);

    print_VkBool32(obj.cooperativeMatrixRobustBufferAccess, "cooperativeMatrixRobustBufferAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCooperativeMatrixFeaturesNV(const VkPhysicalDeviceCooperativeMatrixFeaturesNV* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->cooperativeMatrix, "cooperativeMatrix", 1);

    print_VkBool32(obj->cooperativeMatrixRobustBufferAccess, "cooperativeMatrixRobustBufferAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDeviceCooperativeMatrixPropertiesNV obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj.cooperativeMatrixSupportedStages, "cooperativeMatrixSupportedStages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCooperativeMatrixPropertiesNV(const VkPhysicalDeviceCooperativeMatrixPropertiesNV* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj->cooperativeMatrixSupportedStages, "cooperativeMatrixSupportedStages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkCoverageReductionModeNV_map = {
    std::make_pair(0, "VK_COVERAGE_REDUCTION_MODE_MERGE_NV"),
    std::make_pair(1, "VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV"),
};
static void print_VkCoverageReductionModeNV(VkCoverageReductionModeNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCoverageReductionModeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCoverageReductionModeNV_map[obj] << "\"" << std::endl;
}
static void print_VkCoverageReductionModeNV(const VkCoverageReductionModeNV* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCoverageReductionModeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCoverageReductionModeNV_map[*obj] << "\"" << std::endl;
}

static void print_VkPipelineCoverageReductionStateCreateFlagsNV(VkPipelineCoverageReductionStateCreateFlagsNV obj,
                                                                const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPhysicalDeviceCoverageReductionModeFeaturesNV(VkPhysicalDeviceCoverageReductionModeFeaturesNV obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.coverageReductionMode, "coverageReductionMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCoverageReductionModeFeaturesNV(const VkPhysicalDeviceCoverageReductionModeFeaturesNV* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->coverageReductionMode, "coverageReductionMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineCoverageReductionStateCreateInfoNV(VkPipelineCoverageReductionStateCreateInfoNV obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCoverageReductionStateCreateFlagsNV(obj.flags, "flags", 1);

    print_VkCoverageReductionModeNV(obj.coverageReductionMode, "coverageReductionMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineCoverageReductionStateCreateInfoNV(const VkPipelineCoverageReductionStateCreateInfoNV* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCoverageReductionStateCreateFlagsNV(obj->flags, "flags", 1);

    print_VkCoverageReductionModeNV(obj->coverageReductionMode, "coverageReductionMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkFramebufferMixedSamplesCombinationNV(VkFramebufferMixedSamplesCombinationNV obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkCoverageReductionModeNV(obj.coverageReductionMode, "coverageReductionMode", 1);

    print_VkSampleCountFlagBits(obj.rasterizationSamples, "rasterizationSamples", 1);

    print_VkSampleCountFlags(obj.depthStencilSamples, "depthStencilSamples", 1);

    print_VkSampleCountFlags(obj.colorSamples, "colorSamples", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkFramebufferMixedSamplesCombinationNV(const VkFramebufferMixedSamplesCombinationNV* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkCoverageReductionModeNV(obj->coverageReductionMode, "coverageReductionMode", 1);

    print_VkSampleCountFlagBits(obj->rasterizationSamples, "rasterizationSamples", 1);

    print_VkSampleCountFlags(obj->depthStencilSamples, "depthStencilSamples", 1);

    print_VkSampleCountFlags(obj->colorSamples, "colorSamples", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.fragmentShaderSampleInterlock, "fragmentShaderSampleInterlock", 1);

    print_VkBool32(obj.fragmentShaderPixelInterlock, "fragmentShaderPixelInterlock", 1);

    print_VkBool32(obj.fragmentShaderShadingRateInterlock, "fragmentShaderShadingRateInterlock", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->fragmentShaderSampleInterlock, "fragmentShaderSampleInterlock", 1);

    print_VkBool32(obj->fragmentShaderPixelInterlock, "fragmentShaderPixelInterlock", 1);

    print_VkBool32(obj->fragmentShaderShadingRateInterlock, "fragmentShaderShadingRateInterlock", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.ycbcrImageArrays, "ycbcrImageArrays", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->ycbcrImageArrays, "ycbcrImageArrays", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkProvokingVertexModeEXT_map = {
    std::make_pair(0, "VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT"),
    std::make_pair(1, "VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT"),
};
static void print_VkProvokingVertexModeEXT(VkProvokingVertexModeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkProvokingVertexModeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkProvokingVertexModeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkProvokingVertexModeEXT(const VkProvokingVertexModeEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkProvokingVertexModeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkProvokingVertexModeEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceProvokingVertexFeaturesEXT(VkPhysicalDeviceProvokingVertexFeaturesEXT obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.provokingVertexLast, "provokingVertexLast", 1);

    print_VkBool32(obj.transformFeedbackPreservesProvokingVertex, "transformFeedbackPreservesProvokingVertex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceProvokingVertexFeaturesEXT(const VkPhysicalDeviceProvokingVertexFeaturesEXT* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->provokingVertexLast, "provokingVertexLast", 1);

    print_VkBool32(obj->transformFeedbackPreservesProvokingVertex, "transformFeedbackPreservesProvokingVertex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceProvokingVertexPropertiesEXT(VkPhysicalDeviceProvokingVertexPropertiesEXT obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.provokingVertexModePerPipeline, "provokingVertexModePerPipeline", 1);

    print_VkBool32(obj.transformFeedbackPreservesTriangleFanProvokingVertex, "transformFeedbackPreservesTriangleFanProvokingVertex",
                   0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceProvokingVertexPropertiesEXT(const VkPhysicalDeviceProvokingVertexPropertiesEXT* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->provokingVertexModePerPipeline, "provokingVertexModePerPipeline", 1);

    print_VkBool32(obj->transformFeedbackPreservesTriangleFanProvokingVertex,
                   "transformFeedbackPreservesTriangleFanProvokingVertex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
    VkPipelineRasterizationProvokingVertexStateCreateInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkProvokingVertexModeEXT(obj.provokingVertexMode, "provokingVertexMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
    const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkProvokingVertexModeEXT(obj->provokingVertexMode, "provokingVertexMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkHeadlessSurfaceCreateFlagsEXT(VkHeadlessSurfaceCreateFlagsEXT obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkHeadlessSurfaceCreateInfoEXT(VkHeadlessSurfaceCreateInfoEXT obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkHeadlessSurfaceCreateFlagsEXT(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkHeadlessSurfaceCreateInfoEXT(const VkHeadlessSurfaceCreateInfoEXT* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkHeadlessSurfaceCreateFlagsEXT(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkLineRasterizationModeEXT_map = {
    std::make_pair(0, "VK_LINE_RASTERIZATION_MODE_DEFAULT"),
    std::make_pair(1, "VK_LINE_RASTERIZATION_MODE_RECTANGULAR"),
    std::make_pair(2, "VK_LINE_RASTERIZATION_MODE_BRESENHAM"),
    std::make_pair(3, "VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH"),
};
static void print_VkLineRasterizationModeEXT(VkLineRasterizationModeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLineRasterizationModeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLineRasterizationModeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkLineRasterizationModeEXT(const VkLineRasterizationModeEXT* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLineRasterizationModeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLineRasterizationModeEXT_map[*obj] << "\"" << std::endl;
}

typedef VkPhysicalDeviceLineRasterizationFeatures VkPhysicalDeviceLineRasterizationFeaturesEXT;

typedef VkPhysicalDeviceLineRasterizationProperties VkPhysicalDeviceLineRasterizationPropertiesEXT;

typedef VkPipelineRasterizationLineStateCreateInfo VkPipelineRasterizationLineStateCreateInfoEXT;

static void print_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderBufferFloat32Atomics, "shaderBufferFloat32Atomics", 1);

    print_VkBool32(obj.shaderBufferFloat32AtomicAdd, "shaderBufferFloat32AtomicAdd", 1);

    print_VkBool32(obj.shaderBufferFloat64Atomics, "shaderBufferFloat64Atomics", 1);

    print_VkBool32(obj.shaderBufferFloat64AtomicAdd, "shaderBufferFloat64AtomicAdd", 1);

    print_VkBool32(obj.shaderSharedFloat32Atomics, "shaderSharedFloat32Atomics", 1);

    print_VkBool32(obj.shaderSharedFloat32AtomicAdd, "shaderSharedFloat32AtomicAdd", 1);

    print_VkBool32(obj.shaderSharedFloat64Atomics, "shaderSharedFloat64Atomics", 1);

    print_VkBool32(obj.shaderSharedFloat64AtomicAdd, "shaderSharedFloat64AtomicAdd", 1);

    print_VkBool32(obj.shaderImageFloat32Atomics, "shaderImageFloat32Atomics", 1);

    print_VkBool32(obj.shaderImageFloat32AtomicAdd, "shaderImageFloat32AtomicAdd", 1);

    print_VkBool32(obj.sparseImageFloat32Atomics, "sparseImageFloat32Atomics", 1);

    print_VkBool32(obj.sparseImageFloat32AtomicAdd, "sparseImageFloat32AtomicAdd", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderBufferFloat32Atomics, "shaderBufferFloat32Atomics", 1);

    print_VkBool32(obj->shaderBufferFloat32AtomicAdd, "shaderBufferFloat32AtomicAdd", 1);

    print_VkBool32(obj->shaderBufferFloat64Atomics, "shaderBufferFloat64Atomics", 1);

    print_VkBool32(obj->shaderBufferFloat64AtomicAdd, "shaderBufferFloat64AtomicAdd", 1);

    print_VkBool32(obj->shaderSharedFloat32Atomics, "shaderSharedFloat32Atomics", 1);

    print_VkBool32(obj->shaderSharedFloat32AtomicAdd, "shaderSharedFloat32AtomicAdd", 1);

    print_VkBool32(obj->shaderSharedFloat64Atomics, "shaderSharedFloat64Atomics", 1);

    print_VkBool32(obj->shaderSharedFloat64AtomicAdd, "shaderSharedFloat64AtomicAdd", 1);

    print_VkBool32(obj->shaderImageFloat32Atomics, "shaderImageFloat32Atomics", 1);

    print_VkBool32(obj->shaderImageFloat32AtomicAdd, "shaderImageFloat32AtomicAdd", 1);

    print_VkBool32(obj->sparseImageFloat32Atomics, "sparseImageFloat32Atomics", 1);

    print_VkBool32(obj->sparseImageFloat32AtomicAdd, "sparseImageFloat32AtomicAdd", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceHostQueryResetFeatures VkPhysicalDeviceHostQueryResetFeaturesEXT;

typedef VkPhysicalDeviceIndexTypeUint8Features VkPhysicalDeviceIndexTypeUint8FeaturesEXT;

static void print_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.extendedDynamicState, "extendedDynamicState", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->extendedDynamicState, "extendedDynamicState", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkHostImageCopyFlagBits_map = {
    std::make_pair(1ULL << 0, "VK_HOST_IMAGE_COPY_MEMCPY"),
};
static void print_VkHostImageCopyFlagBits(VkHostImageCopyFlagBits obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkHostImageCopyFlagBits_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkHostImageCopyFlagBits_map[obj] << "\"" << std::endl;
}
static void print_VkHostImageCopyFlagBits(const VkHostImageCopyFlagBits* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkHostImageCopyFlagBits_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkHostImageCopyFlagBits_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkHostImageCopyFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_HOST_IMAGE_COPY_MEMCPY"),
};
static void print_VkHostImageCopyFlagBitsEXT(VkHostImageCopyFlagBitsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkHostImageCopyFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkHostImageCopyFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkHostImageCopyFlagBitsEXT(const VkHostImageCopyFlagBitsEXT* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkHostImageCopyFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkHostImageCopyFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkHostImageCopyFlags(VkHostImageCopyFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkHostImageCopyFlagBits_map[1ULL << i] << " | ";
            else
                _OUT << VkHostImageCopyFlagBits_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceHostImageCopyFeatures(VkPhysicalDeviceHostImageCopyFeatures obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.hostImageCopy, "hostImageCopy", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceHostImageCopyFeatures(const VkPhysicalDeviceHostImageCopyFeatures* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->hostImageCopy, "hostImageCopy", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceHostImageCopyFeatures VkPhysicalDeviceHostImageCopyFeaturesEXT;

static void print_VkPhysicalDeviceHostImageCopyProperties(VkPhysicalDeviceHostImageCopyProperties obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.copySrcLayoutCount, "copySrcLayoutCount", 1);

    PRINT_SPACE
    _OUT << "\"pCopySrcLayouts\":" << std::endl;
    PRINT_SPACE
    if (obj.pCopySrcLayouts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.copySrcLayoutCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.copySrcLayoutCount;
            print_VkImageLayout(obj.pCopySrcLayouts[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.copyDstLayoutCount, "copyDstLayoutCount", 1);

    PRINT_SPACE
    _OUT << "\"pCopyDstLayouts\":" << std::endl;
    PRINT_SPACE
    if (obj.pCopyDstLayouts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.copyDstLayoutCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.copyDstLayoutCount;
            print_VkImageLayout(obj.pCopyDstLayouts[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"optimalTilingLayoutUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj.optimalTilingLayoutUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkBool32(obj.identicalMemoryTypeRequirements, "identicalMemoryTypeRequirements", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceHostImageCopyProperties(const VkPhysicalDeviceHostImageCopyProperties* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->copySrcLayoutCount, "copySrcLayoutCount", 1);

    PRINT_SPACE
    _OUT << "\"pCopySrcLayouts\":" << std::endl;
    PRINT_SPACE
    if (obj->pCopySrcLayouts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->copySrcLayoutCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->copySrcLayoutCount;
            print_VkImageLayout(obj->pCopySrcLayouts[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->copyDstLayoutCount, "copyDstLayoutCount", 1);

    PRINT_SPACE
    _OUT << "\"pCopyDstLayouts\":" << std::endl;
    PRINT_SPACE
    if (obj->pCopyDstLayouts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->copyDstLayoutCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->copyDstLayoutCount;
            print_VkImageLayout(obj->pCopyDstLayouts[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"optimalTilingLayoutUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj->optimalTilingLayoutUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_VkBool32(obj->identicalMemoryTypeRequirements, "identicalMemoryTypeRequirements", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceHostImageCopyProperties VkPhysicalDeviceHostImageCopyPropertiesEXT;

static void print_VkMemoryToImageCopy(VkMemoryToImageCopy obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    print_uint32_t(obj.memoryRowLength, "memoryRowLength", 1);

    print_uint32_t(obj.memoryImageHeight, "memoryImageHeight", 1);

    PRINT_SPACE
    _OUT << "\"imageSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.imageSubresource, "imageSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"imageOffset\": " << std::endl;
    { print_VkOffset3D(obj.imageOffset, "imageOffset", 1); }

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent3D(obj.imageExtent, "imageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryToImageCopy(const VkMemoryToImageCopy* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    print_uint32_t(obj->memoryRowLength, "memoryRowLength", 1);

    print_uint32_t(obj->memoryImageHeight, "memoryImageHeight", 1);

    PRINT_SPACE
    _OUT << "\"imageSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->imageSubresource, "imageSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"imageOffset\": " << std::endl;
    { print_VkOffset3D(obj->imageOffset, "imageOffset", 1); }

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent3D(obj->imageExtent, "imageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkMemoryToImageCopy VkMemoryToImageCopyEXT;

static void print_VkImageToMemoryCopy(VkImageToMemoryCopy obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    print_uint32_t(obj.memoryRowLength, "memoryRowLength", 1);

    print_uint32_t(obj.memoryImageHeight, "memoryImageHeight", 1);

    PRINT_SPACE
    _OUT << "\"imageSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.imageSubresource, "imageSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"imageOffset\": " << std::endl;
    { print_VkOffset3D(obj.imageOffset, "imageOffset", 1); }

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent3D(obj.imageExtent, "imageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageToMemoryCopy(const VkImageToMemoryCopy* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    print_uint32_t(obj->memoryRowLength, "memoryRowLength", 1);

    print_uint32_t(obj->memoryImageHeight, "memoryImageHeight", 1);

    PRINT_SPACE
    _OUT << "\"imageSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->imageSubresource, "imageSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"imageOffset\": " << std::endl;
    { print_VkOffset3D(obj->imageOffset, "imageOffset", 1); }

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent3D(obj->imageExtent, "imageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkImageToMemoryCopy VkImageToMemoryCopyEXT;

static void print_VkCopyMemoryToImageInfo(VkCopyMemoryToImageInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkHostImageCopyFlags(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.dstImageLayout, "dstImageLayout", 1);

    print_uint32_t(obj.regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj.pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.regionCount; i++) {
            if (i + 1 == obj.regionCount)
                print_VkMemoryToImageCopy(obj.pRegions[i], "pRegions", 0);
            else
                print_VkMemoryToImageCopy(obj.pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyMemoryToImageInfo(const VkCopyMemoryToImageInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkHostImageCopyFlags(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->dstImageLayout, "dstImageLayout", 1);

    print_uint32_t(obj->regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj->pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->regionCount; i++) {
            if (i + 1 == obj->regionCount)
                print_VkMemoryToImageCopy(obj->pRegions[i], "pRegions", 0);
            else
                print_VkMemoryToImageCopy(obj->pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkCopyMemoryToImageInfo VkCopyMemoryToImageInfoEXT;

static void print_VkCopyImageToMemoryInfo(VkCopyImageToMemoryInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkHostImageCopyFlags(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.srcImageLayout, "srcImageLayout", 1);

    print_uint32_t(obj.regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj.pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.regionCount; i++) {
            if (i + 1 == obj.regionCount)
                print_VkImageToMemoryCopy(obj.pRegions[i], "pRegions", 0);
            else
                print_VkImageToMemoryCopy(obj.pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyImageToMemoryInfo(const VkCopyImageToMemoryInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkHostImageCopyFlags(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->srcImageLayout, "srcImageLayout", 1);

    print_uint32_t(obj->regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj->pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->regionCount; i++) {
            if (i + 1 == obj->regionCount)
                print_VkImageToMemoryCopy(obj->pRegions[i], "pRegions", 0);
            else
                print_VkImageToMemoryCopy(obj->pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkCopyImageToMemoryInfo VkCopyImageToMemoryInfoEXT;

static void print_VkCopyImageToImageInfo(VkCopyImageToImageInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkHostImageCopyFlags(obj.flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.srcImageLayout, "srcImageLayout", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.dstImageLayout, "dstImageLayout", 1);

    print_uint32_t(obj.regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj.pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.regionCount; i++) {
            if (i + 1 == obj.regionCount)
                print_VkImageCopy2(obj.pRegions[i], "pRegions", 0);
            else
                print_VkImageCopy2(obj.pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyImageToImageInfo(const VkCopyImageToImageInfo* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkHostImageCopyFlags(obj->flags, "flags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->srcImageLayout, "srcImageLayout", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstImage"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->dstImageLayout, "dstImageLayout", 1);

    print_uint32_t(obj->regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj->pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->regionCount; i++) {
            if (i + 1 == obj->regionCount)
                print_VkImageCopy2(obj->pRegions[i], "pRegions", 0);
            else
                print_VkImageCopy2(obj->pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkCopyImageToImageInfo VkCopyImageToImageInfoEXT;

static void print_VkHostImageLayoutTransitionInfo(VkHostImageLayoutTransitionInfo obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj.oldLayout, "oldLayout", 1);

    print_VkImageLayout(obj.newLayout, "newLayout", 1);

    PRINT_SPACE
    _OUT << "\"subresourceRange\": " << std::endl;
    { print_VkImageSubresourceRange(obj.subresourceRange, "subresourceRange", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkHostImageLayoutTransitionInfo(const VkHostImageLayoutTransitionInfo* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkImageLayout(obj->oldLayout, "oldLayout", 1);

    print_VkImageLayout(obj->newLayout, "newLayout", 1);

    PRINT_SPACE
    _OUT << "\"subresourceRange\": " << std::endl;
    { print_VkImageSubresourceRange(obj->subresourceRange, "subresourceRange", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkHostImageLayoutTransitionInfo VkHostImageLayoutTransitionInfoEXT;

static void print_VkSubresourceHostMemcpySize(VkSubresourceHostMemcpySize obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj.size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubresourceHostMemcpySize(const VkSubresourceHostMemcpySize* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj->size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkSubresourceHostMemcpySize VkSubresourceHostMemcpySizeEXT;

static void print_VkHostImageCopyDevicePerformanceQuery(VkHostImageCopyDevicePerformanceQuery obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.optimalDeviceAccess, "optimalDeviceAccess", 1);

    print_VkBool32(obj.identicalMemoryLayout, "identicalMemoryLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkHostImageCopyDevicePerformanceQuery(const VkHostImageCopyDevicePerformanceQuery* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->optimalDeviceAccess, "optimalDeviceAccess", 1);

    print_VkBool32(obj->identicalMemoryLayout, "identicalMemoryLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkHostImageCopyDevicePerformanceQuery VkHostImageCopyDevicePerformanceQueryEXT;

typedef VkSubresourceLayout2 VkSubresourceLayout2EXT;

typedef VkImageSubresource2 VkImageSubresource2EXT;

static void print_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(VkPhysicalDeviceMapMemoryPlacedFeaturesEXT obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.memoryMapPlaced, "memoryMapPlaced", 1);

    print_VkBool32(obj.memoryMapRangePlaced, "memoryMapRangePlaced", 1);

    print_VkBool32(obj.memoryUnmapReserve, "memoryUnmapReserve", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->memoryMapPlaced, "memoryMapPlaced", 1);

    print_VkBool32(obj->memoryMapRangePlaced, "memoryMapRangePlaced", 1);

    print_VkBool32(obj->memoryUnmapReserve, "memoryUnmapReserve", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(VkPhysicalDeviceMapMemoryPlacedPropertiesEXT obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj.minPlacedMemoryMapAlignment, "minPlacedMemoryMapAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(const VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj->minPlacedMemoryMapAlignment, "minPlacedMemoryMapAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryMapPlacedInfoEXT(VkMemoryMapPlacedInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryMapPlacedInfoEXT(const VkMemoryMapPlacedInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderBufferFloat16Atomics, "shaderBufferFloat16Atomics", 1);

    print_VkBool32(obj.shaderBufferFloat16AtomicAdd, "shaderBufferFloat16AtomicAdd", 1);

    print_VkBool32(obj.shaderBufferFloat16AtomicMinMax, "shaderBufferFloat16AtomicMinMax", 1);

    print_VkBool32(obj.shaderBufferFloat32AtomicMinMax, "shaderBufferFloat32AtomicMinMax", 1);

    print_VkBool32(obj.shaderBufferFloat64AtomicMinMax, "shaderBufferFloat64AtomicMinMax", 1);

    print_VkBool32(obj.shaderSharedFloat16Atomics, "shaderSharedFloat16Atomics", 1);

    print_VkBool32(obj.shaderSharedFloat16AtomicAdd, "shaderSharedFloat16AtomicAdd", 1);

    print_VkBool32(obj.shaderSharedFloat16AtomicMinMax, "shaderSharedFloat16AtomicMinMax", 1);

    print_VkBool32(obj.shaderSharedFloat32AtomicMinMax, "shaderSharedFloat32AtomicMinMax", 1);

    print_VkBool32(obj.shaderSharedFloat64AtomicMinMax, "shaderSharedFloat64AtomicMinMax", 1);

    print_VkBool32(obj.shaderImageFloat32AtomicMinMax, "shaderImageFloat32AtomicMinMax", 1);

    print_VkBool32(obj.sparseImageFloat32AtomicMinMax, "sparseImageFloat32AtomicMinMax", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderBufferFloat16Atomics, "shaderBufferFloat16Atomics", 1);

    print_VkBool32(obj->shaderBufferFloat16AtomicAdd, "shaderBufferFloat16AtomicAdd", 1);

    print_VkBool32(obj->shaderBufferFloat16AtomicMinMax, "shaderBufferFloat16AtomicMinMax", 1);

    print_VkBool32(obj->shaderBufferFloat32AtomicMinMax, "shaderBufferFloat32AtomicMinMax", 1);

    print_VkBool32(obj->shaderBufferFloat64AtomicMinMax, "shaderBufferFloat64AtomicMinMax", 1);

    print_VkBool32(obj->shaderSharedFloat16Atomics, "shaderSharedFloat16Atomics", 1);

    print_VkBool32(obj->shaderSharedFloat16AtomicAdd, "shaderSharedFloat16AtomicAdd", 1);

    print_VkBool32(obj->shaderSharedFloat16AtomicMinMax, "shaderSharedFloat16AtomicMinMax", 1);

    print_VkBool32(obj->shaderSharedFloat32AtomicMinMax, "shaderSharedFloat32AtomicMinMax", 1);

    print_VkBool32(obj->shaderSharedFloat64AtomicMinMax, "shaderSharedFloat64AtomicMinMax", 1);

    print_VkBool32(obj->shaderImageFloat32AtomicMinMax, "shaderImageFloat32AtomicMinMax", 1);

    print_VkBool32(obj->sparseImageFloat32AtomicMinMax, "sparseImageFloat32AtomicMinMax", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkPresentScalingFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT"),
    std::make_pair(1ULL << 1, "VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT"),
    std::make_pair(1ULL << 2, "VK_PRESENT_SCALING_STRETCH_BIT_EXT"),
};
static void print_VkPresentScalingFlagBitsEXT(VkPresentScalingFlagBitsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPresentScalingFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPresentScalingFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkPresentScalingFlagBitsEXT(const VkPresentScalingFlagBitsEXT* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPresentScalingFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPresentScalingFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPresentGravityFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_PRESENT_GRAVITY_MIN_BIT_EXT"),
    std::make_pair(1ULL << 1, "VK_PRESENT_GRAVITY_MAX_BIT_EXT"),
    std::make_pair(1ULL << 2, "VK_PRESENT_GRAVITY_CENTERED_BIT_EXT"),
};
static void print_VkPresentGravityFlagBitsEXT(VkPresentGravityFlagBitsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPresentGravityFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPresentGravityFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkPresentGravityFlagBitsEXT(const VkPresentGravityFlagBitsEXT* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPresentGravityFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPresentGravityFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkPresentScalingFlagsEXT(VkPresentScalingFlagsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPresentScalingFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkPresentScalingFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPresentGravityFlagsEXT(VkPresentGravityFlagsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPresentGravityFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkPresentGravityFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkSurfacePresentModeEXT(VkSurfacePresentModeEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPresentModeKHR(obj.presentMode, "presentMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSurfacePresentModeEXT(const VkSurfacePresentModeEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPresentModeKHR(obj->presentMode, "presentMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSurfacePresentScalingCapabilitiesEXT(VkSurfacePresentScalingCapabilitiesEXT obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPresentScalingFlagsEXT(obj.supportedPresentScaling, "supportedPresentScaling", 1);

    print_VkPresentGravityFlagsEXT(obj.supportedPresentGravityX, "supportedPresentGravityX", 1);

    print_VkPresentGravityFlagsEXT(obj.supportedPresentGravityY, "supportedPresentGravityY", 1);

    PRINT_SPACE
    _OUT << "\"minScaledImageExtent\": " << std::endl;
    { print_VkExtent2D(obj.minScaledImageExtent, "minScaledImageExtent", 1); }

    PRINT_SPACE
    _OUT << "\"maxScaledImageExtent\": " << std::endl;
    { print_VkExtent2D(obj.maxScaledImageExtent, "maxScaledImageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSurfacePresentScalingCapabilitiesEXT(const VkSurfacePresentScalingCapabilitiesEXT* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPresentScalingFlagsEXT(obj->supportedPresentScaling, "supportedPresentScaling", 1);

    print_VkPresentGravityFlagsEXT(obj->supportedPresentGravityX, "supportedPresentGravityX", 1);

    print_VkPresentGravityFlagsEXT(obj->supportedPresentGravityY, "supportedPresentGravityY", 1);

    PRINT_SPACE
    _OUT << "\"minScaledImageExtent\": " << std::endl;
    { print_VkExtent2D(obj->minScaledImageExtent, "minScaledImageExtent", 1); }

    PRINT_SPACE
    _OUT << "\"maxScaledImageExtent\": " << std::endl;
    { print_VkExtent2D(obj->maxScaledImageExtent, "maxScaledImageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSurfacePresentModeCompatibilityEXT(VkSurfacePresentModeCompatibilityEXT obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.presentModeCount, "presentModeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPresentModes\":" << std::endl;
    PRINT_SPACE
    if (obj.pPresentModes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.presentModeCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.presentModeCount;
            print_VkPresentModeKHR(obj.pPresentModes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSurfacePresentModeCompatibilityEXT(const VkSurfacePresentModeCompatibilityEXT* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->presentModeCount, "presentModeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPresentModes\":" << std::endl;
    PRINT_SPACE
    if (obj->pPresentModes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->presentModeCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->presentModeCount;
            print_VkPresentModeKHR(obj->pPresentModes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.swapchainMaintenance1, "swapchainMaintenance1", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->swapchainMaintenance1, "swapchainMaintenance1", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSwapchainPresentFenceInfoEXT(VkSwapchainPresentFenceInfoEXT obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pFences\":" << std::endl;
    PRINT_SPACE
    if (obj.pFences) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.swapchainCount; i++) {
            std::stringstream tmp;
            tmp << "pFences"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.swapchainCount;
            print_VkFence(obj.pFences[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSwapchainPresentFenceInfoEXT(const VkSwapchainPresentFenceInfoEXT* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pFences\":" << std::endl;
    PRINT_SPACE
    if (obj->pFences) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->swapchainCount; i++) {
            std::stringstream tmp;
            tmp << "pFences"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->swapchainCount;
            print_VkFence(obj->pFences[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSwapchainPresentModesCreateInfoEXT(VkSwapchainPresentModesCreateInfoEXT obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.presentModeCount, "presentModeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPresentModes\":" << std::endl;
    PRINT_SPACE
    if (obj.pPresentModes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.presentModeCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.presentModeCount;
            print_VkPresentModeKHR(obj.pPresentModes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSwapchainPresentModesCreateInfoEXT(const VkSwapchainPresentModesCreateInfoEXT* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->presentModeCount, "presentModeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPresentModes\":" << std::endl;
    PRINT_SPACE
    if (obj->pPresentModes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->presentModeCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->presentModeCount;
            print_VkPresentModeKHR(obj->pPresentModes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSwapchainPresentModeInfoEXT(VkSwapchainPresentModeInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pPresentModes\":" << std::endl;
    PRINT_SPACE
    if (obj.pPresentModes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.swapchainCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.swapchainCount;
            print_VkPresentModeKHR(obj.pPresentModes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSwapchainPresentModeInfoEXT(const VkSwapchainPresentModeInfoEXT* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->swapchainCount, "swapchainCount", 1);

    PRINT_SPACE
    _OUT << "\"pPresentModes\":" << std::endl;
    PRINT_SPACE
    if (obj->pPresentModes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->swapchainCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->swapchainCount;
            print_VkPresentModeKHR(obj->pPresentModes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSwapchainPresentScalingCreateInfoEXT(VkSwapchainPresentScalingCreateInfoEXT obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPresentScalingFlagsEXT(obj.scalingBehavior, "scalingBehavior", 1);

    print_VkPresentGravityFlagsEXT(obj.presentGravityX, "presentGravityX", 1);

    print_VkPresentGravityFlagsEXT(obj.presentGravityY, "presentGravityY", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSwapchainPresentScalingCreateInfoEXT(const VkSwapchainPresentScalingCreateInfoEXT* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPresentScalingFlagsEXT(obj->scalingBehavior, "scalingBehavior", 1);

    print_VkPresentGravityFlagsEXT(obj->presentGravityX, "presentGravityX", 1);

    print_VkPresentGravityFlagsEXT(obj->presentGravityY, "presentGravityY", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkReleaseSwapchainImagesInfoEXT(VkReleaseSwapchainImagesInfoEXT obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "swapchain"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.imageIndexCount, "imageIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pImageIndices\":" << std::endl;
    PRINT_SPACE
    if (obj.pImageIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.imageIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.imageIndexCount;
            print_uint32_t(obj.pImageIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkReleaseSwapchainImagesInfoEXT(const VkReleaseSwapchainImagesInfoEXT* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "swapchain"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->imageIndexCount, "imageIndexCount", 1);

    PRINT_SPACE
    _OUT << "\"pImageIndices\":" << std::endl;
    PRINT_SPACE
    if (obj->pImageIndices) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->imageIndexCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->imageIndexCount;
            print_uint32_t(obj->pImageIndices[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures obj,
                                                                         const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderDemoteToHelperInvocation, "shaderDemoteToHelperInvocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(
    const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderDemoteToHelperInvocation, "shaderDemoteToHelperInvocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;

static void print_VkIndirectCommandsLayoutNV(VkIndirectCommandsLayoutNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkIndirectStateFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV"),
};
static void print_VkIndirectStateFlagBitsNV(VkIndirectStateFlagBitsNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectStateFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectStateFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkIndirectStateFlagBitsNV(const VkIndirectStateFlagBitsNV* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectStateFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectStateFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkIndirectCommandsTokenTypeNV_map = {
    std::make_pair(0, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV"),
    std::make_pair(1, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV"),
    std::make_pair(2, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV"),
    std::make_pair(3, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV"),
    std::make_pair(4, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV"),
    std::make_pair(5, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV"),
    std::make_pair(6, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV"),
    std::make_pair(7, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV"),
    std::make_pair(1000328000, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV"),
    std::make_pair(1000428003, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV"),
    std::make_pair(1000428004, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV"),
};
static void print_VkIndirectCommandsTokenTypeNV(VkIndirectCommandsTokenTypeNV obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectCommandsTokenTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectCommandsTokenTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkIndirectCommandsTokenTypeNV(const VkIndirectCommandsTokenTypeNV* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectCommandsTokenTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectCommandsTokenTypeNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkIndirectCommandsLayoutUsageFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV"),
    std::make_pair(1ULL << 1, "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV"),
    std::make_pair(1ULL << 2, "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV"),
};
static void print_VkIndirectCommandsLayoutUsageFlagBitsNV(VkIndirectCommandsLayoutUsageFlagBitsNV obj, const std::string& str,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectCommandsLayoutUsageFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectCommandsLayoutUsageFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkIndirectCommandsLayoutUsageFlagBitsNV(const VkIndirectCommandsLayoutUsageFlagBitsNV* obj,
                                                          const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectCommandsLayoutUsageFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectCommandsLayoutUsageFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static void print_VkIndirectStateFlagsNV(VkIndirectStateFlagsNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkIndirectStateFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkIndirectStateFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkIndirectCommandsLayoutUsageFlagsNV(VkIndirectCommandsLayoutUsageFlagsNV obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkIndirectCommandsLayoutUsageFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkIndirectCommandsLayoutUsageFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxGraphicsShaderGroupCount, "maxGraphicsShaderGroupCount", 1);

    print_uint32_t(obj.maxIndirectSequenceCount, "maxIndirectSequenceCount", 1);

    print_uint32_t(obj.maxIndirectCommandsTokenCount, "maxIndirectCommandsTokenCount", 1);

    print_uint32_t(obj.maxIndirectCommandsStreamCount, "maxIndirectCommandsStreamCount", 1);

    print_uint32_t(obj.maxIndirectCommandsTokenOffset, "maxIndirectCommandsTokenOffset", 1);

    print_uint32_t(obj.maxIndirectCommandsStreamStride, "maxIndirectCommandsStreamStride", 1);

    print_uint32_t(obj.minSequencesCountBufferOffsetAlignment, "minSequencesCountBufferOffsetAlignment", 1);

    print_uint32_t(obj.minSequencesIndexBufferOffsetAlignment, "minSequencesIndexBufferOffsetAlignment", 1);

    print_uint32_t(obj.minIndirectCommandsBufferOffsetAlignment, "minIndirectCommandsBufferOffsetAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
    const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxGraphicsShaderGroupCount, "maxGraphicsShaderGroupCount", 1);

    print_uint32_t(obj->maxIndirectSequenceCount, "maxIndirectSequenceCount", 1);

    print_uint32_t(obj->maxIndirectCommandsTokenCount, "maxIndirectCommandsTokenCount", 1);

    print_uint32_t(obj->maxIndirectCommandsStreamCount, "maxIndirectCommandsStreamCount", 1);

    print_uint32_t(obj->maxIndirectCommandsTokenOffset, "maxIndirectCommandsTokenOffset", 1);

    print_uint32_t(obj->maxIndirectCommandsStreamStride, "maxIndirectCommandsStreamStride", 1);

    print_uint32_t(obj->minSequencesCountBufferOffsetAlignment, "minSequencesCountBufferOffsetAlignment", 1);

    print_uint32_t(obj->minSequencesIndexBufferOffsetAlignment, "minSequencesIndexBufferOffsetAlignment", 1);

    print_uint32_t(obj->minIndirectCommandsBufferOffsetAlignment, "minIndirectCommandsBufferOffsetAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.deviceGeneratedCommands, "deviceGeneratedCommands", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->deviceGeneratedCommands, "deviceGeneratedCommands", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGraphicsShaderGroupCreateInfoNV(VkGraphicsShaderGroupCreateInfoNV obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.stageCount, "stageCount", 1);

    PRINT_SPACE
    _OUT << "\"pStages\": " << std::endl;
    if (obj.pStages) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stageCount; i++) {
            if (i + 1 == obj.stageCount)
                print_VkPipelineShaderStageCreateInfo(obj.pStages[i], "pStages", 0);
            else
                print_VkPipelineShaderStageCreateInfo(obj.pStages[i], "pStages", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pVertexInputState\": " << std::endl;
    if (obj.pVertexInputState) {
        print_VkPipelineVertexInputStateCreateInfo(obj.pVertexInputState, "pVertexInputState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pTessellationState\": " << std::endl;
    if (obj.pTessellationState) {
        print_VkPipelineTessellationStateCreateInfo(obj.pTessellationState, "pTessellationState", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGraphicsShaderGroupCreateInfoNV(const VkGraphicsShaderGroupCreateInfoNV* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->stageCount, "stageCount", 1);

    PRINT_SPACE
    _OUT << "\"pStages\": " << std::endl;
    if (obj->pStages) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stageCount; i++) {
            if (i + 1 == obj->stageCount)
                print_VkPipelineShaderStageCreateInfo(obj->pStages[i], "pStages", 0);
            else
                print_VkPipelineShaderStageCreateInfo(obj->pStages[i], "pStages", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pVertexInputState\": " << std::endl;
    if (obj->pVertexInputState) {
        print_VkPipelineVertexInputStateCreateInfo(obj->pVertexInputState, "pVertexInputState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pTessellationState\": " << std::endl;
    if (obj->pTessellationState) {
        print_VkPipelineTessellationStateCreateInfo(obj->pTessellationState, "pTessellationState", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGraphicsPipelineShaderGroupsCreateInfoNV(VkGraphicsPipelineShaderGroupsCreateInfoNV obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.groupCount, "groupCount", 1);

    PRINT_SPACE
    _OUT << "\"pGroups\": " << std::endl;
    if (obj.pGroups) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.groupCount; i++) {
            if (i + 1 == obj.groupCount)
                print_VkGraphicsShaderGroupCreateInfoNV(obj.pGroups[i], "pGroups", 0);
            else
                print_VkGraphicsShaderGroupCreateInfoNV(obj.pGroups[i], "pGroups", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.pipelineCount, "pipelineCount", 1);

    PRINT_SPACE
    _OUT << "\"pPipelines\":" << std::endl;
    PRINT_SPACE
    if (obj.pPipelines) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.pipelineCount; i++) {
            std::stringstream tmp;
            tmp << "pPipelines"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.pipelineCount;
            print_VkPipeline(obj.pPipelines[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGraphicsPipelineShaderGroupsCreateInfoNV(const VkGraphicsPipelineShaderGroupsCreateInfoNV* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->groupCount, "groupCount", 1);

    PRINT_SPACE
    _OUT << "\"pGroups\": " << std::endl;
    if (obj->pGroups) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->groupCount; i++) {
            if (i + 1 == obj->groupCount)
                print_VkGraphicsShaderGroupCreateInfoNV(obj->pGroups[i], "pGroups", 0);
            else
                print_VkGraphicsShaderGroupCreateInfoNV(obj->pGroups[i], "pGroups", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->pipelineCount, "pipelineCount", 1);

    PRINT_SPACE
    _OUT << "\"pPipelines\":" << std::endl;
    PRINT_SPACE
    if (obj->pPipelines) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->pipelineCount; i++) {
            std::stringstream tmp;
            tmp << "pPipelines"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->pipelineCount;
            print_VkPipeline(obj->pPipelines[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindShaderGroupIndirectCommandNV(VkBindShaderGroupIndirectCommandNV obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.groupIndex, "groupIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindShaderGroupIndirectCommandNV(const VkBindShaderGroupIndirectCommandNV* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->groupIndex, "groupIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindIndexBufferIndirectCommandNV(VkBindIndexBufferIndirectCommandNV obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.bufferAddress, "bufferAddress", 1);

    print_uint32_t(obj.size, "size", 1);

    print_VkIndexType(obj.indexType, "indexType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindIndexBufferIndirectCommandNV(const VkBindIndexBufferIndirectCommandNV* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->bufferAddress, "bufferAddress", 1);

    print_uint32_t(obj->size, "size", 1);

    print_VkIndexType(obj->indexType, "indexType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindVertexBufferIndirectCommandNV(VkBindVertexBufferIndirectCommandNV obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.bufferAddress, "bufferAddress", 1);

    print_uint32_t(obj.size, "size", 1);

    print_uint32_t(obj.stride, "stride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindVertexBufferIndirectCommandNV(const VkBindVertexBufferIndirectCommandNV* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->bufferAddress, "bufferAddress", 1);

    print_uint32_t(obj->size, "size", 1);

    print_uint32_t(obj->stride, "stride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSetStateFlagsIndirectCommandNV(VkSetStateFlagsIndirectCommandNV obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.data, "data", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSetStateFlagsIndirectCommandNV(const VkSetStateFlagsIndirectCommandNV* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->data, "data", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectCommandsStreamNV(VkIndirectCommandsStreamNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.offset, "offset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectCommandsStreamNV(const VkIndirectCommandsStreamNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->offset, "offset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectCommandsLayoutTokenNV(VkIndirectCommandsLayoutTokenNV obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkIndirectCommandsTokenTypeNV(obj.tokenType, "tokenType", 1);

    print_uint32_t(obj.stream, "stream", 1);

    print_uint32_t(obj.offset, "offset", 1);

    print_uint32_t(obj.vertexBindingUnit, "vertexBindingUnit", 1);

    print_VkBool32(obj.vertexDynamicStride, "vertexDynamicStride", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pushconstantPipelineLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkShaderStageFlags(obj.pushconstantShaderStageFlags, "pushconstantShaderStageFlags", 1);

    print_uint32_t(obj.pushconstantOffset, "pushconstantOffset", 1);

    print_uint32_t(obj.pushconstantSize, "pushconstantSize", 1);

    print_VkIndirectStateFlagsNV(obj.indirectStateFlags, "indirectStateFlags", 1);

    print_uint32_t(obj.indexTypeCount, "indexTypeCount", 1);

    PRINT_SPACE
    _OUT << "\"pIndexTypes\":" << std::endl;
    PRINT_SPACE
    if (obj.pIndexTypes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.indexTypeCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.indexTypeCount;
            print_VkIndexType(obj.pIndexTypes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pIndexTypeValues\":" << std::endl;
    PRINT_SPACE
    if (obj.pIndexTypeValues) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.indexTypeCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.indexTypeCount;
            print_uint32_t(obj.pIndexTypeValues[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectCommandsLayoutTokenNV(const VkIndirectCommandsLayoutTokenNV* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkIndirectCommandsTokenTypeNV(obj->tokenType, "tokenType", 1);

    print_uint32_t(obj->stream, "stream", 1);

    print_uint32_t(obj->offset, "offset", 1);

    print_uint32_t(obj->vertexBindingUnit, "vertexBindingUnit", 1);

    print_VkBool32(obj->vertexDynamicStride, "vertexDynamicStride", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pushconstantPipelineLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkShaderStageFlags(obj->pushconstantShaderStageFlags, "pushconstantShaderStageFlags", 1);

    print_uint32_t(obj->pushconstantOffset, "pushconstantOffset", 1);

    print_uint32_t(obj->pushconstantSize, "pushconstantSize", 1);

    print_VkIndirectStateFlagsNV(obj->indirectStateFlags, "indirectStateFlags", 1);

    print_uint32_t(obj->indexTypeCount, "indexTypeCount", 1);

    PRINT_SPACE
    _OUT << "\"pIndexTypes\":" << std::endl;
    PRINT_SPACE
    if (obj->pIndexTypes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->indexTypeCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->indexTypeCount;
            print_VkIndexType(obj->pIndexTypes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pIndexTypeValues\":" << std::endl;
    PRINT_SPACE
    if (obj->pIndexTypeValues) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->indexTypeCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->indexTypeCount;
            print_uint32_t(obj->pIndexTypeValues[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectCommandsLayoutCreateInfoNV(VkIndirectCommandsLayoutCreateInfoNV obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkIndirectCommandsLayoutUsageFlagsNV(obj.flags, "flags", 1);

    print_VkPipelineBindPoint(obj.pipelineBindPoint, "pipelineBindPoint", 1);

    print_uint32_t(obj.tokenCount, "tokenCount", 1);

    PRINT_SPACE
    _OUT << "\"pTokens\": " << std::endl;
    if (obj.pTokens) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.tokenCount; i++) {
            if (i + 1 == obj.tokenCount)
                print_VkIndirectCommandsLayoutTokenNV(obj.pTokens[i], "pTokens", 0);
            else
                print_VkIndirectCommandsLayoutTokenNV(obj.pTokens[i], "pTokens", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.streamCount, "streamCount", 1);

    PRINT_SPACE
    _OUT << "\"pStreamStrides\":" << std::endl;
    PRINT_SPACE
    if (obj.pStreamStrides) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.streamCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.streamCount;
            print_uint32_t(obj.pStreamStrides[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectCommandsLayoutCreateInfoNV(const VkIndirectCommandsLayoutCreateInfoNV* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkIndirectCommandsLayoutUsageFlagsNV(obj->flags, "flags", 1);

    print_VkPipelineBindPoint(obj->pipelineBindPoint, "pipelineBindPoint", 1);

    print_uint32_t(obj->tokenCount, "tokenCount", 1);

    PRINT_SPACE
    _OUT << "\"pTokens\": " << std::endl;
    if (obj->pTokens) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->tokenCount; i++) {
            if (i + 1 == obj->tokenCount)
                print_VkIndirectCommandsLayoutTokenNV(obj->pTokens[i], "pTokens", 0);
            else
                print_VkIndirectCommandsLayoutTokenNV(obj->pTokens[i], "pTokens", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->streamCount, "streamCount", 1);

    PRINT_SPACE
    _OUT << "\"pStreamStrides\":" << std::endl;
    PRINT_SPACE
    if (obj->pStreamStrides) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->streamCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->streamCount;
            print_uint32_t(obj->pStreamStrides[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGeneratedCommandsInfoNV(VkGeneratedCommandsInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineBindPoint(obj.pipelineBindPoint, "pipelineBindPoint", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indirectCommandsLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.streamCount, "streamCount", 1);

    PRINT_SPACE
    _OUT << "\"pStreams\": " << std::endl;
    if (obj.pStreams) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.streamCount; i++) {
            if (i + 1 == obj.streamCount)
                print_VkIndirectCommandsStreamNV(obj.pStreams[i], "pStreams", 0);
            else
                print_VkIndirectCommandsStreamNV(obj.pStreams[i], "pStreams", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.sequencesCount, "sequencesCount", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "preprocessBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.preprocessOffset, "preprocessOffset", 1);

    print_VkDeviceSize(obj.preprocessSize, "preprocessSize", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "sequencesCountBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.sequencesCountOffset, "sequencesCountOffset", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "sequencesIndexBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.sequencesIndexOffset, "sequencesIndexOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGeneratedCommandsInfoNV(const VkGeneratedCommandsInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineBindPoint(obj->pipelineBindPoint, "pipelineBindPoint", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indirectCommandsLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->streamCount, "streamCount", 1);

    PRINT_SPACE
    _OUT << "\"pStreams\": " << std::endl;
    if (obj->pStreams) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->streamCount; i++) {
            if (i + 1 == obj->streamCount)
                print_VkIndirectCommandsStreamNV(obj->pStreams[i], "pStreams", 0);
            else
                print_VkIndirectCommandsStreamNV(obj->pStreams[i], "pStreams", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->sequencesCount, "sequencesCount", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "preprocessBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->preprocessOffset, "preprocessOffset", 1);

    print_VkDeviceSize(obj->preprocessSize, "preprocessSize", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "sequencesCountBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->sequencesCountOffset, "sequencesCountOffset", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "sequencesIndexBuffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->sequencesIndexOffset, "sequencesIndexOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGeneratedCommandsMemoryRequirementsInfoNV(VkGeneratedCommandsMemoryRequirementsInfoNV obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineBindPoint(obj.pipelineBindPoint, "pipelineBindPoint", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indirectCommandsLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.maxSequencesCount, "maxSequencesCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGeneratedCommandsMemoryRequirementsInfoNV(const VkGeneratedCommandsMemoryRequirementsInfoNV* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineBindPoint(obj->pipelineBindPoint, "pipelineBindPoint", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indirectCommandsLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->maxSequencesCount, "maxSequencesCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceInheritedViewportScissorFeaturesNV(VkPhysicalDeviceInheritedViewportScissorFeaturesNV obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.inheritedViewportScissor2D, "inheritedViewportScissor2D", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceInheritedViewportScissorFeaturesNV(const VkPhysicalDeviceInheritedViewportScissorFeaturesNV* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->inheritedViewportScissor2D, "inheritedViewportScissor2D", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCommandBufferInheritanceViewportScissorInfoNV(VkCommandBufferInheritanceViewportScissorInfoNV obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.viewportScissor2D, "viewportScissor2D", 1);

    print_uint32_t(obj.viewportDepthCount, "viewportDepthCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewportDepths\": " << std::endl;
    if (obj.pViewportDepths) {
        print_VkViewport(obj.pViewportDepths, "pViewportDepths", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCommandBufferInheritanceViewportScissorInfoNV(const VkCommandBufferInheritanceViewportScissorInfoNV* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->viewportScissor2D, "viewportScissor2D", 1);

    print_uint32_t(obj->viewportDepthCount, "viewportDepthCount", 1);

    PRINT_SPACE
    _OUT << "\"pViewportDepths\": " << std::endl;
    if (obj->pViewportDepths) {
        print_VkViewport(obj->pViewportDepths, "pViewportDepths", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.texelBufferAlignment, "texelBufferAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->texelBufferAlignment, "texelBufferAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceTexelBufferAlignmentProperties(VkPhysicalDeviceTexelBufferAlignmentProperties obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj.storageTexelBufferOffsetAlignmentBytes, "storageTexelBufferOffsetAlignmentBytes", 1);

    print_VkBool32(obj.storageTexelBufferOffsetSingleTexelAlignment, "storageTexelBufferOffsetSingleTexelAlignment", 1);

    print_VkDeviceSize(obj.uniformTexelBufferOffsetAlignmentBytes, "uniformTexelBufferOffsetAlignmentBytes", 1);

    print_VkBool32(obj.uniformTexelBufferOffsetSingleTexelAlignment, "uniformTexelBufferOffsetSingleTexelAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceTexelBufferAlignmentProperties(const VkPhysicalDeviceTexelBufferAlignmentProperties* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj->storageTexelBufferOffsetAlignmentBytes, "storageTexelBufferOffsetAlignmentBytes", 1);

    print_VkBool32(obj->storageTexelBufferOffsetSingleTexelAlignment, "storageTexelBufferOffsetSingleTexelAlignment", 1);

    print_VkDeviceSize(obj->uniformTexelBufferOffsetAlignmentBytes, "uniformTexelBufferOffsetAlignmentBytes", 1);

    print_VkBool32(obj->uniformTexelBufferOffsetSingleTexelAlignment, "uniformTexelBufferOffsetSingleTexelAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceTexelBufferAlignmentProperties VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT;

static void print_VkRenderPassTransformBeginInfoQCOM(VkRenderPassTransformBeginInfoQCOM obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSurfaceTransformFlagBitsKHR(obj.transform, "transform", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassTransformBeginInfoQCOM(const VkRenderPassTransformBeginInfoQCOM* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSurfaceTransformFlagBitsKHR(obj->transform, "transform", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(VkCommandBufferInheritanceRenderPassTransformInfoQCOM obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSurfaceTransformFlagBitsKHR(obj.transform, "transform", 1);

    PRINT_SPACE
    _OUT << "\"renderArea\": " << std::endl;
    { print_VkRect2D(obj.renderArea, "renderArea", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
    const VkCommandBufferInheritanceRenderPassTransformInfoQCOM* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSurfaceTransformFlagBitsKHR(obj->transform, "transform", 1);

    PRINT_SPACE
    _OUT << "\"renderArea\": " << std::endl;
    { print_VkRect2D(obj->renderArea, "renderArea", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkDepthBiasRepresentationEXT_map = {
    std::make_pair(0, "VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT"),
    std::make_pair(1, "VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT"),
    std::make_pair(2, "VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT"),
};
static void print_VkDepthBiasRepresentationEXT(VkDepthBiasRepresentationEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDepthBiasRepresentationEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDepthBiasRepresentationEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDepthBiasRepresentationEXT(const VkDepthBiasRepresentationEXT* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDepthBiasRepresentationEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDepthBiasRepresentationEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceDepthBiasControlFeaturesEXT(VkPhysicalDeviceDepthBiasControlFeaturesEXT obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.depthBiasControl, "depthBiasControl", 1);

    print_VkBool32(obj.leastRepresentableValueForceUnormRepresentation, "leastRepresentableValueForceUnormRepresentation", 1);

    print_VkBool32(obj.floatRepresentation, "floatRepresentation", 1);

    print_VkBool32(obj.depthBiasExact, "depthBiasExact", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDepthBiasControlFeaturesEXT(const VkPhysicalDeviceDepthBiasControlFeaturesEXT* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->depthBiasControl, "depthBiasControl", 1);

    print_VkBool32(obj->leastRepresentableValueForceUnormRepresentation, "leastRepresentableValueForceUnormRepresentation", 1);

    print_VkBool32(obj->floatRepresentation, "floatRepresentation", 1);

    print_VkBool32(obj->depthBiasExact, "depthBiasExact", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDepthBiasInfoEXT(VkDepthBiasInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_float(obj.depthBiasConstantFactor, "depthBiasConstantFactor", 1);

    print_float(obj.depthBiasClamp, "depthBiasClamp", 1);

    print_float(obj.depthBiasSlopeFactor, "depthBiasSlopeFactor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDepthBiasInfoEXT(const VkDepthBiasInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_float(obj->depthBiasConstantFactor, "depthBiasConstantFactor", 1);

    print_float(obj->depthBiasClamp, "depthBiasClamp", 1);

    print_float(obj->depthBiasSlopeFactor, "depthBiasSlopeFactor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDepthBiasRepresentationInfoEXT(VkDepthBiasRepresentationInfoEXT obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDepthBiasRepresentationEXT(obj.depthBiasRepresentation, "depthBiasRepresentation", 1);

    print_VkBool32(obj.depthBiasExact, "depthBiasExact", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDepthBiasRepresentationInfoEXT(const VkDepthBiasRepresentationInfoEXT* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDepthBiasRepresentationEXT(obj->depthBiasRepresentation, "depthBiasRepresentation", 1);

    print_VkBool32(obj->depthBiasExact, "depthBiasExact", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkDeviceMemoryReportEventTypeEXT_map = {
    std::make_pair(0, "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT"),
    std::make_pair(1, "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT"),
    std::make_pair(2, "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT"),
    std::make_pair(3, "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT"),
    std::make_pair(4, "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT"),
};
static void print_VkDeviceMemoryReportEventTypeEXT(VkDeviceMemoryReportEventTypeEXT obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceMemoryReportEventTypeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceMemoryReportEventTypeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDeviceMemoryReportEventTypeEXT(const VkDeviceMemoryReportEventTypeEXT* obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceMemoryReportEventTypeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceMemoryReportEventTypeEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkDeviceMemoryReportFlagsEXT(VkDeviceMemoryReportFlagsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.deviceMemoryReport, "deviceMemoryReport", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->deviceMemoryReport, "deviceMemoryReport", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceMemoryReportCallbackDataEXT(VkDeviceMemoryReportCallbackDataEXT obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceMemoryReportFlagsEXT(obj.flags, "flags", 1);

    print_VkDeviceMemoryReportEventTypeEXT(obj.type, "type", 1);

    print_uint64_t(obj.memoryObjectId, "memoryObjectId", 1);

    print_VkDeviceSize(obj.size, "size", 1);

    print_VkObjectType(obj.objectType, "objectType", 1);

    print_uint64_t(obj.objectHandle, "objectHandle", 1);

    print_uint32_t(obj.heapIndex, "heapIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceMemoryReportCallbackDataEXT(const VkDeviceMemoryReportCallbackDataEXT* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceMemoryReportFlagsEXT(obj->flags, "flags", 1);

    print_VkDeviceMemoryReportEventTypeEXT(obj->type, "type", 1);

    print_uint64_t(obj->memoryObjectId, "memoryObjectId", 1);

    print_VkDeviceSize(obj->size, "size", 1);

    print_VkObjectType(obj->objectType, "objectType", 1);

    print_uint64_t(obj->objectHandle, "objectHandle", 1);

    print_uint32_t(obj->heapIndex, "heapIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceDeviceMemoryReportCreateInfoEXT(VkDeviceDeviceMemoryReportCreateInfoEXT obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceMemoryReportFlagsEXT(obj.flags, "flags", 1);

    /** Note: Ignoring function pointer (PFN_vkDeviceMemoryReportCallbackEXT). **/

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceDeviceMemoryReportCreateInfoEXT(const VkDeviceDeviceMemoryReportCreateInfoEXT* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceMemoryReportFlagsEXT(obj->flags, "flags", 1);

    /** Note: Ignoring function pointer (PFN_vkDeviceMemoryReportCallbackEXT). **/

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRobustness2FeaturesEXT(VkPhysicalDeviceRobustness2FeaturesEXT obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.robustBufferAccess2, "robustBufferAccess2", 1);

    print_VkBool32(obj.robustImageAccess2, "robustImageAccess2", 1);

    print_VkBool32(obj.nullDescriptor, "nullDescriptor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRobustness2FeaturesEXT(const VkPhysicalDeviceRobustness2FeaturesEXT* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->robustBufferAccess2, "robustBufferAccess2", 1);

    print_VkBool32(obj->robustImageAccess2, "robustImageAccess2", 1);

    print_VkBool32(obj->nullDescriptor, "nullDescriptor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRobustness2PropertiesEXT(VkPhysicalDeviceRobustness2PropertiesEXT obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj.robustStorageBufferAccessSizeAlignment, "robustStorageBufferAccessSizeAlignment", 1);

    print_VkDeviceSize(obj.robustUniformBufferAccessSizeAlignment, "robustUniformBufferAccessSizeAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRobustness2PropertiesEXT(const VkPhysicalDeviceRobustness2PropertiesEXT* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj->robustStorageBufferAccessSizeAlignment, "robustStorageBufferAccessSizeAlignment", 1);

    print_VkDeviceSize(obj->robustUniformBufferAccessSizeAlignment, "robustUniformBufferAccessSizeAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSamplerCustomBorderColorCreateInfoEXT(VkSamplerCustomBorderColorCreateInfoEXT obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkClearColorValue(obj.customBorderColor, "customBorderColor", 1);

    print_VkFormat(obj.format, "format", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSamplerCustomBorderColorCreateInfoEXT(const VkSamplerCustomBorderColorCreateInfoEXT* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkClearColorValue(obj->customBorderColor, "customBorderColor", 1);

    print_VkFormat(obj->format, "format", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCustomBorderColorPropertiesEXT(VkPhysicalDeviceCustomBorderColorPropertiesEXT obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxCustomBorderColorSamplers, "maxCustomBorderColorSamplers", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCustomBorderColorPropertiesEXT(const VkPhysicalDeviceCustomBorderColorPropertiesEXT* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxCustomBorderColorSamplers, "maxCustomBorderColorSamplers", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCustomBorderColorFeaturesEXT(VkPhysicalDeviceCustomBorderColorFeaturesEXT obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.customBorderColors, "customBorderColors", 1);

    print_VkBool32(obj.customBorderColorWithoutFormat, "customBorderColorWithoutFormat", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCustomBorderColorFeaturesEXT(const VkPhysicalDeviceCustomBorderColorFeaturesEXT* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->customBorderColors, "customBorderColors", 1);

    print_VkBool32(obj->customBorderColorWithoutFormat, "customBorderColorWithoutFormat", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePresentBarrierFeaturesNV(VkPhysicalDevicePresentBarrierFeaturesNV obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.presentBarrier, "presentBarrier", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePresentBarrierFeaturesNV(const VkPhysicalDevicePresentBarrierFeaturesNV* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->presentBarrier, "presentBarrier", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSurfaceCapabilitiesPresentBarrierNV(VkSurfaceCapabilitiesPresentBarrierNV obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.presentBarrierSupported, "presentBarrierSupported", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSurfaceCapabilitiesPresentBarrierNV(const VkSurfaceCapabilitiesPresentBarrierNV* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->presentBarrierSupported, "presentBarrierSupported", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSwapchainPresentBarrierCreateInfoNV(VkSwapchainPresentBarrierCreateInfoNV obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.presentBarrierEnable, "presentBarrierEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSwapchainPresentBarrierCreateInfoNV(const VkSwapchainPresentBarrierCreateInfoNV* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->presentBarrierEnable, "presentBarrierEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPrivateDataSlot(VkPrivateDataSlot obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkPrivateDataSlotCreateFlags(VkPrivateDataSlotCreateFlags obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkPhysicalDevicePrivateDataFeatures(VkPhysicalDevicePrivateDataFeatures obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.privateData, "privateData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePrivateDataFeatures(const VkPhysicalDevicePrivateDataFeatures* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->privateData, "privateData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDevicePrivateDataFeatures VkPhysicalDevicePrivateDataFeaturesEXT;

static void print_VkDevicePrivateDataCreateInfo(VkDevicePrivateDataCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.privateDataSlotRequestCount, "privateDataSlotRequestCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDevicePrivateDataCreateInfo(const VkDevicePrivateDataCreateInfo* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->privateDataSlotRequestCount, "privateDataSlotRequestCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkDevicePrivateDataCreateInfo VkDevicePrivateDataCreateInfoEXT;

static void print_VkPrivateDataSlotCreateInfo(VkPrivateDataSlotCreateInfo obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPrivateDataSlotCreateFlags(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPrivateDataSlotCreateInfo(const VkPrivateDataSlotCreateInfo* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPrivateDataSlotCreateFlags(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPrivateDataSlotCreateInfo VkPrivateDataSlotCreateInfoEXT;

static void print_VkPhysicalDevicePipelineCreationCacheControlFeatures(VkPhysicalDevicePipelineCreationCacheControlFeatures obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.pipelineCreationCacheControl, "pipelineCreationCacheControl", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePipelineCreationCacheControlFeatures(
    const VkPhysicalDevicePipelineCreationCacheControlFeatures* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->pipelineCreationCacheControl, "pipelineCreationCacheControl", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDevicePipelineCreationCacheControlFeatures VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT;

static std::map<uint64_t, std::string> VkDeviceDiagnosticsConfigFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV"),
    std::make_pair(1ULL << 1, "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV"),
    std::make_pair(1ULL << 2, "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV"),
    std::make_pair(1ULL << 3, "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV"),
};
static void print_VkDeviceDiagnosticsConfigFlagBitsNV(VkDeviceDiagnosticsConfigFlagBitsNV obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceDiagnosticsConfigFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceDiagnosticsConfigFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkDeviceDiagnosticsConfigFlagBitsNV(const VkDeviceDiagnosticsConfigFlagBitsNV* obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceDiagnosticsConfigFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceDiagnosticsConfigFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static void print_VkDeviceDiagnosticsConfigFlagsNV(VkDeviceDiagnosticsConfigFlagsNV obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkDeviceDiagnosticsConfigFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkDeviceDiagnosticsConfigFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(VkPhysicalDeviceDiagnosticsConfigFeaturesNV obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.diagnosticsConfig, "diagnosticsConfig", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(const VkPhysicalDeviceDiagnosticsConfigFeaturesNV* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->diagnosticsConfig, "diagnosticsConfig", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceDiagnosticsConfigCreateInfoNV(VkDeviceDiagnosticsConfigCreateInfoNV obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceDiagnosticsConfigFlagsNV(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceDiagnosticsConfigCreateInfoNV(const VkDeviceDiagnosticsConfigCreateInfoNV* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceDiagnosticsConfigFlagsNV(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCudaModuleNV(VkCudaModuleNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkCudaFunctionNV(VkCudaFunctionNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkCudaModuleCreateInfoNV(VkCudaModuleCreateInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_size_t(obj.dataSize, "dataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCudaModuleCreateInfoNV(const VkCudaModuleCreateInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_size_t(obj->dataSize, "dataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCudaFunctionCreateInfoNV(VkCudaFunctionCreateInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "module"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_char(obj.pName, "pName", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCudaFunctionCreateInfoNV(const VkCudaFunctionCreateInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "module"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_char(obj->pName, "pName", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCudaLaunchInfoNV(VkCudaLaunchInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "function"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.gridDimX, "gridDimX", 1);

    print_uint32_t(obj.gridDimY, "gridDimY", 1);

    print_uint32_t(obj.gridDimZ, "gridDimZ", 1);

    print_uint32_t(obj.blockDimX, "blockDimX", 1);

    print_uint32_t(obj.blockDimY, "blockDimY", 1);

    print_uint32_t(obj.blockDimZ, "blockDimZ", 1);

    print_uint32_t(obj.sharedMemBytes, "sharedMemBytes", 1);

    print_size_t(obj.paramCount, "paramCount", 1);

    /** Note: Ignoring void* data. **/

    print_size_t(obj.extraCount, "extraCount", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCudaLaunchInfoNV(const VkCudaLaunchInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "function"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->gridDimX, "gridDimX", 1);

    print_uint32_t(obj->gridDimY, "gridDimY", 1);

    print_uint32_t(obj->gridDimZ, "gridDimZ", 1);

    print_uint32_t(obj->blockDimX, "blockDimX", 1);

    print_uint32_t(obj->blockDimY, "blockDimY", 1);

    print_uint32_t(obj->blockDimZ, "blockDimZ", 1);

    print_uint32_t(obj->sharedMemBytes, "sharedMemBytes", 1);

    print_size_t(obj->paramCount, "paramCount", 1);

    /** Note: Ignoring void* data. **/

    print_size_t(obj->extraCount, "extraCount", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCudaKernelLaunchFeaturesNV(VkPhysicalDeviceCudaKernelLaunchFeaturesNV obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.cudaKernelLaunchFeatures, "cudaKernelLaunchFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCudaKernelLaunchFeaturesNV(const VkPhysicalDeviceCudaKernelLaunchFeaturesNV* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->cudaKernelLaunchFeatures, "cudaKernelLaunchFeatures", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCudaKernelLaunchPropertiesNV(VkPhysicalDeviceCudaKernelLaunchPropertiesNV obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.computeCapabilityMinor, "computeCapabilityMinor", 1);

    print_uint32_t(obj.computeCapabilityMajor, "computeCapabilityMajor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCudaKernelLaunchPropertiesNV(const VkPhysicalDeviceCudaKernelLaunchPropertiesNV* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->computeCapabilityMinor, "computeCapabilityMinor", 1);

    print_uint32_t(obj->computeCapabilityMajor, "computeCapabilityMajor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkQueryLowLatencySupportNV(VkQueryLowLatencySupportNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkQueryLowLatencySupportNV(const VkQueryLowLatencySupportNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureKHR(VkAccelerationStructureKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkPhysicalDeviceDescriptorBufferPropertiesEXT(VkPhysicalDeviceDescriptorBufferPropertiesEXT obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.combinedImageSamplerDescriptorSingleArray, "combinedImageSamplerDescriptorSingleArray", 1);

    print_VkBool32(obj.bufferlessPushDescriptors, "bufferlessPushDescriptors", 1);

    print_VkBool32(obj.allowSamplerImageViewPostSubmitCreation, "allowSamplerImageViewPostSubmitCreation", 1);

    print_VkDeviceSize(obj.descriptorBufferOffsetAlignment, "descriptorBufferOffsetAlignment", 1);

    print_uint32_t(obj.maxDescriptorBufferBindings, "maxDescriptorBufferBindings", 1);

    print_uint32_t(obj.maxResourceDescriptorBufferBindings, "maxResourceDescriptorBufferBindings", 1);

    print_uint32_t(obj.maxSamplerDescriptorBufferBindings, "maxSamplerDescriptorBufferBindings", 1);

    print_uint32_t(obj.maxEmbeddedImmutableSamplerBindings, "maxEmbeddedImmutableSamplerBindings", 1);

    print_uint32_t(obj.maxEmbeddedImmutableSamplers, "maxEmbeddedImmutableSamplers", 1);

    print_size_t(obj.bufferCaptureReplayDescriptorDataSize, "bufferCaptureReplayDescriptorDataSize", 1);

    print_size_t(obj.imageCaptureReplayDescriptorDataSize, "imageCaptureReplayDescriptorDataSize", 1);

    print_size_t(obj.imageViewCaptureReplayDescriptorDataSize, "imageViewCaptureReplayDescriptorDataSize", 1);

    print_size_t(obj.samplerCaptureReplayDescriptorDataSize, "samplerCaptureReplayDescriptorDataSize", 1);

    print_size_t(obj.accelerationStructureCaptureReplayDescriptorDataSize, "accelerationStructureCaptureReplayDescriptorDataSize",
                 1);

    print_size_t(obj.samplerDescriptorSize, "samplerDescriptorSize", 1);

    print_size_t(obj.combinedImageSamplerDescriptorSize, "combinedImageSamplerDescriptorSize", 1);

    print_size_t(obj.sampledImageDescriptorSize, "sampledImageDescriptorSize", 1);

    print_size_t(obj.storageImageDescriptorSize, "storageImageDescriptorSize", 1);

    print_size_t(obj.uniformTexelBufferDescriptorSize, "uniformTexelBufferDescriptorSize", 1);

    print_size_t(obj.robustUniformTexelBufferDescriptorSize, "robustUniformTexelBufferDescriptorSize", 1);

    print_size_t(obj.storageTexelBufferDescriptorSize, "storageTexelBufferDescriptorSize", 1);

    print_size_t(obj.robustStorageTexelBufferDescriptorSize, "robustStorageTexelBufferDescriptorSize", 1);

    print_size_t(obj.uniformBufferDescriptorSize, "uniformBufferDescriptorSize", 1);

    print_size_t(obj.robustUniformBufferDescriptorSize, "robustUniformBufferDescriptorSize", 1);

    print_size_t(obj.storageBufferDescriptorSize, "storageBufferDescriptorSize", 1);

    print_size_t(obj.robustStorageBufferDescriptorSize, "robustStorageBufferDescriptorSize", 1);

    print_size_t(obj.inputAttachmentDescriptorSize, "inputAttachmentDescriptorSize", 1);

    print_size_t(obj.accelerationStructureDescriptorSize, "accelerationStructureDescriptorSize", 1);

    print_VkDeviceSize(obj.maxSamplerDescriptorBufferRange, "maxSamplerDescriptorBufferRange", 1);

    print_VkDeviceSize(obj.maxResourceDescriptorBufferRange, "maxResourceDescriptorBufferRange", 1);

    print_VkDeviceSize(obj.samplerDescriptorBufferAddressSpaceSize, "samplerDescriptorBufferAddressSpaceSize", 1);

    print_VkDeviceSize(obj.resourceDescriptorBufferAddressSpaceSize, "resourceDescriptorBufferAddressSpaceSize", 1);

    print_VkDeviceSize(obj.descriptorBufferAddressSpaceSize, "descriptorBufferAddressSpaceSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDescriptorBufferPropertiesEXT(const VkPhysicalDeviceDescriptorBufferPropertiesEXT* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->combinedImageSamplerDescriptorSingleArray, "combinedImageSamplerDescriptorSingleArray", 1);

    print_VkBool32(obj->bufferlessPushDescriptors, "bufferlessPushDescriptors", 1);

    print_VkBool32(obj->allowSamplerImageViewPostSubmitCreation, "allowSamplerImageViewPostSubmitCreation", 1);

    print_VkDeviceSize(obj->descriptorBufferOffsetAlignment, "descriptorBufferOffsetAlignment", 1);

    print_uint32_t(obj->maxDescriptorBufferBindings, "maxDescriptorBufferBindings", 1);

    print_uint32_t(obj->maxResourceDescriptorBufferBindings, "maxResourceDescriptorBufferBindings", 1);

    print_uint32_t(obj->maxSamplerDescriptorBufferBindings, "maxSamplerDescriptorBufferBindings", 1);

    print_uint32_t(obj->maxEmbeddedImmutableSamplerBindings, "maxEmbeddedImmutableSamplerBindings", 1);

    print_uint32_t(obj->maxEmbeddedImmutableSamplers, "maxEmbeddedImmutableSamplers", 1);

    print_size_t(obj->bufferCaptureReplayDescriptorDataSize, "bufferCaptureReplayDescriptorDataSize", 1);

    print_size_t(obj->imageCaptureReplayDescriptorDataSize, "imageCaptureReplayDescriptorDataSize", 1);

    print_size_t(obj->imageViewCaptureReplayDescriptorDataSize, "imageViewCaptureReplayDescriptorDataSize", 1);

    print_size_t(obj->samplerCaptureReplayDescriptorDataSize, "samplerCaptureReplayDescriptorDataSize", 1);

    print_size_t(obj->accelerationStructureCaptureReplayDescriptorDataSize, "accelerationStructureCaptureReplayDescriptorDataSize",
                 1);

    print_size_t(obj->samplerDescriptorSize, "samplerDescriptorSize", 1);

    print_size_t(obj->combinedImageSamplerDescriptorSize, "combinedImageSamplerDescriptorSize", 1);

    print_size_t(obj->sampledImageDescriptorSize, "sampledImageDescriptorSize", 1);

    print_size_t(obj->storageImageDescriptorSize, "storageImageDescriptorSize", 1);

    print_size_t(obj->uniformTexelBufferDescriptorSize, "uniformTexelBufferDescriptorSize", 1);

    print_size_t(obj->robustUniformTexelBufferDescriptorSize, "robustUniformTexelBufferDescriptorSize", 1);

    print_size_t(obj->storageTexelBufferDescriptorSize, "storageTexelBufferDescriptorSize", 1);

    print_size_t(obj->robustStorageTexelBufferDescriptorSize, "robustStorageTexelBufferDescriptorSize", 1);

    print_size_t(obj->uniformBufferDescriptorSize, "uniformBufferDescriptorSize", 1);

    print_size_t(obj->robustUniformBufferDescriptorSize, "robustUniformBufferDescriptorSize", 1);

    print_size_t(obj->storageBufferDescriptorSize, "storageBufferDescriptorSize", 1);

    print_size_t(obj->robustStorageBufferDescriptorSize, "robustStorageBufferDescriptorSize", 1);

    print_size_t(obj->inputAttachmentDescriptorSize, "inputAttachmentDescriptorSize", 1);

    print_size_t(obj->accelerationStructureDescriptorSize, "accelerationStructureDescriptorSize", 1);

    print_VkDeviceSize(obj->maxSamplerDescriptorBufferRange, "maxSamplerDescriptorBufferRange", 1);

    print_VkDeviceSize(obj->maxResourceDescriptorBufferRange, "maxResourceDescriptorBufferRange", 1);

    print_VkDeviceSize(obj->samplerDescriptorBufferAddressSpaceSize, "samplerDescriptorBufferAddressSpaceSize", 1);

    print_VkDeviceSize(obj->resourceDescriptorBufferAddressSpaceSize, "resourceDescriptorBufferAddressSpaceSize", 1);

    print_VkDeviceSize(obj->descriptorBufferAddressSpaceSize, "descriptorBufferAddressSpaceSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(
    VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_size_t(obj.combinedImageSamplerDensityMapDescriptorSize, "combinedImageSamplerDensityMapDescriptorSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(
    const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_size_t(obj->combinedImageSamplerDensityMapDescriptorSize, "combinedImageSamplerDensityMapDescriptorSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDescriptorBufferFeaturesEXT(VkPhysicalDeviceDescriptorBufferFeaturesEXT obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.descriptorBuffer, "descriptorBuffer", 1);

    print_VkBool32(obj.descriptorBufferCaptureReplay, "descriptorBufferCaptureReplay", 1);

    print_VkBool32(obj.descriptorBufferImageLayoutIgnored, "descriptorBufferImageLayoutIgnored", 1);

    print_VkBool32(obj.descriptorBufferPushDescriptors, "descriptorBufferPushDescriptors", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDescriptorBufferFeaturesEXT(const VkPhysicalDeviceDescriptorBufferFeaturesEXT* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->descriptorBuffer, "descriptorBuffer", 1);

    print_VkBool32(obj->descriptorBufferCaptureReplay, "descriptorBufferCaptureReplay", 1);

    print_VkBool32(obj->descriptorBufferImageLayoutIgnored, "descriptorBufferImageLayoutIgnored", 1);

    print_VkBool32(obj->descriptorBufferPushDescriptors, "descriptorBufferPushDescriptors", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorAddressInfoEXT(VkDescriptorAddressInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceAddress(obj.address, "address", 1);

    print_VkDeviceSize(obj.range, "range", 1);

    print_VkFormat(obj.format, "format", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorAddressInfoEXT(const VkDescriptorAddressInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceAddress(obj->address, "address", 1);

    print_VkDeviceSize(obj->range, "range", 1);

    print_VkFormat(obj->format, "format", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorBufferBindingInfoEXT(VkDescriptorBufferBindingInfoEXT obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceAddress(obj.address, "address", 1);

    print_VkBufferUsageFlags(obj.usage, "usage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorBufferBindingInfoEXT(const VkDescriptorBufferBindingInfoEXT* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceAddress(obj->address, "address", 1);

    print_VkBufferUsageFlags(obj->usage, "usage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT obj,
                                                                         const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(
    const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorDataEXT(VkDescriptorDataEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pSampler"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"pCombinedImageSampler\": " << std::endl;
    if (obj.pCombinedImageSampler) {
        print_VkDescriptorImageInfo(obj.pCombinedImageSampler, "pCombinedImageSampler", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pInputAttachmentImage\": " << std::endl;
    if (obj.pInputAttachmentImage) {
        print_VkDescriptorImageInfo(obj.pInputAttachmentImage, "pInputAttachmentImage", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pSampledImage\": " << std::endl;
    if (obj.pSampledImage) {
        print_VkDescriptorImageInfo(obj.pSampledImage, "pSampledImage", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pStorageImage\": " << std::endl;
    if (obj.pStorageImage) {
        print_VkDescriptorImageInfo(obj.pStorageImage, "pStorageImage", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pUniformTexelBuffer\": " << std::endl;
    if (obj.pUniformTexelBuffer) {
        print_VkDescriptorAddressInfoEXT(obj.pUniformTexelBuffer, "pUniformTexelBuffer", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pStorageTexelBuffer\": " << std::endl;
    if (obj.pStorageTexelBuffer) {
        print_VkDescriptorAddressInfoEXT(obj.pStorageTexelBuffer, "pStorageTexelBuffer", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pUniformBuffer\": " << std::endl;
    if (obj.pUniformBuffer) {
        print_VkDescriptorAddressInfoEXT(obj.pUniformBuffer, "pUniformBuffer", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pStorageBuffer\": " << std::endl;
    if (obj.pStorageBuffer) {
        print_VkDescriptorAddressInfoEXT(obj.pStorageBuffer, "pStorageBuffer", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkDeviceAddress(obj.accelerationStructure, "accelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorDataEXT(const VkDescriptorDataEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pSampler"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    PRINT_SPACE
    _OUT << "\"pCombinedImageSampler\": " << std::endl;
    if (obj->pCombinedImageSampler) {
        print_VkDescriptorImageInfo(obj->pCombinedImageSampler, "pCombinedImageSampler", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pInputAttachmentImage\": " << std::endl;
    if (obj->pInputAttachmentImage) {
        print_VkDescriptorImageInfo(obj->pInputAttachmentImage, "pInputAttachmentImage", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pSampledImage\": " << std::endl;
    if (obj->pSampledImage) {
        print_VkDescriptorImageInfo(obj->pSampledImage, "pSampledImage", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pStorageImage\": " << std::endl;
    if (obj->pStorageImage) {
        print_VkDescriptorImageInfo(obj->pStorageImage, "pStorageImage", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pUniformTexelBuffer\": " << std::endl;
    if (obj->pUniformTexelBuffer) {
        print_VkDescriptorAddressInfoEXT(obj->pUniformTexelBuffer, "pUniformTexelBuffer", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pStorageTexelBuffer\": " << std::endl;
    if (obj->pStorageTexelBuffer) {
        print_VkDescriptorAddressInfoEXT(obj->pStorageTexelBuffer, "pStorageTexelBuffer", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pUniformBuffer\": " << std::endl;
    if (obj->pUniformBuffer) {
        print_VkDescriptorAddressInfoEXT(obj->pUniformBuffer, "pUniformBuffer", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pStorageBuffer\": " << std::endl;
    if (obj->pStorageBuffer) {
        print_VkDescriptorAddressInfoEXT(obj->pStorageBuffer, "pStorageBuffer", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkDeviceAddress(obj->accelerationStructure, "accelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorGetInfoEXT(VkDescriptorGetInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDescriptorType(obj.type, "type", 1);

    print_VkDescriptorDataEXT(obj.data, "data", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorGetInfoEXT(const VkDescriptorGetInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDescriptorType(obj->type, "type", 1);

    print_VkDescriptorDataEXT(obj->data, "data", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBufferCaptureDescriptorDataInfoEXT(VkBufferCaptureDescriptorDataInfoEXT obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBufferCaptureDescriptorDataInfoEXT(const VkBufferCaptureDescriptorDataInfoEXT* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageCaptureDescriptorDataInfoEXT(VkImageCaptureDescriptorDataInfoEXT obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageCaptureDescriptorDataInfoEXT(const VkImageCaptureDescriptorDataInfoEXT* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "image"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageViewCaptureDescriptorDataInfoEXT(VkImageViewCaptureDescriptorDataInfoEXT obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageViewCaptureDescriptorDataInfoEXT(const VkImageViewCaptureDescriptorDataInfoEXT* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "imageView"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSamplerCaptureDescriptorDataInfoEXT(VkSamplerCaptureDescriptorDataInfoEXT obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "sampler"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSamplerCaptureDescriptorDataInfoEXT(const VkSamplerCaptureDescriptorDataInfoEXT* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "sampler"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkOpaqueCaptureDescriptorDataCreateInfoEXT(VkOpaqueCaptureDescriptorDataCreateInfoEXT obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkOpaqueCaptureDescriptorDataCreateInfoEXT(const VkOpaqueCaptureDescriptorDataCreateInfoEXT* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureCaptureDescriptorDataInfoEXT(VkAccelerationStructureCaptureDescriptorDataInfoEXT obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "accelerationStructure"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "accelerationStructureNV"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureCaptureDescriptorDataInfoEXT(
    const VkAccelerationStructureCaptureDescriptorDataInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "accelerationStructure"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "accelerationStructureNV"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkGraphicsPipelineLibraryFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT"),
    std::make_pair(1ULL << 1, "VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT"),
    std::make_pair(1ULL << 2, "VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT"),
    std::make_pair(1ULL << 3, "VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT"),
};
static void print_VkGraphicsPipelineLibraryFlagBitsEXT(VkGraphicsPipelineLibraryFlagBitsEXT obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGraphicsPipelineLibraryFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGraphicsPipelineLibraryFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkGraphicsPipelineLibraryFlagBitsEXT(const VkGraphicsPipelineLibraryFlagBitsEXT* obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkGraphicsPipelineLibraryFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkGraphicsPipelineLibraryFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkGraphicsPipelineLibraryFlagsEXT(VkGraphicsPipelineLibraryFlagsEXT obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkGraphicsPipelineLibraryFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkGraphicsPipelineLibraryFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.graphicsPipelineLibrary, "graphicsPipelineLibrary", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->graphicsPipelineLibrary, "graphicsPipelineLibrary", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.graphicsPipelineLibraryFastLinking, "graphicsPipelineLibraryFastLinking", 1);

    print_VkBool32(obj.graphicsPipelineLibraryIndependentInterpolationDecoration,
                   "graphicsPipelineLibraryIndependentInterpolationDecoration", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(
    const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->graphicsPipelineLibraryFastLinking, "graphicsPipelineLibraryFastLinking", 1);

    print_VkBool32(obj->graphicsPipelineLibraryIndependentInterpolationDecoration,
                   "graphicsPipelineLibraryIndependentInterpolationDecoration", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGraphicsPipelineLibraryCreateInfoEXT(VkGraphicsPipelineLibraryCreateInfoEXT obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkGraphicsPipelineLibraryFlagsEXT(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGraphicsPipelineLibraryCreateInfoEXT(const VkGraphicsPipelineLibraryCreateInfoEXT* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkGraphicsPipelineLibraryFlagsEXT(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(
    VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderEarlyAndLateFragmentTests, "shaderEarlyAndLateFragmentTests", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(
    const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderEarlyAndLateFragmentTests, "shaderEarlyAndLateFragmentTests", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkFragmentShadingRateTypeNV_map = {
    std::make_pair(0, "VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV"),
    std::make_pair(1, "VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV"),
};
static void print_VkFragmentShadingRateTypeNV(VkFragmentShadingRateTypeNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFragmentShadingRateTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFragmentShadingRateTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkFragmentShadingRateTypeNV(const VkFragmentShadingRateTypeNV* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFragmentShadingRateTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFragmentShadingRateTypeNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkFragmentShadingRateNV_map = {
    std::make_pair(0, "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV"),
    std::make_pair(1, "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV"),
    std::make_pair(4, "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV"),
    std::make_pair(5, "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV"),
    std::make_pair(6, "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV"),
    std::make_pair(9, "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV"),
    std::make_pair(10, "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV"),
    std::make_pair(11, "VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV"),
    std::make_pair(12, "VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV"),
    std::make_pair(13, "VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV"),
    std::make_pair(14, "VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV"),
    std::make_pair(15, "VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV"),
};
static void print_VkFragmentShadingRateNV(VkFragmentShadingRateNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFragmentShadingRateNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFragmentShadingRateNV_map[obj] << "\"" << std::endl;
}
static void print_VkFragmentShadingRateNV(const VkFragmentShadingRateNV* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFragmentShadingRateNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFragmentShadingRateNV_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.fragmentShadingRateEnums, "fragmentShadingRateEnums", 1);

    print_VkBool32(obj.supersampleFragmentShadingRates, "supersampleFragmentShadingRates", 1);

    print_VkBool32(obj.noInvocationFragmentShadingRates, "noInvocationFragmentShadingRates", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->fragmentShadingRateEnums, "fragmentShadingRateEnums", 1);

    print_VkBool32(obj->supersampleFragmentShadingRates, "supersampleFragmentShadingRates", 1);

    print_VkBool32(obj->noInvocationFragmentShadingRates, "noInvocationFragmentShadingRates", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSampleCountFlagBits(obj.maxFragmentShadingRateInvocationCount, "maxFragmentShadingRateInvocationCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
    const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSampleCountFlagBits(obj->maxFragmentShadingRateInvocationCount, "maxFragmentShadingRateInvocationCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(VkPipelineFragmentShadingRateEnumStateCreateInfoNV obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFragmentShadingRateTypeNV(obj.shadingRateType, "shadingRateType", 1);

    print_VkFragmentShadingRateNV(obj.shadingRate, "shadingRate", 1);

    PRINT_SPACE
    _OUT << "\"combinerOps\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_VkFragmentShadingRateCombinerOpKHR(obj.combinerOps[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(const VkPipelineFragmentShadingRateEnumStateCreateInfoNV* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFragmentShadingRateTypeNV(obj->shadingRateType, "shadingRateType", 1);

    print_VkFragmentShadingRateNV(obj->shadingRate, "shadingRate", 1);

    PRINT_SPACE
    _OUT << "\"combinerOps\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 2; i++) {
        bool isCommaNeeded = (i + 1) != 2;
        print_VkFragmentShadingRateCombinerOpKHR(obj->combinerOps[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkAccelerationStructureMotionInstanceTypeNV_map = {
    std::make_pair(0, "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV"),
    std::make_pair(1, "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV"),
    std::make_pair(2, "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV"),
};
static void print_VkAccelerationStructureMotionInstanceTypeNV(VkAccelerationStructureMotionInstanceTypeNV obj,
                                                              const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureMotionInstanceTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureMotionInstanceTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkAccelerationStructureMotionInstanceTypeNV(const VkAccelerationStructureMotionInstanceTypeNV* obj,
                                                              const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureMotionInstanceTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureMotionInstanceTypeNV_map[*obj] << "\"" << std::endl;
}

static void print_VkAccelerationStructureMotionInfoFlagsNV(VkAccelerationStructureMotionInfoFlagsNV obj, const std::string& str,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkAccelerationStructureMotionInstanceFlagsNV(VkAccelerationStructureMotionInstanceFlagsNV obj,
                                                               const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkDeviceOrHostAddressConstKHR(VkDeviceOrHostAddressConstKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.deviceAddress, "deviceAddress", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceOrHostAddressConstKHR(const VkDeviceOrHostAddressConstKHR* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->deviceAddress, "deviceAddress", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureGeometryMotionTrianglesDataNV(VkAccelerationStructureGeometryMotionTrianglesDataNV obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceOrHostAddressConstKHR(obj.vertexData, "vertexData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureGeometryMotionTrianglesDataNV(
    const VkAccelerationStructureGeometryMotionTrianglesDataNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceOrHostAddressConstKHR(obj->vertexData, "vertexData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureMotionInfoNV(VkAccelerationStructureMotionInfoNV obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxInstances, "maxInstances", 1);

    print_VkAccelerationStructureMotionInfoFlagsNV(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureMotionInfoNV(const VkAccelerationStructureMotionInfoNV* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxInstances, "maxInstances", 1);

    print_VkAccelerationStructureMotionInfoFlagsNV(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureMatrixMotionInstanceNV(VkAccelerationStructureMatrixMotionInstanceNV obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"transformT0\": " << std::endl;
    { print_VkTransformMatrixKHR(obj.transformT0, "transformT0", 1); }

    PRINT_SPACE
    _OUT << "\"transformT1\": " << std::endl;
    { print_VkTransformMatrixKHR(obj.transformT1, "transformT1", 1); }

    print_uint32_t(obj.instanceCustomIndex, "instanceCustomIndex", 1);

    print_uint32_t(obj.mask, "mask", 1);

    print_uint32_t(obj.instanceShaderBindingTableRecordOffset, "instanceShaderBindingTableRecordOffset", 1);

    print_VkGeometryInstanceFlagsKHR(obj.flags, "flags", 1);

    print_uint64_t(obj.accelerationStructureReference, "accelerationStructureReference", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureMatrixMotionInstanceNV(const VkAccelerationStructureMatrixMotionInstanceNV* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"transformT0\": " << std::endl;
    { print_VkTransformMatrixKHR(obj->transformT0, "transformT0", 1); }

    PRINT_SPACE
    _OUT << "\"transformT1\": " << std::endl;
    { print_VkTransformMatrixKHR(obj->transformT1, "transformT1", 1); }

    print_uint32_t(obj->instanceCustomIndex, "instanceCustomIndex", 1);

    print_uint32_t(obj->mask, "mask", 1);

    print_uint32_t(obj->instanceShaderBindingTableRecordOffset, "instanceShaderBindingTableRecordOffset", 1);

    print_VkGeometryInstanceFlagsKHR(obj->flags, "flags", 1);

    print_uint64_t(obj->accelerationStructureReference, "accelerationStructureReference", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSRTDataNV(VkSRTDataNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj.sx, "sx", 1);

    print_float(obj.a, "a", 1);

    print_float(obj.b, "b", 1);

    print_float(obj.pvx, "pvx", 1);

    print_float(obj.sy, "sy", 1);

    print_float(obj.c, "c", 1);

    print_float(obj.pvy, "pvy", 1);

    print_float(obj.sz, "sz", 1);

    print_float(obj.pvz, "pvz", 1);

    print_float(obj.qx, "qx", 1);

    print_float(obj.qy, "qy", 1);

    print_float(obj.qz, "qz", 1);

    print_float(obj.qw, "qw", 1);

    print_float(obj.tx, "tx", 1);

    print_float(obj.ty, "ty", 1);

    print_float(obj.tz, "tz", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSRTDataNV(const VkSRTDataNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj->sx, "sx", 1);

    print_float(obj->a, "a", 1);

    print_float(obj->b, "b", 1);

    print_float(obj->pvx, "pvx", 1);

    print_float(obj->sy, "sy", 1);

    print_float(obj->c, "c", 1);

    print_float(obj->pvy, "pvy", 1);

    print_float(obj->sz, "sz", 1);

    print_float(obj->pvz, "pvz", 1);

    print_float(obj->qx, "qx", 1);

    print_float(obj->qy, "qy", 1);

    print_float(obj->qz, "qz", 1);

    print_float(obj->qw, "qw", 1);

    print_float(obj->tx, "tx", 1);

    print_float(obj->ty, "ty", 1);

    print_float(obj->tz, "tz", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureSRTMotionInstanceNV(VkAccelerationStructureSRTMotionInstanceNV obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"transformT0\": " << std::endl;
    { print_VkSRTDataNV(obj.transformT0, "transformT0", 1); }

    PRINT_SPACE
    _OUT << "\"transformT1\": " << std::endl;
    { print_VkSRTDataNV(obj.transformT1, "transformT1", 1); }

    print_uint32_t(obj.instanceCustomIndex, "instanceCustomIndex", 1);

    print_uint32_t(obj.mask, "mask", 1);

    print_uint32_t(obj.instanceShaderBindingTableRecordOffset, "instanceShaderBindingTableRecordOffset", 1);

    print_VkGeometryInstanceFlagsKHR(obj.flags, "flags", 1);

    print_uint64_t(obj.accelerationStructureReference, "accelerationStructureReference", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureSRTMotionInstanceNV(const VkAccelerationStructureSRTMotionInstanceNV* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"transformT0\": " << std::endl;
    { print_VkSRTDataNV(obj->transformT0, "transformT0", 1); }

    PRINT_SPACE
    _OUT << "\"transformT1\": " << std::endl;
    { print_VkSRTDataNV(obj->transformT1, "transformT1", 1); }

    print_uint32_t(obj->instanceCustomIndex, "instanceCustomIndex", 1);

    print_uint32_t(obj->mask, "mask", 1);

    print_uint32_t(obj->instanceShaderBindingTableRecordOffset, "instanceShaderBindingTableRecordOffset", 1);

    print_VkGeometryInstanceFlagsKHR(obj->flags, "flags", 1);

    print_uint64_t(obj->accelerationStructureReference, "accelerationStructureReference", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureMotionInstanceDataNV(VkAccelerationStructureMotionInstanceDataNV obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"staticInstance\": " << std::endl;
    { print_VkAccelerationStructureInstanceKHR(obj.staticInstance, "staticInstance", 1); }

    PRINT_SPACE
    _OUT << "\"matrixMotionInstance\": " << std::endl;
    { print_VkAccelerationStructureMatrixMotionInstanceNV(obj.matrixMotionInstance, "matrixMotionInstance", 1); }

    PRINT_SPACE
    _OUT << "\"srtMotionInstance\": " << std::endl;
    { print_VkAccelerationStructureSRTMotionInstanceNV(obj.srtMotionInstance, "srtMotionInstance", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureMotionInstanceDataNV(const VkAccelerationStructureMotionInstanceDataNV* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"staticInstance\": " << std::endl;
    { print_VkAccelerationStructureInstanceKHR(obj->staticInstance, "staticInstance", 1); }

    PRINT_SPACE
    _OUT << "\"matrixMotionInstance\": " << std::endl;
    { print_VkAccelerationStructureMatrixMotionInstanceNV(obj->matrixMotionInstance, "matrixMotionInstance", 1); }

    PRINT_SPACE
    _OUT << "\"srtMotionInstance\": " << std::endl;
    { print_VkAccelerationStructureSRTMotionInstanceNV(obj->srtMotionInstance, "srtMotionInstance", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureMotionInstanceNV(VkAccelerationStructureMotionInstanceNV obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkAccelerationStructureMotionInstanceTypeNV(obj.type, "type", 1);

    print_VkAccelerationStructureMotionInstanceFlagsNV(obj.flags, "flags", 1);

    print_VkAccelerationStructureMotionInstanceDataNV(obj.data, "data", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureMotionInstanceNV(const VkAccelerationStructureMotionInstanceNV* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkAccelerationStructureMotionInstanceTypeNV(obj->type, "type", 1);

    print_VkAccelerationStructureMotionInstanceFlagsNV(obj->flags, "flags", 1);

    print_VkAccelerationStructureMotionInstanceDataNV(obj->data, "data", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.rayTracingMotionBlur, "rayTracingMotionBlur", 1);

    print_VkBool32(obj.rayTracingMotionBlurPipelineTraceRaysIndirect, "rayTracingMotionBlurPipelineTraceRaysIndirect", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->rayTracingMotionBlur, "rayTracingMotionBlur", 1);

    print_VkBool32(obj->rayTracingMotionBlurPipelineTraceRaysIndirect, "rayTracingMotionBlurPipelineTraceRaysIndirect", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.ycbcr2plane444Formats, "ycbcr2plane444Formats", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->ycbcr2plane444Formats, "ycbcr2plane444Formats", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.fragmentDensityMapDeferred, "fragmentDensityMapDeferred", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->fragmentDensityMapDeferred, "fragmentDensityMapDeferred", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.subsampledLoads, "subsampledLoads", 1);

    print_VkBool32(obj.subsampledCoarseReconstructionEarlyAccess, "subsampledCoarseReconstructionEarlyAccess", 1);

    print_uint32_t(obj.maxSubsampledArrayLayers, "maxSubsampledArrayLayers", 1);

    print_uint32_t(obj.maxDescriptorSetSubsampledSamplers, "maxDescriptorSetSubsampledSamplers", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->subsampledLoads, "subsampledLoads", 1);

    print_VkBool32(obj->subsampledCoarseReconstructionEarlyAccess, "subsampledCoarseReconstructionEarlyAccess", 1);

    print_uint32_t(obj->maxSubsampledArrayLayers, "maxSubsampledArrayLayers", 1);

    print_uint32_t(obj->maxDescriptorSetSubsampledSamplers, "maxDescriptorSetSubsampledSamplers", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCopyCommandTransformInfoQCOM(VkCopyCommandTransformInfoQCOM obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSurfaceTransformFlagBitsKHR(obj.transform, "transform", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyCommandTransformInfoQCOM(const VkCopyCommandTransformInfoQCOM* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkSurfaceTransformFlagBitsKHR(obj->transform, "transform", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceImageRobustnessFeatures(VkPhysicalDeviceImageRobustnessFeatures obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.robustImageAccess, "robustImageAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageRobustnessFeatures(const VkPhysicalDeviceImageRobustnessFeatures* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->robustImageAccess, "robustImageAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceImageRobustnessFeatures VkPhysicalDeviceImageRobustnessFeaturesEXT;

static std::map<uint64_t, std::string> VkImageCompressionFlagBitsEXT_map = {
    std::make_pair(0, "VK_IMAGE_COMPRESSION_DEFAULT_EXT"),
    std::make_pair(1ULL << 0, "VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT"),
    std::make_pair(1ULL << 1, "VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT"),
    std::make_pair(1ULL << 2, "VK_IMAGE_COMPRESSION_DISABLED_EXT"),
};
static void print_VkImageCompressionFlagBitsEXT(VkImageCompressionFlagBitsEXT obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageCompressionFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageCompressionFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkImageCompressionFlagBitsEXT(const VkImageCompressionFlagBitsEXT* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageCompressionFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageCompressionFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkImageCompressionFixedRateFlagBitsEXT_map = {
    std::make_pair(0, "VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT"),
    std::make_pair(1ULL << 0, "VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT"),
    std::make_pair(1ULL << 1, "VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT"),
    std::make_pair(1ULL << 2, "VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT"),
    std::make_pair(1ULL << 3, "VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT"),
    std::make_pair(1ULL << 4, "VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT"),
    std::make_pair(1ULL << 5, "VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT"),
    std::make_pair(1ULL << 6, "VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT"),
    std::make_pair(1ULL << 7, "VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT"),
    std::make_pair(1ULL << 8, "VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT"),
    std::make_pair(1ULL << 9, "VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT"),
    std::make_pair(1ULL << 10, "VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT"),
    std::make_pair(1ULL << 11, "VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT"),
    std::make_pair(1ULL << 12, "VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT"),
    std::make_pair(1ULL << 13, "VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT"),
    std::make_pair(1ULL << 14, "VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT"),
    std::make_pair(1ULL << 15, "VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT"),
    std::make_pair(1ULL << 16, "VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT"),
    std::make_pair(1ULL << 17, "VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT"),
    std::make_pair(1ULL << 18, "VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT"),
    std::make_pair(1ULL << 19, "VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT"),
    std::make_pair(1ULL << 20, "VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT"),
    std::make_pair(1ULL << 21, "VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT"),
    std::make_pair(1ULL << 22, "VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT"),
    std::make_pair(1ULL << 23, "VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT"),
};
static void print_VkImageCompressionFixedRateFlagBitsEXT(VkImageCompressionFixedRateFlagBitsEXT obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageCompressionFixedRateFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageCompressionFixedRateFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkImageCompressionFixedRateFlagBitsEXT(const VkImageCompressionFixedRateFlagBitsEXT* obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkImageCompressionFixedRateFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkImageCompressionFixedRateFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkImageCompressionFlagsEXT(VkImageCompressionFlagsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkImageCompressionFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkImageCompressionFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkImageCompressionFixedRateFlagsEXT(VkImageCompressionFixedRateFlagsEXT obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkImageCompressionFixedRateFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkImageCompressionFixedRateFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceImageCompressionControlFeaturesEXT(VkPhysicalDeviceImageCompressionControlFeaturesEXT obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.imageCompressionControl, "imageCompressionControl", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageCompressionControlFeaturesEXT(const VkPhysicalDeviceImageCompressionControlFeaturesEXT* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->imageCompressionControl, "imageCompressionControl", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageCompressionControlEXT(VkImageCompressionControlEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageCompressionFlagsEXT(obj.flags, "flags", 1);

    print_uint32_t(obj.compressionControlPlaneCount, "compressionControlPlaneCount", 1);

    PRINT_SPACE
    _OUT << "\"pFixedRateFlags\":" << std::endl;
    PRINT_SPACE
    if (obj.pFixedRateFlags) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.compressionControlPlaneCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.compressionControlPlaneCount;
            print_VkImageCompressionFixedRateFlagsEXT(obj.pFixedRateFlags[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageCompressionControlEXT(const VkImageCompressionControlEXT* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageCompressionFlagsEXT(obj->flags, "flags", 1);

    print_uint32_t(obj->compressionControlPlaneCount, "compressionControlPlaneCount", 1);

    PRINT_SPACE
    _OUT << "\"pFixedRateFlags\":" << std::endl;
    PRINT_SPACE
    if (obj->pFixedRateFlags) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->compressionControlPlaneCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->compressionControlPlaneCount;
            print_VkImageCompressionFixedRateFlagsEXT(obj->pFixedRateFlags[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageCompressionPropertiesEXT(VkImageCompressionPropertiesEXT obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageCompressionFlagsEXT(obj.imageCompressionFlags, "imageCompressionFlags", 1);

    print_VkImageCompressionFixedRateFlagsEXT(obj.imageCompressionFixedRateFlags, "imageCompressionFixedRateFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageCompressionPropertiesEXT(const VkImageCompressionPropertiesEXT* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkImageCompressionFlagsEXT(obj->imageCompressionFlags, "imageCompressionFlags", 1);

    print_VkImageCompressionFixedRateFlagsEXT(obj->imageCompressionFixedRateFlags, "imageCompressionFixedRateFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(
    VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.attachmentFeedbackLoopLayout, "attachmentFeedbackLoopLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(
    const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->attachmentFeedbackLoopLayout, "attachmentFeedbackLoopLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevice4444FormatsFeaturesEXT(VkPhysicalDevice4444FormatsFeaturesEXT obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.formatA4R4G4B4, "formatA4R4G4B4", 1);

    print_VkBool32(obj.formatA4B4G4R4, "formatA4B4G4R4", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevice4444FormatsFeaturesEXT(const VkPhysicalDevice4444FormatsFeaturesEXT* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->formatA4R4G4B4, "formatA4R4G4B4", 1);

    print_VkBool32(obj->formatA4B4G4R4, "formatA4B4G4R4", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkDeviceFaultAddressTypeEXT_map = {
    std::make_pair(0, "VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT"),
    std::make_pair(1, "VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT"),
    std::make_pair(2, "VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT"),
    std::make_pair(3, "VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT"),
    std::make_pair(4, "VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT"),
    std::make_pair(5, "VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT"),
    std::make_pair(6, "VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT"),
};
static void print_VkDeviceFaultAddressTypeEXT(VkDeviceFaultAddressTypeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceFaultAddressTypeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceFaultAddressTypeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDeviceFaultAddressTypeEXT(const VkDeviceFaultAddressTypeEXT* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceFaultAddressTypeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceFaultAddressTypeEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDeviceFaultVendorBinaryHeaderVersionEXT_map = {
    std::make_pair(1, "VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT"),
};
static void print_VkDeviceFaultVendorBinaryHeaderVersionEXT(VkDeviceFaultVendorBinaryHeaderVersionEXT obj, const std::string& str,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceFaultVendorBinaryHeaderVersionEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceFaultVendorBinaryHeaderVersionEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDeviceFaultVendorBinaryHeaderVersionEXT(const VkDeviceFaultVendorBinaryHeaderVersionEXT* obj,
                                                            const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceFaultVendorBinaryHeaderVersionEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceFaultVendorBinaryHeaderVersionEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceFaultFeaturesEXT(VkPhysicalDeviceFaultFeaturesEXT obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.deviceFault, "deviceFault", 1);

    print_VkBool32(obj.deviceFaultVendorBinary, "deviceFaultVendorBinary", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFaultFeaturesEXT(const VkPhysicalDeviceFaultFeaturesEXT* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->deviceFault, "deviceFault", 1);

    print_VkBool32(obj->deviceFaultVendorBinary, "deviceFaultVendorBinary", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceFaultCountsEXT(VkDeviceFaultCountsEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.addressInfoCount, "addressInfoCount", 1);

    print_uint32_t(obj.vendorInfoCount, "vendorInfoCount", 1);

    print_VkDeviceSize(obj.vendorBinarySize, "vendorBinarySize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceFaultCountsEXT(const VkDeviceFaultCountsEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->addressInfoCount, "addressInfoCount", 1);

    print_uint32_t(obj->vendorInfoCount, "vendorInfoCount", 1);

    print_VkDeviceSize(obj->vendorBinarySize, "vendorBinarySize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceFaultAddressInfoEXT(VkDeviceFaultAddressInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceFaultAddressTypeEXT(obj.addressType, "addressType", 1);

    print_VkDeviceAddress(obj.reportedAddress, "reportedAddress", 1);

    print_VkDeviceSize(obj.addressPrecision, "addressPrecision", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceFaultAddressInfoEXT(const VkDeviceFaultAddressInfoEXT* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceFaultAddressTypeEXT(obj->addressType, "addressType", 1);

    print_VkDeviceAddress(obj->reportedAddress, "reportedAddress", 1);

    print_VkDeviceSize(obj->addressPrecision, "addressPrecision", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceFaultVendorInfoEXT(VkDeviceFaultVendorInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint64_t(obj.vendorFaultCode, "vendorFaultCode", 1);

    print_uint64_t(obj.vendorFaultData, "vendorFaultData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceFaultVendorInfoEXT(const VkDeviceFaultVendorInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint64_t(obj->vendorFaultCode, "vendorFaultCode", 1);

    print_uint64_t(obj->vendorFaultData, "vendorFaultData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceFaultInfoEXT(VkDeviceFaultInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"pAddressInfos\": " << std::endl;
    if (obj.pAddressInfos) {
        print_VkDeviceFaultAddressInfoEXT(obj.pAddressInfos, "pAddressInfos", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pVendorInfos\": " << std::endl;
    if (obj.pVendorInfos) {
        print_VkDeviceFaultVendorInfoEXT(obj.pVendorInfos, "pVendorInfos", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceFaultInfoEXT(const VkDeviceFaultInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"pAddressInfos\": " << std::endl;
    if (obj->pAddressInfos) {
        print_VkDeviceFaultAddressInfoEXT(obj->pAddressInfos, "pAddressInfos", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pVendorInfos\": " << std::endl;
    if (obj->pVendorInfos) {
        print_VkDeviceFaultVendorInfoEXT(obj->pVendorInfos, "pVendorInfos", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceFaultVendorBinaryHeaderVersionOneEXT(VkDeviceFaultVendorBinaryHeaderVersionOneEXT obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.headerSize, "headerSize", 1);

    print_VkDeviceFaultVendorBinaryHeaderVersionEXT(obj.headerVersion, "headerVersion", 1);

    print_uint32_t(obj.vendorID, "vendorID", 1);

    print_uint32_t(obj.deviceID, "deviceID", 1);

    print_uint32_t(obj.driverVersion, "driverVersion", 1);

    PRINT_SPACE
    _OUT << "\"pipelineCacheUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj.pipelineCacheUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.applicationNameOffset, "applicationNameOffset", 1);

    print_uint32_t(obj.applicationVersion, "applicationVersion", 1);

    print_uint32_t(obj.engineNameOffset, "engineNameOffset", 1);

    print_uint32_t(obj.engineVersion, "engineVersion", 1);

    print_uint32_t(obj.apiVersion, "apiVersion", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceFaultVendorBinaryHeaderVersionOneEXT(const VkDeviceFaultVendorBinaryHeaderVersionOneEXT* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->headerSize, "headerSize", 1);

    print_VkDeviceFaultVendorBinaryHeaderVersionEXT(obj->headerVersion, "headerVersion", 1);

    print_uint32_t(obj->vendorID, "vendorID", 1);

    print_uint32_t(obj->deviceID, "deviceID", 1);

    print_uint32_t(obj->driverVersion, "driverVersion", 1);

    PRINT_SPACE
    _OUT << "\"pipelineCacheUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj->pipelineCacheUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->applicationNameOffset, "applicationNameOffset", 1);

    print_uint32_t(obj->applicationVersion, "applicationVersion", 1);

    print_uint32_t(obj->engineNameOffset, "engineNameOffset", 1);

    print_uint32_t(obj->engineVersion, "engineVersion", 1);

    print_uint32_t(obj->apiVersion, "apiVersion", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(
    VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.rasterizationOrderColorAttachmentAccess, "rasterizationOrderColorAttachmentAccess", 1);

    print_VkBool32(obj.rasterizationOrderDepthAttachmentAccess, "rasterizationOrderDepthAttachmentAccess", 1);

    print_VkBool32(obj.rasterizationOrderStencilAttachmentAccess, "rasterizationOrderStencilAttachmentAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(
    const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->rasterizationOrderColorAttachmentAccess, "rasterizationOrderColorAttachmentAccess", 1);

    print_VkBool32(obj->rasterizationOrderDepthAttachmentAccess, "rasterizationOrderDepthAttachmentAccess", 1);

    print_VkBool32(obj->rasterizationOrderStencilAttachmentAccess, "rasterizationOrderStencilAttachmentAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM;

static void print_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.formatRgba10x6WithoutYCbCrSampler, "formatRgba10x6WithoutYCbCrSampler", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->formatRgba10x6WithoutYCbCrSampler, "formatRgba10x6WithoutYCbCrSampler", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.mutableDescriptorType, "mutableDescriptorType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->mutableDescriptorType, "mutableDescriptorType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE;

static void print_VkMutableDescriptorTypeListEXT(VkMutableDescriptorTypeListEXT obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.descriptorTypeCount, "descriptorTypeCount", 1);

    PRINT_SPACE
    _OUT << "\"pDescriptorTypes\":" << std::endl;
    PRINT_SPACE
    if (obj.pDescriptorTypes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.descriptorTypeCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.descriptorTypeCount;
            print_VkDescriptorType(obj.pDescriptorTypes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMutableDescriptorTypeListEXT(const VkMutableDescriptorTypeListEXT* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->descriptorTypeCount, "descriptorTypeCount", 1);

    PRINT_SPACE
    _OUT << "\"pDescriptorTypes\":" << std::endl;
    PRINT_SPACE
    if (obj->pDescriptorTypes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->descriptorTypeCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->descriptorTypeCount;
            print_VkDescriptorType(obj->pDescriptorTypes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkMutableDescriptorTypeListEXT VkMutableDescriptorTypeListVALVE;

static void print_VkMutableDescriptorTypeCreateInfoEXT(VkMutableDescriptorTypeCreateInfoEXT obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.mutableDescriptorTypeListCount, "mutableDescriptorTypeListCount", 1);

    PRINT_SPACE
    _OUT << "\"pMutableDescriptorTypeLists\": " << std::endl;
    if (obj.pMutableDescriptorTypeLists) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.mutableDescriptorTypeListCount; i++) {
            if (i + 1 == obj.mutableDescriptorTypeListCount)
                print_VkMutableDescriptorTypeListEXT(obj.pMutableDescriptorTypeLists[i], "pMutableDescriptorTypeLists", 0);
            else
                print_VkMutableDescriptorTypeListEXT(obj.pMutableDescriptorTypeLists[i], "pMutableDescriptorTypeLists", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMutableDescriptorTypeCreateInfoEXT(const VkMutableDescriptorTypeCreateInfoEXT* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->mutableDescriptorTypeListCount, "mutableDescriptorTypeListCount", 1);

    PRINT_SPACE
    _OUT << "\"pMutableDescriptorTypeLists\": " << std::endl;
    if (obj->pMutableDescriptorTypeLists) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->mutableDescriptorTypeListCount; i++) {
            if (i + 1 == obj->mutableDescriptorTypeListCount)
                print_VkMutableDescriptorTypeListEXT(obj->pMutableDescriptorTypeLists[i], "pMutableDescriptorTypeLists", 0);
            else
                print_VkMutableDescriptorTypeListEXT(obj->pMutableDescriptorTypeLists[i], "pMutableDescriptorTypeLists", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkMutableDescriptorTypeCreateInfoEXT VkMutableDescriptorTypeCreateInfoVALVE;

static void print_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.vertexInputDynamicState, "vertexInputDynamicState", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->vertexInputDynamicState, "vertexInputDynamicState", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVertexInputBindingDescription2EXT(VkVertexInputBindingDescription2EXT obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.binding, "binding", 1);

    print_uint32_t(obj.stride, "stride", 1);

    print_VkVertexInputRate(obj.inputRate, "inputRate", 1);

    print_uint32_t(obj.divisor, "divisor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVertexInputBindingDescription2EXT(const VkVertexInputBindingDescription2EXT* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->binding, "binding", 1);

    print_uint32_t(obj->stride, "stride", 1);

    print_VkVertexInputRate(obj->inputRate, "inputRate", 1);

    print_uint32_t(obj->divisor, "divisor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkVertexInputAttributeDescription2EXT(VkVertexInputAttributeDescription2EXT obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.location, "location", 1);

    print_uint32_t(obj.binding, "binding", 1);

    print_VkFormat(obj.format, "format", 1);

    print_uint32_t(obj.offset, "offset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkVertexInputAttributeDescription2EXT(const VkVertexInputAttributeDescription2EXT* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->location, "location", 1);

    print_uint32_t(obj->binding, "binding", 1);

    print_VkFormat(obj->format, "format", 1);

    print_uint32_t(obj->offset, "offset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDrmPropertiesEXT(VkPhysicalDeviceDrmPropertiesEXT obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.hasPrimary, "hasPrimary", 1);

    print_VkBool32(obj.hasRender, "hasRender", 1);

    print_int64_t(obj.primaryMajor, "primaryMajor", 1);

    print_int64_t(obj.primaryMinor, "primaryMinor", 1);

    print_int64_t(obj.renderMajor, "renderMajor", 1);

    print_int64_t(obj.renderMinor, "renderMinor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDrmPropertiesEXT(const VkPhysicalDeviceDrmPropertiesEXT* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->hasPrimary, "hasPrimary", 1);

    print_VkBool32(obj->hasRender, "hasRender", 1);

    print_int64_t(obj->primaryMajor, "primaryMajor", 1);

    print_int64_t(obj->primaryMinor, "primaryMinor", 1);

    print_int64_t(obj->renderMajor, "renderMajor", 1);

    print_int64_t(obj->renderMinor, "renderMinor", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkDeviceAddressBindingFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT"),
};
static void print_VkDeviceAddressBindingFlagBitsEXT(VkDeviceAddressBindingFlagBitsEXT obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceAddressBindingFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceAddressBindingFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDeviceAddressBindingFlagBitsEXT(const VkDeviceAddressBindingFlagBitsEXT* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceAddressBindingFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceAddressBindingFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDeviceAddressBindingTypeEXT_map = {
    std::make_pair(0, "VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT"),
    std::make_pair(1, "VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT"),
};
static void print_VkDeviceAddressBindingTypeEXT(VkDeviceAddressBindingTypeEXT obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceAddressBindingTypeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceAddressBindingTypeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDeviceAddressBindingTypeEXT(const VkDeviceAddressBindingTypeEXT* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDeviceAddressBindingTypeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDeviceAddressBindingTypeEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkDeviceAddressBindingFlagsEXT(VkDeviceAddressBindingFlagsEXT obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkDeviceAddressBindingFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkDeviceAddressBindingFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceAddressBindingReportFeaturesEXT(VkPhysicalDeviceAddressBindingReportFeaturesEXT obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.reportAddressBinding, "reportAddressBinding", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceAddressBindingReportFeaturesEXT(const VkPhysicalDeviceAddressBindingReportFeaturesEXT* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->reportAddressBinding, "reportAddressBinding", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceAddressBindingCallbackDataEXT(VkDeviceAddressBindingCallbackDataEXT obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceAddressBindingFlagsEXT(obj.flags, "flags", 1);

    print_VkDeviceAddress(obj.baseAddress, "baseAddress", 1);

    print_VkDeviceSize(obj.size, "size", 1);

    print_VkDeviceAddressBindingTypeEXT(obj.bindingType, "bindingType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceAddressBindingCallbackDataEXT(const VkDeviceAddressBindingCallbackDataEXT* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceAddressBindingFlagsEXT(obj->flags, "flags", 1);

    print_VkDeviceAddress(obj->baseAddress, "baseAddress", 1);

    print_VkDeviceSize(obj->size, "size", 1);

    print_VkDeviceAddressBindingTypeEXT(obj->bindingType, "bindingType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDepthClipControlFeaturesEXT(VkPhysicalDeviceDepthClipControlFeaturesEXT obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.depthClipControl, "depthClipControl", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDepthClipControlFeaturesEXT(const VkPhysicalDeviceDepthClipControlFeaturesEXT* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->depthClipControl, "depthClipControl", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineViewportDepthClipControlCreateInfoEXT(VkPipelineViewportDepthClipControlCreateInfoEXT obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.negativeOneToOne, "negativeOneToOne", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineViewportDepthClipControlCreateInfoEXT(const VkPipelineViewportDepthClipControlCreateInfoEXT* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->negativeOneToOne, "negativeOneToOne", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(
    VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.primitiveTopologyListRestart, "primitiveTopologyListRestart", 1);

    print_VkBool32(obj.primitiveTopologyPatchListRestart, "primitiveTopologyPatchListRestart", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(
    const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->primitiveTopologyListRestart, "primitiveTopologyListRestart", 1);

    print_VkBool32(obj->primitiveTopologyPatchListRestart, "primitiveTopologyPatchListRestart", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT(VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.presentModeFifoLatestReady, "presentModeFifoLatestReady", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT(
    const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->presentModeFifoLatestReady, "presentModeFifoLatestReady", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubpassShadingPipelineCreateInfoHUAWEI(VkSubpassShadingPipelineCreateInfoHUAWEI obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "renderPass"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.subpass, "subpass", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubpassShadingPipelineCreateInfoHUAWEI(const VkSubpassShadingPipelineCreateInfoHUAWEI* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "renderPass"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->subpass, "subpass", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.subpassShading, "subpassShading", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->subpassShading, "subpassShading", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxSubpassShadingWorkgroupSizeAspectRatio, "maxSubpassShadingWorkgroupSizeAspectRatio", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxSubpassShadingWorkgroupSizeAspectRatio, "maxSubpassShadingWorkgroupSizeAspectRatio", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.invocationMask, "invocationMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->invocationMask, "invocationMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRemoteAddressNV(VkRemoteAddressNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "\"" << str << "\""
         << " : "
         << "\"" << obj << "\"" << (commaNeeded ? "," : "") << std::endl;
}

static void print_VkMemoryGetRemoteAddressInfoNV(VkMemoryGetRemoteAddressInfoNV obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkExternalMemoryHandleTypeFlagBits(obj.handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryGetRemoteAddressInfoNV(const VkMemoryGetRemoteAddressInfoNV* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkExternalMemoryHandleTypeFlagBits(obj->handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.externalMemoryRDMA, "externalMemoryRDMA", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->externalMemoryRDMA, "externalMemoryRDMA", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPipelineInfoKHR VkPipelineInfoEXT;

static void print_VkPipelinePropertiesIdentifierEXT(VkPipelinePropertiesIdentifierEXT obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pipelineIdentifier\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj.pipelineIdentifier[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelinePropertiesIdentifierEXT(const VkPipelinePropertiesIdentifierEXT* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pipelineIdentifier\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj->pipelineIdentifier[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePipelinePropertiesFeaturesEXT(VkPhysicalDevicePipelinePropertiesFeaturesEXT obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.pipelinePropertiesIdentifier, "pipelinePropertiesIdentifier", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePipelinePropertiesFeaturesEXT(const VkPhysicalDevicePipelinePropertiesFeaturesEXT* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->pipelinePropertiesIdentifier, "pipelinePropertiesIdentifier", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkFrameBoundaryFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT"),
};
static void print_VkFrameBoundaryFlagBitsEXT(VkFrameBoundaryFlagBitsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFrameBoundaryFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFrameBoundaryFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkFrameBoundaryFlagBitsEXT(const VkFrameBoundaryFlagBitsEXT* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkFrameBoundaryFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkFrameBoundaryFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkFrameBoundaryFlagsEXT(VkFrameBoundaryFlagsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkFrameBoundaryFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkFrameBoundaryFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceFrameBoundaryFeaturesEXT(VkPhysicalDeviceFrameBoundaryFeaturesEXT obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.frameBoundary, "frameBoundary", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFrameBoundaryFeaturesEXT(const VkPhysicalDeviceFrameBoundaryFeaturesEXT* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->frameBoundary, "frameBoundary", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkFrameBoundaryEXT(VkFrameBoundaryEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFrameBoundaryFlagsEXT(obj.flags, "flags", 1);

    print_uint64_t(obj.frameID, "frameID", 1);

    print_uint32_t(obj.imageCount, "imageCount", 1);

    PRINT_SPACE
    _OUT << "\"pImages\":" << std::endl;
    PRINT_SPACE
    if (obj.pImages) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.imageCount; i++) {
            std::stringstream tmp;
            tmp << "pImages"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.imageCount;
            print_VkImage(obj.pImages[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.bufferCount, "bufferCount", 1);

    PRINT_SPACE
    _OUT << "\"pBuffers\":" << std::endl;
    PRINT_SPACE
    if (obj.pBuffers) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.bufferCount; i++) {
            std::stringstream tmp;
            tmp << "pBuffers"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.bufferCount;
            print_VkBuffer(obj.pBuffers[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.tagName, "tagName", 1);

    print_size_t(obj.tagSize, "tagSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkFrameBoundaryEXT(const VkFrameBoundaryEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFrameBoundaryFlagsEXT(obj->flags, "flags", 1);

    print_uint64_t(obj->frameID, "frameID", 1);

    print_uint32_t(obj->imageCount, "imageCount", 1);

    PRINT_SPACE
    _OUT << "\"pImages\":" << std::endl;
    PRINT_SPACE
    if (obj->pImages) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->imageCount; i++) {
            std::stringstream tmp;
            tmp << "pImages"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->imageCount;
            print_VkImage(obj->pImages[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->bufferCount, "bufferCount", 1);

    PRINT_SPACE
    _OUT << "\"pBuffers\":" << std::endl;
    PRINT_SPACE
    if (obj->pBuffers) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->bufferCount; i++) {
            std::stringstream tmp;
            tmp << "pBuffers"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->bufferCount;
            print_VkBuffer(obj->pBuffers[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->tagName, "tagName", 1);

    print_size_t(obj->tagSize, "tagSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(
    VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.multisampledRenderToSingleSampled, "multisampledRenderToSingleSampled", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(
    const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->multisampledRenderToSingleSampled, "multisampledRenderToSingleSampled", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubpassResolvePerformanceQueryEXT(VkSubpassResolvePerformanceQueryEXT obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.optimal, "optimal", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubpassResolvePerformanceQueryEXT(const VkSubpassResolvePerformanceQueryEXT* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->optimal, "optimal", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMultisampledRenderToSingleSampledInfoEXT(VkMultisampledRenderToSingleSampledInfoEXT obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.multisampledRenderToSingleSampledEnable, "multisampledRenderToSingleSampledEnable", 1);

    print_VkSampleCountFlagBits(obj.rasterizationSamples, "rasterizationSamples", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMultisampledRenderToSingleSampledInfoEXT(const VkMultisampledRenderToSingleSampledInfoEXT* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->multisampledRenderToSingleSampledEnable, "multisampledRenderToSingleSampledEnable", 1);

    print_VkSampleCountFlagBits(obj->rasterizationSamples, "rasterizationSamples", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.extendedDynamicState2, "extendedDynamicState2", 1);

    print_VkBool32(obj.extendedDynamicState2LogicOp, "extendedDynamicState2LogicOp", 1);

    print_VkBool32(obj.extendedDynamicState2PatchControlPoints, "extendedDynamicState2PatchControlPoints", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->extendedDynamicState2, "extendedDynamicState2", 1);

    print_VkBool32(obj->extendedDynamicState2LogicOp, "extendedDynamicState2LogicOp", 1);

    print_VkBool32(obj->extendedDynamicState2PatchControlPoints, "extendedDynamicState2PatchControlPoints", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceColorWriteEnableFeaturesEXT(VkPhysicalDeviceColorWriteEnableFeaturesEXT obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.colorWriteEnable, "colorWriteEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceColorWriteEnableFeaturesEXT(const VkPhysicalDeviceColorWriteEnableFeaturesEXT* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->colorWriteEnable, "colorWriteEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineColorWriteCreateInfoEXT(VkPipelineColorWriteCreateInfoEXT obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.attachmentCount, "attachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorWriteEnables\":" << std::endl;
    PRINT_SPACE
    if (obj.pColorWriteEnables) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.attachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.attachmentCount;
            print_VkBool32(obj.pColorWriteEnables[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineColorWriteCreateInfoEXT(const VkPipelineColorWriteCreateInfoEXT* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->attachmentCount, "attachmentCount", 1);

    PRINT_SPACE
    _OUT << "\"pColorWriteEnables\":" << std::endl;
    PRINT_SPACE
    if (obj->pColorWriteEnables) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->attachmentCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->attachmentCount;
            print_VkBool32(obj->pColorWriteEnables[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.primitivesGeneratedQuery, "primitivesGeneratedQuery", 1);

    print_VkBool32(obj.primitivesGeneratedQueryWithRasterizerDiscard, "primitivesGeneratedQueryWithRasterizerDiscard", 1);

    print_VkBool32(obj.primitivesGeneratedQueryWithNonZeroStreams, "primitivesGeneratedQueryWithNonZeroStreams", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(
    const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->primitivesGeneratedQuery, "primitivesGeneratedQuery", 1);

    print_VkBool32(obj->primitivesGeneratedQueryWithRasterizerDiscard, "primitivesGeneratedQueryWithRasterizerDiscard", 1);

    print_VkBool32(obj->primitivesGeneratedQueryWithNonZeroStreams, "primitivesGeneratedQueryWithNonZeroStreams", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceGlobalPriorityQueryFeatures VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT;

typedef VkQueueFamilyGlobalPriorityProperties VkQueueFamilyGlobalPriorityPropertiesEXT;

static void print_VkPhysicalDeviceImageViewMinLodFeaturesEXT(VkPhysicalDeviceImageViewMinLodFeaturesEXT obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.minLod, "minLod", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageViewMinLodFeaturesEXT(const VkPhysicalDeviceImageViewMinLodFeaturesEXT* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->minLod, "minLod", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageViewMinLodCreateInfoEXT(VkImageViewMinLodCreateInfoEXT obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_float(obj.minLod, "minLod", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageViewMinLodCreateInfoEXT(const VkImageViewMinLodCreateInfoEXT* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_float(obj->minLod, "minLod", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMultiDrawFeaturesEXT(VkPhysicalDeviceMultiDrawFeaturesEXT obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.multiDraw, "multiDraw", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMultiDrawFeaturesEXT(const VkPhysicalDeviceMultiDrawFeaturesEXT* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->multiDraw, "multiDraw", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMultiDrawPropertiesEXT(VkPhysicalDeviceMultiDrawPropertiesEXT obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxMultiDrawCount, "maxMultiDrawCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMultiDrawPropertiesEXT(const VkPhysicalDeviceMultiDrawPropertiesEXT* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxMultiDrawCount, "maxMultiDrawCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMultiDrawInfoEXT(VkMultiDrawInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.firstVertex, "firstVertex", 1);

    print_uint32_t(obj.vertexCount, "vertexCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMultiDrawInfoEXT(const VkMultiDrawInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->firstVertex, "firstVertex", 1);

    print_uint32_t(obj->vertexCount, "vertexCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMultiDrawIndexedInfoEXT(VkMultiDrawIndexedInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.firstIndex, "firstIndex", 1);

    print_uint32_t(obj.indexCount, "indexCount", 1);

    print_int32_t(obj.vertexOffset, "vertexOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMultiDrawIndexedInfoEXT(const VkMultiDrawIndexedInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->firstIndex, "firstIndex", 1);

    print_uint32_t(obj->indexCount, "indexCount", 1);

    print_int32_t(obj->vertexOffset, "vertexOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.image2DViewOf3D, "image2DViewOf3D", 1);

    print_VkBool32(obj.sampler2DViewOf3D, "sampler2DViewOf3D", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->image2DViewOf3D, "image2DViewOf3D", 1);

    print_VkBool32(obj->sampler2DViewOf3D, "sampler2DViewOf3D", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderTileImageFeaturesEXT(VkPhysicalDeviceShaderTileImageFeaturesEXT obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderTileImageColorReadAccess, "shaderTileImageColorReadAccess", 1);

    print_VkBool32(obj.shaderTileImageDepthReadAccess, "shaderTileImageDepthReadAccess", 1);

    print_VkBool32(obj.shaderTileImageStencilReadAccess, "shaderTileImageStencilReadAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderTileImageFeaturesEXT(const VkPhysicalDeviceShaderTileImageFeaturesEXT* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderTileImageColorReadAccess, "shaderTileImageColorReadAccess", 1);

    print_VkBool32(obj->shaderTileImageDepthReadAccess, "shaderTileImageDepthReadAccess", 1);

    print_VkBool32(obj->shaderTileImageStencilReadAccess, "shaderTileImageStencilReadAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderTileImagePropertiesEXT(VkPhysicalDeviceShaderTileImagePropertiesEXT obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderTileImageCoherentReadAccelerated, "shaderTileImageCoherentReadAccelerated", 1);

    print_VkBool32(obj.shaderTileImageReadSampleFromPixelRateInvocation, "shaderTileImageReadSampleFromPixelRateInvocation", 1);

    print_VkBool32(obj.shaderTileImageReadFromHelperInvocation, "shaderTileImageReadFromHelperInvocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderTileImagePropertiesEXT(const VkPhysicalDeviceShaderTileImagePropertiesEXT* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderTileImageCoherentReadAccelerated, "shaderTileImageCoherentReadAccelerated", 1);

    print_VkBool32(obj->shaderTileImageReadSampleFromPixelRateInvocation, "shaderTileImageReadSampleFromPixelRateInvocation", 1);

    print_VkBool32(obj->shaderTileImageReadFromHelperInvocation, "shaderTileImageReadFromHelperInvocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMicromapEXT(VkMicromapEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkMicromapTypeEXT_map = {
    std::make_pair(0, "VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT"),
    std::make_pair(1000397000, "VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV"),
};
static void print_VkMicromapTypeEXT(VkMicromapTypeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMicromapTypeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMicromapTypeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkMicromapTypeEXT(const VkMicromapTypeEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMicromapTypeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMicromapTypeEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkBuildMicromapFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT"),
    std::make_pair(1ULL << 1, "VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT"),
    std::make_pair(1ULL << 2, "VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT"),
};
static void print_VkBuildMicromapFlagBitsEXT(VkBuildMicromapFlagBitsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBuildMicromapFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBuildMicromapFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkBuildMicromapFlagBitsEXT(const VkBuildMicromapFlagBitsEXT* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBuildMicromapFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBuildMicromapFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkBuildMicromapModeEXT_map = {
    std::make_pair(0, "VK_BUILD_MICROMAP_MODE_BUILD_EXT"),
};
static void print_VkBuildMicromapModeEXT(VkBuildMicromapModeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBuildMicromapModeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBuildMicromapModeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkBuildMicromapModeEXT(const VkBuildMicromapModeEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBuildMicromapModeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBuildMicromapModeEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkMicromapCreateFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT"),
};
static void print_VkMicromapCreateFlagBitsEXT(VkMicromapCreateFlagBitsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMicromapCreateFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMicromapCreateFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkMicromapCreateFlagBitsEXT(const VkMicromapCreateFlagBitsEXT* obj, const std::string& str,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMicromapCreateFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMicromapCreateFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkCopyMicromapModeEXT_map = {
    std::make_pair(0, "VK_COPY_MICROMAP_MODE_CLONE_EXT"),
    std::make_pair(1, "VK_COPY_MICROMAP_MODE_SERIALIZE_EXT"),
    std::make_pair(2, "VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT"),
    std::make_pair(3, "VK_COPY_MICROMAP_MODE_COMPACT_EXT"),
};
static void print_VkCopyMicromapModeEXT(VkCopyMicromapModeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCopyMicromapModeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCopyMicromapModeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkCopyMicromapModeEXT(const VkCopyMicromapModeEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCopyMicromapModeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCopyMicromapModeEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkOpacityMicromapFormatEXT_map = {
    std::make_pair(1, "VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT"),
    std::make_pair(2, "VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT"),
};
static void print_VkOpacityMicromapFormatEXT(VkOpacityMicromapFormatEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpacityMicromapFormatEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpacityMicromapFormatEXT_map[obj] << "\"" << std::endl;
}
static void print_VkOpacityMicromapFormatEXT(const VkOpacityMicromapFormatEXT* obj, const std::string& str,
                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpacityMicromapFormatEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpacityMicromapFormatEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkOpacityMicromapSpecialIndexEXT_map = {
    std::make_pair(-1, "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT"),
    std::make_pair(-2, "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT"),
    std::make_pair(-3, "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT"),
    std::make_pair(-4, "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT"),
    std::make_pair(-5, "VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV"),
};
static void print_VkOpacityMicromapSpecialIndexEXT(VkOpacityMicromapSpecialIndexEXT obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpacityMicromapSpecialIndexEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpacityMicromapSpecialIndexEXT_map[obj] << "\"" << std::endl;
}
static void print_VkOpacityMicromapSpecialIndexEXT(const VkOpacityMicromapSpecialIndexEXT* obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpacityMicromapSpecialIndexEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpacityMicromapSpecialIndexEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAccelerationStructureCompatibilityKHR_map = {
    std::make_pair(0, "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR"),
    std::make_pair(1, "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR"),
};
static void print_VkAccelerationStructureCompatibilityKHR(VkAccelerationStructureCompatibilityKHR obj, const std::string& str,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureCompatibilityKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureCompatibilityKHR_map[obj] << "\"" << std::endl;
}
static void print_VkAccelerationStructureCompatibilityKHR(const VkAccelerationStructureCompatibilityKHR* obj,
                                                          const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureCompatibilityKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureCompatibilityKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAccelerationStructureBuildTypeKHR_map = {
    std::make_pair(0, "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR"),
    std::make_pair(1, "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR"),
    std::make_pair(2, "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR"),
};
static void print_VkAccelerationStructureBuildTypeKHR(VkAccelerationStructureBuildTypeKHR obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureBuildTypeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureBuildTypeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkAccelerationStructureBuildTypeKHR(const VkAccelerationStructureBuildTypeKHR* obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureBuildTypeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureBuildTypeKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkBuildMicromapFlagsEXT(VkBuildMicromapFlagsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkBuildMicromapFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkBuildMicromapFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkMicromapCreateFlagsEXT(VkMicromapCreateFlagsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkMicromapCreateFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkMicromapCreateFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkMicromapUsageEXT(VkMicromapUsageEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.count, "count", 1);

    print_uint32_t(obj.subdivisionLevel, "subdivisionLevel", 1);

    print_uint32_t(obj.format, "format", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMicromapUsageEXT(const VkMicromapUsageEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->count, "count", 1);

    print_uint32_t(obj->subdivisionLevel, "subdivisionLevel", 1);

    print_uint32_t(obj->format, "format", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDeviceOrHostAddressKHR(VkDeviceOrHostAddressKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.deviceAddress, "deviceAddress", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceOrHostAddressKHR(const VkDeviceOrHostAddressKHR* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->deviceAddress, "deviceAddress", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMicromapBuildInfoEXT(VkMicromapBuildInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMicromapTypeEXT(obj.type, "type", 1);

    print_VkBuildMicromapFlagsEXT(obj.flags, "flags", 1);

    print_VkBuildMicromapModeEXT(obj.mode, "mode", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstMicromap"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.usageCountsCount, "usageCountsCount", 1);

    PRINT_SPACE
    _OUT << "\"pUsageCounts\": " << std::endl;
    if (obj.pUsageCounts) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.usageCountsCount; i++) {
            if (i + 1 == obj.usageCountsCount)
                print_VkMicromapUsageEXT(obj.pUsageCounts[i], "pUsageCounts", 0);
            else
                print_VkMicromapUsageEXT(obj.pUsageCounts[i], "pUsageCounts", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"ppUsageCounts\": " << std::endl;
    if (obj.ppUsageCounts) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.usageCountsCount; i++) {
            if (i + 1 == obj.usageCountsCount)
                print_VkMicromapUsageEXT(obj.ppUsageCounts[i], "ppUsageCounts", 0);
            else
                print_VkMicromapUsageEXT(obj.ppUsageCounts[i], "ppUsageCounts", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkDeviceOrHostAddressConstKHR(obj.data, "data", 1);

    print_VkDeviceOrHostAddressKHR(obj.scratchData, "scratchData", 1);

    print_VkDeviceOrHostAddressConstKHR(obj.triangleArray, "triangleArray", 1);

    print_VkDeviceSize(obj.triangleArrayStride, "triangleArrayStride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMicromapBuildInfoEXT(const VkMicromapBuildInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMicromapTypeEXT(obj->type, "type", 1);

    print_VkBuildMicromapFlagsEXT(obj->flags, "flags", 1);

    print_VkBuildMicromapModeEXT(obj->mode, "mode", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstMicromap"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->usageCountsCount, "usageCountsCount", 1);

    PRINT_SPACE
    _OUT << "\"pUsageCounts\": " << std::endl;
    if (obj->pUsageCounts) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->usageCountsCount; i++) {
            if (i + 1 == obj->usageCountsCount)
                print_VkMicromapUsageEXT(obj->pUsageCounts[i], "pUsageCounts", 0);
            else
                print_VkMicromapUsageEXT(obj->pUsageCounts[i], "pUsageCounts", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"ppUsageCounts\": " << std::endl;
    if (obj->ppUsageCounts) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->usageCountsCount; i++) {
            if (i + 1 == obj->usageCountsCount)
                print_VkMicromapUsageEXT(obj->ppUsageCounts[i], "ppUsageCounts", 0);
            else
                print_VkMicromapUsageEXT(obj->ppUsageCounts[i], "ppUsageCounts", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkDeviceOrHostAddressConstKHR(obj->data, "data", 1);

    print_VkDeviceOrHostAddressKHR(obj->scratchData, "scratchData", 1);

    print_VkDeviceOrHostAddressConstKHR(obj->triangleArray, "triangleArray", 1);

    print_VkDeviceSize(obj->triangleArrayStride, "triangleArrayStride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMicromapCreateInfoEXT(VkMicromapCreateInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMicromapCreateFlagsEXT(obj.createFlags, "createFlags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.offset, "offset", 1);

    print_VkDeviceSize(obj.size, "size", 1);

    print_VkMicromapTypeEXT(obj.type, "type", 1);

    print_VkDeviceAddress(obj.deviceAddress, "deviceAddress", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMicromapCreateInfoEXT(const VkMicromapCreateInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMicromapCreateFlagsEXT(obj->createFlags, "createFlags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->offset, "offset", 1);

    print_VkDeviceSize(obj->size, "size", 1);

    print_VkMicromapTypeEXT(obj->type, "type", 1);

    print_VkDeviceAddress(obj->deviceAddress, "deviceAddress", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceOpacityMicromapFeaturesEXT(VkPhysicalDeviceOpacityMicromapFeaturesEXT obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.micromap, "micromap", 1);

    print_VkBool32(obj.micromapCaptureReplay, "micromapCaptureReplay", 1);

    print_VkBool32(obj.micromapHostCommands, "micromapHostCommands", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceOpacityMicromapFeaturesEXT(const VkPhysicalDeviceOpacityMicromapFeaturesEXT* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->micromap, "micromap", 1);

    print_VkBool32(obj->micromapCaptureReplay, "micromapCaptureReplay", 1);

    print_VkBool32(obj->micromapHostCommands, "micromapHostCommands", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceOpacityMicromapPropertiesEXT(VkPhysicalDeviceOpacityMicromapPropertiesEXT obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxOpacity2StateSubdivisionLevel, "maxOpacity2StateSubdivisionLevel", 1);

    print_uint32_t(obj.maxOpacity4StateSubdivisionLevel, "maxOpacity4StateSubdivisionLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceOpacityMicromapPropertiesEXT(const VkPhysicalDeviceOpacityMicromapPropertiesEXT* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxOpacity2StateSubdivisionLevel, "maxOpacity2StateSubdivisionLevel", 1);

    print_uint32_t(obj->maxOpacity4StateSubdivisionLevel, "maxOpacity4StateSubdivisionLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMicromapVersionInfoEXT(VkMicromapVersionInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint8_t(obj.pVersionData, "pVersionData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMicromapVersionInfoEXT(const VkMicromapVersionInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint8_t(obj->pVersionData, "pVersionData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCopyMicromapToMemoryInfoEXT(VkCopyMicromapToMemoryInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "src"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceOrHostAddressKHR(obj.dst, "dst", 1);

    print_VkCopyMicromapModeEXT(obj.mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyMicromapToMemoryInfoEXT(const VkCopyMicromapToMemoryInfoEXT* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "src"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceOrHostAddressKHR(obj->dst, "dst", 1);

    print_VkCopyMicromapModeEXT(obj->mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCopyMemoryToMicromapInfoEXT(VkCopyMemoryToMicromapInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceOrHostAddressConstKHR(obj.src, "src", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dst"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkCopyMicromapModeEXT(obj.mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyMemoryToMicromapInfoEXT(const VkCopyMemoryToMicromapInfoEXT* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceOrHostAddressConstKHR(obj->src, "src", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dst"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkCopyMicromapModeEXT(obj->mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCopyMicromapInfoEXT(VkCopyMicromapInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "src"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dst"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkCopyMicromapModeEXT(obj.mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyMicromapInfoEXT(const VkCopyMicromapInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "src"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dst"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkCopyMicromapModeEXT(obj->mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMicromapBuildSizesInfoEXT(VkMicromapBuildSizesInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj.micromapSize, "micromapSize", 1);

    print_VkDeviceSize(obj.buildScratchSize, "buildScratchSize", 1);

    print_VkBool32(obj.discardable, "discardable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMicromapBuildSizesInfoEXT(const VkMicromapBuildSizesInfoEXT* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj->micromapSize, "micromapSize", 1);

    print_VkDeviceSize(obj->buildScratchSize, "buildScratchSize", 1);

    print_VkBool32(obj->discardable, "discardable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureTrianglesOpacityMicromapEXT(VkAccelerationStructureTrianglesOpacityMicromapEXT obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkIndexType(obj.indexType, "indexType", 1);

    print_VkDeviceOrHostAddressConstKHR(obj.indexBuffer, "indexBuffer", 1);

    print_VkDeviceSize(obj.indexStride, "indexStride", 1);

    print_uint32_t(obj.baseTriangle, "baseTriangle", 1);

    print_uint32_t(obj.usageCountsCount, "usageCountsCount", 1);

    PRINT_SPACE
    _OUT << "\"pUsageCounts\": " << std::endl;
    if (obj.pUsageCounts) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.usageCountsCount; i++) {
            if (i + 1 == obj.usageCountsCount)
                print_VkMicromapUsageEXT(obj.pUsageCounts[i], "pUsageCounts", 0);
            else
                print_VkMicromapUsageEXT(obj.pUsageCounts[i], "pUsageCounts", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"ppUsageCounts\": " << std::endl;
    if (obj.ppUsageCounts) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.usageCountsCount; i++) {
            if (i + 1 == obj.usageCountsCount)
                print_VkMicromapUsageEXT(obj.ppUsageCounts[i], "ppUsageCounts", 0);
            else
                print_VkMicromapUsageEXT(obj.ppUsageCounts[i], "ppUsageCounts", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "micromap"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureTrianglesOpacityMicromapEXT(const VkAccelerationStructureTrianglesOpacityMicromapEXT* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkIndexType(obj->indexType, "indexType", 1);

    print_VkDeviceOrHostAddressConstKHR(obj->indexBuffer, "indexBuffer", 1);

    print_VkDeviceSize(obj->indexStride, "indexStride", 1);

    print_uint32_t(obj->baseTriangle, "baseTriangle", 1);

    print_uint32_t(obj->usageCountsCount, "usageCountsCount", 1);

    PRINT_SPACE
    _OUT << "\"pUsageCounts\": " << std::endl;
    if (obj->pUsageCounts) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->usageCountsCount; i++) {
            if (i + 1 == obj->usageCountsCount)
                print_VkMicromapUsageEXT(obj->pUsageCounts[i], "pUsageCounts", 0);
            else
                print_VkMicromapUsageEXT(obj->pUsageCounts[i], "pUsageCounts", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"ppUsageCounts\": " << std::endl;
    if (obj->ppUsageCounts) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->usageCountsCount; i++) {
            if (i + 1 == obj->usageCountsCount)
                print_VkMicromapUsageEXT(obj->ppUsageCounts[i], "ppUsageCounts", 0);
            else
                print_VkMicromapUsageEXT(obj->ppUsageCounts[i], "ppUsageCounts", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "micromap"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMicromapTriangleEXT(VkMicromapTriangleEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.dataOffset, "dataOffset", 1);

    print_uint16_t(obj.subdivisionLevel, "subdivisionLevel", 1);

    print_uint16_t(obj.format, "format", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMicromapTriangleEXT(const VkMicromapTriangleEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->dataOffset, "dataOffset", 1);

    print_uint16_t(obj->subdivisionLevel, "subdivisionLevel", 1);

    print_uint16_t(obj->format, "format", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.clustercullingShader, "clustercullingShader", 1);

    print_VkBool32(obj.multiviewClusterCullingShader, "multiviewClusterCullingShader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->clustercullingShader, "clustercullingShader", 1);

    print_VkBool32(obj->multiviewClusterCullingShader, "multiviewClusterCullingShader", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"maxWorkGroupCount\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj.maxWorkGroupCount[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"maxWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj.maxWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.maxOutputClusterCount, "maxOutputClusterCount", 1);

    print_VkDeviceSize(obj.indirectBufferOffsetAlignment, "indirectBufferOffsetAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(
    const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"maxWorkGroupCount\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj->maxWorkGroupCount[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    PRINT_SPACE
    _OUT << "\"maxWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj->maxWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->maxOutputClusterCount, "maxOutputClusterCount", 1);

    print_VkDeviceSize(obj->indirectBufferOffsetAlignment, "indirectBufferOffsetAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.clusterShadingRate, "clusterShadingRate", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(
    const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->clusterShadingRate, "clusterShadingRate", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.borderColorSwizzle, "borderColorSwizzle", 1);

    print_VkBool32(obj.borderColorSwizzleFromImage, "borderColorSwizzleFromImage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->borderColorSwizzle, "borderColorSwizzle", 1);

    print_VkBool32(obj->borderColorSwizzleFromImage, "borderColorSwizzleFromImage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSamplerBorderColorComponentMappingCreateInfoEXT(VkSamplerBorderColorComponentMappingCreateInfoEXT obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"components\": " << std::endl;
    { print_VkComponentMapping(obj.components, "components", 1); }

    print_VkBool32(obj.srgb, "srgb", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSamplerBorderColorComponentMappingCreateInfoEXT(const VkSamplerBorderColorComponentMappingCreateInfoEXT* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"components\": " << std::endl;
    { print_VkComponentMapping(obj->components, "components", 1); }

    print_VkBool32(obj->srgb, "srgb", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.pageableDeviceLocalMemory, "pageableDeviceLocalMemory", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(
    const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->pageableDeviceLocalMemory, "pageableDeviceLocalMemory", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderCorePropertiesARM(VkPhysicalDeviceShaderCorePropertiesARM obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.pixelRate, "pixelRate", 1);

    print_uint32_t(obj.texelRate, "texelRate", 1);

    print_uint32_t(obj.fmaRate, "fmaRate", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderCorePropertiesARM(const VkPhysicalDeviceShaderCorePropertiesARM* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->pixelRate, "pixelRate", 1);

    print_uint32_t(obj->texelRate, "texelRate", 1);

    print_uint32_t(obj->fmaRate, "fmaRate", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkPhysicalDeviceSchedulingControlsFlagBitsARM_map = {
    std::make_pair(1ULL << 0, "VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM"),
};
static void print_VkPhysicalDeviceSchedulingControlsFlagBitsARM(VkPhysicalDeviceSchedulingControlsFlagBitsARM obj,
                                                                const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPhysicalDeviceSchedulingControlsFlagBitsARM_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPhysicalDeviceSchedulingControlsFlagBitsARM_map[obj] << "\"" << std::endl;
}
static void print_VkPhysicalDeviceSchedulingControlsFlagBitsARM(const VkPhysicalDeviceSchedulingControlsFlagBitsARM* obj,
                                                                const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPhysicalDeviceSchedulingControlsFlagBitsARM_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPhysicalDeviceSchedulingControlsFlagBitsARM_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceSchedulingControlsFlagsARM(VkPhysicalDeviceSchedulingControlsFlagsARM obj, const std::string& str,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkDeviceQueueShaderCoreControlCreateInfoARM(VkDeviceQueueShaderCoreControlCreateInfoARM obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.shaderCoreCount, "shaderCoreCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDeviceQueueShaderCoreControlCreateInfoARM(const VkDeviceQueueShaderCoreControlCreateInfoARM* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->shaderCoreCount, "shaderCoreCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceSchedulingControlsFeaturesARM(VkPhysicalDeviceSchedulingControlsFeaturesARM obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.schedulingControls, "schedulingControls", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSchedulingControlsFeaturesARM(const VkPhysicalDeviceSchedulingControlsFeaturesARM* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->schedulingControls, "schedulingControls", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceSchedulingControlsPropertiesARM(VkPhysicalDeviceSchedulingControlsPropertiesARM obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPhysicalDeviceSchedulingControlsFlagsARM(obj.schedulingControlsFlags, "schedulingControlsFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSchedulingControlsPropertiesARM(const VkPhysicalDeviceSchedulingControlsPropertiesARM* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPhysicalDeviceSchedulingControlsFlagsARM(obj->schedulingControlsFlags, "schedulingControlsFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.imageSlicedViewOf3D, "imageSlicedViewOf3D", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->imageSlicedViewOf3D, "imageSlicedViewOf3D", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageViewSlicedCreateInfoEXT(VkImageViewSlicedCreateInfoEXT obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.sliceOffset, "sliceOffset", 1);

    print_uint32_t(obj.sliceCount, "sliceCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageViewSlicedCreateInfoEXT(const VkImageViewSlicedCreateInfoEXT* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->sliceOffset, "sliceOffset", 1);

    print_uint32_t(obj->sliceCount, "sliceCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.descriptorSetHostMapping, "descriptorSetHostMapping", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(
    const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->descriptorSetHostMapping, "descriptorSetHostMapping", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorSetBindingReferenceVALVE(VkDescriptorSetBindingReferenceVALVE obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "descriptorSetLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.binding, "binding", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorSetBindingReferenceVALVE(const VkDescriptorSetBindingReferenceVALVE* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "descriptorSetLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->binding, "binding", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDescriptorSetLayoutHostMappingInfoVALVE(VkDescriptorSetLayoutHostMappingInfoVALVE obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_size_t(obj.descriptorOffset, "descriptorOffset", 1);

    print_uint32_t(obj.descriptorSize, "descriptorSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDescriptorSetLayoutHostMappingInfoVALVE(const VkDescriptorSetLayoutHostMappingInfoVALVE* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_size_t(obj->descriptorOffset, "descriptorOffset", 1);

    print_uint32_t(obj->descriptorSize, "descriptorSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDeviceDepthClampZeroOneFeaturesKHR VkPhysicalDeviceDepthClampZeroOneFeaturesEXT;

static void print_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.nonSeamlessCubeMap, "nonSeamlessCubeMap", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->nonSeamlessCubeMap, "nonSeamlessCubeMap", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRenderPassStripedFeaturesARM(VkPhysicalDeviceRenderPassStripedFeaturesARM obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.renderPassStriped, "renderPassStriped", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRenderPassStripedFeaturesARM(const VkPhysicalDeviceRenderPassStripedFeaturesARM* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->renderPassStriped, "renderPassStriped", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRenderPassStripedPropertiesARM(VkPhysicalDeviceRenderPassStripedPropertiesARM obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"renderPassStripeGranularity\": " << std::endl;
    { print_VkExtent2D(obj.renderPassStripeGranularity, "renderPassStripeGranularity", 1); }

    print_uint32_t(obj.maxRenderPassStripes, "maxRenderPassStripes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRenderPassStripedPropertiesARM(const VkPhysicalDeviceRenderPassStripedPropertiesARM* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"renderPassStripeGranularity\": " << std::endl;
    { print_VkExtent2D(obj->renderPassStripeGranularity, "renderPassStripeGranularity", 1); }

    print_uint32_t(obj->maxRenderPassStripes, "maxRenderPassStripes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassStripeInfoARM(VkRenderPassStripeInfoARM obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"stripeArea\": " << std::endl;
    { print_VkRect2D(obj.stripeArea, "stripeArea", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassStripeInfoARM(const VkRenderPassStripeInfoARM* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"stripeArea\": " << std::endl;
    { print_VkRect2D(obj->stripeArea, "stripeArea", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassStripeBeginInfoARM(VkRenderPassStripeBeginInfoARM obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.stripeInfoCount, "stripeInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pStripeInfos\": " << std::endl;
    if (obj.pStripeInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stripeInfoCount; i++) {
            if (i + 1 == obj.stripeInfoCount)
                print_VkRenderPassStripeInfoARM(obj.pStripeInfos[i], "pStripeInfos", 0);
            else
                print_VkRenderPassStripeInfoARM(obj.pStripeInfos[i], "pStripeInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassStripeBeginInfoARM(const VkRenderPassStripeBeginInfoARM* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->stripeInfoCount, "stripeInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pStripeInfos\": " << std::endl;
    if (obj->pStripeInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stripeInfoCount; i++) {
            if (i + 1 == obj->stripeInfoCount)
                print_VkRenderPassStripeInfoARM(obj->pStripeInfos[i], "pStripeInfos", 0);
            else
                print_VkRenderPassStripeInfoARM(obj->pStripeInfos[i], "pStripeInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassStripeSubmitInfoARM(VkRenderPassStripeSubmitInfoARM obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.stripeSemaphoreInfoCount, "stripeSemaphoreInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pStripeSemaphoreInfos\": " << std::endl;
    if (obj.pStripeSemaphoreInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stripeSemaphoreInfoCount; i++) {
            if (i + 1 == obj.stripeSemaphoreInfoCount)
                print_VkSemaphoreSubmitInfo(obj.pStripeSemaphoreInfos[i], "pStripeSemaphoreInfos", 0);
            else
                print_VkSemaphoreSubmitInfo(obj.pStripeSemaphoreInfos[i], "pStripeSemaphoreInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassStripeSubmitInfoARM(const VkRenderPassStripeSubmitInfoARM* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->stripeSemaphoreInfoCount, "stripeSemaphoreInfoCount", 1);

    PRINT_SPACE
    _OUT << "\"pStripeSemaphoreInfos\": " << std::endl;
    if (obj->pStripeSemaphoreInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stripeSemaphoreInfoCount; i++) {
            if (i + 1 == obj->stripeSemaphoreInfoCount)
                print_VkSemaphoreSubmitInfo(obj->pStripeSemaphoreInfos[i], "pStripeSemaphoreInfos", 0);
            else
                print_VkSemaphoreSubmitInfo(obj->pStripeSemaphoreInfos[i], "pStripeSemaphoreInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.fragmentDensityMapOffset, "fragmentDensityMapOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM(
    const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->fragmentDensityMapOffset, "fragmentDensityMapOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM obj,
                                                                         const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"fragmentDensityOffsetGranularity\": " << std::endl;
    { print_VkExtent2D(obj.fragmentDensityOffsetGranularity, "fragmentDensityOffsetGranularity", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM(
    const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"fragmentDensityOffsetGranularity\": " << std::endl;
    { print_VkExtent2D(obj->fragmentDensityOffsetGranularity, "fragmentDensityOffsetGranularity", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSubpassFragmentDensityMapOffsetEndInfoQCOM(VkSubpassFragmentDensityMapOffsetEndInfoQCOM obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.fragmentDensityOffsetCount, "fragmentDensityOffsetCount", 1);

    PRINT_SPACE
    _OUT << "\"pFragmentDensityOffsets\": " << std::endl;
    if (obj.pFragmentDensityOffsets) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.fragmentDensityOffsetCount; i++) {
            if (i + 1 == obj.fragmentDensityOffsetCount)
                print_VkOffset2D(obj.pFragmentDensityOffsets[i], "pFragmentDensityOffsets", 0);
            else
                print_VkOffset2D(obj.pFragmentDensityOffsets[i], "pFragmentDensityOffsets", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSubpassFragmentDensityMapOffsetEndInfoQCOM(const VkSubpassFragmentDensityMapOffsetEndInfoQCOM* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->fragmentDensityOffsetCount, "fragmentDensityOffsetCount", 1);

    PRINT_SPACE
    _OUT << "\"pFragmentDensityOffsets\": " << std::endl;
    if (obj->pFragmentDensityOffsets) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->fragmentDensityOffsetCount; i++) {
            if (i + 1 == obj->fragmentDensityOffsetCount)
                print_VkOffset2D(obj->pFragmentDensityOffsets[i], "pFragmentDensityOffsets", 0);
            else
                print_VkOffset2D(obj->pFragmentDensityOffsets[i], "pFragmentDensityOffsets", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCopyMemoryIndirectCommandNV(VkCopyMemoryIndirectCommandNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.srcAddress, "srcAddress", 1);

    print_VkDeviceAddress(obj.dstAddress, "dstAddress", 1);

    print_VkDeviceSize(obj.size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyMemoryIndirectCommandNV(const VkCopyMemoryIndirectCommandNV* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->srcAddress, "srcAddress", 1);

    print_VkDeviceAddress(obj->dstAddress, "dstAddress", 1);

    print_VkDeviceSize(obj->size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCopyMemoryToImageIndirectCommandNV(VkCopyMemoryToImageIndirectCommandNV obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.srcAddress, "srcAddress", 1);

    print_uint32_t(obj.bufferRowLength, "bufferRowLength", 1);

    print_uint32_t(obj.bufferImageHeight, "bufferImageHeight", 1);

    PRINT_SPACE
    _OUT << "\"imageSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj.imageSubresource, "imageSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"imageOffset\": " << std::endl;
    { print_VkOffset3D(obj.imageOffset, "imageOffset", 1); }

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent3D(obj.imageExtent, "imageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyMemoryToImageIndirectCommandNV(const VkCopyMemoryToImageIndirectCommandNV* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->srcAddress, "srcAddress", 1);

    print_uint32_t(obj->bufferRowLength, "bufferRowLength", 1);

    print_uint32_t(obj->bufferImageHeight, "bufferImageHeight", 1);

    PRINT_SPACE
    _OUT << "\"imageSubresource\": " << std::endl;
    { print_VkImageSubresourceLayers(obj->imageSubresource, "imageSubresource", 1); }

    PRINT_SPACE
    _OUT << "\"imageOffset\": " << std::endl;
    { print_VkOffset3D(obj->imageOffset, "imageOffset", 1); }

    PRINT_SPACE
    _OUT << "\"imageExtent\": " << std::endl;
    { print_VkExtent3D(obj->imageExtent, "imageExtent", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCopyMemoryIndirectFeaturesNV(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.indirectCopy, "indirectCopy", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCopyMemoryIndirectFeaturesNV(const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->indirectCopy, "indirectCopy", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCopyMemoryIndirectPropertiesNV(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkQueueFlags(obj.supportedQueues, "supportedQueues", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCopyMemoryIndirectPropertiesNV(const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkQueueFlags(obj->supportedQueues, "supportedQueues", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkMemoryDecompressionMethodFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV"),
};
static void print_VkMemoryDecompressionMethodFlagBitsNV(VkMemoryDecompressionMethodFlagBitsNV obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryDecompressionMethodFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryDecompressionMethodFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkMemoryDecompressionMethodFlagBitsNV(const VkMemoryDecompressionMethodFlagBitsNV* obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkMemoryDecompressionMethodFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkMemoryDecompressionMethodFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static void print_VkMemoryDecompressionMethodFlagsNV(VkMemoryDecompressionMethodFlagsNV obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkDecompressMemoryRegionNV(VkDecompressMemoryRegionNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.srcAddress, "srcAddress", 1);

    print_VkDeviceAddress(obj.dstAddress, "dstAddress", 1);

    print_VkDeviceSize(obj.compressedSize, "compressedSize", 1);

    print_VkDeviceSize(obj.decompressedSize, "decompressedSize", 1);

    print_VkMemoryDecompressionMethodFlagsNV(obj.decompressionMethod, "decompressionMethod", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDecompressMemoryRegionNV(const VkDecompressMemoryRegionNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->srcAddress, "srcAddress", 1);

    print_VkDeviceAddress(obj->dstAddress, "dstAddress", 1);

    print_VkDeviceSize(obj->compressedSize, "compressedSize", 1);

    print_VkDeviceSize(obj->decompressedSize, "decompressedSize", 1);

    print_VkMemoryDecompressionMethodFlagsNV(obj->decompressionMethod, "decompressionMethod", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMemoryDecompressionFeaturesNV(VkPhysicalDeviceMemoryDecompressionFeaturesNV obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.memoryDecompression, "memoryDecompression", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMemoryDecompressionFeaturesNV(const VkPhysicalDeviceMemoryDecompressionFeaturesNV* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->memoryDecompression, "memoryDecompression", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMemoryDecompressionPropertiesNV(VkPhysicalDeviceMemoryDecompressionPropertiesNV obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMemoryDecompressionMethodFlagsNV(obj.decompressionMethods, "decompressionMethods", 1);

    print_uint64_t(obj.maxDecompressionIndirectCount, "maxDecompressionIndirectCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMemoryDecompressionPropertiesNV(const VkPhysicalDeviceMemoryDecompressionPropertiesNV* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkMemoryDecompressionMethodFlagsNV(obj->decompressionMethods, "decompressionMethods", 1);

    print_uint64_t(obj->maxDecompressionIndirectCount, "maxDecompressionIndirectCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV(
    VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.deviceGeneratedCompute, "deviceGeneratedCompute", 1);

    print_VkBool32(obj.deviceGeneratedComputePipelines, "deviceGeneratedComputePipelines", 1);

    print_VkBool32(obj.deviceGeneratedComputeCaptureReplay, "deviceGeneratedComputeCaptureReplay", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV(
    const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->deviceGeneratedCompute, "deviceGeneratedCompute", 1);

    print_VkBool32(obj->deviceGeneratedComputePipelines, "deviceGeneratedComputePipelines", 1);

    print_VkBool32(obj->deviceGeneratedComputeCaptureReplay, "deviceGeneratedComputeCaptureReplay", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkComputePipelineIndirectBufferInfoNV(VkComputePipelineIndirectBufferInfoNV obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceAddress(obj.deviceAddress, "deviceAddress", 1);

    print_VkDeviceSize(obj.size, "size", 1);

    print_VkDeviceAddress(obj.pipelineDeviceAddressCaptureReplay, "pipelineDeviceAddressCaptureReplay", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkComputePipelineIndirectBufferInfoNV(const VkComputePipelineIndirectBufferInfoNV* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceAddress(obj->deviceAddress, "deviceAddress", 1);

    print_VkDeviceSize(obj->size, "size", 1);

    print_VkDeviceAddress(obj->pipelineDeviceAddressCaptureReplay, "pipelineDeviceAddressCaptureReplay", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineIndirectDeviceAddressInfoNV(VkPipelineIndirectDeviceAddressInfoNV obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineBindPoint(obj.pipelineBindPoint, "pipelineBindPoint", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineIndirectDeviceAddressInfoNV(const VkPipelineIndirectDeviceAddressInfoNV* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineBindPoint(obj->pipelineBindPoint, "pipelineBindPoint", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindPipelineIndirectCommandNV(VkBindPipelineIndirectCommandNV obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.pipelineAddress, "pipelineAddress", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindPipelineIndirectCommandNV(const VkBindPipelineIndirectCommandNV* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->pipelineAddress, "pipelineAddress", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkRayTracingLssIndexingModeNV_map = {
    std::make_pair(0, "VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV"),
    std::make_pair(1, "VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV"),
};
static void print_VkRayTracingLssIndexingModeNV(VkRayTracingLssIndexingModeNV obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRayTracingLssIndexingModeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRayTracingLssIndexingModeNV_map[obj] << "\"" << std::endl;
}
static void print_VkRayTracingLssIndexingModeNV(const VkRayTracingLssIndexingModeNV* obj, const std::string& str,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRayTracingLssIndexingModeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRayTracingLssIndexingModeNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkRayTracingLssPrimitiveEndCapsModeNV_map = {
    std::make_pair(0, "VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV"),
    std::make_pair(1, "VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV"),
};
static void print_VkRayTracingLssPrimitiveEndCapsModeNV(VkRayTracingLssPrimitiveEndCapsModeNV obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRayTracingLssPrimitiveEndCapsModeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRayTracingLssPrimitiveEndCapsModeNV_map[obj] << "\"" << std::endl;
}
static void print_VkRayTracingLssPrimitiveEndCapsModeNV(const VkRayTracingLssPrimitiveEndCapsModeNV* obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRayTracingLssPrimitiveEndCapsModeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRayTracingLssPrimitiveEndCapsModeNV_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV(VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV obj,
                                                                         const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.spheres, "spheres", 1);

    print_VkBool32(obj.linearSweptSpheres, "linearSweptSpheres", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV(
    const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->spheres, "spheres", 1);

    print_VkBool32(obj->linearSweptSpheres, "linearSweptSpheres", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureGeometryLinearSweptSpheresDataNV(
    VkAccelerationStructureGeometryLinearSweptSpheresDataNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj.vertexFormat, "vertexFormat", 1);

    print_VkDeviceOrHostAddressConstKHR(obj.vertexData, "vertexData", 1);

    print_VkDeviceSize(obj.vertexStride, "vertexStride", 1);

    print_VkFormat(obj.radiusFormat, "radiusFormat", 1);

    print_VkDeviceOrHostAddressConstKHR(obj.radiusData, "radiusData", 1);

    print_VkDeviceSize(obj.radiusStride, "radiusStride", 1);

    print_VkIndexType(obj.indexType, "indexType", 1);

    print_VkDeviceOrHostAddressConstKHR(obj.indexData, "indexData", 1);

    print_VkDeviceSize(obj.indexStride, "indexStride", 1);

    print_VkRayTracingLssIndexingModeNV(obj.indexingMode, "indexingMode", 1);

    print_VkRayTracingLssPrimitiveEndCapsModeNV(obj.endCapsMode, "endCapsMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureGeometryLinearSweptSpheresDataNV(
    const VkAccelerationStructureGeometryLinearSweptSpheresDataNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj->vertexFormat, "vertexFormat", 1);

    print_VkDeviceOrHostAddressConstKHR(obj->vertexData, "vertexData", 1);

    print_VkDeviceSize(obj->vertexStride, "vertexStride", 1);

    print_VkFormat(obj->radiusFormat, "radiusFormat", 1);

    print_VkDeviceOrHostAddressConstKHR(obj->radiusData, "radiusData", 1);

    print_VkDeviceSize(obj->radiusStride, "radiusStride", 1);

    print_VkIndexType(obj->indexType, "indexType", 1);

    print_VkDeviceOrHostAddressConstKHR(obj->indexData, "indexData", 1);

    print_VkDeviceSize(obj->indexStride, "indexStride", 1);

    print_VkRayTracingLssIndexingModeNV(obj->indexingMode, "indexingMode", 1);

    print_VkRayTracingLssPrimitiveEndCapsModeNV(obj->endCapsMode, "endCapsMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureGeometrySpheresDataNV(VkAccelerationStructureGeometrySpheresDataNV obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj.vertexFormat, "vertexFormat", 1);

    print_VkDeviceOrHostAddressConstKHR(obj.vertexData, "vertexData", 1);

    print_VkDeviceSize(obj.vertexStride, "vertexStride", 1);

    print_VkFormat(obj.radiusFormat, "radiusFormat", 1);

    print_VkDeviceOrHostAddressConstKHR(obj.radiusData, "radiusData", 1);

    print_VkDeviceSize(obj.radiusStride, "radiusStride", 1);

    print_VkIndexType(obj.indexType, "indexType", 1);

    print_VkDeviceOrHostAddressConstKHR(obj.indexData, "indexData", 1);

    print_VkDeviceSize(obj.indexStride, "indexStride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureGeometrySpheresDataNV(const VkAccelerationStructureGeometrySpheresDataNV* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj->vertexFormat, "vertexFormat", 1);

    print_VkDeviceOrHostAddressConstKHR(obj->vertexData, "vertexData", 1);

    print_VkDeviceSize(obj->vertexStride, "vertexStride", 1);

    print_VkFormat(obj->radiusFormat, "radiusFormat", 1);

    print_VkDeviceOrHostAddressConstKHR(obj->radiusData, "radiusData", 1);

    print_VkDeviceSize(obj->radiusStride, "radiusStride", 1);

    print_VkIndexType(obj->indexType, "indexType", 1);

    print_VkDeviceOrHostAddressConstKHR(obj->indexData, "indexData", 1);

    print_VkDeviceSize(obj->indexStride, "indexStride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceLinearColorAttachmentFeaturesNV(VkPhysicalDeviceLinearColorAttachmentFeaturesNV obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.linearColorAttachment, "linearColorAttachment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceLinearColorAttachmentFeaturesNV(const VkPhysicalDeviceLinearColorAttachmentFeaturesNV* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->linearColorAttachment, "linearColorAttachment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(
    VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.imageCompressionControlSwapchain, "imageCompressionControlSwapchain", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(
    const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->imageCompressionControlSwapchain, "imageCompressionControlSwapchain", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageViewSampleWeightCreateInfoQCOM(VkImageViewSampleWeightCreateInfoQCOM obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"filterCenter\": " << std::endl;
    { print_VkOffset2D(obj.filterCenter, "filterCenter", 1); }

    PRINT_SPACE
    _OUT << "\"filterSize\": " << std::endl;
    { print_VkExtent2D(obj.filterSize, "filterSize", 1); }

    print_uint32_t(obj.numPhases, "numPhases", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageViewSampleWeightCreateInfoQCOM(const VkImageViewSampleWeightCreateInfoQCOM* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"filterCenter\": " << std::endl;
    { print_VkOffset2D(obj->filterCenter, "filterCenter", 1); }

    PRINT_SPACE
    _OUT << "\"filterSize\": " << std::endl;
    { print_VkExtent2D(obj->filterSize, "filterSize", 1); }

    print_uint32_t(obj->numPhases, "numPhases", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceImageProcessingFeaturesQCOM(VkPhysicalDeviceImageProcessingFeaturesQCOM obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.textureSampleWeighted, "textureSampleWeighted", 1);

    print_VkBool32(obj.textureBoxFilter, "textureBoxFilter", 1);

    print_VkBool32(obj.textureBlockMatch, "textureBlockMatch", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageProcessingFeaturesQCOM(const VkPhysicalDeviceImageProcessingFeaturesQCOM* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->textureSampleWeighted, "textureSampleWeighted", 1);

    print_VkBool32(obj->textureBoxFilter, "textureBoxFilter", 1);

    print_VkBool32(obj->textureBlockMatch, "textureBlockMatch", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceImageProcessingPropertiesQCOM(VkPhysicalDeviceImageProcessingPropertiesQCOM obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxWeightFilterPhases, "maxWeightFilterPhases", 1);

    PRINT_SPACE
    _OUT << "\"maxWeightFilterDimension\": " << std::endl;
    { print_VkExtent2D(obj.maxWeightFilterDimension, "maxWeightFilterDimension", 1); }

    PRINT_SPACE
    _OUT << "\"maxBlockMatchRegion\": " << std::endl;
    { print_VkExtent2D(obj.maxBlockMatchRegion, "maxBlockMatchRegion", 1); }

    PRINT_SPACE
    _OUT << "\"maxBoxFilterBlockSize\": " << std::endl;
    { print_VkExtent2D(obj.maxBoxFilterBlockSize, "maxBoxFilterBlockSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageProcessingPropertiesQCOM(const VkPhysicalDeviceImageProcessingPropertiesQCOM* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxWeightFilterPhases, "maxWeightFilterPhases", 1);

    PRINT_SPACE
    _OUT << "\"maxWeightFilterDimension\": " << std::endl;
    { print_VkExtent2D(obj->maxWeightFilterDimension, "maxWeightFilterDimension", 1); }

    PRINT_SPACE
    _OUT << "\"maxBlockMatchRegion\": " << std::endl;
    { print_VkExtent2D(obj->maxBlockMatchRegion, "maxBlockMatchRegion", 1); }

    PRINT_SPACE
    _OUT << "\"maxBoxFilterBlockSize\": " << std::endl;
    { print_VkExtent2D(obj->maxBoxFilterBlockSize, "maxBoxFilterBlockSize", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(VkPhysicalDeviceNestedCommandBufferFeaturesEXT obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.nestedCommandBuffer, "nestedCommandBuffer", 1);

    print_VkBool32(obj.nestedCommandBufferRendering, "nestedCommandBufferRendering", 1);

    print_VkBool32(obj.nestedCommandBufferSimultaneousUse, "nestedCommandBufferSimultaneousUse", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(const VkPhysicalDeviceNestedCommandBufferFeaturesEXT* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->nestedCommandBuffer, "nestedCommandBuffer", 1);

    print_VkBool32(obj->nestedCommandBufferRendering, "nestedCommandBufferRendering", 1);

    print_VkBool32(obj->nestedCommandBufferSimultaneousUse, "nestedCommandBufferSimultaneousUse", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(VkPhysicalDeviceNestedCommandBufferPropertiesEXT obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxCommandBufferNestingLevel, "maxCommandBufferNestingLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(const VkPhysicalDeviceNestedCommandBufferPropertiesEXT* obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxCommandBufferNestingLevel, "maxCommandBufferNestingLevel", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkExternalMemoryAcquireUnmodifiedEXT(VkExternalMemoryAcquireUnmodifiedEXT obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.acquireUnmodifiedMemory, "acquireUnmodifiedMemory", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkExternalMemoryAcquireUnmodifiedEXT(const VkExternalMemoryAcquireUnmodifiedEXT* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->acquireUnmodifiedMemory, "acquireUnmodifiedMemory", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.extendedDynamicState3TessellationDomainOrigin, "extendedDynamicState3TessellationDomainOrigin", 1);

    print_VkBool32(obj.extendedDynamicState3DepthClampEnable, "extendedDynamicState3DepthClampEnable", 1);

    print_VkBool32(obj.extendedDynamicState3PolygonMode, "extendedDynamicState3PolygonMode", 1);

    print_VkBool32(obj.extendedDynamicState3RasterizationSamples, "extendedDynamicState3RasterizationSamples", 1);

    print_VkBool32(obj.extendedDynamicState3SampleMask, "extendedDynamicState3SampleMask", 1);

    print_VkBool32(obj.extendedDynamicState3AlphaToCoverageEnable, "extendedDynamicState3AlphaToCoverageEnable", 1);

    print_VkBool32(obj.extendedDynamicState3AlphaToOneEnable, "extendedDynamicState3AlphaToOneEnable", 1);

    print_VkBool32(obj.extendedDynamicState3LogicOpEnable, "extendedDynamicState3LogicOpEnable", 1);

    print_VkBool32(obj.extendedDynamicState3ColorBlendEnable, "extendedDynamicState3ColorBlendEnable", 1);

    print_VkBool32(obj.extendedDynamicState3ColorBlendEquation, "extendedDynamicState3ColorBlendEquation", 1);

    print_VkBool32(obj.extendedDynamicState3ColorWriteMask, "extendedDynamicState3ColorWriteMask", 1);

    print_VkBool32(obj.extendedDynamicState3RasterizationStream, "extendedDynamicState3RasterizationStream", 1);

    print_VkBool32(obj.extendedDynamicState3ConservativeRasterizationMode, "extendedDynamicState3ConservativeRasterizationMode", 1);

    print_VkBool32(obj.extendedDynamicState3ExtraPrimitiveOverestimationSize,
                   "extendedDynamicState3ExtraPrimitiveOverestimationSize", 1);

    print_VkBool32(obj.extendedDynamicState3DepthClipEnable, "extendedDynamicState3DepthClipEnable", 1);

    print_VkBool32(obj.extendedDynamicState3SampleLocationsEnable, "extendedDynamicState3SampleLocationsEnable", 1);

    print_VkBool32(obj.extendedDynamicState3ColorBlendAdvanced, "extendedDynamicState3ColorBlendAdvanced", 1);

    print_VkBool32(obj.extendedDynamicState3ProvokingVertexMode, "extendedDynamicState3ProvokingVertexMode", 1);

    print_VkBool32(obj.extendedDynamicState3LineRasterizationMode, "extendedDynamicState3LineRasterizationMode", 1);

    print_VkBool32(obj.extendedDynamicState3LineStippleEnable, "extendedDynamicState3LineStippleEnable", 1);

    print_VkBool32(obj.extendedDynamicState3DepthClipNegativeOneToOne, "extendedDynamicState3DepthClipNegativeOneToOne", 1);

    print_VkBool32(obj.extendedDynamicState3ViewportWScalingEnable, "extendedDynamicState3ViewportWScalingEnable", 1);

    print_VkBool32(obj.extendedDynamicState3ViewportSwizzle, "extendedDynamicState3ViewportSwizzle", 1);

    print_VkBool32(obj.extendedDynamicState3CoverageToColorEnable, "extendedDynamicState3CoverageToColorEnable", 1);

    print_VkBool32(obj.extendedDynamicState3CoverageToColorLocation, "extendedDynamicState3CoverageToColorLocation", 1);

    print_VkBool32(obj.extendedDynamicState3CoverageModulationMode, "extendedDynamicState3CoverageModulationMode", 1);

    print_VkBool32(obj.extendedDynamicState3CoverageModulationTableEnable, "extendedDynamicState3CoverageModulationTableEnable", 1);

    print_VkBool32(obj.extendedDynamicState3CoverageModulationTable, "extendedDynamicState3CoverageModulationTable", 1);

    print_VkBool32(obj.extendedDynamicState3CoverageReductionMode, "extendedDynamicState3CoverageReductionMode", 1);

    print_VkBool32(obj.extendedDynamicState3RepresentativeFragmentTestEnable,
                   "extendedDynamicState3RepresentativeFragmentTestEnable", 1);

    print_VkBool32(obj.extendedDynamicState3ShadingRateImageEnable, "extendedDynamicState3ShadingRateImageEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->extendedDynamicState3TessellationDomainOrigin, "extendedDynamicState3TessellationDomainOrigin", 1);

    print_VkBool32(obj->extendedDynamicState3DepthClampEnable, "extendedDynamicState3DepthClampEnable", 1);

    print_VkBool32(obj->extendedDynamicState3PolygonMode, "extendedDynamicState3PolygonMode", 1);

    print_VkBool32(obj->extendedDynamicState3RasterizationSamples, "extendedDynamicState3RasterizationSamples", 1);

    print_VkBool32(obj->extendedDynamicState3SampleMask, "extendedDynamicState3SampleMask", 1);

    print_VkBool32(obj->extendedDynamicState3AlphaToCoverageEnable, "extendedDynamicState3AlphaToCoverageEnable", 1);

    print_VkBool32(obj->extendedDynamicState3AlphaToOneEnable, "extendedDynamicState3AlphaToOneEnable", 1);

    print_VkBool32(obj->extendedDynamicState3LogicOpEnable, "extendedDynamicState3LogicOpEnable", 1);

    print_VkBool32(obj->extendedDynamicState3ColorBlendEnable, "extendedDynamicState3ColorBlendEnable", 1);

    print_VkBool32(obj->extendedDynamicState3ColorBlendEquation, "extendedDynamicState3ColorBlendEquation", 1);

    print_VkBool32(obj->extendedDynamicState3ColorWriteMask, "extendedDynamicState3ColorWriteMask", 1);

    print_VkBool32(obj->extendedDynamicState3RasterizationStream, "extendedDynamicState3RasterizationStream", 1);

    print_VkBool32(obj->extendedDynamicState3ConservativeRasterizationMode, "extendedDynamicState3ConservativeRasterizationMode",
                   1);

    print_VkBool32(obj->extendedDynamicState3ExtraPrimitiveOverestimationSize,
                   "extendedDynamicState3ExtraPrimitiveOverestimationSize", 1);

    print_VkBool32(obj->extendedDynamicState3DepthClipEnable, "extendedDynamicState3DepthClipEnable", 1);

    print_VkBool32(obj->extendedDynamicState3SampleLocationsEnable, "extendedDynamicState3SampleLocationsEnable", 1);

    print_VkBool32(obj->extendedDynamicState3ColorBlendAdvanced, "extendedDynamicState3ColorBlendAdvanced", 1);

    print_VkBool32(obj->extendedDynamicState3ProvokingVertexMode, "extendedDynamicState3ProvokingVertexMode", 1);

    print_VkBool32(obj->extendedDynamicState3LineRasterizationMode, "extendedDynamicState3LineRasterizationMode", 1);

    print_VkBool32(obj->extendedDynamicState3LineStippleEnable, "extendedDynamicState3LineStippleEnable", 1);

    print_VkBool32(obj->extendedDynamicState3DepthClipNegativeOneToOne, "extendedDynamicState3DepthClipNegativeOneToOne", 1);

    print_VkBool32(obj->extendedDynamicState3ViewportWScalingEnable, "extendedDynamicState3ViewportWScalingEnable", 1);

    print_VkBool32(obj->extendedDynamicState3ViewportSwizzle, "extendedDynamicState3ViewportSwizzle", 1);

    print_VkBool32(obj->extendedDynamicState3CoverageToColorEnable, "extendedDynamicState3CoverageToColorEnable", 1);

    print_VkBool32(obj->extendedDynamicState3CoverageToColorLocation, "extendedDynamicState3CoverageToColorLocation", 1);

    print_VkBool32(obj->extendedDynamicState3CoverageModulationMode, "extendedDynamicState3CoverageModulationMode", 1);

    print_VkBool32(obj->extendedDynamicState3CoverageModulationTableEnable, "extendedDynamicState3CoverageModulationTableEnable",
                   1);

    print_VkBool32(obj->extendedDynamicState3CoverageModulationTable, "extendedDynamicState3CoverageModulationTable", 1);

    print_VkBool32(obj->extendedDynamicState3CoverageReductionMode, "extendedDynamicState3CoverageReductionMode", 1);

    print_VkBool32(obj->extendedDynamicState3RepresentativeFragmentTestEnable,
                   "extendedDynamicState3RepresentativeFragmentTestEnable", 1);

    print_VkBool32(obj->extendedDynamicState3ShadingRateImageEnable, "extendedDynamicState3ShadingRateImageEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.dynamicPrimitiveTopologyUnrestricted, "dynamicPrimitiveTopologyUnrestricted", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->dynamicPrimitiveTopologyUnrestricted, "dynamicPrimitiveTopologyUnrestricted", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkColorBlendEquationEXT(VkColorBlendEquationEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkBlendFactor(obj.srcColorBlendFactor, "srcColorBlendFactor", 1);

    print_VkBlendFactor(obj.dstColorBlendFactor, "dstColorBlendFactor", 1);

    print_VkBlendOp(obj.colorBlendOp, "colorBlendOp", 1);

    print_VkBlendFactor(obj.srcAlphaBlendFactor, "srcAlphaBlendFactor", 1);

    print_VkBlendFactor(obj.dstAlphaBlendFactor, "dstAlphaBlendFactor", 1);

    print_VkBlendOp(obj.alphaBlendOp, "alphaBlendOp", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkColorBlendEquationEXT(const VkColorBlendEquationEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkBlendFactor(obj->srcColorBlendFactor, "srcColorBlendFactor", 1);

    print_VkBlendFactor(obj->dstColorBlendFactor, "dstColorBlendFactor", 1);

    print_VkBlendOp(obj->colorBlendOp, "colorBlendOp", 1);

    print_VkBlendFactor(obj->srcAlphaBlendFactor, "srcAlphaBlendFactor", 1);

    print_VkBlendFactor(obj->dstAlphaBlendFactor, "dstAlphaBlendFactor", 1);

    print_VkBlendOp(obj->alphaBlendOp, "alphaBlendOp", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkColorBlendAdvancedEXT(VkColorBlendAdvancedEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkBlendOp(obj.advancedBlendOp, "advancedBlendOp", 1);

    print_VkBool32(obj.srcPremultiplied, "srcPremultiplied", 1);

    print_VkBool32(obj.dstPremultiplied, "dstPremultiplied", 1);

    print_VkBlendOverlapEXT(obj.blendOverlap, "blendOverlap", 1);

    print_VkBool32(obj.clampResults, "clampResults", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkColorBlendAdvancedEXT(const VkColorBlendAdvancedEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkBlendOp(obj->advancedBlendOp, "advancedBlendOp", 1);

    print_VkBool32(obj->srcPremultiplied, "srcPremultiplied", 1);

    print_VkBool32(obj->dstPremultiplied, "dstPremultiplied", 1);

    print_VkBlendOverlapEXT(obj->blendOverlap, "blendOverlap", 1);

    print_VkBool32(obj->clampResults, "clampResults", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkSubpassMergeStatusEXT_map = {
    std::make_pair(0, "VK_SUBPASS_MERGE_STATUS_MERGED_EXT"),
    std::make_pair(1, "VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT"),
    std::make_pair(2, "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT"),
    std::make_pair(3, "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT"),
    std::make_pair(4, "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT"),
    std::make_pair(5, "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT"),
    std::make_pair(6, "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT"),
    std::make_pair(7, "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT"),
    std::make_pair(8, "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT"),
    std::make_pair(9, "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT"),
    std::make_pair(10, "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT"),
    std::make_pair(11, "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT"),
    std::make_pair(12, "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT"),
    std::make_pair(13, "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT"),
};
static void print_VkSubpassMergeStatusEXT(VkSubpassMergeStatusEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSubpassMergeStatusEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSubpassMergeStatusEXT_map[obj] << "\"" << std::endl;
}
static void print_VkSubpassMergeStatusEXT(const VkSubpassMergeStatusEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkSubpassMergeStatusEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkSubpassMergeStatusEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.subpassMergeFeedback, "subpassMergeFeedback", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->subpassMergeFeedback, "subpassMergeFeedback", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassCreationControlEXT(VkRenderPassCreationControlEXT obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.disallowMerging, "disallowMerging", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassCreationControlEXT(const VkRenderPassCreationControlEXT* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->disallowMerging, "disallowMerging", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassCreationFeedbackInfoEXT(VkRenderPassCreationFeedbackInfoEXT obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.postMergeSubpassCount, "postMergeSubpassCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassCreationFeedbackInfoEXT(const VkRenderPassCreationFeedbackInfoEXT* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->postMergeSubpassCount, "postMergeSubpassCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassCreationFeedbackCreateInfoEXT(VkRenderPassCreationFeedbackCreateInfoEXT obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pRenderPassFeedback\": " << std::endl;
    if (obj.pRenderPassFeedback) {
        print_VkRenderPassCreationFeedbackInfoEXT(obj.pRenderPassFeedback, "pRenderPassFeedback", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassCreationFeedbackCreateInfoEXT(const VkRenderPassCreationFeedbackCreateInfoEXT* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pRenderPassFeedback\": " << std::endl;
    if (obj->pRenderPassFeedback) {
        print_VkRenderPassCreationFeedbackInfoEXT(obj->pRenderPassFeedback, "pRenderPassFeedback", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassSubpassFeedbackInfoEXT(VkRenderPassSubpassFeedbackInfoEXT obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkSubpassMergeStatusEXT(obj.subpassMergeStatus, "subpassMergeStatus", 1);

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj.description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.postMergeIndex, "postMergeIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassSubpassFeedbackInfoEXT(const VkRenderPassSubpassFeedbackInfoEXT* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkSubpassMergeStatusEXT(obj->subpassMergeStatus, "subpassMergeStatus", 1);

    PRINT_SPACE
    _OUT << "\"description\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_DESCRIPTION_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_DESCRIPTION_SIZE;
        print_char(obj->description[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->postMergeIndex, "postMergeIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRenderPassSubpassFeedbackCreateInfoEXT(VkRenderPassSubpassFeedbackCreateInfoEXT obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pSubpassFeedback\": " << std::endl;
    if (obj.pSubpassFeedback) {
        print_VkRenderPassSubpassFeedbackInfoEXT(obj.pSubpassFeedback, "pSubpassFeedback", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRenderPassSubpassFeedbackCreateInfoEXT(const VkRenderPassSubpassFeedbackCreateInfoEXT* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pSubpassFeedback\": " << std::endl;
    if (obj->pSubpassFeedback) {
        print_VkRenderPassSubpassFeedbackInfoEXT(obj->pSubpassFeedback, "pSubpassFeedback", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkDirectDriverLoadingModeLUNARG_map = {
    std::make_pair(0, "VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG"),
    std::make_pair(1, "VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG"),
};
static void print_VkDirectDriverLoadingModeLUNARG(VkDirectDriverLoadingModeLUNARG obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDirectDriverLoadingModeLUNARG_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDirectDriverLoadingModeLUNARG_map[obj] << "\"" << std::endl;
}
static void print_VkDirectDriverLoadingModeLUNARG(const VkDirectDriverLoadingModeLUNARG* obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDirectDriverLoadingModeLUNARG_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDirectDriverLoadingModeLUNARG_map[*obj] << "\"" << std::endl;
}

static void print_VkDirectDriverLoadingFlagsLUNARG(VkDirectDriverLoadingFlagsLUNARG obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << " : " << obj << "," << std::endl;
    else
        _OUT << "\"" << str << "\""
             << " : " << obj << std::endl;
}

static void print_VkDirectDriverLoadingInfoLUNARG(VkDirectDriverLoadingInfoLUNARG obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDirectDriverLoadingFlagsLUNARG(obj.flags, "flags", 1);

    /** Note: Ignoring function pointer (PFN_vkGetInstanceProcAddrLUNARG). **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDirectDriverLoadingInfoLUNARG(const VkDirectDriverLoadingInfoLUNARG* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDirectDriverLoadingFlagsLUNARG(obj->flags, "flags", 1);

    /** Note: Ignoring function pointer (PFN_vkGetInstanceProcAddrLUNARG). **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDirectDriverLoadingListLUNARG(VkDirectDriverLoadingListLUNARG obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDirectDriverLoadingModeLUNARG(obj.mode, "mode", 1);

    print_uint32_t(obj.driverCount, "driverCount", 1);

    PRINT_SPACE
    _OUT << "\"pDrivers\": " << std::endl;
    if (obj.pDrivers) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.driverCount; i++) {
            if (i + 1 == obj.driverCount)
                print_VkDirectDriverLoadingInfoLUNARG(obj.pDrivers[i], "pDrivers", 0);
            else
                print_VkDirectDriverLoadingInfoLUNARG(obj.pDrivers[i], "pDrivers", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDirectDriverLoadingListLUNARG(const VkDirectDriverLoadingListLUNARG* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDirectDriverLoadingModeLUNARG(obj->mode, "mode", 1);

    print_uint32_t(obj->driverCount, "driverCount", 1);

    PRINT_SPACE
    _OUT << "\"pDrivers\": " << std::endl;
    if (obj->pDrivers) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->driverCount; i++) {
            if (i + 1 == obj->driverCount)
                print_VkDirectDriverLoadingInfoLUNARG(obj->pDrivers[i], "pDrivers", 0);
            else
                print_VkDirectDriverLoadingInfoLUNARG(obj->pDrivers[i], "pDrivers", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderModuleIdentifier, "shaderModuleIdentifier", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderModuleIdentifier, "shaderModuleIdentifier", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"shaderModuleIdentifierAlgorithmUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj.shaderModuleIdentifierAlgorithmUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(
    const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"shaderModuleIdentifierAlgorithmUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj->shaderModuleIdentifierAlgorithmUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(VkPipelineShaderStageModuleIdentifierCreateInfoEXT obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.identifierSize, "identifierSize", 1);

    PRINT_SPACE
    _OUT << "\"pIdentifier\":" << std::endl;
    PRINT_SPACE
    if (obj.pIdentifier) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.identifierSize; i++) {
            bool isCommaNeeded = (i + 1) != obj.identifierSize;
            print_uint8_t(obj.pIdentifier[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(const VkPipelineShaderStageModuleIdentifierCreateInfoEXT* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->identifierSize, "identifierSize", 1);

    PRINT_SPACE
    _OUT << "\"pIdentifier\":" << std::endl;
    PRINT_SPACE
    if (obj->pIdentifier) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->identifierSize; i++) {
            bool isCommaNeeded = (i + 1) != obj->identifierSize;
            print_uint8_t(obj->pIdentifier[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkShaderModuleIdentifierEXT(VkShaderModuleIdentifierEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.identifierSize, "identifierSize", 1);

    PRINT_SPACE
    _OUT << "\"identifier\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT;
        print_uint8_t(obj.identifier[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkShaderModuleIdentifierEXT(const VkShaderModuleIdentifierEXT* obj, const std::string& s,
                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->identifierSize, "identifierSize", 1);

    PRINT_SPACE
    _OUT << "\"identifier\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT; i++) {
        bool isCommaNeeded = (i + 1) != VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT;
        print_uint8_t(obj->identifier[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkOpticalFlowSessionNV(VkOpticalFlowSessionNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkOpticalFlowGridSizeFlagBitsNV_map = {
    std::make_pair(0, "VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV"),
    std::make_pair(1ULL << 0, "VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV"),
    std::make_pair(1ULL << 1, "VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV"),
    std::make_pair(1ULL << 2, "VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV"),
    std::make_pair(1ULL << 3, "VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV"),
};
static void print_VkOpticalFlowGridSizeFlagBitsNV(VkOpticalFlowGridSizeFlagBitsNV obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpticalFlowGridSizeFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpticalFlowGridSizeFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkOpticalFlowGridSizeFlagBitsNV(const VkOpticalFlowGridSizeFlagBitsNV* obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpticalFlowGridSizeFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpticalFlowGridSizeFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkOpticalFlowUsageFlagBitsNV_map = {
    std::make_pair(0, "VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV"),
    std::make_pair(1ULL << 0, "VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV"),
    std::make_pair(1ULL << 1, "VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV"),
    std::make_pair(1ULL << 2, "VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV"),
    std::make_pair(1ULL << 3, "VK_OPTICAL_FLOW_USAGE_COST_BIT_NV"),
    std::make_pair(1ULL << 4, "VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV"),
};
static void print_VkOpticalFlowUsageFlagBitsNV(VkOpticalFlowUsageFlagBitsNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpticalFlowUsageFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpticalFlowUsageFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkOpticalFlowUsageFlagBitsNV(const VkOpticalFlowUsageFlagBitsNV* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpticalFlowUsageFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpticalFlowUsageFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkOpticalFlowPerformanceLevelNV_map = {
    std::make_pair(0, "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV"),
    std::make_pair(1, "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV"),
    std::make_pair(2, "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV"),
    std::make_pair(3, "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV"),
};
static void print_VkOpticalFlowPerformanceLevelNV(VkOpticalFlowPerformanceLevelNV obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpticalFlowPerformanceLevelNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpticalFlowPerformanceLevelNV_map[obj] << "\"" << std::endl;
}
static void print_VkOpticalFlowPerformanceLevelNV(const VkOpticalFlowPerformanceLevelNV* obj, const std::string& str,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpticalFlowPerformanceLevelNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpticalFlowPerformanceLevelNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkOpticalFlowSessionBindingPointNV_map = {
    std::make_pair(0, "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV"),
    std::make_pair(1, "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV"),
    std::make_pair(2, "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV"),
    std::make_pair(3, "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV"),
    std::make_pair(4, "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV"),
    std::make_pair(5, "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV"),
    std::make_pair(6, "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV"),
    std::make_pair(7, "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV"),
    std::make_pair(8, "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV"),
};
static void print_VkOpticalFlowSessionBindingPointNV(VkOpticalFlowSessionBindingPointNV obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpticalFlowSessionBindingPointNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpticalFlowSessionBindingPointNV_map[obj] << "\"" << std::endl;
}
static void print_VkOpticalFlowSessionBindingPointNV(const VkOpticalFlowSessionBindingPointNV* obj, const std::string& str,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpticalFlowSessionBindingPointNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpticalFlowSessionBindingPointNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkOpticalFlowSessionCreateFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV"),
    std::make_pair(1ULL << 1, "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV"),
    std::make_pair(1ULL << 2, "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV"),
    std::make_pair(1ULL << 3, "VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV"),
    std::make_pair(1ULL << 4, "VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV"),
};
static void print_VkOpticalFlowSessionCreateFlagBitsNV(VkOpticalFlowSessionCreateFlagBitsNV obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpticalFlowSessionCreateFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpticalFlowSessionCreateFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkOpticalFlowSessionCreateFlagBitsNV(const VkOpticalFlowSessionCreateFlagBitsNV* obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpticalFlowSessionCreateFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpticalFlowSessionCreateFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkOpticalFlowExecuteFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV"),
};
static void print_VkOpticalFlowExecuteFlagBitsNV(VkOpticalFlowExecuteFlagBitsNV obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpticalFlowExecuteFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpticalFlowExecuteFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkOpticalFlowExecuteFlagBitsNV(const VkOpticalFlowExecuteFlagBitsNV* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOpticalFlowExecuteFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOpticalFlowExecuteFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static void print_VkOpticalFlowGridSizeFlagsNV(VkOpticalFlowGridSizeFlagsNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkOpticalFlowGridSizeFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkOpticalFlowGridSizeFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkOpticalFlowUsageFlagsNV(VkOpticalFlowUsageFlagsNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkOpticalFlowUsageFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkOpticalFlowUsageFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkOpticalFlowSessionCreateFlagsNV(VkOpticalFlowSessionCreateFlagsNV obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkOpticalFlowSessionCreateFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkOpticalFlowSessionCreateFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkOpticalFlowExecuteFlagsNV(VkOpticalFlowExecuteFlagsNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkOpticalFlowExecuteFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkOpticalFlowExecuteFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceOpticalFlowFeaturesNV(VkPhysicalDeviceOpticalFlowFeaturesNV obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.opticalFlow, "opticalFlow", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceOpticalFlowFeaturesNV(const VkPhysicalDeviceOpticalFlowFeaturesNV* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->opticalFlow, "opticalFlow", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceOpticalFlowPropertiesNV(VkPhysicalDeviceOpticalFlowPropertiesNV obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkOpticalFlowGridSizeFlagsNV(obj.supportedOutputGridSizes, "supportedOutputGridSizes", 1);

    print_VkOpticalFlowGridSizeFlagsNV(obj.supportedHintGridSizes, "supportedHintGridSizes", 1);

    print_VkBool32(obj.hintSupported, "hintSupported", 1);

    print_VkBool32(obj.costSupported, "costSupported", 1);

    print_VkBool32(obj.bidirectionalFlowSupported, "bidirectionalFlowSupported", 1);

    print_VkBool32(obj.globalFlowSupported, "globalFlowSupported", 1);

    print_uint32_t(obj.minWidth, "minWidth", 1);

    print_uint32_t(obj.minHeight, "minHeight", 1);

    print_uint32_t(obj.maxWidth, "maxWidth", 1);

    print_uint32_t(obj.maxHeight, "maxHeight", 1);

    print_uint32_t(obj.maxNumRegionsOfInterest, "maxNumRegionsOfInterest", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceOpticalFlowPropertiesNV(const VkPhysicalDeviceOpticalFlowPropertiesNV* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkOpticalFlowGridSizeFlagsNV(obj->supportedOutputGridSizes, "supportedOutputGridSizes", 1);

    print_VkOpticalFlowGridSizeFlagsNV(obj->supportedHintGridSizes, "supportedHintGridSizes", 1);

    print_VkBool32(obj->hintSupported, "hintSupported", 1);

    print_VkBool32(obj->costSupported, "costSupported", 1);

    print_VkBool32(obj->bidirectionalFlowSupported, "bidirectionalFlowSupported", 1);

    print_VkBool32(obj->globalFlowSupported, "globalFlowSupported", 1);

    print_uint32_t(obj->minWidth, "minWidth", 1);

    print_uint32_t(obj->minHeight, "minHeight", 1);

    print_uint32_t(obj->maxWidth, "maxWidth", 1);

    print_uint32_t(obj->maxHeight, "maxHeight", 1);

    print_uint32_t(obj->maxNumRegionsOfInterest, "maxNumRegionsOfInterest", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkOpticalFlowImageFormatInfoNV(VkOpticalFlowImageFormatInfoNV obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkOpticalFlowUsageFlagsNV(obj.usage, "usage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkOpticalFlowImageFormatInfoNV(const VkOpticalFlowImageFormatInfoNV* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkOpticalFlowUsageFlagsNV(obj->usage, "usage", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkOpticalFlowImageFormatPropertiesNV(VkOpticalFlowImageFormatPropertiesNV obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj.format, "format", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkOpticalFlowImageFormatPropertiesNV(const VkOpticalFlowImageFormatPropertiesNV* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj->format, "format", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkOpticalFlowSessionCreateInfoNV(VkOpticalFlowSessionCreateInfoNV obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.width, "width", 1);

    print_uint32_t(obj.height, "height", 1);

    print_VkFormat(obj.imageFormat, "imageFormat", 1);

    print_VkFormat(obj.flowVectorFormat, "flowVectorFormat", 1);

    print_VkFormat(obj.costFormat, "costFormat", 1);

    print_VkOpticalFlowGridSizeFlagsNV(obj.outputGridSize, "outputGridSize", 1);

    print_VkOpticalFlowGridSizeFlagsNV(obj.hintGridSize, "hintGridSize", 1);

    print_VkOpticalFlowPerformanceLevelNV(obj.performanceLevel, "performanceLevel", 1);

    print_VkOpticalFlowSessionCreateFlagsNV(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkOpticalFlowSessionCreateInfoNV(const VkOpticalFlowSessionCreateInfoNV* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->width, "width", 1);

    print_uint32_t(obj->height, "height", 1);

    print_VkFormat(obj->imageFormat, "imageFormat", 1);

    print_VkFormat(obj->flowVectorFormat, "flowVectorFormat", 1);

    print_VkFormat(obj->costFormat, "costFormat", 1);

    print_VkOpticalFlowGridSizeFlagsNV(obj->outputGridSize, "outputGridSize", 1);

    print_VkOpticalFlowGridSizeFlagsNV(obj->hintGridSize, "hintGridSize", 1);

    print_VkOpticalFlowPerformanceLevelNV(obj->performanceLevel, "performanceLevel", 1);

    print_VkOpticalFlowSessionCreateFlagsNV(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkOpticalFlowSessionCreatePrivateDataInfoNV(VkOpticalFlowSessionCreatePrivateDataInfoNV obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.id, "id", 1);

    print_uint32_t(obj.size, "size", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkOpticalFlowSessionCreatePrivateDataInfoNV(const VkOpticalFlowSessionCreatePrivateDataInfoNV* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->id, "id", 1);

    print_uint32_t(obj->size, "size", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkOpticalFlowExecuteInfoNV(VkOpticalFlowExecuteInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkOpticalFlowExecuteFlagsNV(obj.flags, "flags", 1);

    print_uint32_t(obj.regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj.pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.regionCount; i++) {
            if (i + 1 == obj.regionCount)
                print_VkRect2D(obj.pRegions[i], "pRegions", 0);
            else
                print_VkRect2D(obj.pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkOpticalFlowExecuteInfoNV(const VkOpticalFlowExecuteInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkOpticalFlowExecuteFlagsNV(obj->flags, "flags", 1);

    print_uint32_t(obj->regionCount, "regionCount", 1);

    PRINT_SPACE
    _OUT << "\"pRegions\": " << std::endl;
    if (obj->pRegions) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->regionCount; i++) {
            if (i + 1 == obj->regionCount)
                print_VkRect2D(obj->pRegions[i], "pRegions", 0);
            else
                print_VkRect2D(obj->pRegions[i], "pRegions", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceLegacyDitheringFeaturesEXT(VkPhysicalDeviceLegacyDitheringFeaturesEXT obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.legacyDithering, "legacyDithering", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceLegacyDitheringFeaturesEXT(const VkPhysicalDeviceLegacyDitheringFeaturesEXT* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->legacyDithering, "legacyDithering", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePipelineProtectedAccessFeatures(VkPhysicalDevicePipelineProtectedAccessFeatures obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.pipelineProtectedAccess, "pipelineProtectedAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePipelineProtectedAccessFeatures(const VkPhysicalDevicePipelineProtectedAccessFeatures* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->pipelineProtectedAccess, "pipelineProtectedAccess", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPhysicalDevicePipelineProtectedAccessFeatures VkPhysicalDevicePipelineProtectedAccessFeaturesEXT;

static std::map<uint64_t, std::string> VkAntiLagModeAMD_map = {
    std::make_pair(0, "VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD"),
    std::make_pair(1, "VK_ANTI_LAG_MODE_ON_AMD"),
    std::make_pair(2, "VK_ANTI_LAG_MODE_OFF_AMD"),
};
static void print_VkAntiLagModeAMD(VkAntiLagModeAMD obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAntiLagModeAMD_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAntiLagModeAMD_map[obj] << "\"" << std::endl;
}
static void print_VkAntiLagModeAMD(const VkAntiLagModeAMD* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAntiLagModeAMD_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAntiLagModeAMD_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAntiLagStageAMD_map = {
    std::make_pair(0, "VK_ANTI_LAG_STAGE_INPUT_AMD"),
    std::make_pair(1, "VK_ANTI_LAG_STAGE_PRESENT_AMD"),
};
static void print_VkAntiLagStageAMD(VkAntiLagStageAMD obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAntiLagStageAMD_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAntiLagStageAMD_map[obj] << "\"" << std::endl;
}
static void print_VkAntiLagStageAMD(const VkAntiLagStageAMD* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAntiLagStageAMD_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAntiLagStageAMD_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceAntiLagFeaturesAMD(VkPhysicalDeviceAntiLagFeaturesAMD obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.antiLag, "antiLag", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceAntiLagFeaturesAMD(const VkPhysicalDeviceAntiLagFeaturesAMD* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->antiLag, "antiLag", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAntiLagPresentationInfoAMD(VkAntiLagPresentationInfoAMD obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAntiLagStageAMD(obj.stage, "stage", 1);

    print_uint64_t(obj.frameIndex, "frameIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAntiLagPresentationInfoAMD(const VkAntiLagPresentationInfoAMD* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAntiLagStageAMD(obj->stage, "stage", 1);

    print_uint64_t(obj->frameIndex, "frameIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAntiLagDataAMD(VkAntiLagDataAMD obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAntiLagModeAMD(obj.mode, "mode", 1);

    print_uint32_t(obj.maxFPS, "maxFPS", 1);

    PRINT_SPACE
    _OUT << "\"pPresentationInfo\": " << std::endl;
    if (obj.pPresentationInfo) {
        print_VkAntiLagPresentationInfoAMD(obj.pPresentationInfo, "pPresentationInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAntiLagDataAMD(const VkAntiLagDataAMD* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAntiLagModeAMD(obj->mode, "mode", 1);

    print_uint32_t(obj->maxFPS, "maxFPS", 1);

    PRINT_SPACE
    _OUT << "\"pPresentationInfo\": " << std::endl;
    if (obj->pPresentationInfo) {
        print_VkAntiLagPresentationInfoAMD(obj->pPresentationInfo, "pPresentationInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkShaderEXT(VkShaderEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkShaderCreateFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_SHADER_CREATE_LINK_STAGE_BIT_EXT"),
    std::make_pair(1ULL << 10, "VK_SHADER_CREATE_RESERVED_10_BIT_KHR"),
    std::make_pair(1ULL << 11, "VK_SHADER_CREATE_RESERVED_11_BIT_KHR"),
    std::make_pair(1ULL << 1, "VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT"),
    std::make_pair(1ULL << 2, "VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT"),
    std::make_pair(1ULL << 3, "VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT"),
    std::make_pair(1ULL << 4, "VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT"),
    std::make_pair(1ULL << 5, "VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT"),
    std::make_pair(1ULL << 6, "VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"),
    std::make_pair(1ULL << 7, "VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT"),
    std::make_pair(1ULL << 8, "VK_SHADER_CREATE_RESERVED_8_BIT_EXT"),
    std::make_pair(1ULL << 9, "VK_SHADER_CREATE_RESERVED_9_BIT_EXT"),
};
static void print_VkShaderCreateFlagBitsEXT(VkShaderCreateFlagBitsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderCreateFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderCreateFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkShaderCreateFlagBitsEXT(const VkShaderCreateFlagBitsEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderCreateFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderCreateFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkShaderCodeTypeEXT_map = {
    std::make_pair(0, "VK_SHADER_CODE_TYPE_BINARY_EXT"),
    std::make_pair(1, "VK_SHADER_CODE_TYPE_SPIRV_EXT"),
};
static void print_VkShaderCodeTypeEXT(VkShaderCodeTypeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderCodeTypeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderCodeTypeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkShaderCodeTypeEXT(const VkShaderCodeTypeEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderCodeTypeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderCodeTypeEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkDepthClampModeEXT_map = {
    std::make_pair(0, "VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT"),
    std::make_pair(1, "VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT"),
};
static void print_VkDepthClampModeEXT(VkDepthClampModeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDepthClampModeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDepthClampModeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkDepthClampModeEXT(const VkDepthClampModeEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDepthClampModeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDepthClampModeEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkShaderCreateFlagsEXT(VkShaderCreateFlagsEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkShaderCreateFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkShaderCreateFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceShaderObjectFeaturesEXT(VkPhysicalDeviceShaderObjectFeaturesEXT obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderObject, "shaderObject", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderObjectFeaturesEXT(const VkPhysicalDeviceShaderObjectFeaturesEXT* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderObject, "shaderObject", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderObjectPropertiesEXT(VkPhysicalDeviceShaderObjectPropertiesEXT obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"shaderBinaryUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj.shaderBinaryUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.shaderBinaryVersion, "shaderBinaryVersion", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderObjectPropertiesEXT(const VkPhysicalDeviceShaderObjectPropertiesEXT* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"shaderBinaryUUID\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < VK_UUID_SIZE; i++) {
        bool isCommaNeeded = (i + 1) != VK_UUID_SIZE;
        print_uint8_t(obj->shaderBinaryUUID[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->shaderBinaryVersion, "shaderBinaryVersion", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkShaderCreateInfoEXT(VkShaderCreateInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderCreateFlagsEXT(obj.flags, "flags", 1);

    print_VkShaderStageFlagBits(obj.stage, "stage", 1);

    print_VkShaderStageFlags(obj.nextStage, "nextStage", 1);

    print_VkShaderCodeTypeEXT(obj.codeType, "codeType", 1);

    print_size_t(obj.codeSize, "codeSize", 1);

    /** Note: Ignoring void* data. **/

    print_char(obj.pName, "pName", 1);

    print_uint32_t(obj.setLayoutCount, "setLayoutCount", 1);

    PRINT_SPACE
    _OUT << "\"pSetLayouts\":" << std::endl;
    PRINT_SPACE
    if (obj.pSetLayouts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.setLayoutCount; i++) {
            std::stringstream tmp;
            tmp << "pSetLayouts"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.setLayoutCount;
            print_VkDescriptorSetLayout(obj.pSetLayouts[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.pushConstantRangeCount, "pushConstantRangeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPushConstantRanges\": " << std::endl;
    if (obj.pPushConstantRanges) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.pushConstantRangeCount; i++) {
            if (i + 1 == obj.pushConstantRangeCount)
                print_VkPushConstantRange(obj.pPushConstantRanges[i], "pPushConstantRanges", 0);
            else
                print_VkPushConstantRange(obj.pPushConstantRanges[i], "pPushConstantRanges", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pSpecializationInfo\": " << std::endl;
    if (obj.pSpecializationInfo) {
        print_VkSpecializationInfo(obj.pSpecializationInfo, "pSpecializationInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkShaderCreateInfoEXT(const VkShaderCreateInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderCreateFlagsEXT(obj->flags, "flags", 1);

    print_VkShaderStageFlagBits(obj->stage, "stage", 1);

    print_VkShaderStageFlags(obj->nextStage, "nextStage", 1);

    print_VkShaderCodeTypeEXT(obj->codeType, "codeType", 1);

    print_size_t(obj->codeSize, "codeSize", 1);

    /** Note: Ignoring void* data. **/

    print_char(obj->pName, "pName", 1);

    print_uint32_t(obj->setLayoutCount, "setLayoutCount", 1);

    PRINT_SPACE
    _OUT << "\"pSetLayouts\":" << std::endl;
    PRINT_SPACE
    if (obj->pSetLayouts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->setLayoutCount; i++) {
            std::stringstream tmp;
            tmp << "pSetLayouts"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->setLayoutCount;
            print_VkDescriptorSetLayout(obj->pSetLayouts[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->pushConstantRangeCount, "pushConstantRangeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPushConstantRanges\": " << std::endl;
    if (obj->pPushConstantRanges) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->pushConstantRangeCount; i++) {
            if (i + 1 == obj->pushConstantRangeCount)
                print_VkPushConstantRange(obj->pPushConstantRanges[i], "pPushConstantRanges", 0);
            else
                print_VkPushConstantRange(obj->pPushConstantRanges[i], "pPushConstantRanges", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pSpecializationInfo\": " << std::endl;
    if (obj->pSpecializationInfo) {
        print_VkSpecializationInfo(obj->pSpecializationInfo, "pSpecializationInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

typedef VkPipelineShaderStageRequiredSubgroupSizeCreateInfo VkShaderRequiredSubgroupSizeCreateInfoEXT;

static void print_VkDepthClampRangeEXT(VkDepthClampRangeEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj.minDepthClamp, "minDepthClamp", 1);

    print_float(obj.maxDepthClamp, "maxDepthClamp", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDepthClampRangeEXT(const VkDepthClampRangeEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_float(obj->minDepthClamp, "minDepthClamp", 1);

    print_float(obj->maxDepthClamp, "maxDepthClamp", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceTilePropertiesFeaturesQCOM(VkPhysicalDeviceTilePropertiesFeaturesQCOM obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.tileProperties, "tileProperties", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceTilePropertiesFeaturesQCOM(const VkPhysicalDeviceTilePropertiesFeaturesQCOM* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->tileProperties, "tileProperties", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkTilePropertiesQCOM(VkTilePropertiesQCOM obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"tileSize\": " << std::endl;
    { print_VkExtent3D(obj.tileSize, "tileSize", 1); }

    PRINT_SPACE
    _OUT << "\"apronSize\": " << std::endl;
    { print_VkExtent2D(obj.apronSize, "apronSize", 1); }

    PRINT_SPACE
    _OUT << "\"origin\": " << std::endl;
    { print_VkOffset2D(obj.origin, "origin", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkTilePropertiesQCOM(const VkTilePropertiesQCOM* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"tileSize\": " << std::endl;
    { print_VkExtent3D(obj->tileSize, "tileSize", 1); }

    PRINT_SPACE
    _OUT << "\"apronSize\": " << std::endl;
    { print_VkExtent2D(obj->apronSize, "apronSize", 1); }

    PRINT_SPACE
    _OUT << "\"origin\": " << std::endl;
    { print_VkOffset2D(obj->origin, "origin", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceAmigoProfilingFeaturesSEC(VkPhysicalDeviceAmigoProfilingFeaturesSEC obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.amigoProfiling, "amigoProfiling", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceAmigoProfilingFeaturesSEC(const VkPhysicalDeviceAmigoProfilingFeaturesSEC* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->amigoProfiling, "amigoProfiling", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAmigoProfilingSubmitInfoSEC(VkAmigoProfilingSubmitInfoSEC obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.firstDrawTimestamp, "firstDrawTimestamp", 1);

    print_uint64_t(obj.swapBufferTimestamp, "swapBufferTimestamp", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAmigoProfilingSubmitInfoSEC(const VkAmigoProfilingSubmitInfoSEC* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->firstDrawTimestamp, "firstDrawTimestamp", 1);

    print_uint64_t(obj->swapBufferTimestamp, "swapBufferTimestamp", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.multiviewPerViewViewports, "multiviewPerViewViewports", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(
    const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->multiviewPerViewViewports, "multiviewPerViewViewports", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkRayTracingInvocationReorderModeNV_map = {
    std::make_pair(0, "VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV"),
    std::make_pair(1, "VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV"),
};
static void print_VkRayTracingInvocationReorderModeNV(VkRayTracingInvocationReorderModeNV obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRayTracingInvocationReorderModeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRayTracingInvocationReorderModeNV_map[obj] << "\"" << std::endl;
}
static void print_VkRayTracingInvocationReorderModeNV(const VkRayTracingInvocationReorderModeNV* obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkRayTracingInvocationReorderModeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkRayTracingInvocationReorderModeNV_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(
    VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRayTracingInvocationReorderModeNV(obj.rayTracingInvocationReorderReorderingHint,
                                              "rayTracingInvocationReorderReorderingHint", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(
    const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRayTracingInvocationReorderModeNV(obj->rayTracingInvocationReorderReorderingHint,
                                              "rayTracingInvocationReorderReorderingHint", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.rayTracingInvocationReorder, "rayTracingInvocationReorder", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(
    const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->rayTracingInvocationReorder, "rayTracingInvocationReorder", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkCooperativeVectorMatrixLayoutNV_map = {
    std::make_pair(0, "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV"),
    std::make_pair(1, "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV"),
    std::make_pair(2, "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV"),
    std::make_pair(3, "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV"),
};
static void print_VkCooperativeVectorMatrixLayoutNV(VkCooperativeVectorMatrixLayoutNV obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCooperativeVectorMatrixLayoutNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCooperativeVectorMatrixLayoutNV_map[obj] << "\"" << std::endl;
}
static void print_VkCooperativeVectorMatrixLayoutNV(const VkCooperativeVectorMatrixLayoutNV* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCooperativeVectorMatrixLayoutNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCooperativeVectorMatrixLayoutNV_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDeviceCooperativeVectorPropertiesNV obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj.cooperativeVectorSupportedStages, "cooperativeVectorSupportedStages", 1);

    print_VkBool32(obj.cooperativeVectorTrainingFloat16Accumulation, "cooperativeVectorTrainingFloat16Accumulation", 1);

    print_VkBool32(obj.cooperativeVectorTrainingFloat32Accumulation, "cooperativeVectorTrainingFloat32Accumulation", 1);

    print_uint32_t(obj.maxCooperativeVectorComponents, "maxCooperativeVectorComponents", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCooperativeVectorPropertiesNV(const VkPhysicalDeviceCooperativeVectorPropertiesNV* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj->cooperativeVectorSupportedStages, "cooperativeVectorSupportedStages", 1);

    print_VkBool32(obj->cooperativeVectorTrainingFloat16Accumulation, "cooperativeVectorTrainingFloat16Accumulation", 1);

    print_VkBool32(obj->cooperativeVectorTrainingFloat32Accumulation, "cooperativeVectorTrainingFloat32Accumulation", 1);

    print_uint32_t(obj->maxCooperativeVectorComponents, "maxCooperativeVectorComponents", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCooperativeVectorFeaturesNV(VkPhysicalDeviceCooperativeVectorFeaturesNV obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.cooperativeVector, "cooperativeVector", 1);

    print_VkBool32(obj.cooperativeVectorTraining, "cooperativeVectorTraining", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCooperativeVectorFeaturesNV(const VkPhysicalDeviceCooperativeVectorFeaturesNV* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->cooperativeVector, "cooperativeVector", 1);

    print_VkBool32(obj->cooperativeVectorTraining, "cooperativeVectorTraining", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCooperativeVectorPropertiesNV(VkCooperativeVectorPropertiesNV obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkComponentTypeKHR(obj.inputType, "inputType", 1);

    print_VkComponentTypeKHR(obj.inputInterpretation, "inputInterpretation", 1);

    print_VkComponentTypeKHR(obj.matrixInterpretation, "matrixInterpretation", 1);

    print_VkComponentTypeKHR(obj.biasInterpretation, "biasInterpretation", 1);

    print_VkComponentTypeKHR(obj.resultType, "resultType", 1);

    print_VkBool32(obj.transpose, "transpose", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCooperativeVectorPropertiesNV(const VkCooperativeVectorPropertiesNV* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkComponentTypeKHR(obj->inputType, "inputType", 1);

    print_VkComponentTypeKHR(obj->inputInterpretation, "inputInterpretation", 1);

    print_VkComponentTypeKHR(obj->matrixInterpretation, "matrixInterpretation", 1);

    print_VkComponentTypeKHR(obj->biasInterpretation, "biasInterpretation", 1);

    print_VkComponentTypeKHR(obj->resultType, "resultType", 1);

    print_VkBool32(obj->transpose, "transpose", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkConvertCooperativeVectorMatrixInfoNV(VkConvertCooperativeVectorMatrixInfoNV obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_size_t(obj.srcSize, "srcSize", 1);

    print_VkDeviceOrHostAddressConstKHR(obj.srcData, "srcData", 1);

    print_size_t(obj.pDstSize, "pDstSize", 1);

    print_VkDeviceOrHostAddressKHR(obj.dstData, "dstData", 1);

    print_VkComponentTypeKHR(obj.srcComponentType, "srcComponentType", 1);

    print_VkComponentTypeKHR(obj.dstComponentType, "dstComponentType", 1);

    print_uint32_t(obj.numRows, "numRows", 1);

    print_uint32_t(obj.numColumns, "numColumns", 1);

    print_VkCooperativeVectorMatrixLayoutNV(obj.srcLayout, "srcLayout", 1);

    print_size_t(obj.srcStride, "srcStride", 1);

    print_VkCooperativeVectorMatrixLayoutNV(obj.dstLayout, "dstLayout", 1);

    print_size_t(obj.dstStride, "dstStride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkConvertCooperativeVectorMatrixInfoNV(const VkConvertCooperativeVectorMatrixInfoNV* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_size_t(obj->srcSize, "srcSize", 1);

    print_VkDeviceOrHostAddressConstKHR(obj->srcData, "srcData", 1);

    print_size_t(obj->pDstSize, "pDstSize", 1);

    print_VkDeviceOrHostAddressKHR(obj->dstData, "dstData", 1);

    print_VkComponentTypeKHR(obj->srcComponentType, "srcComponentType", 1);

    print_VkComponentTypeKHR(obj->dstComponentType, "dstComponentType", 1);

    print_uint32_t(obj->numRows, "numRows", 1);

    print_uint32_t(obj->numColumns, "numColumns", 1);

    print_VkCooperativeVectorMatrixLayoutNV(obj->srcLayout, "srcLayout", 1);

    print_size_t(obj->srcStride, "srcStride", 1);

    print_VkCooperativeVectorMatrixLayoutNV(obj->dstLayout, "dstLayout", 1);

    print_size_t(obj->dstStride, "dstStride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV(VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.extendedSparseAddressSpace, "extendedSparseAddressSpace", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV(
    const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->extendedSparseAddressSpace, "extendedSparseAddressSpace", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV(VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV obj,
                                                                         const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj.extendedSparseAddressSpaceSize, "extendedSparseAddressSpaceSize", 1);

    print_VkImageUsageFlags(obj.extendedSparseImageUsageFlags, "extendedSparseImageUsageFlags", 1);

    print_VkBufferUsageFlags(obj.extendedSparseBufferUsageFlags, "extendedSparseBufferUsageFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV(
    const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj->extendedSparseAddressSpaceSize, "extendedSparseAddressSpaceSize", 1);

    print_VkImageUsageFlags(obj->extendedSparseImageUsageFlags, "extendedSparseImageUsageFlags", 1);

    print_VkBufferUsageFlags(obj->extendedSparseBufferUsageFlags, "extendedSparseBufferUsageFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.legacyVertexAttributes, "legacyVertexAttributes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->legacyVertexAttributes, "legacyVertexAttributes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.nativeUnalignedPerformance, "nativeUnalignedPerformance", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(
    const VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->nativeUnalignedPerformance, "nativeUnalignedPerformance", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkLayerSettingTypeEXT_map = {
    std::make_pair(0, "VK_LAYER_SETTING_TYPE_BOOL32_EXT"),  std::make_pair(1, "VK_LAYER_SETTING_TYPE_INT32_EXT"),
    std::make_pair(2, "VK_LAYER_SETTING_TYPE_INT64_EXT"),   std::make_pair(3, "VK_LAYER_SETTING_TYPE_UINT32_EXT"),
    std::make_pair(4, "VK_LAYER_SETTING_TYPE_UINT64_EXT"),  std::make_pair(5, "VK_LAYER_SETTING_TYPE_FLOAT32_EXT"),
    std::make_pair(6, "VK_LAYER_SETTING_TYPE_FLOAT64_EXT"), std::make_pair(7, "VK_LAYER_SETTING_TYPE_STRING_EXT"),
};
static void print_VkLayerSettingTypeEXT(VkLayerSettingTypeEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLayerSettingTypeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLayerSettingTypeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkLayerSettingTypeEXT(const VkLayerSettingTypeEXT* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLayerSettingTypeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLayerSettingTypeEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkLayerSettingEXT(VkLayerSettingEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_char(obj.pLayerName, "pLayerName", 1);

    print_char(obj.pSettingName, "pSettingName", 1);

    print_VkLayerSettingTypeEXT(obj.type, "type", 1);

    print_uint32_t(obj.valueCount, "valueCount", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkLayerSettingEXT(const VkLayerSettingEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_char(obj->pLayerName, "pLayerName", 1);

    print_char(obj->pSettingName, "pSettingName", 1);

    print_VkLayerSettingTypeEXT(obj->type, "type", 1);

    print_uint32_t(obj->valueCount, "valueCount", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkLayerSettingsCreateInfoEXT(VkLayerSettingsCreateInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.settingCount, "settingCount", 1);

    PRINT_SPACE
    _OUT << "\"pSettings\": " << std::endl;
    if (obj.pSettings) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.settingCount; i++) {
            if (i + 1 == obj.settingCount)
                print_VkLayerSettingEXT(obj.pSettings[i], "pSettings", 0);
            else
                print_VkLayerSettingEXT(obj.pSettings[i], "pSettings", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkLayerSettingsCreateInfoEXT(const VkLayerSettingsCreateInfoEXT* obj, const std::string& s,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->settingCount, "settingCount", 1);

    PRINT_SPACE
    _OUT << "\"pSettings\": " << std::endl;
    if (obj->pSettings) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->settingCount; i++) {
            if (i + 1 == obj->settingCount)
                print_VkLayerSettingEXT(obj->pSettings[i], "pSettings", 0);
            else
                print_VkLayerSettingEXT(obj->pSettings[i], "pSettings", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderCoreBuiltins, "shaderCoreBuiltins", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderCoreBuiltins, "shaderCoreBuiltins", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.shaderCoreMask, "shaderCoreMask", 1);

    print_uint32_t(obj.shaderCoreCount, "shaderCoreCount", 1);

    print_uint32_t(obj.shaderWarpsPerCore, "shaderWarpsPerCore", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->shaderCoreMask, "shaderCoreMask", 1);

    print_uint32_t(obj->shaderCoreCount, "shaderCoreCount", 1);

    print_uint32_t(obj->shaderWarpsPerCore, "shaderWarpsPerCore", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT obj,
                                                                         const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.pipelineLibraryGroupHandles, "pipelineLibraryGroupHandles", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(
    const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->pipelineLibraryGroupHandles, "pipelineLibraryGroupHandles", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(
    VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.dynamicRenderingUnusedAttachments, "dynamicRenderingUnusedAttachments", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(
    const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->dynamicRenderingUnusedAttachments, "dynamicRenderingUnusedAttachments", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkLatencyMarkerNV_map = {
    std::make_pair(0, "VK_LATENCY_MARKER_SIMULATION_START_NV"),
    std::make_pair(1, "VK_LATENCY_MARKER_SIMULATION_END_NV"),
    std::make_pair(2, "VK_LATENCY_MARKER_RENDERSUBMIT_START_NV"),
    std::make_pair(3, "VK_LATENCY_MARKER_RENDERSUBMIT_END_NV"),
    std::make_pair(4, "VK_LATENCY_MARKER_PRESENT_START_NV"),
    std::make_pair(5, "VK_LATENCY_MARKER_PRESENT_END_NV"),
    std::make_pair(6, "VK_LATENCY_MARKER_INPUT_SAMPLE_NV"),
    std::make_pair(7, "VK_LATENCY_MARKER_TRIGGER_FLASH_NV"),
    std::make_pair(8, "VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV"),
    std::make_pair(9, "VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV"),
    std::make_pair(10, "VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV"),
    std::make_pair(11, "VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV"),
};
static void print_VkLatencyMarkerNV(VkLatencyMarkerNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLatencyMarkerNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLatencyMarkerNV_map[obj] << "\"" << std::endl;
}
static void print_VkLatencyMarkerNV(const VkLatencyMarkerNV* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLatencyMarkerNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLatencyMarkerNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkOutOfBandQueueTypeNV_map = {
    std::make_pair(0, "VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV"),
    std::make_pair(1, "VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV"),
};
static void print_VkOutOfBandQueueTypeNV(VkOutOfBandQueueTypeNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOutOfBandQueueTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOutOfBandQueueTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkOutOfBandQueueTypeNV(const VkOutOfBandQueueTypeNV* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkOutOfBandQueueTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkOutOfBandQueueTypeNV_map[*obj] << "\"" << std::endl;
}

static void print_VkLatencySleepModeInfoNV(VkLatencySleepModeInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.lowLatencyMode, "lowLatencyMode", 1);

    print_VkBool32(obj.lowLatencyBoost, "lowLatencyBoost", 1);

    print_uint32_t(obj.minimumIntervalUs, "minimumIntervalUs", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkLatencySleepModeInfoNV(const VkLatencySleepModeInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->lowLatencyMode, "lowLatencyMode", 1);

    print_VkBool32(obj->lowLatencyBoost, "lowLatencyBoost", 1);

    print_uint32_t(obj->minimumIntervalUs, "minimumIntervalUs", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkLatencySleepInfoNV(VkLatencySleepInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "signalSemaphore"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint64_t(obj.value, "value", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkLatencySleepInfoNV(const VkLatencySleepInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "signalSemaphore"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint64_t(obj->value, "value", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSetLatencyMarkerInfoNV(VkSetLatencyMarkerInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.presentID, "presentID", 1);

    print_VkLatencyMarkerNV(obj.marker, "marker", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSetLatencyMarkerInfoNV(const VkSetLatencyMarkerInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->presentID, "presentID", 1);

    print_VkLatencyMarkerNV(obj->marker, "marker", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkLatencyTimingsFrameReportNV(VkLatencyTimingsFrameReportNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.presentID, "presentID", 1);

    print_uint64_t(obj.inputSampleTimeUs, "inputSampleTimeUs", 1);

    print_uint64_t(obj.simStartTimeUs, "simStartTimeUs", 1);

    print_uint64_t(obj.simEndTimeUs, "simEndTimeUs", 1);

    print_uint64_t(obj.renderSubmitStartTimeUs, "renderSubmitStartTimeUs", 1);

    print_uint64_t(obj.renderSubmitEndTimeUs, "renderSubmitEndTimeUs", 1);

    print_uint64_t(obj.presentStartTimeUs, "presentStartTimeUs", 1);

    print_uint64_t(obj.presentEndTimeUs, "presentEndTimeUs", 1);

    print_uint64_t(obj.driverStartTimeUs, "driverStartTimeUs", 1);

    print_uint64_t(obj.driverEndTimeUs, "driverEndTimeUs", 1);

    print_uint64_t(obj.osRenderQueueStartTimeUs, "osRenderQueueStartTimeUs", 1);

    print_uint64_t(obj.osRenderQueueEndTimeUs, "osRenderQueueEndTimeUs", 1);

    print_uint64_t(obj.gpuRenderStartTimeUs, "gpuRenderStartTimeUs", 1);

    print_uint64_t(obj.gpuRenderEndTimeUs, "gpuRenderEndTimeUs", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkLatencyTimingsFrameReportNV(const VkLatencyTimingsFrameReportNV* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->presentID, "presentID", 1);

    print_uint64_t(obj->inputSampleTimeUs, "inputSampleTimeUs", 1);

    print_uint64_t(obj->simStartTimeUs, "simStartTimeUs", 1);

    print_uint64_t(obj->simEndTimeUs, "simEndTimeUs", 1);

    print_uint64_t(obj->renderSubmitStartTimeUs, "renderSubmitStartTimeUs", 1);

    print_uint64_t(obj->renderSubmitEndTimeUs, "renderSubmitEndTimeUs", 1);

    print_uint64_t(obj->presentStartTimeUs, "presentStartTimeUs", 1);

    print_uint64_t(obj->presentEndTimeUs, "presentEndTimeUs", 1);

    print_uint64_t(obj->driverStartTimeUs, "driverStartTimeUs", 1);

    print_uint64_t(obj->driverEndTimeUs, "driverEndTimeUs", 1);

    print_uint64_t(obj->osRenderQueueStartTimeUs, "osRenderQueueStartTimeUs", 1);

    print_uint64_t(obj->osRenderQueueEndTimeUs, "osRenderQueueEndTimeUs", 1);

    print_uint64_t(obj->gpuRenderStartTimeUs, "gpuRenderStartTimeUs", 1);

    print_uint64_t(obj->gpuRenderEndTimeUs, "gpuRenderEndTimeUs", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGetLatencyMarkerInfoNV(VkGetLatencyMarkerInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.timingCount, "timingCount", 1);

    PRINT_SPACE
    _OUT << "\"pTimings\": " << std::endl;
    if (obj.pTimings) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.timingCount; i++) {
            if (i + 1 == obj.timingCount)
                print_VkLatencyTimingsFrameReportNV(obj.pTimings[i], "pTimings", 0);
            else
                print_VkLatencyTimingsFrameReportNV(obj.pTimings[i], "pTimings", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGetLatencyMarkerInfoNV(const VkGetLatencyMarkerInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->timingCount, "timingCount", 1);

    PRINT_SPACE
    _OUT << "\"pTimings\": " << std::endl;
    if (obj->pTimings) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->timingCount; i++) {
            if (i + 1 == obj->timingCount)
                print_VkLatencyTimingsFrameReportNV(obj->pTimings[i], "pTimings", 0);
            else
                print_VkLatencyTimingsFrameReportNV(obj->pTimings[i], "pTimings", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkLatencySubmissionPresentIdNV(VkLatencySubmissionPresentIdNV obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.presentID, "presentID", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkLatencySubmissionPresentIdNV(const VkLatencySubmissionPresentIdNV* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->presentID, "presentID", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSwapchainLatencyCreateInfoNV(VkSwapchainLatencyCreateInfoNV obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.latencyModeEnable, "latencyModeEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSwapchainLatencyCreateInfoNV(const VkSwapchainLatencyCreateInfoNV* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->latencyModeEnable, "latencyModeEnable", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkOutOfBandQueueTypeInfoNV(VkOutOfBandQueueTypeInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkOutOfBandQueueTypeNV(obj.queueType, "queueType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkOutOfBandQueueTypeInfoNV(const VkOutOfBandQueueTypeInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkOutOfBandQueueTypeNV(obj->queueType, "queueType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkLatencySurfaceCapabilitiesNV(VkLatencySurfaceCapabilitiesNV obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.presentModeCount, "presentModeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPresentModes\":" << std::endl;
    PRINT_SPACE
    if (obj.pPresentModes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.presentModeCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.presentModeCount;
            print_VkPresentModeKHR(obj.pPresentModes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkLatencySurfaceCapabilitiesNV(const VkLatencySurfaceCapabilitiesNV* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->presentModeCount, "presentModeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPresentModes\":" << std::endl;
    PRINT_SPACE
    if (obj->pPresentModes) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->presentModeCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->presentModeCount;
            print_VkPresentModeKHR(obj->pPresentModes[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(
    VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.multiviewPerViewRenderAreas, "multiviewPerViewRenderAreas", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(
    const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->multiviewPerViewRenderAreas, "multiviewPerViewRenderAreas", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.perViewRenderAreaCount, "perViewRenderAreaCount", 1);

    PRINT_SPACE
    _OUT << "\"pPerViewRenderAreas\": " << std::endl;
    if (obj.pPerViewRenderAreas) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.perViewRenderAreaCount; i++) {
            if (i + 1 == obj.perViewRenderAreaCount)
                print_VkRect2D(obj.pPerViewRenderAreas[i], "pPerViewRenderAreas", 0);
            else
                print_VkRect2D(obj.pPerViewRenderAreas[i], "pPerViewRenderAreas", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(
    const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->perViewRenderAreaCount, "perViewRenderAreaCount", 1);

    PRINT_SPACE
    _OUT << "\"pPerViewRenderAreas\": " << std::endl;
    if (obj->pPerViewRenderAreas) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->perViewRenderAreaCount; i++) {
            if (i + 1 == obj->perViewRenderAreaCount)
                print_VkRect2D(obj->pPerViewRenderAreas[i], "pPerViewRenderAreas", 0);
            else
                print_VkRect2D(obj->pPerViewRenderAreas[i], "pPerViewRenderAreas", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePerStageDescriptorSetFeaturesNV(VkPhysicalDevicePerStageDescriptorSetFeaturesNV obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.perStageDescriptorSet, "perStageDescriptorSet", 1);

    print_VkBool32(obj.dynamicPipelineLayout, "dynamicPipelineLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePerStageDescriptorSetFeaturesNV(const VkPhysicalDevicePerStageDescriptorSetFeaturesNV* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->perStageDescriptorSet, "perStageDescriptorSet", 1);

    print_VkBool32(obj->dynamicPipelineLayout, "dynamicPipelineLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkBlockMatchWindowCompareModeQCOM_map = {
    std::make_pair(0, "VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM"),
    std::make_pair(1, "VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM"),
};
static void print_VkBlockMatchWindowCompareModeQCOM(VkBlockMatchWindowCompareModeQCOM obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBlockMatchWindowCompareModeQCOM_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBlockMatchWindowCompareModeQCOM_map[obj] << "\"" << std::endl;
}
static void print_VkBlockMatchWindowCompareModeQCOM(const VkBlockMatchWindowCompareModeQCOM* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBlockMatchWindowCompareModeQCOM_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBlockMatchWindowCompareModeQCOM_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceImageProcessing2FeaturesQCOM(VkPhysicalDeviceImageProcessing2FeaturesQCOM obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.textureBlockMatch2, "textureBlockMatch2", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageProcessing2FeaturesQCOM(const VkPhysicalDeviceImageProcessing2FeaturesQCOM* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->textureBlockMatch2, "textureBlockMatch2", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceImageProcessing2PropertiesQCOM(VkPhysicalDeviceImageProcessing2PropertiesQCOM obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"maxBlockMatchWindow\": " << std::endl;
    { print_VkExtent2D(obj.maxBlockMatchWindow, "maxBlockMatchWindow", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageProcessing2PropertiesQCOM(const VkPhysicalDeviceImageProcessing2PropertiesQCOM* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"maxBlockMatchWindow\": " << std::endl;
    { print_VkExtent2D(obj->maxBlockMatchWindow, "maxBlockMatchWindow", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSamplerBlockMatchWindowCreateInfoQCOM(VkSamplerBlockMatchWindowCreateInfoQCOM obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"windowExtent\": " << std::endl;
    { print_VkExtent2D(obj.windowExtent, "windowExtent", 1); }

    print_VkBlockMatchWindowCompareModeQCOM(obj.windowCompareMode, "windowCompareMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSamplerBlockMatchWindowCreateInfoQCOM(const VkSamplerBlockMatchWindowCreateInfoQCOM* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"windowExtent\": " << std::endl;
    { print_VkExtent2D(obj->windowExtent, "windowExtent", 1); }

    print_VkBlockMatchWindowCompareModeQCOM(obj->windowCompareMode, "windowCompareMode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkCubicFilterWeightsQCOM_map = {
    std::make_pair(0, "VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM"),
    std::make_pair(1, "VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM"),
    std::make_pair(2, "VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM"),
    std::make_pair(3, "VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM"),
};
static void print_VkCubicFilterWeightsQCOM(VkCubicFilterWeightsQCOM obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCubicFilterWeightsQCOM_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCubicFilterWeightsQCOM_map[obj] << "\"" << std::endl;
}
static void print_VkCubicFilterWeightsQCOM(const VkCubicFilterWeightsQCOM* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkCubicFilterWeightsQCOM_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkCubicFilterWeightsQCOM_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceCubicWeightsFeaturesQCOM(VkPhysicalDeviceCubicWeightsFeaturesQCOM obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.selectableCubicWeights, "selectableCubicWeights", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCubicWeightsFeaturesQCOM(const VkPhysicalDeviceCubicWeightsFeaturesQCOM* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->selectableCubicWeights, "selectableCubicWeights", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSamplerCubicWeightsCreateInfoQCOM(VkSamplerCubicWeightsCreateInfoQCOM obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkCubicFilterWeightsQCOM(obj.cubicWeights, "cubicWeights", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSamplerCubicWeightsCreateInfoQCOM(const VkSamplerCubicWeightsCreateInfoQCOM* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkCubicFilterWeightsQCOM(obj->cubicWeights, "cubicWeights", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBlitImageCubicWeightsInfoQCOM(VkBlitImageCubicWeightsInfoQCOM obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkCubicFilterWeightsQCOM(obj.cubicWeights, "cubicWeights", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBlitImageCubicWeightsInfoQCOM(const VkBlitImageCubicWeightsInfoQCOM* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkCubicFilterWeightsQCOM(obj->cubicWeights, "cubicWeights", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM(VkPhysicalDeviceYcbcrDegammaFeaturesQCOM obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.ycbcrDegamma, "ycbcrDegamma", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM(const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->ycbcrDegamma, "ycbcrDegamma", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM(VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.enableYDegamma, "enableYDegamma", 1);

    print_VkBool32(obj.enableCbCrDegamma, "enableCbCrDegamma", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM(const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->enableYDegamma, "enableYDegamma", 1);

    print_VkBool32(obj->enableCbCrDegamma, "enableCbCrDegamma", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCubicClampFeaturesQCOM(VkPhysicalDeviceCubicClampFeaturesQCOM obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.cubicRangeClamp, "cubicRangeClamp", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCubicClampFeaturesQCOM(const VkPhysicalDeviceCubicClampFeaturesQCOM* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->cubicRangeClamp, "cubicRangeClamp", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(
    VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.attachmentFeedbackLoopDynamicState, "attachmentFeedbackLoopDynamicState", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(
    const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->attachmentFeedbackLoopDynamicState, "attachmentFeedbackLoopDynamicState", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkLayeredDriverUnderlyingApiMSFT_map = {
    std::make_pair(0, "VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT"),
    std::make_pair(1, "VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT"),
};
static void print_VkLayeredDriverUnderlyingApiMSFT(VkLayeredDriverUnderlyingApiMSFT obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLayeredDriverUnderlyingApiMSFT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLayeredDriverUnderlyingApiMSFT_map[obj] << "\"" << std::endl;
}
static void print_VkLayeredDriverUnderlyingApiMSFT(const VkLayeredDriverUnderlyingApiMSFT* obj, const std::string& str,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkLayeredDriverUnderlyingApiMSFT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkLayeredDriverUnderlyingApiMSFT_map[*obj] << "\"" << std::endl;
}

static void print_VkPhysicalDeviceLayeredDriverPropertiesMSFT(VkPhysicalDeviceLayeredDriverPropertiesMSFT obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkLayeredDriverUnderlyingApiMSFT(obj.underlyingAPI, "underlyingAPI", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceLayeredDriverPropertiesMSFT(const VkPhysicalDeviceLayeredDriverPropertiesMSFT* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkLayeredDriverUnderlyingApiMSFT(obj->underlyingAPI, "underlyingAPI", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV(VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV obj,
                                                                         const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.descriptorPoolOverallocation, "descriptorPoolOverallocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV(
    const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->descriptorPoolOverallocation, "descriptorPoolOverallocation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkDisplaySurfaceStereoTypeNV_map = {
    std::make_pair(0, "VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV"),
    std::make_pair(1, "VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV"),
    std::make_pair(2, "VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV"),
    std::make_pair(3, "VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV"),
};
static void print_VkDisplaySurfaceStereoTypeNV(VkDisplaySurfaceStereoTypeNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDisplaySurfaceStereoTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDisplaySurfaceStereoTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkDisplaySurfaceStereoTypeNV(const VkDisplaySurfaceStereoTypeNV* obj, const std::string& str,
                                               bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkDisplaySurfaceStereoTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkDisplaySurfaceStereoTypeNV_map[*obj] << "\"" << std::endl;
}

static void print_VkDisplaySurfaceStereoCreateInfoNV(VkDisplaySurfaceStereoCreateInfoNV obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDisplaySurfaceStereoTypeNV(obj.stereoType, "stereoType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplaySurfaceStereoCreateInfoNV(const VkDisplaySurfaceStereoCreateInfoNV* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDisplaySurfaceStereoTypeNV(obj->stereoType, "stereoType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDisplayModeStereoPropertiesNV(VkDisplayModeStereoPropertiesNV obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.hdmi3DSupported, "hdmi3DSupported", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDisplayModeStereoPropertiesNV(const VkDisplayModeStereoPropertiesNV* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->hdmi3DSupported, "hdmi3DSupported", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRawAccessChainsFeaturesNV(VkPhysicalDeviceRawAccessChainsFeaturesNV obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderRawAccessChains, "shaderRawAccessChains", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRawAccessChainsFeaturesNV(const VkPhysicalDeviceRawAccessChainsFeaturesNV* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderRawAccessChains, "shaderRawAccessChains", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV(VkPhysicalDeviceCommandBufferInheritanceFeaturesNV obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.commandBufferInheritance, "commandBufferInheritance", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV(const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->commandBufferInheritance, "commandBufferInheritance", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV(VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderFloat16VectorAtomics, "shaderFloat16VectorAtomics", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV(
    const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderFloat16VectorAtomics, "shaderFloat16VectorAtomics", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.shaderReplicatedComposites, "shaderReplicatedComposites", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(
    const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->shaderReplicatedComposites, "shaderReplicatedComposites", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRayTracingValidationFeaturesNV(VkPhysicalDeviceRayTracingValidationFeaturesNV obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.rayTracingValidation, "rayTracingValidation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRayTracingValidationFeaturesNV(const VkPhysicalDeviceRayTracingValidationFeaturesNV* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->rayTracingValidation, "rayTracingValidation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkClusterAccelerationStructureTypeNV_map = {
    std::make_pair(0, "VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV"),
    std::make_pair(1, "VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV"),
    std::make_pair(2, "VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV"),
};
static void print_VkClusterAccelerationStructureTypeNV(VkClusterAccelerationStructureTypeNV obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkClusterAccelerationStructureTypeNV(const VkClusterAccelerationStructureTypeNV* obj, const std::string& str,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureTypeNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkClusterAccelerationStructureOpTypeNV_map = {
    std::make_pair(0, "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV"),
    std::make_pair(1, "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV"),
    std::make_pair(2, "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV"),
    std::make_pair(3, "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV"),
    std::make_pair(4, "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV"),
};
static void print_VkClusterAccelerationStructureOpTypeNV(VkClusterAccelerationStructureOpTypeNV obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureOpTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureOpTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkClusterAccelerationStructureOpTypeNV(const VkClusterAccelerationStructureOpTypeNV* obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureOpTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureOpTypeNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkClusterAccelerationStructureOpModeNV_map = {
    std::make_pair(0, "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV"),
    std::make_pair(1, "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV"),
    std::make_pair(2, "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV"),
};
static void print_VkClusterAccelerationStructureOpModeNV(VkClusterAccelerationStructureOpModeNV obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureOpModeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureOpModeNV_map[obj] << "\"" << std::endl;
}
static void print_VkClusterAccelerationStructureOpModeNV(const VkClusterAccelerationStructureOpModeNV* obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureOpModeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureOpModeNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkClusterAccelerationStructureAddressResolutionFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV"),
    std::make_pair(1ULL << 1, "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV"),
    std::make_pair(1ULL << 2, "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV"),
    std::make_pair(1ULL << 3, "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV"),
    std::make_pair(1ULL << 4, "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV"),
    std::make_pair(1ULL << 5, "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV"),
};
static void print_VkClusterAccelerationStructureAddressResolutionFlagBitsNV(
    VkClusterAccelerationStructureAddressResolutionFlagBitsNV obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureAddressResolutionFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureAddressResolutionFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkClusterAccelerationStructureAddressResolutionFlagBitsNV(
    const VkClusterAccelerationStructureAddressResolutionFlagBitsNV* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureAddressResolutionFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureAddressResolutionFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkClusterAccelerationStructureClusterFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV"),
};
static void print_VkClusterAccelerationStructureClusterFlagBitsNV(VkClusterAccelerationStructureClusterFlagBitsNV obj,
                                                                  const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureClusterFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureClusterFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkClusterAccelerationStructureClusterFlagBitsNV(const VkClusterAccelerationStructureClusterFlagBitsNV* obj,
                                                                  const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureClusterFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureClusterFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkClusterAccelerationStructureGeometryFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV"),
    std::make_pair(1ULL << 1, "VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV"),
    std::make_pair(1ULL << 2, "VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV"),
};
static void print_VkClusterAccelerationStructureGeometryFlagBitsNV(VkClusterAccelerationStructureGeometryFlagBitsNV obj,
                                                                   const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureGeometryFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureGeometryFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkClusterAccelerationStructureGeometryFlagBitsNV(const VkClusterAccelerationStructureGeometryFlagBitsNV* obj,
                                                                   const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureGeometryFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureGeometryFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkClusterAccelerationStructureIndexFormatFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV"),
    std::make_pair(1ULL << 1, "VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV"),
    std::make_pair(1ULL << 2, "VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV"),
};
static void print_VkClusterAccelerationStructureIndexFormatFlagBitsNV(VkClusterAccelerationStructureIndexFormatFlagBitsNV obj,
                                                                      const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureIndexFormatFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureIndexFormatFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkClusterAccelerationStructureIndexFormatFlagBitsNV(
    const VkClusterAccelerationStructureIndexFormatFlagBitsNV* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkClusterAccelerationStructureIndexFormatFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkClusterAccelerationStructureIndexFormatFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static void print_VkClusterAccelerationStructureAddressResolutionFlagsNV(VkClusterAccelerationStructureAddressResolutionFlagsNV obj,
                                                                         const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkClusterAccelerationStructureAddressResolutionFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkClusterAccelerationStructureAddressResolutionFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkClusterAccelerationStructureClusterFlagsNV(VkClusterAccelerationStructureClusterFlagsNV obj,
                                                               const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkClusterAccelerationStructureClusterFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkClusterAccelerationStructureClusterFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkClusterAccelerationStructureGeometryFlagsNV(VkClusterAccelerationStructureGeometryFlagsNV obj,
                                                                const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkClusterAccelerationStructureGeometryFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkClusterAccelerationStructureGeometryFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkClusterAccelerationStructureIndexFormatFlagsNV(VkClusterAccelerationStructureIndexFormatFlagsNV obj,
                                                                   const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkClusterAccelerationStructureIndexFormatFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkClusterAccelerationStructureIndexFormatFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceClusterAccelerationStructureFeaturesNV(VkPhysicalDeviceClusterAccelerationStructureFeaturesNV obj,
                                                                         const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.clusterAccelerationStructure, "clusterAccelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceClusterAccelerationStructureFeaturesNV(
    const VkPhysicalDeviceClusterAccelerationStructureFeaturesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->clusterAccelerationStructure, "clusterAccelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceClusterAccelerationStructurePropertiesNV(
    VkPhysicalDeviceClusterAccelerationStructurePropertiesNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxVerticesPerCluster, "maxVerticesPerCluster", 1);

    print_uint32_t(obj.maxTrianglesPerCluster, "maxTrianglesPerCluster", 1);

    print_uint32_t(obj.clusterScratchByteAlignment, "clusterScratchByteAlignment", 1);

    print_uint32_t(obj.clusterByteAlignment, "clusterByteAlignment", 1);

    print_uint32_t(obj.clusterTemplateByteAlignment, "clusterTemplateByteAlignment", 1);

    print_uint32_t(obj.clusterBottomLevelByteAlignment, "clusterBottomLevelByteAlignment", 1);

    print_uint32_t(obj.clusterTemplateBoundsByteAlignment, "clusterTemplateBoundsByteAlignment", 1);

    print_uint32_t(obj.maxClusterGeometryIndex, "maxClusterGeometryIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceClusterAccelerationStructurePropertiesNV(
    const VkPhysicalDeviceClusterAccelerationStructurePropertiesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxVerticesPerCluster, "maxVerticesPerCluster", 1);

    print_uint32_t(obj->maxTrianglesPerCluster, "maxTrianglesPerCluster", 1);

    print_uint32_t(obj->clusterScratchByteAlignment, "clusterScratchByteAlignment", 1);

    print_uint32_t(obj->clusterByteAlignment, "clusterByteAlignment", 1);

    print_uint32_t(obj->clusterTemplateByteAlignment, "clusterTemplateByteAlignment", 1);

    print_uint32_t(obj->clusterBottomLevelByteAlignment, "clusterBottomLevelByteAlignment", 1);

    print_uint32_t(obj->clusterTemplateBoundsByteAlignment, "clusterTemplateBoundsByteAlignment", 1);

    print_uint32_t(obj->maxClusterGeometryIndex, "maxClusterGeometryIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClusterAccelerationStructureClustersBottomLevelInputNV(
    VkClusterAccelerationStructureClustersBottomLevelInputNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxTotalClusterCount, "maxTotalClusterCount", 1);

    print_uint32_t(obj.maxClusterCountPerAccelerationStructure, "maxClusterCountPerAccelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClusterAccelerationStructureClustersBottomLevelInputNV(
    const VkClusterAccelerationStructureClustersBottomLevelInputNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxTotalClusterCount, "maxTotalClusterCount", 1);

    print_uint32_t(obj->maxClusterCountPerAccelerationStructure, "maxClusterCountPerAccelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClusterAccelerationStructureTriangleClusterInputNV(VkClusterAccelerationStructureTriangleClusterInputNV obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj.vertexFormat, "vertexFormat", 1);

    print_uint32_t(obj.maxGeometryIndexValue, "maxGeometryIndexValue", 1);

    print_uint32_t(obj.maxClusterUniqueGeometryCount, "maxClusterUniqueGeometryCount", 1);

    print_uint32_t(obj.maxClusterTriangleCount, "maxClusterTriangleCount", 1);

    print_uint32_t(obj.maxClusterVertexCount, "maxClusterVertexCount", 1);

    print_uint32_t(obj.maxTotalTriangleCount, "maxTotalTriangleCount", 1);

    print_uint32_t(obj.maxTotalVertexCount, "maxTotalVertexCount", 1);

    print_uint32_t(obj.minPositionTruncateBitCount, "minPositionTruncateBitCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClusterAccelerationStructureTriangleClusterInputNV(
    const VkClusterAccelerationStructureTriangleClusterInputNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj->vertexFormat, "vertexFormat", 1);

    print_uint32_t(obj->maxGeometryIndexValue, "maxGeometryIndexValue", 1);

    print_uint32_t(obj->maxClusterUniqueGeometryCount, "maxClusterUniqueGeometryCount", 1);

    print_uint32_t(obj->maxClusterTriangleCount, "maxClusterTriangleCount", 1);

    print_uint32_t(obj->maxClusterVertexCount, "maxClusterVertexCount", 1);

    print_uint32_t(obj->maxTotalTriangleCount, "maxTotalTriangleCount", 1);

    print_uint32_t(obj->maxTotalVertexCount, "maxTotalVertexCount", 1);

    print_uint32_t(obj->minPositionTruncateBitCount, "minPositionTruncateBitCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClusterAccelerationStructureMoveObjectsInputNV(VkClusterAccelerationStructureMoveObjectsInputNV obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkClusterAccelerationStructureTypeNV(obj.type, "type", 1);

    print_VkBool32(obj.noMoveOverlap, "noMoveOverlap", 1);

    print_VkDeviceSize(obj.maxMovedBytes, "maxMovedBytes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClusterAccelerationStructureMoveObjectsInputNV(const VkClusterAccelerationStructureMoveObjectsInputNV* obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkClusterAccelerationStructureTypeNV(obj->type, "type", 1);

    print_VkBool32(obj->noMoveOverlap, "noMoveOverlap", 1);

    print_VkDeviceSize(obj->maxMovedBytes, "maxMovedBytes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClusterAccelerationStructureOpInputNV(VkClusterAccelerationStructureOpInputNV obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"pClustersBottomLevel\": " << std::endl;
    if (obj.pClustersBottomLevel) {
        print_VkClusterAccelerationStructureClustersBottomLevelInputNV(obj.pClustersBottomLevel, "pClustersBottomLevel", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pTriangleClusters\": " << std::endl;
    if (obj.pTriangleClusters) {
        print_VkClusterAccelerationStructureTriangleClusterInputNV(obj.pTriangleClusters, "pTriangleClusters", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pMoveObjects\": " << std::endl;
    if (obj.pMoveObjects) {
        print_VkClusterAccelerationStructureMoveObjectsInputNV(obj.pMoveObjects, "pMoveObjects", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClusterAccelerationStructureOpInputNV(const VkClusterAccelerationStructureOpInputNV* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"pClustersBottomLevel\": " << std::endl;
    if (obj->pClustersBottomLevel) {
        print_VkClusterAccelerationStructureClustersBottomLevelInputNV(obj->pClustersBottomLevel, "pClustersBottomLevel", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pTriangleClusters\": " << std::endl;
    if (obj->pTriangleClusters) {
        print_VkClusterAccelerationStructureTriangleClusterInputNV(obj->pTriangleClusters, "pTriangleClusters", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pMoveObjects\": " << std::endl;
    if (obj->pMoveObjects) {
        print_VkClusterAccelerationStructureMoveObjectsInputNV(obj->pMoveObjects, "pMoveObjects", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClusterAccelerationStructureInputInfoNV(VkClusterAccelerationStructureInputInfoNV obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxAccelerationStructureCount, "maxAccelerationStructureCount", 1);

    print_VkBuildAccelerationStructureFlagsKHR(obj.flags, "flags", 1);

    print_VkClusterAccelerationStructureOpTypeNV(obj.opType, "opType", 1);

    print_VkClusterAccelerationStructureOpModeNV(obj.opMode, "opMode", 1);

    print_VkClusterAccelerationStructureOpInputNV(obj.opInput, "opInput", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClusterAccelerationStructureInputInfoNV(const VkClusterAccelerationStructureInputInfoNV* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxAccelerationStructureCount, "maxAccelerationStructureCount", 1);

    print_VkBuildAccelerationStructureFlagsKHR(obj->flags, "flags", 1);

    print_VkClusterAccelerationStructureOpTypeNV(obj->opType, "opType", 1);

    print_VkClusterAccelerationStructureOpModeNV(obj->opMode, "opMode", 1);

    print_VkClusterAccelerationStructureOpInputNV(obj->opInput, "opInput", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkStridedDeviceAddressRegionKHR(VkStridedDeviceAddressRegionKHR obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.deviceAddress, "deviceAddress", 1);

    print_VkDeviceSize(obj.stride, "stride", 1);

    print_VkDeviceSize(obj.size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkStridedDeviceAddressRegionKHR(const VkStridedDeviceAddressRegionKHR* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->deviceAddress, "deviceAddress", 1);

    print_VkDeviceSize(obj->stride, "stride", 1);

    print_VkDeviceSize(obj->size, "size", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClusterAccelerationStructureCommandsInfoNV(VkClusterAccelerationStructureCommandsInfoNV obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"input\": " << std::endl;
    { print_VkClusterAccelerationStructureInputInfoNV(obj.input, "input", 1); }

    print_VkDeviceAddress(obj.dstImplicitData, "dstImplicitData", 1);

    print_VkDeviceAddress(obj.scratchData, "scratchData", 1);

    PRINT_SPACE
    _OUT << "\"dstAddressesArray\": " << std::endl;
    { print_VkStridedDeviceAddressRegionKHR(obj.dstAddressesArray, "dstAddressesArray", 1); }

    PRINT_SPACE
    _OUT << "\"dstSizesArray\": " << std::endl;
    { print_VkStridedDeviceAddressRegionKHR(obj.dstSizesArray, "dstSizesArray", 1); }

    PRINT_SPACE
    _OUT << "\"srcInfosArray\": " << std::endl;
    { print_VkStridedDeviceAddressRegionKHR(obj.srcInfosArray, "srcInfosArray", 1); }

    print_VkDeviceAddress(obj.srcInfosCount, "srcInfosCount", 1);

    print_VkClusterAccelerationStructureAddressResolutionFlagsNV(obj.addressResolutionFlags, "addressResolutionFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClusterAccelerationStructureCommandsInfoNV(const VkClusterAccelerationStructureCommandsInfoNV* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"input\": " << std::endl;
    { print_VkClusterAccelerationStructureInputInfoNV(obj->input, "input", 1); }

    print_VkDeviceAddress(obj->dstImplicitData, "dstImplicitData", 1);

    print_VkDeviceAddress(obj->scratchData, "scratchData", 1);

    PRINT_SPACE
    _OUT << "\"dstAddressesArray\": " << std::endl;
    { print_VkStridedDeviceAddressRegionKHR(obj->dstAddressesArray, "dstAddressesArray", 1); }

    PRINT_SPACE
    _OUT << "\"dstSizesArray\": " << std::endl;
    { print_VkStridedDeviceAddressRegionKHR(obj->dstSizesArray, "dstSizesArray", 1); }

    PRINT_SPACE
    _OUT << "\"srcInfosArray\": " << std::endl;
    { print_VkStridedDeviceAddressRegionKHR(obj->srcInfosArray, "srcInfosArray", 1); }

    print_VkDeviceAddress(obj->srcInfosCount, "srcInfosCount", 1);

    print_VkClusterAccelerationStructureAddressResolutionFlagsNV(obj->addressResolutionFlags, "addressResolutionFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkStridedDeviceAddressNV(VkStridedDeviceAddressNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.startAddress, "startAddress", 1);

    print_VkDeviceSize(obj.strideInBytes, "strideInBytes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkStridedDeviceAddressNV(const VkStridedDeviceAddressNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->startAddress, "startAddress", 1);

    print_VkDeviceSize(obj->strideInBytes, "strideInBytes", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV(
    VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.geometryIndex, "geometryIndex", 1);

    print_uint32_t(obj.reserved, "reserved", 1);

    print_uint32_t(obj.geometryFlags, "geometryFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV(
    const VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->geometryIndex, "geometryIndex", 1);

    print_uint32_t(obj->reserved, "reserved", 1);

    print_uint32_t(obj->geometryFlags, "geometryFlags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClusterAccelerationStructureMoveObjectsInfoNV(VkClusterAccelerationStructureMoveObjectsInfoNV obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.srcAccelerationStructure, "srcAccelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClusterAccelerationStructureMoveObjectsInfoNV(const VkClusterAccelerationStructureMoveObjectsInfoNV* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->srcAccelerationStructure, "srcAccelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV(
    VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.clusterReferencesCount, "clusterReferencesCount", 1);

    print_uint32_t(obj.clusterReferencesStride, "clusterReferencesStride", 1);

    print_VkDeviceAddress(obj.clusterReferences, "clusterReferences", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV(
    const VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->clusterReferencesCount, "clusterReferencesCount", 1);

    print_uint32_t(obj->clusterReferencesStride, "clusterReferencesStride", 1);

    print_VkDeviceAddress(obj->clusterReferences, "clusterReferences", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClusterAccelerationStructureBuildTriangleClusterInfoNV(
    VkClusterAccelerationStructureBuildTriangleClusterInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.clusterID, "clusterID", 1);

    print_VkClusterAccelerationStructureClusterFlagsNV(obj.clusterFlags, "clusterFlags", 1);

    print_uint32_t(obj.triangleCount, "triangleCount", 1);

    print_uint32_t(obj.vertexCount, "vertexCount", 1);

    print_uint32_t(obj.positionTruncateBitCount, "positionTruncateBitCount", 1);

    print_uint32_t(obj.indexType, "indexType", 1);

    print_uint32_t(obj.opacityMicromapIndexType, "opacityMicromapIndexType", 1);

    PRINT_SPACE
    _OUT << "\"baseGeometryIndexAndGeometryFlags\": " << std::endl;
    {
        print_VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV(obj.baseGeometryIndexAndGeometryFlags,
                                                                            "baseGeometryIndexAndGeometryFlags", 1);
    }

    print_uint16_t(obj.indexBufferStride, "indexBufferStride", 1);

    print_uint16_t(obj.vertexBufferStride, "vertexBufferStride", 1);

    print_uint16_t(obj.geometryIndexAndFlagsBufferStride, "geometryIndexAndFlagsBufferStride", 1);

    print_uint16_t(obj.opacityMicromapIndexBufferStride, "opacityMicromapIndexBufferStride", 1);

    print_VkDeviceAddress(obj.indexBuffer, "indexBuffer", 1);

    print_VkDeviceAddress(obj.vertexBuffer, "vertexBuffer", 1);

    print_VkDeviceAddress(obj.geometryIndexAndFlagsBuffer, "geometryIndexAndFlagsBuffer", 1);

    print_VkDeviceAddress(obj.opacityMicromapArray, "opacityMicromapArray", 1);

    print_VkDeviceAddress(obj.opacityMicromapIndexBuffer, "opacityMicromapIndexBuffer", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClusterAccelerationStructureBuildTriangleClusterInfoNV(
    const VkClusterAccelerationStructureBuildTriangleClusterInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->clusterID, "clusterID", 1);

    print_VkClusterAccelerationStructureClusterFlagsNV(obj->clusterFlags, "clusterFlags", 1);

    print_uint32_t(obj->triangleCount, "triangleCount", 1);

    print_uint32_t(obj->vertexCount, "vertexCount", 1);

    print_uint32_t(obj->positionTruncateBitCount, "positionTruncateBitCount", 1);

    print_uint32_t(obj->indexType, "indexType", 1);

    print_uint32_t(obj->opacityMicromapIndexType, "opacityMicromapIndexType", 1);

    PRINT_SPACE
    _OUT << "\"baseGeometryIndexAndGeometryFlags\": " << std::endl;
    {
        print_VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV(obj->baseGeometryIndexAndGeometryFlags,
                                                                            "baseGeometryIndexAndGeometryFlags", 1);
    }

    print_uint16_t(obj->indexBufferStride, "indexBufferStride", 1);

    print_uint16_t(obj->vertexBufferStride, "vertexBufferStride", 1);

    print_uint16_t(obj->geometryIndexAndFlagsBufferStride, "geometryIndexAndFlagsBufferStride", 1);

    print_uint16_t(obj->opacityMicromapIndexBufferStride, "opacityMicromapIndexBufferStride", 1);

    print_VkDeviceAddress(obj->indexBuffer, "indexBuffer", 1);

    print_VkDeviceAddress(obj->vertexBuffer, "vertexBuffer", 1);

    print_VkDeviceAddress(obj->geometryIndexAndFlagsBuffer, "geometryIndexAndFlagsBuffer", 1);

    print_VkDeviceAddress(obj->opacityMicromapArray, "opacityMicromapArray", 1);

    print_VkDeviceAddress(obj->opacityMicromapIndexBuffer, "opacityMicromapIndexBuffer", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV(
    VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.clusterID, "clusterID", 1);

    print_VkClusterAccelerationStructureClusterFlagsNV(obj.clusterFlags, "clusterFlags", 1);

    print_uint32_t(obj.triangleCount, "triangleCount", 1);

    print_uint32_t(obj.vertexCount, "vertexCount", 1);

    print_uint32_t(obj.positionTruncateBitCount, "positionTruncateBitCount", 1);

    print_uint32_t(obj.indexType, "indexType", 1);

    print_uint32_t(obj.opacityMicromapIndexType, "opacityMicromapIndexType", 1);

    PRINT_SPACE
    _OUT << "\"baseGeometryIndexAndGeometryFlags\": " << std::endl;
    {
        print_VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV(obj.baseGeometryIndexAndGeometryFlags,
                                                                            "baseGeometryIndexAndGeometryFlags", 1);
    }

    print_uint16_t(obj.indexBufferStride, "indexBufferStride", 1);

    print_uint16_t(obj.vertexBufferStride, "vertexBufferStride", 1);

    print_uint16_t(obj.geometryIndexAndFlagsBufferStride, "geometryIndexAndFlagsBufferStride", 1);

    print_uint16_t(obj.opacityMicromapIndexBufferStride, "opacityMicromapIndexBufferStride", 1);

    print_VkDeviceAddress(obj.indexBuffer, "indexBuffer", 1);

    print_VkDeviceAddress(obj.vertexBuffer, "vertexBuffer", 1);

    print_VkDeviceAddress(obj.geometryIndexAndFlagsBuffer, "geometryIndexAndFlagsBuffer", 1);

    print_VkDeviceAddress(obj.opacityMicromapArray, "opacityMicromapArray", 1);

    print_VkDeviceAddress(obj.opacityMicromapIndexBuffer, "opacityMicromapIndexBuffer", 1);

    print_VkDeviceAddress(obj.instantiationBoundingBoxLimit, "instantiationBoundingBoxLimit", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV(
    const VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->clusterID, "clusterID", 1);

    print_VkClusterAccelerationStructureClusterFlagsNV(obj->clusterFlags, "clusterFlags", 1);

    print_uint32_t(obj->triangleCount, "triangleCount", 1);

    print_uint32_t(obj->vertexCount, "vertexCount", 1);

    print_uint32_t(obj->positionTruncateBitCount, "positionTruncateBitCount", 1);

    print_uint32_t(obj->indexType, "indexType", 1);

    print_uint32_t(obj->opacityMicromapIndexType, "opacityMicromapIndexType", 1);

    PRINT_SPACE
    _OUT << "\"baseGeometryIndexAndGeometryFlags\": " << std::endl;
    {
        print_VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV(obj->baseGeometryIndexAndGeometryFlags,
                                                                            "baseGeometryIndexAndGeometryFlags", 1);
    }

    print_uint16_t(obj->indexBufferStride, "indexBufferStride", 1);

    print_uint16_t(obj->vertexBufferStride, "vertexBufferStride", 1);

    print_uint16_t(obj->geometryIndexAndFlagsBufferStride, "geometryIndexAndFlagsBufferStride", 1);

    print_uint16_t(obj->opacityMicromapIndexBufferStride, "opacityMicromapIndexBufferStride", 1);

    print_VkDeviceAddress(obj->indexBuffer, "indexBuffer", 1);

    print_VkDeviceAddress(obj->vertexBuffer, "vertexBuffer", 1);

    print_VkDeviceAddress(obj->geometryIndexAndFlagsBuffer, "geometryIndexAndFlagsBuffer", 1);

    print_VkDeviceAddress(obj->opacityMicromapArray, "opacityMicromapArray", 1);

    print_VkDeviceAddress(obj->opacityMicromapIndexBuffer, "opacityMicromapIndexBuffer", 1);

    print_VkDeviceAddress(obj->instantiationBoundingBoxLimit, "instantiationBoundingBoxLimit", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkClusterAccelerationStructureInstantiateClusterInfoNV(VkClusterAccelerationStructureInstantiateClusterInfoNV obj,
                                                                         const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.clusterIdOffset, "clusterIdOffset", 1);

    print_uint32_t(obj.geometryIndexOffset, "geometryIndexOffset", 1);

    print_uint32_t(obj.reserved, "reserved", 1);

    print_VkDeviceAddress(obj.clusterTemplateAddress, "clusterTemplateAddress", 1);

    PRINT_SPACE
    _OUT << "\"vertexBuffer\": " << std::endl;
    { print_VkStridedDeviceAddressNV(obj.vertexBuffer, "vertexBuffer", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkClusterAccelerationStructureInstantiateClusterInfoNV(
    const VkClusterAccelerationStructureInstantiateClusterInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->clusterIdOffset, "clusterIdOffset", 1);

    print_uint32_t(obj->geometryIndexOffset, "geometryIndexOffset", 1);

    print_uint32_t(obj->reserved, "reserved", 1);

    print_VkDeviceAddress(obj->clusterTemplateAddress, "clusterTemplateAddress", 1);

    PRINT_SPACE
    _OUT << "\"vertexBuffer\": " << std::endl;
    { print_VkStridedDeviceAddressNV(obj->vertexBuffer, "vertexBuffer", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureBuildSizesInfoKHR(VkAccelerationStructureBuildSizesInfoKHR obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj.accelerationStructureSize, "accelerationStructureSize", 1);

    print_VkDeviceSize(obj.updateScratchSize, "updateScratchSize", 1);

    print_VkDeviceSize(obj.buildScratchSize, "buildScratchSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureBuildSizesInfoKHR(const VkAccelerationStructureBuildSizesInfoKHR* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceSize(obj->accelerationStructureSize, "accelerationStructureSize", 1);

    print_VkDeviceSize(obj->updateScratchSize, "updateScratchSize", 1);

    print_VkDeviceSize(obj->buildScratchSize, "buildScratchSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV(
    VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.allowClusterAccelerationStructure, "allowClusterAccelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV(
    const VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->allowClusterAccelerationStructure, "allowClusterAccelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkPartitionedAccelerationStructureOpTypeNV_map = {
    std::make_pair(0, "VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV"),
    std::make_pair(1, "VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV"),
    std::make_pair(2, "VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV"),
};
static void print_VkPartitionedAccelerationStructureOpTypeNV(VkPartitionedAccelerationStructureOpTypeNV obj, const std::string& str,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPartitionedAccelerationStructureOpTypeNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPartitionedAccelerationStructureOpTypeNV_map[obj] << "\"" << std::endl;
}
static void print_VkPartitionedAccelerationStructureOpTypeNV(const VkPartitionedAccelerationStructureOpTypeNV* obj,
                                                             const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPartitionedAccelerationStructureOpTypeNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPartitionedAccelerationStructureOpTypeNV_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkPartitionedAccelerationStructureInstanceFlagBitsNV_map = {
    std::make_pair(1ULL << 0, "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV"),
    std::make_pair(1ULL << 1, "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV"),
    std::make_pair(1ULL << 2, "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV"),
    std::make_pair(1ULL << 3, "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV"),
    std::make_pair(1ULL << 4, "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV"),
};
static void print_VkPartitionedAccelerationStructureInstanceFlagBitsNV(VkPartitionedAccelerationStructureInstanceFlagBitsNV obj,
                                                                       const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPartitionedAccelerationStructureInstanceFlagBitsNV_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPartitionedAccelerationStructureInstanceFlagBitsNV_map[obj] << "\"" << std::endl;
}
static void print_VkPartitionedAccelerationStructureInstanceFlagBitsNV(
    const VkPartitionedAccelerationStructureInstanceFlagBitsNV* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkPartitionedAccelerationStructureInstanceFlagBitsNV_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkPartitionedAccelerationStructureInstanceFlagBitsNV_map[*obj] << "\"" << std::endl;
}

static void print_VkPartitionedAccelerationStructureInstanceFlagsNV(VkPartitionedAccelerationStructureInstanceFlagsNV obj,
                                                                    const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkPartitionedAccelerationStructureInstanceFlagBitsNV_map[1ULL << i] << " | ";
            else
                _OUT << VkPartitionedAccelerationStructureInstanceFlagBitsNV_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV(
    VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.partitionedAccelerationStructure, "partitionedAccelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV(
    const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->partitionedAccelerationStructure, "partitionedAccelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV(
    VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxPartitionCount, "maxPartitionCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV(
    const VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxPartitionCount, "maxPartitionCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPartitionedAccelerationStructureFlagsNV(VkPartitionedAccelerationStructureFlagsNV obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.enablePartitionTranslation, "enablePartitionTranslation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPartitionedAccelerationStructureFlagsNV(const VkPartitionedAccelerationStructureFlagsNV* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->enablePartitionTranslation, "enablePartitionTranslation", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBuildPartitionedAccelerationStructureIndirectCommandNV(
    VkBuildPartitionedAccelerationStructureIndirectCommandNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkPartitionedAccelerationStructureOpTypeNV(obj.opType, "opType", 1);

    print_uint32_t(obj.argCount, "argCount", 1);

    PRINT_SPACE
    _OUT << "\"argData\": " << std::endl;
    { print_VkStridedDeviceAddressNV(obj.argData, "argData", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBuildPartitionedAccelerationStructureIndirectCommandNV(
    const VkBuildPartitionedAccelerationStructureIndirectCommandNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkPartitionedAccelerationStructureOpTypeNV(obj->opType, "opType", 1);

    print_uint32_t(obj->argCount, "argCount", 1);

    PRINT_SPACE
    _OUT << "\"argData\": " << std::endl;
    { print_VkStridedDeviceAddressNV(obj->argData, "argData", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPartitionedAccelerationStructureWriteInstanceDataNV(VkPartitionedAccelerationStructureWriteInstanceDataNV obj,
                                                                        const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"transform\": " << std::endl;
    { print_VkTransformMatrixKHR(obj.transform, "transform", 1); }

    PRINT_SPACE
    _OUT << "\"explicitAABB\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 6; i++) {
        bool isCommaNeeded = (i + 1) != 6;
        print_float(obj.explicitAABB[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.instanceID, "instanceID", 1);

    print_uint32_t(obj.instanceMask, "instanceMask", 1);

    print_uint32_t(obj.instanceContributionToHitGroupIndex, "instanceContributionToHitGroupIndex", 1);

    print_VkPartitionedAccelerationStructureInstanceFlagsNV(obj.instanceFlags, "instanceFlags", 1);

    print_uint32_t(obj.instanceIndex, "instanceIndex", 1);

    print_uint32_t(obj.partitionIndex, "partitionIndex", 1);

    print_VkDeviceAddress(obj.accelerationStructure, "accelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPartitionedAccelerationStructureWriteInstanceDataNV(
    const VkPartitionedAccelerationStructureWriteInstanceDataNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"transform\": " << std::endl;
    { print_VkTransformMatrixKHR(obj->transform, "transform", 1); }

    PRINT_SPACE
    _OUT << "\"explicitAABB\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 6; i++) {
        bool isCommaNeeded = (i + 1) != 6;
        print_float(obj->explicitAABB[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->instanceID, "instanceID", 1);

    print_uint32_t(obj->instanceMask, "instanceMask", 1);

    print_uint32_t(obj->instanceContributionToHitGroupIndex, "instanceContributionToHitGroupIndex", 1);

    print_VkPartitionedAccelerationStructureInstanceFlagsNV(obj->instanceFlags, "instanceFlags", 1);

    print_uint32_t(obj->instanceIndex, "instanceIndex", 1);

    print_uint32_t(obj->partitionIndex, "partitionIndex", 1);

    print_VkDeviceAddress(obj->accelerationStructure, "accelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPartitionedAccelerationStructureUpdateInstanceDataNV(VkPartitionedAccelerationStructureUpdateInstanceDataNV obj,
                                                                         const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.instanceIndex, "instanceIndex", 1);

    print_uint32_t(obj.instanceContributionToHitGroupIndex, "instanceContributionToHitGroupIndex", 1);

    print_VkDeviceAddress(obj.accelerationStructure, "accelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPartitionedAccelerationStructureUpdateInstanceDataNV(
    const VkPartitionedAccelerationStructureUpdateInstanceDataNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->instanceIndex, "instanceIndex", 1);

    print_uint32_t(obj->instanceContributionToHitGroupIndex, "instanceContributionToHitGroupIndex", 1);

    print_VkDeviceAddress(obj->accelerationStructure, "accelerationStructure", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV(
    VkPartitionedAccelerationStructureWritePartitionTranslationDataNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.partitionIndex, "partitionIndex", 1);

    PRINT_SPACE
    _OUT << "\"partitionTranslation\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_float(obj.partitionTranslation[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV(
    const VkPartitionedAccelerationStructureWritePartitionTranslationDataNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->partitionIndex, "partitionIndex", 1);

    PRINT_SPACE
    _OUT << "\"partitionTranslation\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_float(obj->partitionTranslation[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkWriteDescriptorSetPartitionedAccelerationStructureNV(VkWriteDescriptorSetPartitionedAccelerationStructureNV obj,
                                                                         const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.accelerationStructureCount, "accelerationStructureCount", 1);

    PRINT_SPACE
    _OUT << "\"pAccelerationStructures\":" << std::endl;
    PRINT_SPACE
    if (obj.pAccelerationStructures) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.accelerationStructureCount; i++) {
            bool isCommaNeeded = (i + 1) != obj.accelerationStructureCount;
            print_VkDeviceAddress(obj.pAccelerationStructures[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkWriteDescriptorSetPartitionedAccelerationStructureNV(
    const VkWriteDescriptorSetPartitionedAccelerationStructureNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->accelerationStructureCount, "accelerationStructureCount", 1);

    PRINT_SPACE
    _OUT << "\"pAccelerationStructures\":" << std::endl;
    PRINT_SPACE
    if (obj->pAccelerationStructures) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->accelerationStructureCount; i++) {
            bool isCommaNeeded = (i + 1) != obj->accelerationStructureCount;
            print_VkDeviceAddress(obj->pAccelerationStructures[i], "", isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPartitionedAccelerationStructureInstancesInputNV(VkPartitionedAccelerationStructureInstancesInputNV obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBuildAccelerationStructureFlagsKHR(obj.flags, "flags", 1);

    print_uint32_t(obj.instanceCount, "instanceCount", 1);

    print_uint32_t(obj.maxInstancePerPartitionCount, "maxInstancePerPartitionCount", 1);

    print_uint32_t(obj.partitionCount, "partitionCount", 1);

    print_uint32_t(obj.maxInstanceInGlobalPartitionCount, "maxInstanceInGlobalPartitionCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPartitionedAccelerationStructureInstancesInputNV(const VkPartitionedAccelerationStructureInstancesInputNV* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBuildAccelerationStructureFlagsKHR(obj->flags, "flags", 1);

    print_uint32_t(obj->instanceCount, "instanceCount", 1);

    print_uint32_t(obj->maxInstancePerPartitionCount, "maxInstancePerPartitionCount", 1);

    print_uint32_t(obj->partitionCount, "partitionCount", 1);

    print_uint32_t(obj->maxInstanceInGlobalPartitionCount, "maxInstanceInGlobalPartitionCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBuildPartitionedAccelerationStructureInfoNV(VkBuildPartitionedAccelerationStructureInfoNV obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"input\": " << std::endl;
    { print_VkPartitionedAccelerationStructureInstancesInputNV(obj.input, "input", 1); }

    print_VkDeviceAddress(obj.srcAccelerationStructureData, "srcAccelerationStructureData", 1);

    print_VkDeviceAddress(obj.dstAccelerationStructureData, "dstAccelerationStructureData", 1);

    print_VkDeviceAddress(obj.scratchData, "scratchData", 1);

    print_VkDeviceAddress(obj.srcInfos, "srcInfos", 1);

    print_VkDeviceAddress(obj.srcInfosCount, "srcInfosCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBuildPartitionedAccelerationStructureInfoNV(const VkBuildPartitionedAccelerationStructureInfoNV* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"input\": " << std::endl;
    { print_VkPartitionedAccelerationStructureInstancesInputNV(obj->input, "input", 1); }

    print_VkDeviceAddress(obj->srcAccelerationStructureData, "srcAccelerationStructureData", 1);

    print_VkDeviceAddress(obj->dstAccelerationStructureData, "dstAccelerationStructureData", 1);

    print_VkDeviceAddress(obj->scratchData, "scratchData", 1);

    print_VkDeviceAddress(obj->srcInfos, "srcInfos", 1);

    print_VkDeviceAddress(obj->srcInfosCount, "srcInfosCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectExecutionSetEXT(VkIndirectExecutionSetEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static void print_VkIndirectCommandsLayoutEXT(VkIndirectCommandsLayoutEXT obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "\"" << str << "\""
             << "," << std::endl;
    else
        _OUT << "\"" << str << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkIndirectCommandsInputModeFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT"),
    std::make_pair(1ULL << 1, "VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT"),
};
static void print_VkIndirectCommandsInputModeFlagBitsEXT(VkIndirectCommandsInputModeFlagBitsEXT obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectCommandsInputModeFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectCommandsInputModeFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkIndirectCommandsInputModeFlagBitsEXT(const VkIndirectCommandsInputModeFlagBitsEXT* obj, const std::string& str,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectCommandsInputModeFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectCommandsInputModeFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkIndirectExecutionSetInfoTypeEXT_map = {
    std::make_pair(0, "VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT"),
    std::make_pair(1, "VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT"),
};
static void print_VkIndirectExecutionSetInfoTypeEXT(VkIndirectExecutionSetInfoTypeEXT obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectExecutionSetInfoTypeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectExecutionSetInfoTypeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkIndirectExecutionSetInfoTypeEXT(const VkIndirectExecutionSetInfoTypeEXT* obj, const std::string& str,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectExecutionSetInfoTypeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectExecutionSetInfoTypeEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkIndirectCommandsLayoutUsageFlagBitsEXT_map = {
    std::make_pair(1ULL << 0, "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT"),
    std::make_pair(1ULL << 1, "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT"),
};
static void print_VkIndirectCommandsLayoutUsageFlagBitsEXT(VkIndirectCommandsLayoutUsageFlagBitsEXT obj, const std::string& str,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectCommandsLayoutUsageFlagBitsEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectCommandsLayoutUsageFlagBitsEXT_map[obj] << "\"" << std::endl;
}
static void print_VkIndirectCommandsLayoutUsageFlagBitsEXT(const VkIndirectCommandsLayoutUsageFlagBitsEXT* obj,
                                                           const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectCommandsLayoutUsageFlagBitsEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectCommandsLayoutUsageFlagBitsEXT_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkIndirectCommandsTokenTypeEXT_map = {
    std::make_pair(0, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT"),
    std::make_pair(1, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT"),
    std::make_pair(2, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT"),
    std::make_pair(3, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT"),
    std::make_pair(4, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT"),
    std::make_pair(5, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT"),
    std::make_pair(6, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT"),
    std::make_pair(7, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT"),
    std::make_pair(8, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT"),
    std::make_pair(9, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT"),
    std::make_pair(1000202002, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT"),
    std::make_pair(1000202003, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT"),
    std::make_pair(1000328000, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT"),
    std::make_pair(1000328001, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT"),
    std::make_pair(1000386004, "VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT"),
};
static void print_VkIndirectCommandsTokenTypeEXT(VkIndirectCommandsTokenTypeEXT obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectCommandsTokenTypeEXT_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectCommandsTokenTypeEXT_map[obj] << "\"" << std::endl;
}
static void print_VkIndirectCommandsTokenTypeEXT(const VkIndirectCommandsTokenTypeEXT* obj, const std::string& str,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkIndirectCommandsTokenTypeEXT_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkIndirectCommandsTokenTypeEXT_map[*obj] << "\"" << std::endl;
}

static void print_VkIndirectCommandsInputModeFlagsEXT(VkIndirectCommandsInputModeFlagsEXT obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkIndirectCommandsInputModeFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkIndirectCommandsInputModeFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkIndirectCommandsLayoutUsageFlagsEXT(VkIndirectCommandsLayoutUsageFlagsEXT obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkIndirectCommandsLayoutUsageFlagBitsEXT_map[1ULL << i] << " | ";
            else
                _OUT << VkIndirectCommandsLayoutUsageFlagBitsEXT_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.deviceGeneratedCommands, "deviceGeneratedCommands", 1);

    print_VkBool32(obj.dynamicGeneratedPipelineLayout, "dynamicGeneratedPipelineLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->deviceGeneratedCommands, "deviceGeneratedCommands", 1);

    print_VkBool32(obj->dynamicGeneratedPipelineLayout, "dynamicGeneratedPipelineLayout", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxIndirectPipelineCount, "maxIndirectPipelineCount", 1);

    print_uint32_t(obj.maxIndirectShaderObjectCount, "maxIndirectShaderObjectCount", 1);

    print_uint32_t(obj.maxIndirectSequenceCount, "maxIndirectSequenceCount", 1);

    print_uint32_t(obj.maxIndirectCommandsTokenCount, "maxIndirectCommandsTokenCount", 1);

    print_uint32_t(obj.maxIndirectCommandsTokenOffset, "maxIndirectCommandsTokenOffset", 1);

    print_uint32_t(obj.maxIndirectCommandsIndirectStride, "maxIndirectCommandsIndirectStride", 1);

    print_VkIndirectCommandsInputModeFlagsEXT(obj.supportedIndirectCommandsInputModes, "supportedIndirectCommandsInputModes", 1);

    print_VkShaderStageFlags(obj.supportedIndirectCommandsShaderStages, "supportedIndirectCommandsShaderStages", 1);

    print_VkShaderStageFlags(obj.supportedIndirectCommandsShaderStagesPipelineBinding,
                             "supportedIndirectCommandsShaderStagesPipelineBinding", 1);

    print_VkShaderStageFlags(obj.supportedIndirectCommandsShaderStagesShaderBinding,
                             "supportedIndirectCommandsShaderStagesShaderBinding", 1);

    print_VkBool32(obj.deviceGeneratedCommandsTransformFeedback, "deviceGeneratedCommandsTransformFeedback", 1);

    print_VkBool32(obj.deviceGeneratedCommandsMultiDrawIndirectCount, "deviceGeneratedCommandsMultiDrawIndirectCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(
    const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxIndirectPipelineCount, "maxIndirectPipelineCount", 1);

    print_uint32_t(obj->maxIndirectShaderObjectCount, "maxIndirectShaderObjectCount", 1);

    print_uint32_t(obj->maxIndirectSequenceCount, "maxIndirectSequenceCount", 1);

    print_uint32_t(obj->maxIndirectCommandsTokenCount, "maxIndirectCommandsTokenCount", 1);

    print_uint32_t(obj->maxIndirectCommandsTokenOffset, "maxIndirectCommandsTokenOffset", 1);

    print_uint32_t(obj->maxIndirectCommandsIndirectStride, "maxIndirectCommandsIndirectStride", 1);

    print_VkIndirectCommandsInputModeFlagsEXT(obj->supportedIndirectCommandsInputModes, "supportedIndirectCommandsInputModes", 1);

    print_VkShaderStageFlags(obj->supportedIndirectCommandsShaderStages, "supportedIndirectCommandsShaderStages", 1);

    print_VkShaderStageFlags(obj->supportedIndirectCommandsShaderStagesPipelineBinding,
                             "supportedIndirectCommandsShaderStagesPipelineBinding", 1);

    print_VkShaderStageFlags(obj->supportedIndirectCommandsShaderStagesShaderBinding,
                             "supportedIndirectCommandsShaderStagesShaderBinding", 1);

    print_VkBool32(obj->deviceGeneratedCommandsTransformFeedback, "deviceGeneratedCommandsTransformFeedback", 1);

    print_VkBool32(obj->deviceGeneratedCommandsMultiDrawIndirectCount, "deviceGeneratedCommandsMultiDrawIndirectCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGeneratedCommandsMemoryRequirementsInfoEXT(VkGeneratedCommandsMemoryRequirementsInfoEXT obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indirectExecutionSet"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indirectCommandsLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.maxSequenceCount, "maxSequenceCount", 1);

    print_uint32_t(obj.maxDrawCount, "maxDrawCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGeneratedCommandsMemoryRequirementsInfoEXT(const VkGeneratedCommandsMemoryRequirementsInfoEXT* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indirectExecutionSet"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indirectCommandsLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->maxSequenceCount, "maxSequenceCount", 1);

    print_uint32_t(obj->maxDrawCount, "maxDrawCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectExecutionSetPipelineInfoEXT(VkIndirectExecutionSetPipelineInfoEXT obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "initialPipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.maxPipelineCount, "maxPipelineCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectExecutionSetPipelineInfoEXT(const VkIndirectExecutionSetPipelineInfoEXT* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "initialPipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->maxPipelineCount, "maxPipelineCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectExecutionSetShaderLayoutInfoEXT(VkIndirectExecutionSetShaderLayoutInfoEXT obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.setLayoutCount, "setLayoutCount", 1);

    PRINT_SPACE
    _OUT << "\"pSetLayouts\":" << std::endl;
    PRINT_SPACE
    if (obj.pSetLayouts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.setLayoutCount; i++) {
            std::stringstream tmp;
            tmp << "pSetLayouts"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.setLayoutCount;
            print_VkDescriptorSetLayout(obj.pSetLayouts[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectExecutionSetShaderLayoutInfoEXT(const VkIndirectExecutionSetShaderLayoutInfoEXT* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->setLayoutCount, "setLayoutCount", 1);

    PRINT_SPACE
    _OUT << "\"pSetLayouts\":" << std::endl;
    PRINT_SPACE
    if (obj->pSetLayouts) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->setLayoutCount; i++) {
            std::stringstream tmp;
            tmp << "pSetLayouts"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->setLayoutCount;
            print_VkDescriptorSetLayout(obj->pSetLayouts[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectExecutionSetShaderInfoEXT(VkIndirectExecutionSetShaderInfoEXT obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.shaderCount, "shaderCount", 1);

    PRINT_SPACE
    _OUT << "\"pInitialShaders\":" << std::endl;
    PRINT_SPACE
    if (obj.pInitialShaders) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.shaderCount; i++) {
            std::stringstream tmp;
            tmp << "pInitialShaders"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.shaderCount;
            print_VkShaderEXT(obj.pInitialShaders[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pSetLayoutInfos\": " << std::endl;
    if (obj.pSetLayoutInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.shaderCount; i++) {
            if (i + 1 == obj.shaderCount)
                print_VkIndirectExecutionSetShaderLayoutInfoEXT(obj.pSetLayoutInfos[i], "pSetLayoutInfos", 0);
            else
                print_VkIndirectExecutionSetShaderLayoutInfoEXT(obj.pSetLayoutInfos[i], "pSetLayoutInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.maxShaderCount, "maxShaderCount", 1);

    print_uint32_t(obj.pushConstantRangeCount, "pushConstantRangeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPushConstantRanges\": " << std::endl;
    if (obj.pPushConstantRanges) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.pushConstantRangeCount; i++) {
            if (i + 1 == obj.pushConstantRangeCount)
                print_VkPushConstantRange(obj.pPushConstantRanges[i], "pPushConstantRanges", 0);
            else
                print_VkPushConstantRange(obj.pPushConstantRanges[i], "pPushConstantRanges", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectExecutionSetShaderInfoEXT(const VkIndirectExecutionSetShaderInfoEXT* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->shaderCount, "shaderCount", 1);

    PRINT_SPACE
    _OUT << "\"pInitialShaders\":" << std::endl;
    PRINT_SPACE
    if (obj->pInitialShaders) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->shaderCount; i++) {
            std::stringstream tmp;
            tmp << "pInitialShaders"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->shaderCount;
            print_VkShaderEXT(obj->pInitialShaders[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "," << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pSetLayoutInfos\": " << std::endl;
    if (obj->pSetLayoutInfos) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->shaderCount; i++) {
            if (i + 1 == obj->shaderCount)
                print_VkIndirectExecutionSetShaderLayoutInfoEXT(obj->pSetLayoutInfos[i], "pSetLayoutInfos", 0);
            else
                print_VkIndirectExecutionSetShaderLayoutInfoEXT(obj->pSetLayoutInfos[i], "pSetLayoutInfos", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->maxShaderCount, "maxShaderCount", 1);

    print_uint32_t(obj->pushConstantRangeCount, "pushConstantRangeCount", 1);

    PRINT_SPACE
    _OUT << "\"pPushConstantRanges\": " << std::endl;
    if (obj->pPushConstantRanges) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->pushConstantRangeCount; i++) {
            if (i + 1 == obj->pushConstantRangeCount)
                print_VkPushConstantRange(obj->pPushConstantRanges[i], "pPushConstantRanges", 0);
            else
                print_VkPushConstantRange(obj->pPushConstantRanges[i], "pPushConstantRanges", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectExecutionSetInfoEXT(VkIndirectExecutionSetInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"pPipelineInfo\": " << std::endl;
    if (obj.pPipelineInfo) {
        print_VkIndirectExecutionSetPipelineInfoEXT(obj.pPipelineInfo, "pPipelineInfo", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pShaderInfo\": " << std::endl;
    if (obj.pShaderInfo) {
        print_VkIndirectExecutionSetShaderInfoEXT(obj.pShaderInfo, "pShaderInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectExecutionSetInfoEXT(const VkIndirectExecutionSetInfoEXT* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"pPipelineInfo\": " << std::endl;
    if (obj->pPipelineInfo) {
        print_VkIndirectExecutionSetPipelineInfoEXT(obj->pPipelineInfo, "pPipelineInfo", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pShaderInfo\": " << std::endl;
    if (obj->pShaderInfo) {
        print_VkIndirectExecutionSetShaderInfoEXT(obj->pShaderInfo, "pShaderInfo", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectExecutionSetCreateInfoEXT(VkIndirectExecutionSetCreateInfoEXT obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkIndirectExecutionSetInfoTypeEXT(obj.type, "type", 1);

    print_VkIndirectExecutionSetInfoEXT(obj.info, "info", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectExecutionSetCreateInfoEXT(const VkIndirectExecutionSetCreateInfoEXT* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkIndirectExecutionSetInfoTypeEXT(obj->type, "type", 1);

    print_VkIndirectExecutionSetInfoEXT(obj->info, "info", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGeneratedCommandsInfoEXT(VkGeneratedCommandsInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj.shaderStages, "shaderStages", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indirectExecutionSet"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indirectCommandsLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceAddress(obj.indirectAddress, "indirectAddress", 1);

    print_VkDeviceSize(obj.indirectAddressSize, "indirectAddressSize", 1);

    print_VkDeviceAddress(obj.preprocessAddress, "preprocessAddress", 1);

    print_VkDeviceSize(obj.preprocessSize, "preprocessSize", 1);

    print_uint32_t(obj.maxSequenceCount, "maxSequenceCount", 1);

    print_VkDeviceAddress(obj.sequenceCountAddress, "sequenceCountAddress", 1);

    print_uint32_t(obj.maxDrawCount, "maxDrawCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGeneratedCommandsInfoEXT(const VkGeneratedCommandsInfoEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkShaderStageFlags(obj->shaderStages, "shaderStages", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indirectExecutionSet"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "indirectCommandsLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceAddress(obj->indirectAddress, "indirectAddress", 1);

    print_VkDeviceSize(obj->indirectAddressSize, "indirectAddressSize", 1);

    print_VkDeviceAddress(obj->preprocessAddress, "preprocessAddress", 1);

    print_VkDeviceSize(obj->preprocessSize, "preprocessSize", 1);

    print_uint32_t(obj->maxSequenceCount, "maxSequenceCount", 1);

    print_VkDeviceAddress(obj->sequenceCountAddress, "sequenceCountAddress", 1);

    print_uint32_t(obj->maxDrawCount, "maxDrawCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkWriteIndirectExecutionSetPipelineEXT(VkWriteIndirectExecutionSetPipelineEXT obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.index, "index", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkWriteIndirectExecutionSetPipelineEXT(const VkWriteIndirectExecutionSetPipelineEXT* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->index, "index", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectCommandsPushConstantTokenEXT(VkIndirectCommandsPushConstantTokenEXT obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"updateRange\": " << std::endl;
    { print_VkPushConstantRange(obj.updateRange, "updateRange", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectCommandsPushConstantTokenEXT(const VkIndirectCommandsPushConstantTokenEXT* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"updateRange\": " << std::endl;
    { print_VkPushConstantRange(obj->updateRange, "updateRange", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectCommandsVertexBufferTokenEXT(VkIndirectCommandsVertexBufferTokenEXT obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.vertexBindingUnit, "vertexBindingUnit", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectCommandsVertexBufferTokenEXT(const VkIndirectCommandsVertexBufferTokenEXT* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->vertexBindingUnit, "vertexBindingUnit", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectCommandsIndexBufferTokenEXT(VkIndirectCommandsIndexBufferTokenEXT obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkIndirectCommandsInputModeFlagBitsEXT(obj.mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectCommandsIndexBufferTokenEXT(const VkIndirectCommandsIndexBufferTokenEXT* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkIndirectCommandsInputModeFlagBitsEXT(obj->mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectCommandsExecutionSetTokenEXT(VkIndirectCommandsExecutionSetTokenEXT obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkIndirectExecutionSetInfoTypeEXT(obj.type, "type", 1);

    print_VkShaderStageFlags(obj.shaderStages, "shaderStages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectCommandsExecutionSetTokenEXT(const VkIndirectCommandsExecutionSetTokenEXT* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkIndirectExecutionSetInfoTypeEXT(obj->type, "type", 1);

    print_VkShaderStageFlags(obj->shaderStages, "shaderStages", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectCommandsTokenDataEXT(VkIndirectCommandsTokenDataEXT obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"pPushConstant\": " << std::endl;
    if (obj.pPushConstant) {
        print_VkIndirectCommandsPushConstantTokenEXT(obj.pPushConstant, "pPushConstant", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pVertexBuffer\": " << std::endl;
    if (obj.pVertexBuffer) {
        print_VkIndirectCommandsVertexBufferTokenEXT(obj.pVertexBuffer, "pVertexBuffer", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pIndexBuffer\": " << std::endl;
    if (obj.pIndexBuffer) {
        print_VkIndirectCommandsIndexBufferTokenEXT(obj.pIndexBuffer, "pIndexBuffer", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pExecutionSet\": " << std::endl;
    if (obj.pExecutionSet) {
        print_VkIndirectCommandsExecutionSetTokenEXT(obj.pExecutionSet, "pExecutionSet", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectCommandsTokenDataEXT(const VkIndirectCommandsTokenDataEXT* obj, const std::string& s,
                                                 bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"pPushConstant\": " << std::endl;
    if (obj->pPushConstant) {
        print_VkIndirectCommandsPushConstantTokenEXT(obj->pPushConstant, "pPushConstant", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pVertexBuffer\": " << std::endl;
    if (obj->pVertexBuffer) {
        print_VkIndirectCommandsVertexBufferTokenEXT(obj->pVertexBuffer, "pVertexBuffer", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pIndexBuffer\": " << std::endl;
    if (obj->pIndexBuffer) {
        print_VkIndirectCommandsIndexBufferTokenEXT(obj->pIndexBuffer, "pIndexBuffer", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pExecutionSet\": " << std::endl;
    if (obj->pExecutionSet) {
        print_VkIndirectCommandsExecutionSetTokenEXT(obj->pExecutionSet, "pExecutionSet", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectCommandsLayoutTokenEXT(VkIndirectCommandsLayoutTokenEXT obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkIndirectCommandsTokenTypeEXT(obj.type, "type", 1);

    print_VkIndirectCommandsTokenDataEXT(obj.data, "data", 1);

    print_uint32_t(obj.offset, "offset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectCommandsLayoutTokenEXT(const VkIndirectCommandsLayoutTokenEXT* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkIndirectCommandsTokenTypeEXT(obj->type, "type", 1);

    print_VkIndirectCommandsTokenDataEXT(obj->data, "data", 1);

    print_uint32_t(obj->offset, "offset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkIndirectCommandsLayoutCreateInfoEXT(VkIndirectCommandsLayoutCreateInfoEXT obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkIndirectCommandsLayoutUsageFlagsEXT(obj.flags, "flags", 1);

    print_VkShaderStageFlags(obj.shaderStages, "shaderStages", 1);

    print_uint32_t(obj.indirectStride, "indirectStride", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipelineLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.tokenCount, "tokenCount", 1);

    PRINT_SPACE
    _OUT << "\"pTokens\": " << std::endl;
    if (obj.pTokens) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.tokenCount; i++) {
            if (i + 1 == obj.tokenCount)
                print_VkIndirectCommandsLayoutTokenEXT(obj.pTokens[i], "pTokens", 0);
            else
                print_VkIndirectCommandsLayoutTokenEXT(obj.pTokens[i], "pTokens", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkIndirectCommandsLayoutCreateInfoEXT(const VkIndirectCommandsLayoutCreateInfoEXT* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkIndirectCommandsLayoutUsageFlagsEXT(obj->flags, "flags", 1);

    print_VkShaderStageFlags(obj->shaderStages, "shaderStages", 1);

    print_uint32_t(obj->indirectStride, "indirectStride", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipelineLayout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->tokenCount, "tokenCount", 1);

    PRINT_SPACE
    _OUT << "\"pTokens\": " << std::endl;
    if (obj->pTokens) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->tokenCount; i++) {
            if (i + 1 == obj->tokenCount)
                print_VkIndirectCommandsLayoutTokenEXT(obj->pTokens[i], "pTokens", 0);
            else
                print_VkIndirectCommandsLayoutTokenEXT(obj->pTokens[i], "pTokens", 1);
        }
        PRINT_SPACE
        _OUT << "]" << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDrawIndirectCountIndirectCommandEXT(VkDrawIndirectCountIndirectCommandEXT obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.bufferAddress, "bufferAddress", 1);

    print_uint32_t(obj.stride, "stride", 1);

    print_uint32_t(obj.commandCount, "commandCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDrawIndirectCountIndirectCommandEXT(const VkDrawIndirectCountIndirectCommandEXT* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->bufferAddress, "bufferAddress", 1);

    print_uint32_t(obj->stride, "stride", 1);

    print_uint32_t(obj->commandCount, "commandCount", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindVertexBufferIndirectCommandEXT(VkBindVertexBufferIndirectCommandEXT obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.bufferAddress, "bufferAddress", 1);

    print_uint32_t(obj.size, "size", 1);

    print_uint32_t(obj.stride, "stride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindVertexBufferIndirectCommandEXT(const VkBindVertexBufferIndirectCommandEXT* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->bufferAddress, "bufferAddress", 1);

    print_uint32_t(obj->size, "size", 1);

    print_uint32_t(obj->stride, "stride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkBindIndexBufferIndirectCommandEXT(VkBindIndexBufferIndirectCommandEXT obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj.bufferAddress, "bufferAddress", 1);

    print_uint32_t(obj.size, "size", 1);

    print_VkIndexType(obj.indexType, "indexType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkBindIndexBufferIndirectCommandEXT(const VkBindIndexBufferIndirectCommandEXT* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkDeviceAddress(obj->bufferAddress, "bufferAddress", 1);

    print_uint32_t(obj->size, "size", 1);

    print_VkIndexType(obj->indexType, "indexType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGeneratedCommandsPipelineInfoEXT(VkGeneratedCommandsPipelineInfoEXT obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGeneratedCommandsPipelineInfoEXT(const VkGeneratedCommandsPipelineInfoEXT* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "pipeline"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkGeneratedCommandsShaderInfoEXT(VkGeneratedCommandsShaderInfoEXT obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.shaderCount, "shaderCount", 1);

    PRINT_SPACE
    _OUT << "\"pShaders\":" << std::endl;
    PRINT_SPACE
    if (obj.pShaders) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.shaderCount; i++) {
            std::stringstream tmp;
            tmp << "pShaders"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.shaderCount;
            print_VkShaderEXT(obj.pShaders[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkGeneratedCommandsShaderInfoEXT(const VkGeneratedCommandsShaderInfoEXT* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->shaderCount, "shaderCount", 1);

    PRINT_SPACE
    _OUT << "\"pShaders\":" << std::endl;
    PRINT_SPACE
    if (obj->pShaders) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->shaderCount; i++) {
            std::stringstream tmp;
            tmp << "pShaders"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->shaderCount;
            print_VkShaderEXT(obj->pShaders[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkWriteIndirectExecutionSetShaderEXT(VkWriteIndirectExecutionSetShaderEXT obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.index, "index", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "shader"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkWriteIndirectExecutionSetShaderEXT(const VkWriteIndirectExecutionSetShaderEXT* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->index, "index", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "shader"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(VkPhysicalDeviceImageAlignmentControlFeaturesMESA obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.imageAlignmentControl, "imageAlignmentControl", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(const VkPhysicalDeviceImageAlignmentControlFeaturesMESA* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->imageAlignmentControl, "imageAlignmentControl", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceImageAlignmentControlPropertiesMESA(VkPhysicalDeviceImageAlignmentControlPropertiesMESA obj,
                                                                      const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.supportedImageAlignmentMask, "supportedImageAlignmentMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceImageAlignmentControlPropertiesMESA(
    const VkPhysicalDeviceImageAlignmentControlPropertiesMESA* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->supportedImageAlignmentMask, "supportedImageAlignmentMask", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImageAlignmentControlCreateInfoMESA(VkImageAlignmentControlCreateInfoMESA obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maximumRequestedAlignment, "maximumRequestedAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImageAlignmentControlCreateInfoMESA(const VkImageAlignmentControlCreateInfoMESA* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maximumRequestedAlignment, "maximumRequestedAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceDepthClampControlFeaturesEXT(VkPhysicalDeviceDepthClampControlFeaturesEXT obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.depthClampControl, "depthClampControl", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceDepthClampControlFeaturesEXT(const VkPhysicalDeviceDepthClampControlFeaturesEXT* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->depthClampControl, "depthClampControl", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPipelineViewportDepthClampControlCreateInfoEXT(VkPipelineViewportDepthClampControlCreateInfoEXT obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDepthClampModeEXT(obj.depthClampMode, "depthClampMode", 1);

    PRINT_SPACE
    _OUT << "\"pDepthClampRange\": " << std::endl;
    if (obj.pDepthClampRange) {
        print_VkDepthClampRangeEXT(obj.pDepthClampRange, "pDepthClampRange", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPipelineViewportDepthClampControlCreateInfoEXT(const VkPipelineViewportDepthClampControlCreateInfoEXT* obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDepthClampModeEXT(obj->depthClampMode, "depthClampMode", 1);

    PRINT_SPACE
    _OUT << "\"pDepthClampRange\": " << std::endl;
    if (obj->pDepthClampRange) {
        print_VkDepthClampRangeEXT(obj->pDepthClampRange, "pDepthClampRange", 0);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceHdrVividFeaturesHUAWEI(VkPhysicalDeviceHdrVividFeaturesHUAWEI obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.hdrVivid, "hdrVivid", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceHdrVividFeaturesHUAWEI(const VkPhysicalDeviceHdrVividFeaturesHUAWEI* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->hdrVivid, "hdrVivid", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkHdrVividDynamicMetadataHUAWEI(VkHdrVividDynamicMetadataHUAWEI obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_size_t(obj.dynamicMetadataSize, "dynamicMetadataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkHdrVividDynamicMetadataHUAWEI(const VkHdrVividDynamicMetadataHUAWEI* obj, const std::string& s,
                                                  bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_size_t(obj->dynamicMetadataSize, "dynamicMetadataSize", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCooperativeMatrixFlexibleDimensionsPropertiesNV(VkCooperativeMatrixFlexibleDimensionsPropertiesNV obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.MGranularity, "MGranularity", 1);

    print_uint32_t(obj.NGranularity, "NGranularity", 1);

    print_uint32_t(obj.KGranularity, "KGranularity", 1);

    print_VkComponentTypeKHR(obj.AType, "AType", 1);

    print_VkComponentTypeKHR(obj.BType, "BType", 1);

    print_VkComponentTypeKHR(obj.CType, "CType", 1);

    print_VkComponentTypeKHR(obj.ResultType, "ResultType", 1);

    print_VkBool32(obj.saturatingAccumulation, "saturatingAccumulation", 1);

    print_VkScopeKHR(obj.scope, "scope", 1);

    print_uint32_t(obj.workgroupInvocations, "workgroupInvocations", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCooperativeMatrixFlexibleDimensionsPropertiesNV(const VkCooperativeMatrixFlexibleDimensionsPropertiesNV* obj,
                                                                    const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->MGranularity, "MGranularity", 1);

    print_uint32_t(obj->NGranularity, "NGranularity", 1);

    print_uint32_t(obj->KGranularity, "KGranularity", 1);

    print_VkComponentTypeKHR(obj->AType, "AType", 1);

    print_VkComponentTypeKHR(obj->BType, "BType", 1);

    print_VkComponentTypeKHR(obj->CType, "CType", 1);

    print_VkComponentTypeKHR(obj->ResultType, "ResultType", 1);

    print_VkBool32(obj->saturatingAccumulation, "saturatingAccumulation", 1);

    print_VkScopeKHR(obj->scope, "scope", 1);

    print_uint32_t(obj->workgroupInvocations, "workgroupInvocations", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCooperativeMatrix2FeaturesNV(VkPhysicalDeviceCooperativeMatrix2FeaturesNV obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.cooperativeMatrixWorkgroupScope, "cooperativeMatrixWorkgroupScope", 1);

    print_VkBool32(obj.cooperativeMatrixFlexibleDimensions, "cooperativeMatrixFlexibleDimensions", 1);

    print_VkBool32(obj.cooperativeMatrixReductions, "cooperativeMatrixReductions", 1);

    print_VkBool32(obj.cooperativeMatrixConversions, "cooperativeMatrixConversions", 1);

    print_VkBool32(obj.cooperativeMatrixPerElementOperations, "cooperativeMatrixPerElementOperations", 1);

    print_VkBool32(obj.cooperativeMatrixTensorAddressing, "cooperativeMatrixTensorAddressing", 1);

    print_VkBool32(obj.cooperativeMatrixBlockLoads, "cooperativeMatrixBlockLoads", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCooperativeMatrix2FeaturesNV(const VkPhysicalDeviceCooperativeMatrix2FeaturesNV* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->cooperativeMatrixWorkgroupScope, "cooperativeMatrixWorkgroupScope", 1);

    print_VkBool32(obj->cooperativeMatrixFlexibleDimensions, "cooperativeMatrixFlexibleDimensions", 1);

    print_VkBool32(obj->cooperativeMatrixReductions, "cooperativeMatrixReductions", 1);

    print_VkBool32(obj->cooperativeMatrixConversions, "cooperativeMatrixConversions", 1);

    print_VkBool32(obj->cooperativeMatrixPerElementOperations, "cooperativeMatrixPerElementOperations", 1);

    print_VkBool32(obj->cooperativeMatrixTensorAddressing, "cooperativeMatrixTensorAddressing", 1);

    print_VkBool32(obj->cooperativeMatrixBlockLoads, "cooperativeMatrixBlockLoads", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceCooperativeMatrix2PropertiesNV(VkPhysicalDeviceCooperativeMatrix2PropertiesNV obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.cooperativeMatrixWorkgroupScopeMaxWorkgroupSize, "cooperativeMatrixWorkgroupScopeMaxWorkgroupSize", 1);

    print_uint32_t(obj.cooperativeMatrixFlexibleDimensionsMaxDimension, "cooperativeMatrixFlexibleDimensionsMaxDimension", 1);

    print_uint32_t(obj.cooperativeMatrixWorkgroupScopeReservedSharedMemory, "cooperativeMatrixWorkgroupScopeReservedSharedMemory",
                   0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceCooperativeMatrix2PropertiesNV(const VkPhysicalDeviceCooperativeMatrix2PropertiesNV* obj,
                                                                 const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->cooperativeMatrixWorkgroupScopeMaxWorkgroupSize, "cooperativeMatrixWorkgroupScopeMaxWorkgroupSize", 1);

    print_uint32_t(obj->cooperativeMatrixFlexibleDimensionsMaxDimension, "cooperativeMatrixFlexibleDimensionsMaxDimension", 1);

    print_uint32_t(obj->cooperativeMatrixWorkgroupScopeReservedSharedMemory, "cooperativeMatrixWorkgroupScopeReservedSharedMemory",
                   0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM(VkPhysicalDevicePipelineOpacityMicromapFeaturesARM obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.pipelineOpacityMicromap, "pipelineOpacityMicromap", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM(const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->pipelineOpacityMicromap, "pipelineOpacityMicromap", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkImportMemoryMetalHandleInfoEXT(VkImportMemoryMetalHandleInfoEXT obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlagBits(obj.handleType, "handleType", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkImportMemoryMetalHandleInfoEXT(const VkImportMemoryMetalHandleInfoEXT* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkExternalMemoryHandleTypeFlagBits(obj->handleType, "handleType", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryMetalHandlePropertiesEXT(VkMemoryMetalHandlePropertiesEXT obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.memoryTypeBits, "memoryTypeBits", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryMetalHandlePropertiesEXT(const VkMemoryMetalHandlePropertiesEXT* obj, const std::string& s,
                                                   bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->memoryTypeBits, "memoryTypeBits", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkMemoryGetMetalHandleInfoEXT(VkMemoryGetMetalHandleInfoEXT obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkExternalMemoryHandleTypeFlagBits(obj.handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkMemoryGetMetalHandleInfoEXT(const VkMemoryGetMetalHandleInfoEXT* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "memory"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkExternalMemoryHandleTypeFlagBits(obj->handleType, "handleType", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT obj,
                                                                       const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.vertexAttributeRobustness, "vertexAttributeRobustness", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(
    const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->vertexAttributeRobustness, "vertexAttributeRobustness", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkSetPresentConfigNV(VkSetPresentConfigNV obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.numFramesPerBatch, "numFramesPerBatch", 1);

    print_uint32_t(obj.presentConfigFeedback, "presentConfigFeedback", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkSetPresentConfigNV(const VkSetPresentConfigNV* obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->numFramesPerBatch, "numFramesPerBatch", 1);

    print_uint32_t(obj->presentConfigFeedback, "presentConfigFeedback", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDevicePresentMeteringFeaturesNV(VkPhysicalDevicePresentMeteringFeaturesNV obj, const std::string& s,
                                                            bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.presentMetering, "presentMetering", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDevicePresentMeteringFeaturesNV(const VkPhysicalDevicePresentMeteringFeaturesNV* obj,
                                                            const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->presentMetering, "presentMetering", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkBuildAccelerationStructureModeKHR_map = {
    std::make_pair(0, "VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR"),
    std::make_pair(1, "VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR"),
};
static void print_VkBuildAccelerationStructureModeKHR(VkBuildAccelerationStructureModeKHR obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBuildAccelerationStructureModeKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBuildAccelerationStructureModeKHR_map[obj] << "\"" << std::endl;
}
static void print_VkBuildAccelerationStructureModeKHR(const VkBuildAccelerationStructureModeKHR* obj, const std::string& str,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkBuildAccelerationStructureModeKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkBuildAccelerationStructureModeKHR_map[*obj] << "\"" << std::endl;
}

static std::map<uint64_t, std::string> VkAccelerationStructureCreateFlagBitsKHR_map = {
    std::make_pair(1ULL << 0, "VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR"),
    std::make_pair(1ULL << 3, "VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"),
    std::make_pair(1ULL << 2, "VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV"),
};
static void print_VkAccelerationStructureCreateFlagBitsKHR(VkAccelerationStructureCreateFlagBitsKHR obj, const std::string& str,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureCreateFlagBitsKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureCreateFlagBitsKHR_map[obj] << "\"" << std::endl;
}
static void print_VkAccelerationStructureCreateFlagBitsKHR(const VkAccelerationStructureCreateFlagBitsKHR* obj,
                                                           const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkAccelerationStructureCreateFlagBitsKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkAccelerationStructureCreateFlagBitsKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkAccelerationStructureCreateFlagsKHR(VkAccelerationStructureCreateFlagsKHR obj, const std::string& str,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    const int max_bits = 64;  // We don't expect the number to be larger.
    std::bitset<max_bits> b(obj);
    _OUT << "\"";
    if (obj == 0) _OUT << "0";
    for (unsigned int i = 0, bitCount = 0; i < b.size(); i++) {
        if (b[i] == 1) {
            bitCount++;
            if (bitCount < b.count())
                _OUT << VkAccelerationStructureCreateFlagBitsKHR_map[1ULL << i] << " | ";
            else
                _OUT << VkAccelerationStructureCreateFlagBitsKHR_map[1ULL << i];
        }
    }
    if (commaNeeded)
        _OUT << "\""
             << ",";
    else
        _OUT << "\""
             << "";
    _OUT << std::endl;
}

static void print_VkAccelerationStructureBuildRangeInfoKHR(VkAccelerationStructureBuildRangeInfoKHR obj, const std::string& s,
                                                           bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.primitiveCount, "primitiveCount", 1);

    print_uint32_t(obj.primitiveOffset, "primitiveOffset", 1);

    print_uint32_t(obj.firstVertex, "firstVertex", 1);

    print_uint32_t(obj.transformOffset, "transformOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureBuildRangeInfoKHR(const VkAccelerationStructureBuildRangeInfoKHR* obj,
                                                           const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->primitiveCount, "primitiveCount", 1);

    print_uint32_t(obj->primitiveOffset, "primitiveOffset", 1);

    print_uint32_t(obj->firstVertex, "firstVertex", 1);

    print_uint32_t(obj->transformOffset, "transformOffset", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureGeometryTrianglesDataKHR(VkAccelerationStructureGeometryTrianglesDataKHR obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj.vertexFormat, "vertexFormat", 1);

    print_VkDeviceOrHostAddressConstKHR(obj.vertexData, "vertexData", 1);

    print_VkDeviceSize(obj.vertexStride, "vertexStride", 1);

    print_uint32_t(obj.maxVertex, "maxVertex", 1);

    print_VkIndexType(obj.indexType, "indexType", 1);

    print_VkDeviceOrHostAddressConstKHR(obj.indexData, "indexData", 1);

    print_VkDeviceOrHostAddressConstKHR(obj.transformData, "transformData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureGeometryTrianglesDataKHR(const VkAccelerationStructureGeometryTrianglesDataKHR* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkFormat(obj->vertexFormat, "vertexFormat", 1);

    print_VkDeviceOrHostAddressConstKHR(obj->vertexData, "vertexData", 1);

    print_VkDeviceSize(obj->vertexStride, "vertexStride", 1);

    print_uint32_t(obj->maxVertex, "maxVertex", 1);

    print_VkIndexType(obj->indexType, "indexType", 1);

    print_VkDeviceOrHostAddressConstKHR(obj->indexData, "indexData", 1);

    print_VkDeviceOrHostAddressConstKHR(obj->transformData, "transformData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureGeometryAabbsDataKHR(VkAccelerationStructureGeometryAabbsDataKHR obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceOrHostAddressConstKHR(obj.data, "data", 1);

    print_VkDeviceSize(obj.stride, "stride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureGeometryAabbsDataKHR(const VkAccelerationStructureGeometryAabbsDataKHR* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceOrHostAddressConstKHR(obj->data, "data", 1);

    print_VkDeviceSize(obj->stride, "stride", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureGeometryInstancesDataKHR(VkAccelerationStructureGeometryInstancesDataKHR obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.arrayOfPointers, "arrayOfPointers", 1);

    print_VkDeviceOrHostAddressConstKHR(obj.data, "data", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureGeometryInstancesDataKHR(const VkAccelerationStructureGeometryInstancesDataKHR* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->arrayOfPointers, "arrayOfPointers", 1);

    print_VkDeviceOrHostAddressConstKHR(obj->data, "data", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureGeometryDataKHR(VkAccelerationStructureGeometryDataKHR obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"triangles\": " << std::endl;
    { print_VkAccelerationStructureGeometryTrianglesDataKHR(obj.triangles, "triangles", 1); }

    PRINT_SPACE
    _OUT << "\"aabbs\": " << std::endl;
    { print_VkAccelerationStructureGeometryAabbsDataKHR(obj.aabbs, "aabbs", 1); }

    PRINT_SPACE
    _OUT << "\"instances\": " << std::endl;
    { print_VkAccelerationStructureGeometryInstancesDataKHR(obj.instances, "instances", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureGeometryDataKHR(const VkAccelerationStructureGeometryDataKHR* obj, const std::string& s,
                                                         bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    PRINT_SPACE
    _OUT << "\"triangles\": " << std::endl;
    { print_VkAccelerationStructureGeometryTrianglesDataKHR(obj->triangles, "triangles", 1); }

    PRINT_SPACE
    _OUT << "\"aabbs\": " << std::endl;
    { print_VkAccelerationStructureGeometryAabbsDataKHR(obj->aabbs, "aabbs", 1); }

    PRINT_SPACE
    _OUT << "\"instances\": " << std::endl;
    { print_VkAccelerationStructureGeometryInstancesDataKHR(obj->instances, "instances", 0); }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureGeometryKHR(VkAccelerationStructureGeometryKHR obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkGeometryTypeKHR(obj.geometryType, "geometryType", 1);

    print_VkAccelerationStructureGeometryDataKHR(obj.geometry, "geometry", 1);

    print_VkGeometryFlagsKHR(obj.flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureGeometryKHR(const VkAccelerationStructureGeometryKHR* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkGeometryTypeKHR(obj->geometryType, "geometryType", 1);

    print_VkAccelerationStructureGeometryDataKHR(obj->geometry, "geometry", 1);

    print_VkGeometryFlagsKHR(obj->flags, "flags", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureBuildGeometryInfoKHR(VkAccelerationStructureBuildGeometryInfoKHR obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccelerationStructureTypeKHR(obj.type, "type", 1);

    print_VkBuildAccelerationStructureFlagsKHR(obj.flags, "flags", 1);

    print_VkBuildAccelerationStructureModeKHR(obj.mode, "mode", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcAccelerationStructure"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstAccelerationStructure"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj.geometryCount, "geometryCount", 1);

    PRINT_SPACE
    _OUT << "\"pGeometries\": " << std::endl;
    if (obj.pGeometries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.geometryCount; i++) {
            if (i + 1 == obj.geometryCount)
                print_VkAccelerationStructureGeometryKHR(obj.pGeometries[i], "pGeometries", 0);
            else
                print_VkAccelerationStructureGeometryKHR(obj.pGeometries[i], "pGeometries", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"ppGeometries\": " << std::endl;
    if (obj.ppGeometries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.geometryCount; i++) {
            if (i + 1 == obj.geometryCount)
                print_VkAccelerationStructureGeometryKHR(obj.ppGeometries[i], "ppGeometries", 0);
            else
                print_VkAccelerationStructureGeometryKHR(obj.ppGeometries[i], "ppGeometries", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkDeviceOrHostAddressKHR(obj.scratchData, "scratchData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureBuildGeometryInfoKHR(const VkAccelerationStructureBuildGeometryInfoKHR* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccelerationStructureTypeKHR(obj->type, "type", 1);

    print_VkBuildAccelerationStructureFlagsKHR(obj->flags, "flags", 1);

    print_VkBuildAccelerationStructureModeKHR(obj->mode, "mode", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "srcAccelerationStructure"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dstAccelerationStructure"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_uint32_t(obj->geometryCount, "geometryCount", 1);

    PRINT_SPACE
    _OUT << "\"pGeometries\": " << std::endl;
    if (obj->pGeometries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->geometryCount; i++) {
            if (i + 1 == obj->geometryCount)
                print_VkAccelerationStructureGeometryKHR(obj->pGeometries[i], "pGeometries", 0);
            else
                print_VkAccelerationStructureGeometryKHR(obj->pGeometries[i], "pGeometries", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"ppGeometries\": " << std::endl;
    if (obj->ppGeometries) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->geometryCount; i++) {
            if (i + 1 == obj->geometryCount)
                print_VkAccelerationStructureGeometryKHR(obj->ppGeometries[i], "ppGeometries", 0);
            else
                print_VkAccelerationStructureGeometryKHR(obj->ppGeometries[i], "ppGeometries", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_VkDeviceOrHostAddressKHR(obj->scratchData, "scratchData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureCreateInfoKHR(VkAccelerationStructureCreateInfoKHR obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccelerationStructureCreateFlagsKHR(obj.createFlags, "createFlags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj.offset, "offset", 1);

    print_VkDeviceSize(obj.size, "size", 1);

    print_VkAccelerationStructureTypeKHR(obj.type, "type", 1);

    print_VkDeviceAddress(obj.deviceAddress, "deviceAddress", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureCreateInfoKHR(const VkAccelerationStructureCreateInfoKHR* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkAccelerationStructureCreateFlagsKHR(obj->createFlags, "createFlags", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "buffer"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceSize(obj->offset, "offset", 1);

    print_VkDeviceSize(obj->size, "size", 1);

    print_VkAccelerationStructureTypeKHR(obj->type, "type", 1);

    print_VkDeviceAddress(obj->deviceAddress, "deviceAddress", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkWriteDescriptorSetAccelerationStructureKHR(VkWriteDescriptorSetAccelerationStructureKHR obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.accelerationStructureCount, "accelerationStructureCount", 1);

    PRINT_SPACE
    _OUT << "\"pAccelerationStructures\":" << std::endl;
    PRINT_SPACE
    if (obj.pAccelerationStructures) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.accelerationStructureCount; i++) {
            std::stringstream tmp;
            tmp << "pAccelerationStructures"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj.accelerationStructureCount;
            print_VkAccelerationStructureKHR(obj.pAccelerationStructures[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkWriteDescriptorSetAccelerationStructureKHR(const VkWriteDescriptorSetAccelerationStructureKHR* obj,
                                                               const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->accelerationStructureCount, "accelerationStructureCount", 1);

    PRINT_SPACE
    _OUT << "\"pAccelerationStructures\":" << std::endl;
    PRINT_SPACE
    if (obj->pAccelerationStructures) {
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->accelerationStructureCount; i++) {
            std::stringstream tmp;
            tmp << "pAccelerationStructures"
                << "_" << i;
            bool isCommaNeeded = (i + 1) != obj->accelerationStructureCount;
            print_VkAccelerationStructureKHR(obj->pAccelerationStructures[i], tmp.str(), isCommaNeeded);
        }
        PRINT_SPACE
        _OUT << "]"
             << "" << std::endl;
    } else {
        _OUT << "\"NULL\""
             << "" << std::endl;
    }

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceAccelerationStructureFeaturesKHR(VkPhysicalDeviceAccelerationStructureFeaturesKHR obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.accelerationStructure, "accelerationStructure", 1);

    print_VkBool32(obj.accelerationStructureCaptureReplay, "accelerationStructureCaptureReplay", 1);

    print_VkBool32(obj.accelerationStructureIndirectBuild, "accelerationStructureIndirectBuild", 1);

    print_VkBool32(obj.accelerationStructureHostCommands, "accelerationStructureHostCommands", 1);

    print_VkBool32(obj.descriptorBindingAccelerationStructureUpdateAfterBind,
                   "descriptorBindingAccelerationStructureUpdateAfterBind", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceAccelerationStructureFeaturesKHR(const VkPhysicalDeviceAccelerationStructureFeaturesKHR* obj,
                                                                   const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->accelerationStructure, "accelerationStructure", 1);

    print_VkBool32(obj->accelerationStructureCaptureReplay, "accelerationStructureCaptureReplay", 1);

    print_VkBool32(obj->accelerationStructureIndirectBuild, "accelerationStructureIndirectBuild", 1);

    print_VkBool32(obj->accelerationStructureHostCommands, "accelerationStructureHostCommands", 1);

    print_VkBool32(obj->descriptorBindingAccelerationStructureUpdateAfterBind,
                   "descriptorBindingAccelerationStructureUpdateAfterBind", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceAccelerationStructurePropertiesKHR(VkPhysicalDeviceAccelerationStructurePropertiesKHR obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj.maxGeometryCount, "maxGeometryCount", 1);

    print_uint64_t(obj.maxInstanceCount, "maxInstanceCount", 1);

    print_uint64_t(obj.maxPrimitiveCount, "maxPrimitiveCount", 1);

    print_uint32_t(obj.maxPerStageDescriptorAccelerationStructures, "maxPerStageDescriptorAccelerationStructures", 1);

    print_uint32_t(obj.maxPerStageDescriptorUpdateAfterBindAccelerationStructures,
                   "maxPerStageDescriptorUpdateAfterBindAccelerationStructures", 1);

    print_uint32_t(obj.maxDescriptorSetAccelerationStructures, "maxDescriptorSetAccelerationStructures", 1);

    print_uint32_t(obj.maxDescriptorSetUpdateAfterBindAccelerationStructures,
                   "maxDescriptorSetUpdateAfterBindAccelerationStructures", 1);

    print_uint32_t(obj.minAccelerationStructureScratchOffsetAlignment, "minAccelerationStructureScratchOffsetAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceAccelerationStructurePropertiesKHR(const VkPhysicalDeviceAccelerationStructurePropertiesKHR* obj,
                                                                     const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint64_t(obj->maxGeometryCount, "maxGeometryCount", 1);

    print_uint64_t(obj->maxInstanceCount, "maxInstanceCount", 1);

    print_uint64_t(obj->maxPrimitiveCount, "maxPrimitiveCount", 1);

    print_uint32_t(obj->maxPerStageDescriptorAccelerationStructures, "maxPerStageDescriptorAccelerationStructures", 1);

    print_uint32_t(obj->maxPerStageDescriptorUpdateAfterBindAccelerationStructures,
                   "maxPerStageDescriptorUpdateAfterBindAccelerationStructures", 1);

    print_uint32_t(obj->maxDescriptorSetAccelerationStructures, "maxDescriptorSetAccelerationStructures", 1);

    print_uint32_t(obj->maxDescriptorSetUpdateAfterBindAccelerationStructures,
                   "maxDescriptorSetUpdateAfterBindAccelerationStructures", 1);

    print_uint32_t(obj->minAccelerationStructureScratchOffsetAlignment, "minAccelerationStructureScratchOffsetAlignment", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureDeviceAddressInfoKHR(VkAccelerationStructureDeviceAddressInfoKHR obj, const std::string& s,
                                                              bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "accelerationStructure"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureDeviceAddressInfoKHR(const VkAccelerationStructureDeviceAddressInfoKHR* obj,
                                                              const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "accelerationStructure"
                     << "\""
                     << " : "
                     << "\""
                     << "\"" << std::endl;

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkAccelerationStructureVersionInfoKHR(VkAccelerationStructureVersionInfoKHR obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint8_t(obj.pVersionData, "pVersionData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkAccelerationStructureVersionInfoKHR(const VkAccelerationStructureVersionInfoKHR* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint8_t(obj->pVersionData, "pVersionData", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCopyAccelerationStructureToMemoryInfoKHR(VkCopyAccelerationStructureToMemoryInfoKHR obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "src"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceOrHostAddressKHR(obj.dst, "dst", 1);

    print_VkCopyAccelerationStructureModeKHR(obj.mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyAccelerationStructureToMemoryInfoKHR(const VkCopyAccelerationStructureToMemoryInfoKHR* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "src"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkDeviceOrHostAddressKHR(obj->dst, "dst", 1);

    print_VkCopyAccelerationStructureModeKHR(obj->mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCopyMemoryToAccelerationStructureInfoKHR(VkCopyMemoryToAccelerationStructureInfoKHR obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceOrHostAddressConstKHR(obj.src, "src", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dst"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkCopyAccelerationStructureModeKHR(obj.mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyMemoryToAccelerationStructureInfoKHR(const VkCopyMemoryToAccelerationStructureInfoKHR* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkDeviceOrHostAddressConstKHR(obj->src, "src", 1);

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dst"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkCopyAccelerationStructureModeKHR(obj->mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkCopyAccelerationStructureInfoKHR(VkCopyAccelerationStructureInfoKHR obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "src"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dst"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkCopyAccelerationStructureModeKHR(obj.mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkCopyAccelerationStructureInfoKHR(const VkCopyAccelerationStructureInfoKHR* obj, const std::string& s,
                                                     bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "src"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "dst"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_VkCopyAccelerationStructureModeKHR(obj->mode, "mode", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static std::map<uint64_t, std::string> VkShaderGroupShaderKHR_map = {
    std::make_pair(0, "VK_SHADER_GROUP_SHADER_GENERAL_KHR"),
    std::make_pair(1, "VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR"),
    std::make_pair(2, "VK_SHADER_GROUP_SHADER_ANY_HIT_KHR"),
    std::make_pair(3, "VK_SHADER_GROUP_SHADER_INTERSECTION_KHR"),
};
static void print_VkShaderGroupShaderKHR(VkShaderGroupShaderKHR obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderGroupShaderKHR_map[obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderGroupShaderKHR_map[obj] << "\"" << std::endl;
}
static void print_VkShaderGroupShaderKHR(const VkShaderGroupShaderKHR* obj, const std::string& str, bool commaNeeded = true) {
    PRINT_SPACE
    if (str != "")
        _OUT << "\"" << str << "\""
             << " : ";
    if (commaNeeded)
        _OUT << "\"" << VkShaderGroupShaderKHR_map[*obj] << "\"," << std::endl;
    else
        _OUT << "\"" << VkShaderGroupShaderKHR_map[*obj] << "\"" << std::endl;
}

static void print_VkRayTracingShaderGroupCreateInfoKHR(VkRayTracingShaderGroupCreateInfoKHR obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRayTracingShaderGroupTypeKHR(obj.type, "type", 1);

    print_uint32_t(obj.generalShader, "generalShader", 1);

    print_uint32_t(obj.closestHitShader, "closestHitShader", 1);

    print_uint32_t(obj.anyHitShader, "anyHitShader", 1);

    print_uint32_t(obj.intersectionShader, "intersectionShader", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRayTracingShaderGroupCreateInfoKHR(const VkRayTracingShaderGroupCreateInfoKHR* obj, const std::string& s,
                                                       bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkRayTracingShaderGroupTypeKHR(obj->type, "type", 1);

    print_uint32_t(obj->generalShader, "generalShader", 1);

    print_uint32_t(obj->closestHitShader, "closestHitShader", 1);

    print_uint32_t(obj->anyHitShader, "anyHitShader", 1);

    print_uint32_t(obj->intersectionShader, "intersectionShader", 1);

    /** Note: Ignoring void* data. **/

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRayTracingPipelineInterfaceCreateInfoKHR(VkRayTracingPipelineInterfaceCreateInfoKHR obj, const std::string& s,
                                                             bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxPipelineRayPayloadSize, "maxPipelineRayPayloadSize", 1);

    print_uint32_t(obj.maxPipelineRayHitAttributeSize, "maxPipelineRayHitAttributeSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRayTracingPipelineInterfaceCreateInfoKHR(const VkRayTracingPipelineInterfaceCreateInfoKHR* obj,
                                                             const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxPipelineRayPayloadSize, "maxPipelineRayPayloadSize", 1);

    print_uint32_t(obj->maxPipelineRayHitAttributeSize, "maxPipelineRayHitAttributeSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkRayTracingPipelineCreateInfoKHR(VkRayTracingPipelineCreateInfoKHR obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCreateFlags(obj.flags, "flags", 1);

    print_uint32_t(obj.stageCount, "stageCount", 1);

    PRINT_SPACE
    _OUT << "\"pStages\": " << std::endl;
    if (obj.pStages) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.stageCount; i++) {
            if (i + 1 == obj.stageCount)
                print_VkPipelineShaderStageCreateInfo(obj.pStages[i], "pStages", 0);
            else
                print_VkPipelineShaderStageCreateInfo(obj.pStages[i], "pStages", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.groupCount, "groupCount", 1);

    PRINT_SPACE
    _OUT << "\"pGroups\": " << std::endl;
    if (obj.pGroups) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj.groupCount; i++) {
            if (i + 1 == obj.groupCount)
                print_VkRayTracingShaderGroupCreateInfoKHR(obj.pGroups[i], "pGroups", 0);
            else
                print_VkRayTracingShaderGroupCreateInfoKHR(obj.pGroups[i], "pGroups", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj.maxPipelineRayRecursionDepth, "maxPipelineRayRecursionDepth", 1);

    PRINT_SPACE
    _OUT << "\"pLibraryInfo\": " << std::endl;
    if (obj.pLibraryInfo) {
        print_VkPipelineLibraryCreateInfoKHR(obj.pLibraryInfo, "pLibraryInfo", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pLibraryInterface\": " << std::endl;
    if (obj.pLibraryInterface) {
        print_VkRayTracingPipelineInterfaceCreateInfoKHR(obj.pLibraryInterface, "pLibraryInterface", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pDynamicState\": " << std::endl;
    if (obj.pDynamicState) {
        print_VkPipelineDynamicStateCreateInfo(obj.pDynamicState, "pDynamicState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "basePipelineHandle"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_int32_t(obj.basePipelineIndex, "basePipelineIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkRayTracingPipelineCreateInfoKHR(const VkRayTracingPipelineCreateInfoKHR* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkPipelineCreateFlags(obj->flags, "flags", 1);

    print_uint32_t(obj->stageCount, "stageCount", 1);

    PRINT_SPACE
    _OUT << "\"pStages\": " << std::endl;
    if (obj->pStages) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->stageCount; i++) {
            if (i + 1 == obj->stageCount)
                print_VkPipelineShaderStageCreateInfo(obj->pStages[i], "pStages", 0);
            else
                print_VkPipelineShaderStageCreateInfo(obj->pStages[i], "pStages", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->groupCount, "groupCount", 1);

    PRINT_SPACE
    _OUT << "\"pGroups\": " << std::endl;
    if (obj->pGroups) {
        PRINT_SPACE
        _OUT << "[" << std::endl;
        for (unsigned int i = 0; i < obj->groupCount; i++) {
            if (i + 1 == obj->groupCount)
                print_VkRayTracingShaderGroupCreateInfoKHR(obj->pGroups[i], "pGroups", 0);
            else
                print_VkRayTracingShaderGroupCreateInfoKHR(obj->pGroups[i], "pGroups", 1);
        }
        PRINT_SPACE
        _OUT << "]," << std::endl;
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    print_uint32_t(obj->maxPipelineRayRecursionDepth, "maxPipelineRayRecursionDepth", 1);

    PRINT_SPACE
    _OUT << "\"pLibraryInfo\": " << std::endl;
    if (obj->pLibraryInfo) {
        print_VkPipelineLibraryCreateInfoKHR(obj->pLibraryInfo, "pLibraryInfo", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pLibraryInterface\": " << std::endl;
    if (obj->pLibraryInterface) {
        print_VkRayTracingPipelineInterfaceCreateInfoKHR(obj->pLibraryInterface, "pLibraryInterface", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    PRINT_SPACE
    _OUT << "\"pDynamicState\": " << std::endl;
    if (obj->pDynamicState) {
        print_VkPipelineDynamicStateCreateInfo(obj->pDynamicState, "pDynamicState", 1);
    } else {
        PRINT_SPACE _OUT << "\"NULL\""
                         << "," << std::endl;
    }

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "layout"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    /** Note: printing just an empty entry here **/
    PRINT_SPACE _OUT << "\""
                     << "basePipelineHandle"
                     << "\""
                     << " : "
                     << "\""
                     << "\"," << std::endl;

    print_int32_t(obj->basePipelineIndex, "basePipelineIndex", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(VkPhysicalDeviceRayTracingPipelineFeaturesKHR obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.rayTracingPipeline, "rayTracingPipeline", 1);

    print_VkBool32(obj.rayTracingPipelineShaderGroupHandleCaptureReplay, "rayTracingPipelineShaderGroupHandleCaptureReplay", 1);

    print_VkBool32(obj.rayTracingPipelineShaderGroupHandleCaptureReplayMixed,
                   "rayTracingPipelineShaderGroupHandleCaptureReplayMixed", 1);

    print_VkBool32(obj.rayTracingPipelineTraceRaysIndirect, "rayTracingPipelineTraceRaysIndirect", 1);

    print_VkBool32(obj.rayTraversalPrimitiveCulling, "rayTraversalPrimitiveCulling", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(const VkPhysicalDeviceRayTracingPipelineFeaturesKHR* obj,
                                                                const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->rayTracingPipeline, "rayTracingPipeline", 1);

    print_VkBool32(obj->rayTracingPipelineShaderGroupHandleCaptureReplay, "rayTracingPipelineShaderGroupHandleCaptureReplay", 1);

    print_VkBool32(obj->rayTracingPipelineShaderGroupHandleCaptureReplayMixed,
                   "rayTracingPipelineShaderGroupHandleCaptureReplayMixed", 1);

    print_VkBool32(obj->rayTracingPipelineTraceRaysIndirect, "rayTracingPipelineTraceRaysIndirect", 1);

    print_VkBool32(obj->rayTraversalPrimitiveCulling, "rayTraversalPrimitiveCulling", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(VkPhysicalDeviceRayTracingPipelinePropertiesKHR obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.shaderGroupHandleSize, "shaderGroupHandleSize", 1);

    print_uint32_t(obj.maxRayRecursionDepth, "maxRayRecursionDepth", 1);

    print_uint32_t(obj.maxShaderGroupStride, "maxShaderGroupStride", 1);

    print_uint32_t(obj.shaderGroupBaseAlignment, "shaderGroupBaseAlignment", 1);

    print_uint32_t(obj.shaderGroupHandleCaptureReplaySize, "shaderGroupHandleCaptureReplaySize", 1);

    print_uint32_t(obj.maxRayDispatchInvocationCount, "maxRayDispatchInvocationCount", 1);

    print_uint32_t(obj.shaderGroupHandleAlignment, "shaderGroupHandleAlignment", 1);

    print_uint32_t(obj.maxRayHitAttributeSize, "maxRayHitAttributeSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(const VkPhysicalDeviceRayTracingPipelinePropertiesKHR* obj,
                                                                  const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->shaderGroupHandleSize, "shaderGroupHandleSize", 1);

    print_uint32_t(obj->maxRayRecursionDepth, "maxRayRecursionDepth", 1);

    print_uint32_t(obj->maxShaderGroupStride, "maxShaderGroupStride", 1);

    print_uint32_t(obj->shaderGroupBaseAlignment, "shaderGroupBaseAlignment", 1);

    print_uint32_t(obj->shaderGroupHandleCaptureReplaySize, "shaderGroupHandleCaptureReplaySize", 1);

    print_uint32_t(obj->maxRayDispatchInvocationCount, "maxRayDispatchInvocationCount", 1);

    print_uint32_t(obj->shaderGroupHandleAlignment, "shaderGroupHandleAlignment", 1);

    print_uint32_t(obj->maxRayHitAttributeSize, "maxRayHitAttributeSize", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkTraceRaysIndirectCommandKHR(VkTraceRaysIndirectCommandKHR obj, const std::string& s, bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.width, "width", 1);

    print_uint32_t(obj.height, "height", 1);

    print_uint32_t(obj.depth, "depth", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkTraceRaysIndirectCommandKHR(const VkTraceRaysIndirectCommandKHR* obj, const std::string& s,
                                                bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->width, "width", 1);

    print_uint32_t(obj->height, "height", 1);

    print_uint32_t(obj->depth, "depth", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceRayQueryFeaturesKHR(VkPhysicalDeviceRayQueryFeaturesKHR obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.rayQuery, "rayQuery", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceRayQueryFeaturesKHR(const VkPhysicalDeviceRayQueryFeaturesKHR* obj, const std::string& s,
                                                      bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->rayQuery, "rayQuery", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMeshShaderFeaturesEXT(VkPhysicalDeviceMeshShaderFeaturesEXT obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj.taskShader, "taskShader", 1);

    print_VkBool32(obj.meshShader, "meshShader", 1);

    print_VkBool32(obj.multiviewMeshShader, "multiviewMeshShader", 1);

    print_VkBool32(obj.primitiveFragmentShadingRateMeshShader, "primitiveFragmentShadingRateMeshShader", 1);

    print_VkBool32(obj.meshShaderQueries, "meshShaderQueries", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMeshShaderFeaturesEXT(const VkPhysicalDeviceMeshShaderFeaturesEXT* obj, const std::string& s,
                                                        bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_VkBool32(obj->taskShader, "taskShader", 1);

    print_VkBool32(obj->meshShader, "meshShader", 1);

    print_VkBool32(obj->multiviewMeshShader, "multiviewMeshShader", 1);

    print_VkBool32(obj->primitiveFragmentShadingRateMeshShader, "primitiveFragmentShadingRateMeshShader", 1);

    print_VkBool32(obj->meshShaderQueries, "meshShaderQueries", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkPhysicalDeviceMeshShaderPropertiesEXT(VkPhysicalDeviceMeshShaderPropertiesEXT obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj.sType, "sType", 1);

    if (obj.pNext) {
        dumpPNextChain(obj.pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj.maxTaskWorkGroupTotalCount, "maxTaskWorkGroupTotalCount", 1);

    PRINT_SPACE
    _OUT << "\"maxTaskWorkGroupCount\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj.maxTaskWorkGroupCount[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.maxTaskWorkGroupInvocations, "maxTaskWorkGroupInvocations", 1);

    PRINT_SPACE
    _OUT << "\"maxTaskWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj.maxTaskWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.maxTaskPayloadSize, "maxTaskPayloadSize", 1);

    print_uint32_t(obj.maxTaskSharedMemorySize, "maxTaskSharedMemorySize", 1);

    print_uint32_t(obj.maxTaskPayloadAndSharedMemorySize, "maxTaskPayloadAndSharedMemorySize", 1);

    print_uint32_t(obj.maxMeshWorkGroupTotalCount, "maxMeshWorkGroupTotalCount", 1);

    PRINT_SPACE
    _OUT << "\"maxMeshWorkGroupCount\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj.maxMeshWorkGroupCount[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.maxMeshWorkGroupInvocations, "maxMeshWorkGroupInvocations", 1);

    PRINT_SPACE
    _OUT << "\"maxMeshWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj.maxMeshWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj.maxMeshSharedMemorySize, "maxMeshSharedMemorySize", 1);

    print_uint32_t(obj.maxMeshPayloadAndSharedMemorySize, "maxMeshPayloadAndSharedMemorySize", 1);

    print_uint32_t(obj.maxMeshOutputMemorySize, "maxMeshOutputMemorySize", 1);

    print_uint32_t(obj.maxMeshPayloadAndOutputMemorySize, "maxMeshPayloadAndOutputMemorySize", 1);

    print_uint32_t(obj.maxMeshOutputComponents, "maxMeshOutputComponents", 1);

    print_uint32_t(obj.maxMeshOutputVertices, "maxMeshOutputVertices", 1);

    print_uint32_t(obj.maxMeshOutputPrimitives, "maxMeshOutputPrimitives", 1);

    print_uint32_t(obj.maxMeshOutputLayers, "maxMeshOutputLayers", 1);

    print_uint32_t(obj.maxMeshMultiviewViewCount, "maxMeshMultiviewViewCount", 1);

    print_uint32_t(obj.meshOutputPerVertexGranularity, "meshOutputPerVertexGranularity", 1);

    print_uint32_t(obj.meshOutputPerPrimitiveGranularity, "meshOutputPerPrimitiveGranularity", 1);

    print_uint32_t(obj.maxPreferredTaskWorkGroupInvocations, "maxPreferredTaskWorkGroupInvocations", 1);

    print_uint32_t(obj.maxPreferredMeshWorkGroupInvocations, "maxPreferredMeshWorkGroupInvocations", 1);

    print_VkBool32(obj.prefersLocalInvocationVertexOutput, "prefersLocalInvocationVertexOutput", 1);

    print_VkBool32(obj.prefersLocalInvocationPrimitiveOutput, "prefersLocalInvocationPrimitiveOutput", 1);

    print_VkBool32(obj.prefersCompactVertexOutput, "prefersCompactVertexOutput", 1);

    print_VkBool32(obj.prefersCompactPrimitiveOutput, "prefersCompactPrimitiveOutput", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkPhysicalDeviceMeshShaderPropertiesEXT(const VkPhysicalDeviceMeshShaderPropertiesEXT* obj, const std::string& s,
                                                          bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_VkStructureType(obj->sType, "sType", 1);

    if (obj->pNext) {
        dumpPNextChain(obj->pNext);
    } else {
        PRINT_SPACE
        _OUT << "\"pNext\":"
             << "\"NULL\""
             << "," << std::endl;
    }

    print_uint32_t(obj->maxTaskWorkGroupTotalCount, "maxTaskWorkGroupTotalCount", 1);

    PRINT_SPACE
    _OUT << "\"maxTaskWorkGroupCount\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj->maxTaskWorkGroupCount[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->maxTaskWorkGroupInvocations, "maxTaskWorkGroupInvocations", 1);

    PRINT_SPACE
    _OUT << "\"maxTaskWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj->maxTaskWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->maxTaskPayloadSize, "maxTaskPayloadSize", 1);

    print_uint32_t(obj->maxTaskSharedMemorySize, "maxTaskSharedMemorySize", 1);

    print_uint32_t(obj->maxTaskPayloadAndSharedMemorySize, "maxTaskPayloadAndSharedMemorySize", 1);

    print_uint32_t(obj->maxMeshWorkGroupTotalCount, "maxMeshWorkGroupTotalCount", 1);

    PRINT_SPACE
    _OUT << "\"maxMeshWorkGroupCount\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj->maxMeshWorkGroupCount[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->maxMeshWorkGroupInvocations, "maxMeshWorkGroupInvocations", 1);

    PRINT_SPACE
    _OUT << "\"maxMeshWorkGroupSize\":" << std::endl;
    PRINT_SPACE
    _OUT << "[" << std::endl;
    for (unsigned int i = 0; i < 3; i++) {
        bool isCommaNeeded = (i + 1) != 3;
        print_uint32_t(obj->maxMeshWorkGroupSize[i], "", isCommaNeeded);
    }
    PRINT_SPACE
    _OUT << "]"
         << "," << std::endl;

    print_uint32_t(obj->maxMeshSharedMemorySize, "maxMeshSharedMemorySize", 1);

    print_uint32_t(obj->maxMeshPayloadAndSharedMemorySize, "maxMeshPayloadAndSharedMemorySize", 1);

    print_uint32_t(obj->maxMeshOutputMemorySize, "maxMeshOutputMemorySize", 1);

    print_uint32_t(obj->maxMeshPayloadAndOutputMemorySize, "maxMeshPayloadAndOutputMemorySize", 1);

    print_uint32_t(obj->maxMeshOutputComponents, "maxMeshOutputComponents", 1);

    print_uint32_t(obj->maxMeshOutputVertices, "maxMeshOutputVertices", 1);

    print_uint32_t(obj->maxMeshOutputPrimitives, "maxMeshOutputPrimitives", 1);

    print_uint32_t(obj->maxMeshOutputLayers, "maxMeshOutputLayers", 1);

    print_uint32_t(obj->maxMeshMultiviewViewCount, "maxMeshMultiviewViewCount", 1);

    print_uint32_t(obj->meshOutputPerVertexGranularity, "meshOutputPerVertexGranularity", 1);

    print_uint32_t(obj->meshOutputPerPrimitiveGranularity, "meshOutputPerPrimitiveGranularity", 1);

    print_uint32_t(obj->maxPreferredTaskWorkGroupInvocations, "maxPreferredTaskWorkGroupInvocations", 1);

    print_uint32_t(obj->maxPreferredMeshWorkGroupInvocations, "maxPreferredMeshWorkGroupInvocations", 1);

    print_VkBool32(obj->prefersLocalInvocationVertexOutput, "prefersLocalInvocationVertexOutput", 1);

    print_VkBool32(obj->prefersLocalInvocationPrimitiveOutput, "prefersLocalInvocationPrimitiveOutput", 1);

    print_VkBool32(obj->prefersCompactVertexOutput, "prefersCompactVertexOutput", 1);

    print_VkBool32(obj->prefersCompactPrimitiveOutput, "prefersCompactPrimitiveOutput", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

static void print_VkDrawMeshTasksIndirectCommandEXT(VkDrawMeshTasksIndirectCommandEXT obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj.groupCountX, "groupCountX", 1);

    print_uint32_t(obj.groupCountY, "groupCountY", 1);

    print_uint32_t(obj.groupCountZ, "groupCountZ", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}
static void print_VkDrawMeshTasksIndirectCommandEXT(const VkDrawMeshTasksIndirectCommandEXT* obj, const std::string& s,
                                                    bool commaNeeded = true) {
    PRINT_SPACE
    _OUT << "{" << std::endl;
    INDENT(4);

    print_uint32_t(obj->groupCountX, "groupCountX", 1);

    print_uint32_t(obj->groupCountY, "groupCountY", 1);

    print_uint32_t(obj->groupCountZ, "groupCountZ", 0);

    INDENT(-4);
    PRINT_SPACE
    if (commaNeeded)
        _OUT << "}," << std::endl;
    else
        _OUT << "}" << std::endl;
}

/*************************************** Begin prototypes ***********************************/
/*************************************** End prototypes ***********************************/

static void dumpPNextChain(const void* pNext) {
    VkBaseInStructure* pBase = (VkBaseInStructure*)pNext;
    if (pNext) {
        PRINT_SPACE
        _OUT << "\"pNext\":" << std::endl;

        switch (pBase->sType) {
            case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO:
                print_VkBufferUsageFlags2CreateInfo((VkBufferUsageFlags2CreateInfo*)pNext, "VkBufferUsageFlags2CreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
                print_VkShaderModuleCreateInfo((VkShaderModuleCreateInfo*)pNext, "VkShaderModuleCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV:
                print_VkComputePipelineIndirectBufferInfoNV((VkComputePipelineIndirectBufferInfoNV*)pNext,
                                                            "VkComputePipelineIndirectBufferInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO:
                print_VkPipelineCreateFlags2CreateInfo((VkPipelineCreateFlags2CreateInfo*)pNext, "VkPipelineCreateFlags2CreateInfo",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR:
                print_VkPipelineBinaryInfoKHR((VkPipelineBinaryInfoKHR*)pNext, "VkPipelineBinaryInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
                print_VkPipelineLayoutCreateInfo((VkPipelineLayoutCreateInfo*)pNext, "VkPipelineLayoutCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV:
                print_VkDisplaySurfaceStereoCreateInfoNV((VkDisplaySurfaceStereoCreateInfoNV*)pNext,
                                                         "VkDisplaySurfaceStereoCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
                print_VkDisplayPresentInfoKHR((VkDisplayPresentInfoKHR*)pNext, "VkDisplayPresentInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
                print_VkDebugReportCallbackCreateInfoEXT((VkDebugReportCallbackCreateInfoEXT*)pNext,
                                                         "VkDebugReportCallbackCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
                print_VkValidationFlagsEXT((VkValidationFlagsEXT*)pNext, "VkValidationFlagsEXT", true);
                break;
            case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
                print_VkValidationFeaturesEXT((VkValidationFeaturesEXT*)pNext, "VkValidationFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT:
                print_VkLayerSettingsCreateInfoEXT((VkLayerSettingsCreateInfoEXT*)pNext, "VkLayerSettingsCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
                print_VkPipelineRasterizationStateRasterizationOrderAMD((VkPipelineRasterizationStateRasterizationOrderAMD*)pNext,
                                                                        "VkPipelineRasterizationStateRasterizationOrderAMD", true);
                break;
            case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
                print_VkDedicatedAllocationImageCreateInfoNV((VkDedicatedAllocationImageCreateInfoNV*)pNext,
                                                             "VkDedicatedAllocationImageCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
                print_VkDedicatedAllocationBufferCreateInfoNV((VkDedicatedAllocationBufferCreateInfoNV*)pNext,
                                                              "VkDedicatedAllocationBufferCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
                print_VkDedicatedAllocationMemoryAllocateInfoNV((VkDedicatedAllocationMemoryAllocateInfoNV*)pNext,
                                                                "VkDedicatedAllocationMemoryAllocateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
                print_VkExternalMemoryImageCreateInfoNV((VkExternalMemoryImageCreateInfoNV*)pNext,
                                                        "VkExternalMemoryImageCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
                print_VkExportMemoryAllocateInfoNV((VkExportMemoryAllocateInfoNV*)pNext, "VkExportMemoryAllocateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
                print_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV((VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*)pNext,
                                                                        "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
                print_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV(
                    (VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*)pNext,
                    "VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO:
                print_VkDevicePrivateDataCreateInfo((VkDevicePrivateDataCreateInfo*)pNext, "VkDevicePrivateDataCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
                print_VkPhysicalDevicePrivateDataFeatures((VkPhysicalDevicePrivateDataFeatures*)pNext,
                                                          "VkPhysicalDevicePrivateDataFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
                print_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
                    (VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*)pNext,
                    "VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV:
                print_VkPhysicalDeviceClusterAccelerationStructureFeaturesNV(
                    (VkPhysicalDeviceClusterAccelerationStructureFeaturesNV*)pNext,
                    "VkPhysicalDeviceClusterAccelerationStructureFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV:
                print_VkPhysicalDeviceClusterAccelerationStructurePropertiesNV(
                    (VkPhysicalDeviceClusterAccelerationStructurePropertiesNV*)pNext,
                    "VkPhysicalDeviceClusterAccelerationStructurePropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV:
                print_VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV(
                    (VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV*)pNext,
                    "VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
                print_VkPhysicalDeviceMultiDrawPropertiesEXT((VkPhysicalDeviceMultiDrawPropertiesEXT*)pNext,
                                                             "VkPhysicalDeviceMultiDrawPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
                print_VkGraphicsPipelineShaderGroupsCreateInfoNV((VkGraphicsPipelineShaderGroupsCreateInfoNV*)pNext,
                                                                 "VkGraphicsPipelineShaderGroupsCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
                print_VkPhysicalDeviceFeatures2((VkPhysicalDeviceFeatures2*)pNext, "VkPhysicalDeviceFeatures2", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES:
                print_VkPhysicalDevicePushDescriptorProperties((VkPhysicalDevicePushDescriptorProperties*)pNext,
                                                               "VkPhysicalDevicePushDescriptorProperties", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
                print_VkPhysicalDeviceDriverProperties((VkPhysicalDeviceDriverProperties*)pNext, "VkPhysicalDeviceDriverProperties",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
                print_VkPresentRegionsKHR((VkPresentRegionsKHR*)pNext, "VkPresentRegionsKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
                print_VkPhysicalDeviceVariablePointersFeatures((VkPhysicalDeviceVariablePointersFeatures*)pNext,
                                                               "VkPhysicalDeviceVariablePointersFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
                print_VkPhysicalDeviceExternalImageFormatInfo((VkPhysicalDeviceExternalImageFormatInfo*)pNext,
                                                              "VkPhysicalDeviceExternalImageFormatInfo", true);
                break;
            case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
                print_VkExternalImageFormatProperties((VkExternalImageFormatProperties*)pNext, "VkExternalImageFormatProperties",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
                print_VkPhysicalDeviceIDProperties((VkPhysicalDeviceIDProperties*)pNext, "VkPhysicalDeviceIDProperties", true);
                break;
            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
                print_VkExternalMemoryImageCreateInfo((VkExternalMemoryImageCreateInfo*)pNext, "VkExternalMemoryImageCreateInfo",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
                print_VkExternalMemoryBufferCreateInfo((VkExternalMemoryBufferCreateInfo*)pNext, "VkExternalMemoryBufferCreateInfo",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
                print_VkExportMemoryAllocateInfo((VkExportMemoryAllocateInfo*)pNext, "VkExportMemoryAllocateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
                print_VkImportMemoryFdInfoKHR((VkImportMemoryFdInfoKHR*)pNext, "VkImportMemoryFdInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT:
                print_VkImportMemoryMetalHandleInfoEXT((VkImportMemoryMetalHandleInfoEXT*)pNext, "VkImportMemoryMetalHandleInfoEXT",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
                print_VkExportSemaphoreCreateInfo((VkExportSemaphoreCreateInfo*)pNext, "VkExportSemaphoreCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
                print_VkExportFenceCreateInfo((VkExportFenceCreateInfo*)pNext, "VkExportFenceCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
                print_VkPhysicalDeviceMultiviewFeatures((VkPhysicalDeviceMultiviewFeatures*)pNext,
                                                        "VkPhysicalDeviceMultiviewFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
                print_VkPhysicalDeviceMultiviewProperties((VkPhysicalDeviceMultiviewProperties*)pNext,
                                                          "VkPhysicalDeviceMultiviewProperties", true);
                break;
            case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
                print_VkRenderPassMultiviewCreateInfo((VkRenderPassMultiviewCreateInfo*)pNext, "VkRenderPassMultiviewCreateInfo",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
                print_VkSwapchainCounterCreateInfoEXT((VkSwapchainCounterCreateInfoEXT*)pNext, "VkSwapchainCounterCreateInfoEXT",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
                print_VkMemoryAllocateFlagsInfo((VkMemoryAllocateFlagsInfo*)pNext, "VkMemoryAllocateFlagsInfo", true);
                break;
            case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
                print_VkBindBufferMemoryDeviceGroupInfo((VkBindBufferMemoryDeviceGroupInfo*)pNext,
                                                        "VkBindBufferMemoryDeviceGroupInfo", true);
                break;
            case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
                print_VkBindImageMemoryDeviceGroupInfo((VkBindImageMemoryDeviceGroupInfo*)pNext, "VkBindImageMemoryDeviceGroupInfo",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
                print_VkDeviceGroupRenderPassBeginInfo((VkDeviceGroupRenderPassBeginInfo*)pNext, "VkDeviceGroupRenderPassBeginInfo",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
                print_VkDeviceGroupCommandBufferBeginInfo((VkDeviceGroupCommandBufferBeginInfo*)pNext,
                                                          "VkDeviceGroupCommandBufferBeginInfo", true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
                print_VkDeviceGroupSubmitInfo((VkDeviceGroupSubmitInfo*)pNext, "VkDeviceGroupSubmitInfo", true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
                print_VkDeviceGroupBindSparseInfo((VkDeviceGroupBindSparseInfo*)pNext, "VkDeviceGroupBindSparseInfo", true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
                print_VkImageSwapchainCreateInfoKHR((VkImageSwapchainCreateInfoKHR*)pNext, "VkImageSwapchainCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
                print_VkBindImageMemorySwapchainInfoKHR((VkBindImageMemorySwapchainInfoKHR*)pNext,
                                                        "VkBindImageMemorySwapchainInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
                print_VkDeviceGroupPresentInfoKHR((VkDeviceGroupPresentInfoKHR*)pNext, "VkDeviceGroupPresentInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
                print_VkDeviceGroupDeviceCreateInfo((VkDeviceGroupDeviceCreateInfo*)pNext, "VkDeviceGroupDeviceCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
                print_VkDeviceGroupSwapchainCreateInfoKHR((VkDeviceGroupSwapchainCreateInfoKHR*)pNext,
                                                          "VkDeviceGroupSwapchainCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
                print_VkPhysicalDevicePresentIdFeaturesKHR((VkPhysicalDevicePresentIdFeaturesKHR*)pNext,
                                                           "VkPhysicalDevicePresentIdFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
                print_VkPresentIdKHR((VkPresentIdKHR*)pNext, "VkPresentIdKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
                print_VkPhysicalDevicePresentWaitFeaturesKHR((VkPhysicalDevicePresentWaitFeaturesKHR*)pNext,
                                                             "VkPhysicalDevicePresentWaitFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI:
                print_VkHdrVividDynamicMetadataHUAWEI((VkHdrVividDynamicMetadataHUAWEI*)pNext, "VkHdrVividDynamicMetadataHUAWEI",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
                print_VkDisplayNativeHdrSurfaceCapabilitiesAMD((VkDisplayNativeHdrSurfaceCapabilitiesAMD*)pNext,
                                                               "VkDisplayNativeHdrSurfaceCapabilitiesAMD", true);
                break;
            case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
                print_VkSwapchainDisplayNativeHdrCreateInfoAMD((VkSwapchainDisplayNativeHdrCreateInfoAMD*)pNext,
                                                               "VkSwapchainDisplayNativeHdrCreateInfoAMD", true);
                break;
            case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
                print_VkPresentTimesInfoGOOGLE((VkPresentTimesInfoGOOGLE*)pNext, "VkPresentTimesInfoGOOGLE", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
                print_VkPipelineViewportWScalingStateCreateInfoNV((VkPipelineViewportWScalingStateCreateInfoNV*)pNext,
                                                                  "VkPipelineViewportWScalingStateCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
                print_VkPipelineViewportSwizzleStateCreateInfoNV((VkPipelineViewportSwizzleStateCreateInfoNV*)pNext,
                                                                 "VkPipelineViewportSwizzleStateCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
                print_VkPhysicalDeviceDiscardRectanglePropertiesEXT((VkPhysicalDeviceDiscardRectanglePropertiesEXT*)pNext,
                                                                    "VkPhysicalDeviceDiscardRectanglePropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
                print_VkPipelineDiscardRectangleStateCreateInfoEXT((VkPipelineDiscardRectangleStateCreateInfoEXT*)pNext,
                                                                   "VkPipelineDiscardRectangleStateCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
                print_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
                    (VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*)pNext,
                    "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX", true);
                break;
            case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
                print_VkRenderPassInputAttachmentAspectCreateInfo((VkRenderPassInputAttachmentAspectCreateInfo*)pNext,
                                                                  "VkRenderPassInputAttachmentAspectCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV:
                print_VkDisplayModeStereoPropertiesNV((VkDisplayModeStereoPropertiesNV*)pNext, "VkDisplayModeStereoPropertiesNV",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
                print_VkSharedPresentSurfaceCapabilitiesKHR((VkSharedPresentSurfaceCapabilitiesKHR*)pNext,
                                                            "VkSharedPresentSurfaceCapabilitiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
                print_VkPhysicalDevice16BitStorageFeatures((VkPhysicalDevice16BitStorageFeatures*)pNext,
                                                           "VkPhysicalDevice16BitStorageFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
                print_VkPhysicalDeviceSubgroupProperties((VkPhysicalDeviceSubgroupProperties*)pNext,
                                                         "VkPhysicalDeviceSubgroupProperties", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
                print_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
                    (VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*)pNext,
                    "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
                print_VkPhysicalDevicePointClippingProperties((VkPhysicalDevicePointClippingProperties*)pNext,
                                                              "VkPhysicalDevicePointClippingProperties", true);
                break;
            case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
                print_VkMemoryDedicatedRequirements((VkMemoryDedicatedRequirements*)pNext, "VkMemoryDedicatedRequirements", true);
                break;
            case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
                print_VkMemoryDedicatedAllocateInfo((VkMemoryDedicatedAllocateInfo*)pNext, "VkMemoryDedicatedAllocateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
                print_VkImageViewUsageCreateInfo((VkImageViewUsageCreateInfo*)pNext, "VkImageViewUsageCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT:
                print_VkImageViewSlicedCreateInfoEXT((VkImageViewSlicedCreateInfoEXT*)pNext, "VkImageViewSlicedCreateInfoEXT",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
                print_VkPipelineTessellationDomainOriginStateCreateInfo((VkPipelineTessellationDomainOriginStateCreateInfo*)pNext,
                                                                        "VkPipelineTessellationDomainOriginStateCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
                print_VkSamplerYcbcrConversionInfo((VkSamplerYcbcrConversionInfo*)pNext, "VkSamplerYcbcrConversionInfo", true);
                break;
            case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
                print_VkBindImagePlaneMemoryInfo((VkBindImagePlaneMemoryInfo*)pNext, "VkBindImagePlaneMemoryInfo", true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
                print_VkImagePlaneMemoryRequirementsInfo((VkImagePlaneMemoryRequirementsInfo*)pNext,
                                                         "VkImagePlaneMemoryRequirementsInfo", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
                print_VkPhysicalDeviceSamplerYcbcrConversionFeatures((VkPhysicalDeviceSamplerYcbcrConversionFeatures*)pNext,
                                                                     "VkPhysicalDeviceSamplerYcbcrConversionFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
                print_VkSamplerYcbcrConversionImageFormatProperties((VkSamplerYcbcrConversionImageFormatProperties*)pNext,
                                                                    "VkSamplerYcbcrConversionImageFormatProperties", true);
                break;
            case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
                print_VkTextureLODGatherFormatPropertiesAMD((VkTextureLODGatherFormatPropertiesAMD*)pNext,
                                                            "VkTextureLODGatherFormatPropertiesAMD", true);
                break;
            case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
                print_VkProtectedSubmitInfo((VkProtectedSubmitInfo*)pNext, "VkProtectedSubmitInfo", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
                print_VkPhysicalDeviceProtectedMemoryFeatures((VkPhysicalDeviceProtectedMemoryFeatures*)pNext,
                                                              "VkPhysicalDeviceProtectedMemoryFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
                print_VkPhysicalDeviceProtectedMemoryProperties((VkPhysicalDeviceProtectedMemoryProperties*)pNext,
                                                                "VkPhysicalDeviceProtectedMemoryProperties", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
                print_VkPipelineCoverageToColorStateCreateInfoNV((VkPipelineCoverageToColorStateCreateInfoNV*)pNext,
                                                                 "VkPipelineCoverageToColorStateCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
                print_VkPhysicalDeviceSamplerFilterMinmaxProperties((VkPhysicalDeviceSamplerFilterMinmaxProperties*)pNext,
                                                                    "VkPhysicalDeviceSamplerFilterMinmaxProperties", true);
                break;
            case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
                print_VkSampleLocationsInfoEXT((VkSampleLocationsInfoEXT*)pNext, "VkSampleLocationsInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
                print_VkRenderPassSampleLocationsBeginInfoEXT((VkRenderPassSampleLocationsBeginInfoEXT*)pNext,
                                                              "VkRenderPassSampleLocationsBeginInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
                print_VkPipelineSampleLocationsStateCreateInfoEXT((VkPipelineSampleLocationsStateCreateInfoEXT*)pNext,
                                                                  "VkPipelineSampleLocationsStateCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
                print_VkPhysicalDeviceSampleLocationsPropertiesEXT((VkPhysicalDeviceSampleLocationsPropertiesEXT*)pNext,
                                                                   "VkPhysicalDeviceSampleLocationsPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
                print_VkSamplerReductionModeCreateInfo((VkSamplerReductionModeCreateInfo*)pNext, "VkSamplerReductionModeCreateInfo",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
                print_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT((VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*)pNext,
                                                                        "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
                print_VkPhysicalDeviceMultiDrawFeaturesEXT((VkPhysicalDeviceMultiDrawFeaturesEXT*)pNext,
                                                           "VkPhysicalDeviceMultiDrawFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
                print_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
                    (VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*)pNext,
                    "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
                print_VkPipelineColorBlendAdvancedStateCreateInfoEXT((VkPipelineColorBlendAdvancedStateCreateInfoEXT*)pNext,
                                                                     "VkPipelineColorBlendAdvancedStateCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
                print_VkPhysicalDeviceInlineUniformBlockFeatures((VkPhysicalDeviceInlineUniformBlockFeatures*)pNext,
                                                                 "VkPhysicalDeviceInlineUniformBlockFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
                print_VkPhysicalDeviceInlineUniformBlockProperties((VkPhysicalDeviceInlineUniformBlockProperties*)pNext,
                                                                   "VkPhysicalDeviceInlineUniformBlockProperties", true);
                break;
            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK:
                print_VkWriteDescriptorSetInlineUniformBlock((VkWriteDescriptorSetInlineUniformBlock*)pNext,
                                                             "VkWriteDescriptorSetInlineUniformBlock", true);
                break;
            case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO:
                print_VkDescriptorPoolInlineUniformBlockCreateInfo((VkDescriptorPoolInlineUniformBlockCreateInfo*)pNext,
                                                                   "VkDescriptorPoolInlineUniformBlockCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
                print_VkPipelineCoverageModulationStateCreateInfoNV((VkPipelineCoverageModulationStateCreateInfoNV*)pNext,
                                                                    "VkPipelineCoverageModulationStateCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
                print_VkImageFormatListCreateInfo((VkImageFormatListCreateInfo*)pNext, "VkImageFormatListCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
                print_VkShaderModuleValidationCacheCreateInfoEXT((VkShaderModuleValidationCacheCreateInfoEXT*)pNext,
                                                                 "VkShaderModuleValidationCacheCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
                print_VkPhysicalDeviceMaintenance3Properties((VkPhysicalDeviceMaintenance3Properties*)pNext,
                                                             "VkPhysicalDeviceMaintenance3Properties", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
                print_VkPhysicalDeviceMaintenance4Features((VkPhysicalDeviceMaintenance4Features*)pNext,
                                                           "VkPhysicalDeviceMaintenance4Features", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:
                print_VkPhysicalDeviceMaintenance4Properties((VkPhysicalDeviceMaintenance4Properties*)pNext,
                                                             "VkPhysicalDeviceMaintenance4Properties", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES:
                print_VkPhysicalDeviceMaintenance5Features((VkPhysicalDeviceMaintenance5Features*)pNext,
                                                           "VkPhysicalDeviceMaintenance5Features", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES:
                print_VkPhysicalDeviceMaintenance5Properties((VkPhysicalDeviceMaintenance5Properties*)pNext,
                                                             "VkPhysicalDeviceMaintenance5Properties", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES:
                print_VkPhysicalDeviceMaintenance6Features((VkPhysicalDeviceMaintenance6Features*)pNext,
                                                           "VkPhysicalDeviceMaintenance6Features", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES:
                print_VkPhysicalDeviceMaintenance6Properties((VkPhysicalDeviceMaintenance6Properties*)pNext,
                                                             "VkPhysicalDeviceMaintenance6Properties", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR:
                print_VkPhysicalDeviceMaintenance7FeaturesKHR((VkPhysicalDeviceMaintenance7FeaturesKHR*)pNext,
                                                              "VkPhysicalDeviceMaintenance7FeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR:
                print_VkPhysicalDeviceMaintenance7PropertiesKHR((VkPhysicalDeviceMaintenance7PropertiesKHR*)pNext,
                                                                "VkPhysicalDeviceMaintenance7PropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR:
                print_VkPhysicalDeviceLayeredApiPropertiesListKHR((VkPhysicalDeviceLayeredApiPropertiesListKHR*)pNext,
                                                                  "VkPhysicalDeviceLayeredApiPropertiesListKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR:
                print_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR((VkPhysicalDeviceLayeredApiVulkanPropertiesKHR*)pNext,
                                                                    "VkPhysicalDeviceLayeredApiVulkanPropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR:
                print_VkPhysicalDeviceMaintenance8FeaturesKHR((VkPhysicalDeviceMaintenance8FeaturesKHR*)pNext,
                                                              "VkPhysicalDeviceMaintenance8FeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
                print_VkPhysicalDeviceShaderDrawParametersFeatures((VkPhysicalDeviceShaderDrawParametersFeatures*)pNext,
                                                                   "VkPhysicalDeviceShaderDrawParametersFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
                print_VkPhysicalDeviceShaderFloat16Int8Features((VkPhysicalDeviceShaderFloat16Int8Features*)pNext,
                                                                "VkPhysicalDeviceShaderFloat16Int8Features", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
                print_VkPhysicalDeviceFloatControlsProperties((VkPhysicalDeviceFloatControlsProperties*)pNext,
                                                              "VkPhysicalDeviceFloatControlsProperties", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
                print_VkPhysicalDeviceHostQueryResetFeatures((VkPhysicalDeviceHostQueryResetFeatures*)pNext,
                                                             "VkPhysicalDeviceHostQueryResetFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO:
                print_VkDeviceQueueGlobalPriorityCreateInfo((VkDeviceQueueGlobalPriorityCreateInfo*)pNext,
                                                            "VkDeviceQueueGlobalPriorityCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES:
                print_VkPhysicalDeviceGlobalPriorityQueryFeatures((VkPhysicalDeviceGlobalPriorityQueryFeatures*)pNext,
                                                                  "VkPhysicalDeviceGlobalPriorityQueryFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES:
                print_VkQueueFamilyGlobalPriorityProperties((VkQueueFamilyGlobalPriorityProperties*)pNext,
                                                            "VkQueueFamilyGlobalPriorityProperties", true);
                break;
            case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
                print_VkDebugUtilsObjectNameInfoEXT((VkDebugUtilsObjectNameInfoEXT*)pNext, "VkDebugUtilsObjectNameInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
                print_VkDebugUtilsMessengerCreateInfoEXT((VkDebugUtilsMessengerCreateInfoEXT*)pNext,
                                                         "VkDebugUtilsMessengerCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
                print_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT((VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*)pNext,
                                                                    "VkPhysicalDeviceDeviceMemoryReportFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
                print_VkDeviceDeviceMemoryReportCreateInfoEXT((VkDeviceDeviceMemoryReportCreateInfoEXT*)pNext,
                                                              "VkDeviceDeviceMemoryReportCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
                print_VkImportMemoryHostPointerInfoEXT((VkImportMemoryHostPointerInfoEXT*)pNext, "VkImportMemoryHostPointerInfoEXT",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
                print_VkPhysicalDeviceExternalMemoryHostPropertiesEXT((VkPhysicalDeviceExternalMemoryHostPropertiesEXT*)pNext,
                                                                      "VkPhysicalDeviceExternalMemoryHostPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
                print_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
                    (VkPhysicalDeviceConservativeRasterizationPropertiesEXT*)pNext,
                    "VkPhysicalDeviceConservativeRasterizationPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
                print_VkPhysicalDeviceShaderCorePropertiesAMD((VkPhysicalDeviceShaderCorePropertiesAMD*)pNext,
                                                              "VkPhysicalDeviceShaderCorePropertiesAMD", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
                print_VkPhysicalDeviceShaderCoreProperties2AMD((VkPhysicalDeviceShaderCoreProperties2AMD*)pNext,
                                                               "VkPhysicalDeviceShaderCoreProperties2AMD", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
                print_VkPipelineRasterizationConservativeStateCreateInfoEXT(
                    (VkPipelineRasterizationConservativeStateCreateInfoEXT*)pNext,
                    "VkPipelineRasterizationConservativeStateCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
                print_VkPhysicalDeviceDescriptorIndexingFeatures((VkPhysicalDeviceDescriptorIndexingFeatures*)pNext,
                                                                 "VkPhysicalDeviceDescriptorIndexingFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
                print_VkPhysicalDeviceDescriptorIndexingProperties((VkPhysicalDeviceDescriptorIndexingProperties*)pNext,
                                                                   "VkPhysicalDeviceDescriptorIndexingProperties", true);
                break;
            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
                print_VkDescriptorSetLayoutBindingFlagsCreateInfo((VkDescriptorSetLayoutBindingFlagsCreateInfo*)pNext,
                                                                  "VkDescriptorSetLayoutBindingFlagsCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
                print_VkDescriptorSetVariableDescriptorCountAllocateInfo((VkDescriptorSetVariableDescriptorCountAllocateInfo*)pNext,
                                                                         "VkDescriptorSetVariableDescriptorCountAllocateInfo",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
                print_VkDescriptorSetVariableDescriptorCountLayoutSupport(
                    (VkDescriptorSetVariableDescriptorCountLayoutSupport*)pNext,
                    "VkDescriptorSetVariableDescriptorCountLayoutSupport", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
                print_VkPhysicalDeviceTimelineSemaphoreFeatures((VkPhysicalDeviceTimelineSemaphoreFeatures*)pNext,
                                                                "VkPhysicalDeviceTimelineSemaphoreFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
                print_VkPhysicalDeviceTimelineSemaphoreProperties((VkPhysicalDeviceTimelineSemaphoreProperties*)pNext,
                                                                  "VkPhysicalDeviceTimelineSemaphoreProperties", true);
                break;
            case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
                print_VkSemaphoreTypeCreateInfo((VkSemaphoreTypeCreateInfo*)pNext, "VkSemaphoreTypeCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
                print_VkTimelineSemaphoreSubmitInfo((VkTimelineSemaphoreSubmitInfo*)pNext, "VkTimelineSemaphoreSubmitInfo", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO:
                print_VkPipelineVertexInputDivisorStateCreateInfo((VkPipelineVertexInputDivisorStateCreateInfo*)pNext,
                                                                  "VkPipelineVertexInputDivisorStateCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
                print_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
                    (VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*)pNext,
                    "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES:
                print_VkPhysicalDeviceVertexAttributeDivisorProperties((VkPhysicalDeviceVertexAttributeDivisorProperties*)pNext,
                                                                       "VkPhysicalDeviceVertexAttributeDivisorProperties", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
                print_VkPhysicalDevicePCIBusInfoPropertiesEXT((VkPhysicalDevicePCIBusInfoPropertiesEXT*)pNext,
                                                              "VkPhysicalDevicePCIBusInfoPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
                print_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
                    (VkCommandBufferInheritanceConditionalRenderingInfoEXT*)pNext,
                    "VkCommandBufferInheritanceConditionalRenderingInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
                print_VkPhysicalDevice8BitStorageFeatures((VkPhysicalDevice8BitStorageFeatures*)pNext,
                                                          "VkPhysicalDevice8BitStorageFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
                print_VkPhysicalDeviceConditionalRenderingFeaturesEXT((VkPhysicalDeviceConditionalRenderingFeaturesEXT*)pNext,
                                                                      "VkPhysicalDeviceConditionalRenderingFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
                print_VkPhysicalDeviceVulkanMemoryModelFeatures((VkPhysicalDeviceVulkanMemoryModelFeatures*)pNext,
                                                                "VkPhysicalDeviceVulkanMemoryModelFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
                print_VkPhysicalDeviceShaderAtomicInt64Features((VkPhysicalDeviceShaderAtomicInt64Features*)pNext,
                                                                "VkPhysicalDeviceShaderAtomicInt64Features", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
                print_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT((VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*)pNext,
                                                                   "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
                print_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT((VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*)pNext,
                                                                    "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES:
                print_VkPhysicalDeviceVertexAttributeDivisorFeatures((VkPhysicalDeviceVertexAttributeDivisorFeatures*)pNext,
                                                                     "VkPhysicalDeviceVertexAttributeDivisorFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
                print_VkQueueFamilyCheckpointPropertiesNV((VkQueueFamilyCheckpointPropertiesNV*)pNext,
                                                          "VkQueueFamilyCheckpointPropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
                print_VkPhysicalDeviceDepthStencilResolveProperties((VkPhysicalDeviceDepthStencilResolveProperties*)pNext,
                                                                    "VkPhysicalDeviceDepthStencilResolveProperties", true);
                break;
            case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
                print_VkSubpassDescriptionDepthStencilResolve((VkSubpassDescriptionDepthStencilResolve*)pNext,
                                                              "VkSubpassDescriptionDepthStencilResolve", true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
                print_VkImageViewASTCDecodeModeEXT((VkImageViewASTCDecodeModeEXT*)pNext, "VkImageViewASTCDecodeModeEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
                print_VkPhysicalDeviceASTCDecodeFeaturesEXT((VkPhysicalDeviceASTCDecodeFeaturesEXT*)pNext,
                                                            "VkPhysicalDeviceASTCDecodeFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
                print_VkPhysicalDeviceTransformFeedbackFeaturesEXT((VkPhysicalDeviceTransformFeedbackFeaturesEXT*)pNext,
                                                                   "VkPhysicalDeviceTransformFeedbackFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
                print_VkPhysicalDeviceTransformFeedbackPropertiesEXT((VkPhysicalDeviceTransformFeedbackPropertiesEXT*)pNext,
                                                                     "VkPhysicalDeviceTransformFeedbackPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
                print_VkPipelineRasterizationStateStreamCreateInfoEXT((VkPipelineRasterizationStateStreamCreateInfoEXT*)pNext,
                                                                      "VkPipelineRasterizationStateStreamCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
                print_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
                    (VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*)pNext,
                    "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
                print_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
                    (VkPipelineRepresentativeFragmentTestStateCreateInfoNV*)pNext,
                    "VkPipelineRepresentativeFragmentTestStateCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
                print_VkPhysicalDeviceExclusiveScissorFeaturesNV((VkPhysicalDeviceExclusiveScissorFeaturesNV*)pNext,
                                                                 "VkPhysicalDeviceExclusiveScissorFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
                print_VkPipelineViewportExclusiveScissorStateCreateInfoNV(
                    (VkPipelineViewportExclusiveScissorStateCreateInfoNV*)pNext,
                    "VkPipelineViewportExclusiveScissorStateCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
                print_VkPhysicalDeviceCornerSampledImageFeaturesNV((VkPhysicalDeviceCornerSampledImageFeaturesNV*)pNext,
                                                                   "VkPhysicalDeviceCornerSampledImageFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR:
                print_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(
                    (VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR*)pNext,
                    "VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR:
                print_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(
                    (VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR*)pNext,
                    "VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
                print_VkPhysicalDeviceShaderImageFootprintFeaturesNV((VkPhysicalDeviceShaderImageFootprintFeaturesNV*)pNext,
                                                                     "VkPhysicalDeviceShaderImageFootprintFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
                print_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
                    (VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*)pNext,
                    "VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV:
                print_VkPhysicalDeviceCopyMemoryIndirectFeaturesNV((VkPhysicalDeviceCopyMemoryIndirectFeaturesNV*)pNext,
                                                                   "VkPhysicalDeviceCopyMemoryIndirectFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV:
                print_VkPhysicalDeviceCopyMemoryIndirectPropertiesNV((VkPhysicalDeviceCopyMemoryIndirectPropertiesNV*)pNext,
                                                                     "VkPhysicalDeviceCopyMemoryIndirectPropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV:
                print_VkPhysicalDeviceMemoryDecompressionFeaturesNV((VkPhysicalDeviceMemoryDecompressionFeaturesNV*)pNext,
                                                                    "VkPhysicalDeviceMemoryDecompressionFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV:
                print_VkPhysicalDeviceMemoryDecompressionPropertiesNV((VkPhysicalDeviceMemoryDecompressionPropertiesNV*)pNext,
                                                                      "VkPhysicalDeviceMemoryDecompressionPropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
                print_VkPipelineViewportShadingRateImageStateCreateInfoNV(
                    (VkPipelineViewportShadingRateImageStateCreateInfoNV*)pNext,
                    "VkPipelineViewportShadingRateImageStateCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
                print_VkPhysicalDeviceShadingRateImageFeaturesNV((VkPhysicalDeviceShadingRateImageFeaturesNV*)pNext,
                                                                 "VkPhysicalDeviceShadingRateImageFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
                print_VkPhysicalDeviceShadingRateImagePropertiesNV((VkPhysicalDeviceShadingRateImagePropertiesNV*)pNext,
                                                                   "VkPhysicalDeviceShadingRateImagePropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
                print_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI((VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*)pNext,
                                                                   "VkPhysicalDeviceInvocationMaskFeaturesHUAWEI", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
                print_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
                    (VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*)pNext,
                    "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
                print_VkPhysicalDeviceMeshShaderFeaturesNV((VkPhysicalDeviceMeshShaderFeaturesNV*)pNext,
                                                           "VkPhysicalDeviceMeshShaderFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
                print_VkPhysicalDeviceMeshShaderPropertiesNV((VkPhysicalDeviceMeshShaderPropertiesNV*)pNext,
                                                             "VkPhysicalDeviceMeshShaderPropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
                print_VkPhysicalDeviceMeshShaderFeaturesEXT((VkPhysicalDeviceMeshShaderFeaturesEXT*)pNext,
                                                            "VkPhysicalDeviceMeshShaderFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT:
                print_VkPhysicalDeviceMeshShaderPropertiesEXT((VkPhysicalDeviceMeshShaderPropertiesEXT*)pNext,
                                                              "VkPhysicalDeviceMeshShaderPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
                print_VkWriteDescriptorSetAccelerationStructureKHR((VkWriteDescriptorSetAccelerationStructureKHR*)pNext,
                                                                   "VkWriteDescriptorSetAccelerationStructureKHR", true);
                break;
            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
                print_VkWriteDescriptorSetAccelerationStructureNV((VkWriteDescriptorSetAccelerationStructureNV*)pNext,
                                                                  "VkWriteDescriptorSetAccelerationStructureNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
                print_VkPhysicalDeviceAccelerationStructureFeaturesKHR((VkPhysicalDeviceAccelerationStructureFeaturesKHR*)pNext,
                                                                       "VkPhysicalDeviceAccelerationStructureFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
                print_VkPhysicalDeviceRayTracingPipelineFeaturesKHR((VkPhysicalDeviceRayTracingPipelineFeaturesKHR*)pNext,
                                                                    "VkPhysicalDeviceRayTracingPipelineFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
                print_VkPhysicalDeviceRayQueryFeaturesKHR((VkPhysicalDeviceRayQueryFeaturesKHR*)pNext,
                                                          "VkPhysicalDeviceRayQueryFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
                print_VkPhysicalDeviceAccelerationStructurePropertiesKHR((VkPhysicalDeviceAccelerationStructurePropertiesKHR*)pNext,
                                                                         "VkPhysicalDeviceAccelerationStructurePropertiesKHR",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
                print_VkPhysicalDeviceRayTracingPipelinePropertiesKHR((VkPhysicalDeviceRayTracingPipelinePropertiesKHR*)pNext,
                                                                      "VkPhysicalDeviceRayTracingPipelinePropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
                print_VkPhysicalDeviceRayTracingPropertiesNV((VkPhysicalDeviceRayTracingPropertiesNV*)pNext,
                                                             "VkPhysicalDeviceRayTracingPropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
                print_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR((VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*)pNext,
                                                                        "VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
                print_VkDrmFormatModifierPropertiesListEXT((VkDrmFormatModifierPropertiesListEXT*)pNext,
                                                           "VkDrmFormatModifierPropertiesListEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
                print_VkPhysicalDeviceImageDrmFormatModifierInfoEXT((VkPhysicalDeviceImageDrmFormatModifierInfoEXT*)pNext,
                                                                    "VkPhysicalDeviceImageDrmFormatModifierInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
                print_VkImageDrmFormatModifierListCreateInfoEXT((VkImageDrmFormatModifierListCreateInfoEXT*)pNext,
                                                                "VkImageDrmFormatModifierListCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
                print_VkImageDrmFormatModifierExplicitCreateInfoEXT((VkImageDrmFormatModifierExplicitCreateInfoEXT*)pNext,
                                                                    "VkImageDrmFormatModifierExplicitCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
                print_VkImageStencilUsageCreateInfo((VkImageStencilUsageCreateInfo*)pNext, "VkImageStencilUsageCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
                print_VkDeviceMemoryOverallocationCreateInfoAMD((VkDeviceMemoryOverallocationCreateInfoAMD*)pNext,
                                                                "VkDeviceMemoryOverallocationCreateInfoAMD", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
                print_VkPhysicalDeviceFragmentDensityMapFeaturesEXT((VkPhysicalDeviceFragmentDensityMapFeaturesEXT*)pNext,
                                                                    "VkPhysicalDeviceFragmentDensityMapFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
                print_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT((VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*)pNext,
                                                                     "VkPhysicalDeviceFragmentDensityMap2FeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM:
                print_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM(
                    (VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*)pNext,
                    "VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
                print_VkPhysicalDeviceFragmentDensityMapPropertiesEXT((VkPhysicalDeviceFragmentDensityMapPropertiesEXT*)pNext,
                                                                      "VkPhysicalDeviceFragmentDensityMapPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
                print_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT((VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*)pNext,
                                                                       "VkPhysicalDeviceFragmentDensityMap2PropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM:
                print_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM(
                    (VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM*)pNext,
                    "VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
                print_VkRenderPassFragmentDensityMapCreateInfoEXT((VkRenderPassFragmentDensityMapCreateInfoEXT*)pNext,
                                                                  "VkRenderPassFragmentDensityMapCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM:
                print_VkSubpassFragmentDensityMapOffsetEndInfoQCOM((VkSubpassFragmentDensityMapOffsetEndInfoQCOM*)pNext,
                                                                   "VkSubpassFragmentDensityMapOffsetEndInfoQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
                print_VkPhysicalDeviceScalarBlockLayoutFeatures((VkPhysicalDeviceScalarBlockLayoutFeatures*)pNext,
                                                                "VkPhysicalDeviceScalarBlockLayoutFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
                print_VkSurfaceProtectedCapabilitiesKHR((VkSurfaceProtectedCapabilitiesKHR*)pNext,
                                                        "VkSurfaceProtectedCapabilitiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
                print_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
                    (VkPhysicalDeviceUniformBufferStandardLayoutFeatures*)pNext,
                    "VkPhysicalDeviceUniformBufferStandardLayoutFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
                print_VkPhysicalDeviceDepthClipEnableFeaturesEXT((VkPhysicalDeviceDepthClipEnableFeaturesEXT*)pNext,
                                                                 "VkPhysicalDeviceDepthClipEnableFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
                print_VkPipelineRasterizationDepthClipStateCreateInfoEXT((VkPipelineRasterizationDepthClipStateCreateInfoEXT*)pNext,
                                                                         "VkPipelineRasterizationDepthClipStateCreateInfoEXT",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
                print_VkPhysicalDeviceMemoryBudgetPropertiesEXT((VkPhysicalDeviceMemoryBudgetPropertiesEXT*)pNext,
                                                                "VkPhysicalDeviceMemoryBudgetPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
                print_VkPhysicalDeviceMemoryPriorityFeaturesEXT((VkPhysicalDeviceMemoryPriorityFeaturesEXT*)pNext,
                                                                "VkPhysicalDeviceMemoryPriorityFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
                print_VkMemoryPriorityAllocateInfoEXT((VkMemoryPriorityAllocateInfoEXT*)pNext, "VkMemoryPriorityAllocateInfoEXT",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
                print_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(
                    (VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*)pNext,
                    "VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
                print_VkPhysicalDeviceBufferDeviceAddressFeatures((VkPhysicalDeviceBufferDeviceAddressFeatures*)pNext,
                                                                  "VkPhysicalDeviceBufferDeviceAddressFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
                print_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT((VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*)pNext,
                                                                     "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
                print_VkBufferOpaqueCaptureAddressCreateInfo((VkBufferOpaqueCaptureAddressCreateInfo*)pNext,
                                                             "VkBufferOpaqueCaptureAddressCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
                print_VkBufferDeviceAddressCreateInfoEXT((VkBufferDeviceAddressCreateInfoEXT*)pNext,
                                                         "VkBufferDeviceAddressCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
                print_VkPhysicalDeviceImageViewImageFormatInfoEXT((VkPhysicalDeviceImageViewImageFormatInfoEXT*)pNext,
                                                                  "VkPhysicalDeviceImageViewImageFormatInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
                print_VkFilterCubicImageViewImageFormatPropertiesEXT((VkFilterCubicImageViewImageFormatPropertiesEXT*)pNext,
                                                                     "VkFilterCubicImageViewImageFormatPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
                print_VkPhysicalDeviceImagelessFramebufferFeatures((VkPhysicalDeviceImagelessFramebufferFeatures*)pNext,
                                                                   "VkPhysicalDeviceImagelessFramebufferFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
                print_VkFramebufferAttachmentsCreateInfo((VkFramebufferAttachmentsCreateInfo*)pNext,
                                                         "VkFramebufferAttachmentsCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
                print_VkRenderPassAttachmentBeginInfo((VkRenderPassAttachmentBeginInfo*)pNext, "VkRenderPassAttachmentBeginInfo",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
                print_VkPhysicalDeviceTextureCompressionASTCHDRFeatures((VkPhysicalDeviceTextureCompressionASTCHDRFeatures*)pNext,
                                                                        "VkPhysicalDeviceTextureCompressionASTCHDRFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
                print_VkPhysicalDeviceCooperativeMatrixFeaturesNV((VkPhysicalDeviceCooperativeMatrixFeaturesNV*)pNext,
                                                                  "VkPhysicalDeviceCooperativeMatrixFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
                print_VkPhysicalDeviceCooperativeMatrixPropertiesNV((VkPhysicalDeviceCooperativeMatrixPropertiesNV*)pNext,
                                                                    "VkPhysicalDeviceCooperativeMatrixPropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
                print_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT((VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*)pNext,
                                                                  "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
                print_VkPipelineCreationFeedbackCreateInfo((VkPipelineCreationFeedbackCreateInfo*)pNext,
                                                           "VkPipelineCreationFeedbackCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
                print_VkPhysicalDevicePresentBarrierFeaturesNV((VkPhysicalDevicePresentBarrierFeaturesNV*)pNext,
                                                               "VkPhysicalDevicePresentBarrierFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV:
                print_VkSurfaceCapabilitiesPresentBarrierNV((VkSurfaceCapabilitiesPresentBarrierNV*)pNext,
                                                            "VkSurfaceCapabilitiesPresentBarrierNV", true);
                break;
            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV:
                print_VkSwapchainPresentBarrierCreateInfoNV((VkSwapchainPresentBarrierCreateInfoNV*)pNext,
                                                            "VkSwapchainPresentBarrierCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
                print_VkPhysicalDevicePerformanceQueryFeaturesKHR((VkPhysicalDevicePerformanceQueryFeaturesKHR*)pNext,
                                                                  "VkPhysicalDevicePerformanceQueryFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
                print_VkPhysicalDevicePerformanceQueryPropertiesKHR((VkPhysicalDevicePerformanceQueryPropertiesKHR*)pNext,
                                                                    "VkPhysicalDevicePerformanceQueryPropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
                print_VkQueryPoolPerformanceCreateInfoKHR((VkQueryPoolPerformanceCreateInfoKHR*)pNext,
                                                          "VkQueryPoolPerformanceCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
                print_VkPerformanceQuerySubmitInfoKHR((VkPerformanceQuerySubmitInfoKHR*)pNext, "VkPerformanceQuerySubmitInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
                print_VkPhysicalDeviceCoverageReductionModeFeaturesNV((VkPhysicalDeviceCoverageReductionModeFeaturesNV*)pNext,
                                                                      "VkPhysicalDeviceCoverageReductionModeFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
                print_VkPipelineCoverageReductionStateCreateInfoNV((VkPipelineCoverageReductionStateCreateInfoNV*)pNext,
                                                                   "VkPipelineCoverageReductionStateCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
                print_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
                    (VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*)pNext,
                    "VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL", true);
                break;
            case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
                print_VkQueryPoolPerformanceQueryCreateInfoINTEL((VkQueryPoolPerformanceQueryCreateInfoINTEL*)pNext,
                                                                 "VkQueryPoolPerformanceQueryCreateInfoINTEL", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
                print_VkPhysicalDeviceShaderClockFeaturesKHR((VkPhysicalDeviceShaderClockFeaturesKHR*)pNext,
                                                             "VkPhysicalDeviceShaderClockFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES:
                print_VkPhysicalDeviceIndexTypeUint8Features((VkPhysicalDeviceIndexTypeUint8Features*)pNext,
                                                             "VkPhysicalDeviceIndexTypeUint8Features", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
                print_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV((VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*)pNext,
                                                                   "VkPhysicalDeviceShaderSMBuiltinsPropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
                print_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV((VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*)pNext,
                                                                 "VkPhysicalDeviceShaderSMBuiltinsFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
                print_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT((VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*)pNext,
                                                                         "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
                print_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
                    (VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*)pNext,
                    "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
                print_VkAttachmentReferenceStencilLayout((VkAttachmentReferenceStencilLayout*)pNext,
                                                         "VkAttachmentReferenceStencilLayout", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
                print_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(
                    (VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*)pNext,
                    "VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
                print_VkAttachmentDescriptionStencilLayout((VkAttachmentDescriptionStencilLayout*)pNext,
                                                           "VkAttachmentDescriptionStencilLayout", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
                print_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
                    (VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*)pNext,
                    "VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
                print_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(
                    (VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*)pNext,
                    "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
                print_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT((VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*)pNext,
                                                                      "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
                print_VkPhysicalDeviceTexelBufferAlignmentProperties((VkPhysicalDeviceTexelBufferAlignmentProperties*)pNext,
                                                                     "VkPhysicalDeviceTexelBufferAlignmentProperties", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
                print_VkPhysicalDeviceSubgroupSizeControlFeatures((VkPhysicalDeviceSubgroupSizeControlFeatures*)pNext,
                                                                  "VkPhysicalDeviceSubgroupSizeControlFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
                print_VkPhysicalDeviceSubgroupSizeControlProperties((VkPhysicalDeviceSubgroupSizeControlProperties*)pNext,
                                                                    "VkPhysicalDeviceSubgroupSizeControlProperties", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
                print_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(
                    (VkPipelineShaderStageRequiredSubgroupSizeCreateInfo*)pNext,
                    "VkPipelineShaderStageRequiredSubgroupSizeCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI:
                print_VkSubpassShadingPipelineCreateInfoHUAWEI((VkSubpassShadingPipelineCreateInfoHUAWEI*)pNext,
                                                               "VkSubpassShadingPipelineCreateInfoHUAWEI", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI:
                print_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI((VkPhysicalDeviceSubpassShadingPropertiesHUAWEI*)pNext,
                                                                     "VkPhysicalDeviceSubpassShadingPropertiesHUAWEI", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI:
                print_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(
                    (VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI*)pNext,
                    "VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI", true);
                break;
            case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
                print_VkMemoryOpaqueCaptureAddressAllocateInfo((VkMemoryOpaqueCaptureAddressAllocateInfo*)pNext,
                                                               "VkMemoryOpaqueCaptureAddressAllocateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES:
                print_VkPhysicalDeviceLineRasterizationFeatures((VkPhysicalDeviceLineRasterizationFeatures*)pNext,
                                                                "VkPhysicalDeviceLineRasterizationFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES:
                print_VkPhysicalDeviceLineRasterizationProperties((VkPhysicalDeviceLineRasterizationProperties*)pNext,
                                                                  "VkPhysicalDeviceLineRasterizationProperties", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO:
                print_VkPipelineRasterizationLineStateCreateInfo((VkPipelineRasterizationLineStateCreateInfo*)pNext,
                                                                 "VkPipelineRasterizationLineStateCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
                print_VkPhysicalDevicePipelineCreationCacheControlFeatures(
                    (VkPhysicalDevicePipelineCreationCacheControlFeatures*)pNext,
                    "VkPhysicalDevicePipelineCreationCacheControlFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
                print_VkPhysicalDeviceVulkan11Features((VkPhysicalDeviceVulkan11Features*)pNext, "VkPhysicalDeviceVulkan11Features",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
                print_VkPhysicalDeviceVulkan11Properties((VkPhysicalDeviceVulkan11Properties*)pNext,
                                                         "VkPhysicalDeviceVulkan11Properties", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
                print_VkPhysicalDeviceVulkan12Features((VkPhysicalDeviceVulkan12Features*)pNext, "VkPhysicalDeviceVulkan12Features",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
                print_VkPhysicalDeviceVulkan12Properties((VkPhysicalDeviceVulkan12Properties*)pNext,
                                                         "VkPhysicalDeviceVulkan12Properties", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
                print_VkPipelineCompilerControlCreateInfoAMD((VkPipelineCompilerControlCreateInfoAMD*)pNext,
                                                             "VkPipelineCompilerControlCreateInfoAMD", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
                print_VkPhysicalDeviceCoherentMemoryFeaturesAMD((VkPhysicalDeviceCoherentMemoryFeaturesAMD*)pNext,
                                                                "VkPhysicalDeviceCoherentMemoryFeaturesAMD", true);
                break;
            case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
                print_VkSamplerCustomBorderColorCreateInfoEXT((VkSamplerCustomBorderColorCreateInfoEXT*)pNext,
                                                              "VkSamplerCustomBorderColorCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
                print_VkPhysicalDeviceCustomBorderColorPropertiesEXT((VkPhysicalDeviceCustomBorderColorPropertiesEXT*)pNext,
                                                                     "VkPhysicalDeviceCustomBorderColorPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
                print_VkPhysicalDeviceCustomBorderColorFeaturesEXT((VkPhysicalDeviceCustomBorderColorFeaturesEXT*)pNext,
                                                                   "VkPhysicalDeviceCustomBorderColorFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
                print_VkSamplerBorderColorComponentMappingCreateInfoEXT((VkSamplerBorderColorComponentMappingCreateInfoEXT*)pNext,
                                                                        "VkSamplerBorderColorComponentMappingCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
                print_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT((VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*)pNext,
                                                                    "VkPhysicalDeviceBorderColorSwizzleFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV:
                print_VkAccelerationStructureGeometryLinearSweptSpheresDataNV(
                    (VkAccelerationStructureGeometryLinearSweptSpheresDataNV*)pNext,
                    "VkAccelerationStructureGeometryLinearSweptSpheresDataNV", true);
                break;
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV:
                print_VkAccelerationStructureGeometrySpheresDataNV((VkAccelerationStructureGeometrySpheresDataNV*)pNext,
                                                                   "VkAccelerationStructureGeometrySpheresDataNV", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
                print_VkPipelineLibraryCreateInfoKHR((VkPipelineLibraryCreateInfoKHR*)pNext, "VkPipelineLibraryCreateInfoKHR",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
                print_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT((VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*)pNext,
                                                                      "VkPhysicalDeviceExtendedDynamicStateFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
                print_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT((VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*)pNext,
                                                                       "VkPhysicalDeviceExtendedDynamicState2FeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
                print_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT((VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*)pNext,
                                                                       "VkPhysicalDeviceExtendedDynamicState3FeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT:
                print_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT((VkPhysicalDeviceExtendedDynamicState3PropertiesEXT*)pNext,
                                                                         "VkPhysicalDeviceExtendedDynamicState3PropertiesEXT",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
                print_VkRenderPassTransformBeginInfoQCOM((VkRenderPassTransformBeginInfoQCOM*)pNext,
                                                         "VkRenderPassTransformBeginInfoQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
                print_VkCopyCommandTransformInfoQCOM((VkCopyCommandTransformInfoQCOM*)pNext, "VkCopyCommandTransformInfoQCOM",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
                print_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
                    (VkCommandBufferInheritanceRenderPassTransformInfoQCOM*)pNext,
                    "VkCommandBufferInheritanceRenderPassTransformInfoQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV:
                print_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV(
                    (VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV*)pNext,
                    "VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV:
                print_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV(
                    (VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV*)pNext,
                    "VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV:
                print_VkPartitionedAccelerationStructureFlagsNV((VkPartitionedAccelerationStructureFlagsNV*)pNext,
                                                                "VkPartitionedAccelerationStructureFlagsNV", true);
                break;
            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV:
                print_VkWriteDescriptorSetPartitionedAccelerationStructureNV(
                    (VkWriteDescriptorSetPartitionedAccelerationStructureNV*)pNext,
                    "VkWriteDescriptorSetPartitionedAccelerationStructureNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
                print_VkPhysicalDeviceDiagnosticsConfigFeaturesNV((VkPhysicalDeviceDiagnosticsConfigFeaturesNV*)pNext,
                                                                  "VkPhysicalDeviceDiagnosticsConfigFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
                print_VkDeviceDiagnosticsConfigCreateInfoNV((VkDeviceDiagnosticsConfigCreateInfoNV*)pNext,
                                                            "VkDeviceDiagnosticsConfigCreateInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
                print_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(
                    (VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*)pNext,
                    "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
                print_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(
                    (VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*)pNext,
                    "VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
                print_VkPhysicalDeviceRobustness2FeaturesEXT((VkPhysicalDeviceRobustness2FeaturesEXT*)pNext,
                                                             "VkPhysicalDeviceRobustness2FeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
                print_VkPhysicalDeviceRobustness2PropertiesEXT((VkPhysicalDeviceRobustness2PropertiesEXT*)pNext,
                                                               "VkPhysicalDeviceRobustness2PropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
                print_VkPhysicalDeviceImageRobustnessFeatures((VkPhysicalDeviceImageRobustnessFeatures*)pNext,
                                                              "VkPhysicalDeviceImageRobustnessFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
                print_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(
                    (VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*)pNext,
                    "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
                print_VkPhysicalDevice4444FormatsFeaturesEXT((VkPhysicalDevice4444FormatsFeaturesEXT*)pNext,
                                                             "VkPhysicalDevice4444FormatsFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
                print_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI((VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*)pNext,
                                                                   "VkPhysicalDeviceSubpassShadingFeaturesHUAWEI", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
                print_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI((VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*)pNext,
                                                                         "VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI:
                print_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(
                    (VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI*)pNext,
                    "VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
                print_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT((VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*)pNext,
                                                                        "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
                print_VkFragmentShadingRateAttachmentInfoKHR((VkFragmentShadingRateAttachmentInfoKHR*)pNext,
                                                             "VkFragmentShadingRateAttachmentInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
                print_VkPipelineFragmentShadingRateStateCreateInfoKHR((VkPipelineFragmentShadingRateStateCreateInfoKHR*)pNext,
                                                                      "VkPipelineFragmentShadingRateStateCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
                print_VkPhysicalDeviceFragmentShadingRateFeaturesKHR((VkPhysicalDeviceFragmentShadingRateFeaturesKHR*)pNext,
                                                                     "VkPhysicalDeviceFragmentShadingRateFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
                print_VkPhysicalDeviceFragmentShadingRatePropertiesKHR((VkPhysicalDeviceFragmentShadingRatePropertiesKHR*)pNext,
                                                                       "VkPhysicalDeviceFragmentShadingRatePropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
                print_VkPhysicalDeviceShaderTerminateInvocationFeatures((VkPhysicalDeviceShaderTerminateInvocationFeatures*)pNext,
                                                                        "VkPhysicalDeviceShaderTerminateInvocationFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
                print_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV((VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*)pNext,
                                                                         "VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
                print_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
                    (VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*)pNext,
                    "VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
                print_VkPipelineFragmentShadingRateEnumStateCreateInfoNV((VkPipelineFragmentShadingRateEnumStateCreateInfoNV*)pNext,
                                                                         "VkPipelineFragmentShadingRateEnumStateCreateInfoNV",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
                print_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT((VkPhysicalDeviceImage2DViewOf3DFeaturesEXT*)pNext,
                                                                 "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
                print_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT((VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*)pNext,
                                                                     "VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
                print_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(
                    (VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*)pNext,
                    "VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT:
                print_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT((VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT*)pNext,
                                                                        "VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT:
                print_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(
                    (VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT*)pNext,
                    "VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
                print_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT((VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*)pNext,
                                                                       "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT:
                print_VkMutableDescriptorTypeCreateInfoEXT((VkMutableDescriptorTypeCreateInfoEXT*)pNext,
                                                           "VkMutableDescriptorTypeCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
                print_VkPhysicalDeviceDepthClipControlFeaturesEXT((VkPhysicalDeviceDepthClipControlFeaturesEXT*)pNext,
                                                                  "VkPhysicalDeviceDepthClipControlFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT:
                print_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT((VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT*)pNext,
                                                                         "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT:
                print_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(
                    (VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT*)pNext,
                    "VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT:
                print_VkGeneratedCommandsPipelineInfoEXT((VkGeneratedCommandsPipelineInfoEXT*)pNext,
                                                         "VkGeneratedCommandsPipelineInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT:
                print_VkGeneratedCommandsShaderInfoEXT((VkGeneratedCommandsShaderInfoEXT*)pNext, "VkGeneratedCommandsShaderInfoEXT",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT:
                print_VkPipelineViewportDepthClipControlCreateInfoEXT((VkPipelineViewportDepthClipControlCreateInfoEXT*)pNext,
                                                                      "VkPipelineViewportDepthClipControlCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT:
                print_VkPhysicalDeviceDepthClampControlFeaturesEXT((VkPhysicalDeviceDepthClampControlFeaturesEXT*)pNext,
                                                                   "VkPhysicalDeviceDepthClampControlFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT:
                print_VkPipelineViewportDepthClampControlCreateInfoEXT((VkPipelineViewportDepthClampControlCreateInfoEXT*)pNext,
                                                                       "VkPipelineViewportDepthClampControlCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
                print_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT((VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*)pNext,
                                                                         "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV:
                print_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV((VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*)pNext,
                                                                   "VkPhysicalDeviceExternalMemoryRDMAFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR:
                print_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(
                    (VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR*)pNext,
                    "VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
                print_VkPhysicalDeviceColorWriteEnableFeaturesEXT((VkPhysicalDeviceColorWriteEnableFeaturesEXT*)pNext,
                                                                  "VkPhysicalDeviceColorWriteEnableFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT:
                print_VkPipelineColorWriteCreateInfoEXT((VkPipelineColorWriteCreateInfoEXT*)pNext,
                                                        "VkPipelineColorWriteCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2:
                print_VkMemoryBarrier2((VkMemoryBarrier2*)pNext, "VkMemoryBarrier2", true);
                break;
            case VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR:
                print_VkMemoryBarrierAccessFlags3KHR((VkMemoryBarrierAccessFlags3KHR*)pNext, "VkMemoryBarrierAccessFlags3KHR",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
                print_VkQueueFamilyCheckpointProperties2NV((VkQueueFamilyCheckpointProperties2NV*)pNext,
                                                           "VkQueueFamilyCheckpointProperties2NV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
                print_VkPhysicalDeviceSynchronization2Features((VkPhysicalDeviceSynchronization2Features*)pNext,
                                                               "VkPhysicalDeviceSynchronization2Features", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES:
                print_VkPhysicalDeviceHostImageCopyFeatures((VkPhysicalDeviceHostImageCopyFeatures*)pNext,
                                                            "VkPhysicalDeviceHostImageCopyFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES:
                print_VkPhysicalDeviceHostImageCopyProperties((VkPhysicalDeviceHostImageCopyProperties*)pNext,
                                                              "VkPhysicalDeviceHostImageCopyProperties", true);
                break;
            case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE:
                print_VkSubresourceHostMemcpySize((VkSubresourceHostMemcpySize*)pNext, "VkSubresourceHostMemcpySize", true);
                break;
            case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY:
                print_VkHostImageCopyDevicePerformanceQuery((VkHostImageCopyDevicePerformanceQuery*)pNext,
                                                            "VkHostImageCopyDevicePerformanceQuery", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
                print_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(
                    (VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*)pNext,
                    "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
                print_VkPhysicalDeviceLegacyDitheringFeaturesEXT((VkPhysicalDeviceLegacyDitheringFeaturesEXT*)pNext,
                                                                 "VkPhysicalDeviceLegacyDitheringFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
                print_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(
                    (VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*)pNext,
                    "VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
                print_VkSubpassResolvePerformanceQueryEXT((VkSubpassResolvePerformanceQueryEXT*)pNext,
                                                          "VkSubpassResolvePerformanceQueryEXT", true);
                break;
            case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT:
                print_VkMultisampledRenderToSingleSampledInfoEXT((VkMultisampledRenderToSingleSampledInfoEXT*)pNext,
                                                                 "VkMultisampledRenderToSingleSampledInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES:
                print_VkPhysicalDevicePipelineProtectedAccessFeatures((VkPhysicalDevicePipelineProtectedAccessFeatures*)pNext,
                                                                      "VkPhysicalDevicePipelineProtectedAccessFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR:
                print_VkQueueFamilyVideoPropertiesKHR((VkQueueFamilyVideoPropertiesKHR*)pNext, "VkQueueFamilyVideoPropertiesKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR:
                print_VkQueueFamilyQueryResultStatusPropertiesKHR((VkQueueFamilyQueryResultStatusPropertiesKHR*)pNext,
                                                                  "VkQueueFamilyQueryResultStatusPropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
                print_VkVideoProfileListInfoKHR((VkVideoProfileListInfoKHR*)pNext, "VkVideoProfileListInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR:
                print_VkVideoEncodeQuantizationMapCapabilitiesKHR((VkVideoEncodeQuantizationMapCapabilitiesKHR*)pNext,
                                                                  "VkVideoEncodeQuantizationMapCapabilitiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR:
                print_VkVideoEncodeH264QuantizationMapCapabilitiesKHR((VkVideoEncodeH264QuantizationMapCapabilitiesKHR*)pNext,
                                                                      "VkVideoEncodeH264QuantizationMapCapabilitiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR:
                print_VkVideoEncodeH265QuantizationMapCapabilitiesKHR((VkVideoEncodeH265QuantizationMapCapabilitiesKHR*)pNext,
                                                                      "VkVideoEncodeH265QuantizationMapCapabilitiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR:
                print_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR((VkVideoEncodeAV1QuantizationMapCapabilitiesKHR*)pNext,
                                                                     "VkVideoEncodeAV1QuantizationMapCapabilitiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR:
                print_VkVideoFormatQuantizationMapPropertiesKHR((VkVideoFormatQuantizationMapPropertiesKHR*)pNext,
                                                                "VkVideoFormatQuantizationMapPropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR:
                print_VkVideoFormatH265QuantizationMapPropertiesKHR((VkVideoFormatH265QuantizationMapPropertiesKHR*)pNext,
                                                                    "VkVideoFormatH265QuantizationMapPropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR:
                print_VkVideoFormatAV1QuantizationMapPropertiesKHR((VkVideoFormatAV1QuantizationMapPropertiesKHR*)pNext,
                                                                   "VkVideoFormatAV1QuantizationMapPropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR:
                print_VkVideoProfileInfoKHR((VkVideoProfileInfoKHR*)pNext, "VkVideoProfileInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR:
                print_VkVideoDecodeCapabilitiesKHR((VkVideoDecodeCapabilitiesKHR*)pNext, "VkVideoDecodeCapabilitiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR:
                print_VkVideoDecodeUsageInfoKHR((VkVideoDecodeUsageInfoKHR*)pNext, "VkVideoDecodeUsageInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR:
                print_VkPhysicalDeviceVideoMaintenance1FeaturesKHR((VkPhysicalDeviceVideoMaintenance1FeaturesKHR*)pNext,
                                                                   "VkPhysicalDeviceVideoMaintenance1FeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR:
                print_VkPhysicalDeviceVideoMaintenance2FeaturesKHR((VkPhysicalDeviceVideoMaintenance2FeaturesKHR*)pNext,
                                                                   "VkPhysicalDeviceVideoMaintenance2FeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR:
                print_VkVideoInlineQueryInfoKHR((VkVideoInlineQueryInfoKHR*)pNext, "VkVideoInlineQueryInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR:
                print_VkVideoDecodeH264ProfileInfoKHR((VkVideoDecodeH264ProfileInfoKHR*)pNext, "VkVideoDecodeH264ProfileInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR:
                print_VkVideoDecodeH264CapabilitiesKHR((VkVideoDecodeH264CapabilitiesKHR*)pNext, "VkVideoDecodeH264CapabilitiesKHR",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
                print_VkVideoDecodeH264SessionParametersAddInfoKHR((VkVideoDecodeH264SessionParametersAddInfoKHR*)pNext,
                                                                   "VkVideoDecodeH264SessionParametersAddInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
                print_VkVideoDecodeH264SessionParametersCreateInfoKHR((VkVideoDecodeH264SessionParametersCreateInfoKHR*)pNext,
                                                                      "VkVideoDecodeH264SessionParametersCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR:
                print_VkVideoDecodeH264InlineSessionParametersInfoKHR((VkVideoDecodeH264InlineSessionParametersInfoKHR*)pNext,
                                                                      "VkVideoDecodeH264InlineSessionParametersInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR:
                print_VkVideoDecodeH264PictureInfoKHR((VkVideoDecodeH264PictureInfoKHR*)pNext, "VkVideoDecodeH264PictureInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR:
                print_VkVideoDecodeH264DpbSlotInfoKHR((VkVideoDecodeH264DpbSlotInfoKHR*)pNext, "VkVideoDecodeH264DpbSlotInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR:
                print_VkVideoDecodeH265ProfileInfoKHR((VkVideoDecodeH265ProfileInfoKHR*)pNext, "VkVideoDecodeH265ProfileInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR:
                print_VkVideoDecodeH265CapabilitiesKHR((VkVideoDecodeH265CapabilitiesKHR*)pNext, "VkVideoDecodeH265CapabilitiesKHR",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR:
                print_VkVideoDecodeH265SessionParametersAddInfoKHR((VkVideoDecodeH265SessionParametersAddInfoKHR*)pNext,
                                                                   "VkVideoDecodeH265SessionParametersAddInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR:
                print_VkVideoDecodeH265SessionParametersCreateInfoKHR((VkVideoDecodeH265SessionParametersCreateInfoKHR*)pNext,
                                                                      "VkVideoDecodeH265SessionParametersCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR:
                print_VkVideoDecodeH265InlineSessionParametersInfoKHR((VkVideoDecodeH265InlineSessionParametersInfoKHR*)pNext,
                                                                      "VkVideoDecodeH265InlineSessionParametersInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR:
                print_VkVideoDecodeH265PictureInfoKHR((VkVideoDecodeH265PictureInfoKHR*)pNext, "VkVideoDecodeH265PictureInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR:
                print_VkVideoDecodeH265DpbSlotInfoKHR((VkVideoDecodeH265DpbSlotInfoKHR*)pNext, "VkVideoDecodeH265DpbSlotInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR:
                print_VkVideoDecodeAV1ProfileInfoKHR((VkVideoDecodeAV1ProfileInfoKHR*)pNext, "VkVideoDecodeAV1ProfileInfoKHR",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR:
                print_VkVideoDecodeAV1CapabilitiesKHR((VkVideoDecodeAV1CapabilitiesKHR*)pNext, "VkVideoDecodeAV1CapabilitiesKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR:
                print_VkVideoDecodeAV1SessionParametersCreateInfoKHR((VkVideoDecodeAV1SessionParametersCreateInfoKHR*)pNext,
                                                                     "VkVideoDecodeAV1SessionParametersCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR:
                print_VkVideoDecodeAV1InlineSessionParametersInfoKHR((VkVideoDecodeAV1InlineSessionParametersInfoKHR*)pNext,
                                                                     "VkVideoDecodeAV1InlineSessionParametersInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR:
                print_VkVideoDecodeAV1PictureInfoKHR((VkVideoDecodeAV1PictureInfoKHR*)pNext, "VkVideoDecodeAV1PictureInfoKHR",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR:
                print_VkVideoDecodeAV1DpbSlotInfoKHR((VkVideoDecodeAV1DpbSlotInfoKHR*)pNext, "VkVideoDecodeAV1DpbSlotInfoKHR",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR:
                print_VkVideoEncodeUsageInfoKHR((VkVideoEncodeUsageInfoKHR*)pNext, "VkVideoEncodeUsageInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR:
                print_VkVideoEncodeQuantizationMapInfoKHR((VkVideoEncodeQuantizationMapInfoKHR*)pNext,
                                                          "VkVideoEncodeQuantizationMapInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR:
                print_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(
                    (VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR*)pNext,
                    "VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR:
                print_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(
                    (VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR*)pNext,
                    "VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR:
                print_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR((VkQueryPoolVideoEncodeFeedbackCreateInfoKHR*)pNext,
                                                                  "VkQueryPoolVideoEncodeFeedbackCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR:
                print_VkVideoEncodeQualityLevelInfoKHR((VkVideoEncodeQualityLevelInfoKHR*)pNext, "VkVideoEncodeQualityLevelInfoKHR",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR:
                print_VkVideoEncodeRateControlInfoKHR((VkVideoEncodeRateControlInfoKHR*)pNext, "VkVideoEncodeRateControlInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR:
                print_VkVideoEncodeCapabilitiesKHR((VkVideoEncodeCapabilitiesKHR*)pNext, "VkVideoEncodeCapabilitiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR:
                print_VkVideoEncodeH264CapabilitiesKHR((VkVideoEncodeH264CapabilitiesKHR*)pNext, "VkVideoEncodeH264CapabilitiesKHR",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR:
                print_VkVideoEncodeH264QualityLevelPropertiesKHR((VkVideoEncodeH264QualityLevelPropertiesKHR*)pNext,
                                                                 "VkVideoEncodeH264QualityLevelPropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR:
                print_VkVideoEncodeH264SessionCreateInfoKHR((VkVideoEncodeH264SessionCreateInfoKHR*)pNext,
                                                            "VkVideoEncodeH264SessionCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
                print_VkVideoEncodeH264SessionParametersAddInfoKHR((VkVideoEncodeH264SessionParametersAddInfoKHR*)pNext,
                                                                   "VkVideoEncodeH264SessionParametersAddInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
                print_VkVideoEncodeH264SessionParametersCreateInfoKHR((VkVideoEncodeH264SessionParametersCreateInfoKHR*)pNext,
                                                                      "VkVideoEncodeH264SessionParametersCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR:
                print_VkVideoEncodeH264SessionParametersGetInfoKHR((VkVideoEncodeH264SessionParametersGetInfoKHR*)pNext,
                                                                   "VkVideoEncodeH264SessionParametersGetInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR:
                print_VkVideoEncodeH264SessionParametersFeedbackInfoKHR((VkVideoEncodeH264SessionParametersFeedbackInfoKHR*)pNext,
                                                                        "VkVideoEncodeH264SessionParametersFeedbackInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR:
                print_VkVideoEncodeH264DpbSlotInfoKHR((VkVideoEncodeH264DpbSlotInfoKHR*)pNext, "VkVideoEncodeH264DpbSlotInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR:
                print_VkVideoEncodeH264PictureInfoKHR((VkVideoEncodeH264PictureInfoKHR*)pNext, "VkVideoEncodeH264PictureInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR:
                print_VkVideoEncodeH264ProfileInfoKHR((VkVideoEncodeH264ProfileInfoKHR*)pNext, "VkVideoEncodeH264ProfileInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR:
                print_VkVideoEncodeH264RateControlInfoKHR((VkVideoEncodeH264RateControlInfoKHR*)pNext,
                                                          "VkVideoEncodeH264RateControlInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR:
                print_VkVideoEncodeH264GopRemainingFrameInfoKHR((VkVideoEncodeH264GopRemainingFrameInfoKHR*)pNext,
                                                                "VkVideoEncodeH264GopRemainingFrameInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR:
                print_VkVideoEncodeH264RateControlLayerInfoKHR((VkVideoEncodeH264RateControlLayerInfoKHR*)pNext,
                                                               "VkVideoEncodeH264RateControlLayerInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR:
                print_VkVideoEncodeH265CapabilitiesKHR((VkVideoEncodeH265CapabilitiesKHR*)pNext, "VkVideoEncodeH265CapabilitiesKHR",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR:
                print_VkVideoEncodeH265QualityLevelPropertiesKHR((VkVideoEncodeH265QualityLevelPropertiesKHR*)pNext,
                                                                 "VkVideoEncodeH265QualityLevelPropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR:
                print_VkVideoEncodeH265SessionCreateInfoKHR((VkVideoEncodeH265SessionCreateInfoKHR*)pNext,
                                                            "VkVideoEncodeH265SessionCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR:
                print_VkVideoEncodeH265SessionParametersAddInfoKHR((VkVideoEncodeH265SessionParametersAddInfoKHR*)pNext,
                                                                   "VkVideoEncodeH265SessionParametersAddInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR:
                print_VkVideoEncodeH265SessionParametersCreateInfoKHR((VkVideoEncodeH265SessionParametersCreateInfoKHR*)pNext,
                                                                      "VkVideoEncodeH265SessionParametersCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR:
                print_VkVideoEncodeH265SessionParametersGetInfoKHR((VkVideoEncodeH265SessionParametersGetInfoKHR*)pNext,
                                                                   "VkVideoEncodeH265SessionParametersGetInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR:
                print_VkVideoEncodeH265SessionParametersFeedbackInfoKHR((VkVideoEncodeH265SessionParametersFeedbackInfoKHR*)pNext,
                                                                        "VkVideoEncodeH265SessionParametersFeedbackInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR:
                print_VkVideoEncodeH265PictureInfoKHR((VkVideoEncodeH265PictureInfoKHR*)pNext, "VkVideoEncodeH265PictureInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR:
                print_VkVideoEncodeH265RateControlInfoKHR((VkVideoEncodeH265RateControlInfoKHR*)pNext,
                                                          "VkVideoEncodeH265RateControlInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR:
                print_VkVideoEncodeH265GopRemainingFrameInfoKHR((VkVideoEncodeH265GopRemainingFrameInfoKHR*)pNext,
                                                                "VkVideoEncodeH265GopRemainingFrameInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR:
                print_VkVideoEncodeH265RateControlLayerInfoKHR((VkVideoEncodeH265RateControlLayerInfoKHR*)pNext,
                                                               "VkVideoEncodeH265RateControlLayerInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR:
                print_VkVideoEncodeH265ProfileInfoKHR((VkVideoEncodeH265ProfileInfoKHR*)pNext, "VkVideoEncodeH265ProfileInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR:
                print_VkVideoEncodeH265DpbSlotInfoKHR((VkVideoEncodeH265DpbSlotInfoKHR*)pNext, "VkVideoEncodeH265DpbSlotInfoKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR:
                print_VkVideoEncodeAV1CapabilitiesKHR((VkVideoEncodeAV1CapabilitiesKHR*)pNext, "VkVideoEncodeAV1CapabilitiesKHR",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR:
                print_VkVideoEncodeAV1QualityLevelPropertiesKHR((VkVideoEncodeAV1QualityLevelPropertiesKHR*)pNext,
                                                                "VkVideoEncodeAV1QualityLevelPropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR:
                print_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR((VkPhysicalDeviceVideoEncodeAV1FeaturesKHR*)pNext,
                                                                "VkPhysicalDeviceVideoEncodeAV1FeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR:
                print_VkVideoEncodeAV1SessionCreateInfoKHR((VkVideoEncodeAV1SessionCreateInfoKHR*)pNext,
                                                           "VkVideoEncodeAV1SessionCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR:
                print_VkVideoEncodeAV1SessionParametersCreateInfoKHR((VkVideoEncodeAV1SessionParametersCreateInfoKHR*)pNext,
                                                                     "VkVideoEncodeAV1SessionParametersCreateInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR:
                print_VkVideoEncodeAV1DpbSlotInfoKHR((VkVideoEncodeAV1DpbSlotInfoKHR*)pNext, "VkVideoEncodeAV1DpbSlotInfoKHR",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR:
                print_VkVideoEncodeAV1PictureInfoKHR((VkVideoEncodeAV1PictureInfoKHR*)pNext, "VkVideoEncodeAV1PictureInfoKHR",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR:
                print_VkVideoEncodeAV1ProfileInfoKHR((VkVideoEncodeAV1ProfileInfoKHR*)pNext, "VkVideoEncodeAV1ProfileInfoKHR",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR:
                print_VkVideoEncodeAV1RateControlInfoKHR((VkVideoEncodeAV1RateControlInfoKHR*)pNext,
                                                         "VkVideoEncodeAV1RateControlInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR:
                print_VkVideoEncodeAV1GopRemainingFrameInfoKHR((VkVideoEncodeAV1GopRemainingFrameInfoKHR*)pNext,
                                                               "VkVideoEncodeAV1GopRemainingFrameInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR:
                print_VkVideoEncodeAV1RateControlLayerInfoKHR((VkVideoEncodeAV1RateControlLayerInfoKHR*)pNext,
                                                              "VkVideoEncodeAV1RateControlLayerInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
                print_VkPhysicalDeviceInheritedViewportScissorFeaturesNV((VkPhysicalDeviceInheritedViewportScissorFeaturesNV*)pNext,
                                                                         "VkPhysicalDeviceInheritedViewportScissorFeaturesNV",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
                print_VkCommandBufferInheritanceViewportScissorInfoNV((VkCommandBufferInheritanceViewportScissorInfoNV*)pNext,
                                                                      "VkCommandBufferInheritanceViewportScissorInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
                print_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT((VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*)pNext,
                                                                       "VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
                print_VkPhysicalDeviceProvokingVertexFeaturesEXT((VkPhysicalDeviceProvokingVertexFeaturesEXT*)pNext,
                                                                 "VkPhysicalDeviceProvokingVertexFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
                print_VkPhysicalDeviceProvokingVertexPropertiesEXT((VkPhysicalDeviceProvokingVertexPropertiesEXT*)pNext,
                                                                   "VkPhysicalDeviceProvokingVertexPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT:
                print_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
                    (VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*)pNext,
                    "VkPipelineRasterizationProvokingVertexStateCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX:
                print_VkCuModuleTexturingModeCreateInfoNVX((VkCuModuleTexturingModeCreateInfoNVX*)pNext,
                                                           "VkCuModuleTexturingModeCreateInfoNVX", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT:
                print_VkPhysicalDeviceDescriptorBufferFeaturesEXT((VkPhysicalDeviceDescriptorBufferFeaturesEXT*)pNext,
                                                                  "VkPhysicalDeviceDescriptorBufferFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT:
                print_VkPhysicalDeviceDescriptorBufferPropertiesEXT((VkPhysicalDeviceDescriptorBufferPropertiesEXT*)pNext,
                                                                    "VkPhysicalDeviceDescriptorBufferPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT:
                print_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(
                    (VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT*)pNext,
                    "VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT:
                print_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(
                    (VkDescriptorBufferBindingPushDescriptorBufferHandleEXT*)pNext,
                    "VkDescriptorBufferBindingPushDescriptorBufferHandleEXT", true);
                break;
            case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
                print_VkOpaqueCaptureDescriptorDataCreateInfoEXT((VkOpaqueCaptureDescriptorDataCreateInfoEXT*)pNext,
                                                                 "VkOpaqueCaptureDescriptorDataCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
                print_VkPhysicalDeviceShaderIntegerDotProductFeatures((VkPhysicalDeviceShaderIntegerDotProductFeatures*)pNext,
                                                                      "VkPhysicalDeviceShaderIntegerDotProductFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES:
                print_VkPhysicalDeviceShaderIntegerDotProductProperties((VkPhysicalDeviceShaderIntegerDotProductProperties*)pNext,
                                                                        "VkPhysicalDeviceShaderIntegerDotProductProperties", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT:
                print_VkPhysicalDeviceDrmPropertiesEXT((VkPhysicalDeviceDrmPropertiesEXT*)pNext, "VkPhysicalDeviceDrmPropertiesEXT",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
                print_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(
                    (VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*)pNext,
                    "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR:
                print_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(
                    (VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR*)pNext,
                    "VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
                print_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV((VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*)pNext,
                                                                     "VkPhysicalDeviceRayTracingMotionBlurFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV:
                print_VkPhysicalDeviceRayTracingValidationFeaturesNV((VkPhysicalDeviceRayTracingValidationFeaturesNV*)pNext,
                                                                     "VkPhysicalDeviceRayTracingValidationFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV:
                print_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV(
                    (VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV*)pNext,
                    "VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV:
                print_VkAccelerationStructureGeometryMotionTrianglesDataNV(
                    (VkAccelerationStructureGeometryMotionTrianglesDataNV*)pNext,
                    "VkAccelerationStructureGeometryMotionTrianglesDataNV", true);
                break;
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV:
                print_VkAccelerationStructureMotionInfoNV((VkAccelerationStructureMotionInfoNV*)pNext,
                                                          "VkAccelerationStructureMotionInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
                print_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT((VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*)pNext,
                                                                 "VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3:
                print_VkFormatProperties3((VkFormatProperties3*)pNext, "VkFormatProperties3", true);
                break;
            case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
                print_VkDrmFormatModifierPropertiesList2EXT((VkDrmFormatModifierPropertiesList2EXT*)pNext,
                                                            "VkDrmFormatModifierPropertiesList2EXT", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:
                print_VkPipelineRenderingCreateInfo((VkPipelineRenderingCreateInfo*)pNext, "VkPipelineRenderingCreateInfo", true);
                break;
            case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
                print_VkRenderingFragmentShadingRateAttachmentInfoKHR((VkRenderingFragmentShadingRateAttachmentInfoKHR*)pNext,
                                                                      "VkRenderingFragmentShadingRateAttachmentInfoKHR", true);
                break;
            case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT:
                print_VkRenderingFragmentDensityMapAttachmentInfoEXT((VkRenderingFragmentDensityMapAttachmentInfoEXT*)pNext,
                                                                     "VkRenderingFragmentDensityMapAttachmentInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
                print_VkPhysicalDeviceDynamicRenderingFeatures((VkPhysicalDeviceDynamicRenderingFeatures*)pNext,
                                                               "VkPhysicalDeviceDynamicRenderingFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
                print_VkCommandBufferInheritanceRenderingInfo((VkCommandBufferInheritanceRenderingInfo*)pNext,
                                                              "VkCommandBufferInheritanceRenderingInfo", true);
                break;
            case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
                print_VkAttachmentSampleCountInfoAMD((VkAttachmentSampleCountInfoAMD*)pNext, "VkAttachmentSampleCountInfoAMD",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
                print_VkMultiviewPerViewAttributesInfoNVX((VkMultiviewPerViewAttributesInfoNVX*)pNext,
                                                          "VkMultiviewPerViewAttributesInfoNVX", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
                print_VkPhysicalDeviceImageViewMinLodFeaturesEXT((VkPhysicalDeviceImageViewMinLodFeaturesEXT*)pNext,
                                                                 "VkPhysicalDeviceImageViewMinLodFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT:
                print_VkImageViewMinLodCreateInfoEXT((VkImageViewMinLodCreateInfoEXT*)pNext, "VkImageViewMinLodCreateInfoEXT",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
                print_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(
                    (VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*)pNext,
                    "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
                print_VkPhysicalDeviceLinearColorAttachmentFeaturesNV((VkPhysicalDeviceLinearColorAttachmentFeaturesNV*)pNext,
                                                                      "VkPhysicalDeviceLinearColorAttachmentFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
                print_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT((VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*)pNext,
                                                                         "VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR:
                print_VkPhysicalDevicePipelineBinaryFeaturesKHR((VkPhysicalDevicePipelineBinaryFeaturesKHR*)pNext,
                                                                "VkPhysicalDevicePipelineBinaryFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR:
                print_VkDevicePipelineBinaryInternalCacheControlKHR((VkDevicePipelineBinaryInternalCacheControlKHR*)pNext,
                                                                    "VkDevicePipelineBinaryInternalCacheControlKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR:
                print_VkPhysicalDevicePipelineBinaryPropertiesKHR((VkPhysicalDevicePipelineBinaryPropertiesKHR*)pNext,
                                                                  "VkPhysicalDevicePipelineBinaryPropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT:
                print_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(
                    (VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*)pNext,
                    "VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT:
                print_VkGraphicsPipelineLibraryCreateInfoEXT((VkGraphicsPipelineLibraryCreateInfoEXT*)pNext,
                                                             "VkGraphicsPipelineLibraryCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
                print_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(
                    (VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*)pNext,
                    "VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT:
                print_VkPhysicalDeviceNestedCommandBufferFeaturesEXT((VkPhysicalDeviceNestedCommandBufferFeaturesEXT*)pNext,
                                                                     "VkPhysicalDeviceNestedCommandBufferFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT:
                print_VkPhysicalDeviceNestedCommandBufferPropertiesEXT((VkPhysicalDeviceNestedCommandBufferPropertiesEXT*)pNext,
                                                                       "VkPhysicalDeviceNestedCommandBufferPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
                print_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT((VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*)pNext,
                                                                        "VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT:
                print_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(
                    (VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT*)pNext,
                    "VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT:
                print_VkPipelineShaderStageModuleIdentifierCreateInfoEXT((VkPipelineShaderStageModuleIdentifierCreateInfoEXT*)pNext,
                                                                         "VkPipelineShaderStageModuleIdentifierCreateInfoEXT",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
                print_VkImageCompressionControlEXT((VkImageCompressionControlEXT*)pNext, "VkImageCompressionControlEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
                print_VkPhysicalDeviceImageCompressionControlFeaturesEXT((VkPhysicalDeviceImageCompressionControlFeaturesEXT*)pNext,
                                                                         "VkPhysicalDeviceImageCompressionControlFeaturesEXT",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
                print_VkImageCompressionPropertiesEXT((VkImageCompressionPropertiesEXT*)pNext, "VkImageCompressionPropertiesEXT",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
                print_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(
                    (VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*)pNext,
                    "VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT:
                print_VkRenderPassCreationControlEXT((VkRenderPassCreationControlEXT*)pNext, "VkRenderPassCreationControlEXT",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT:
                print_VkRenderPassCreationFeedbackCreateInfoEXT((VkRenderPassCreationFeedbackCreateInfoEXT*)pNext,
                                                                "VkRenderPassCreationFeedbackCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT:
                print_VkRenderPassSubpassFeedbackCreateInfoEXT((VkRenderPassSubpassFeedbackCreateInfoEXT*)pNext,
                                                               "VkRenderPassSubpassFeedbackCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
                print_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT((VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*)pNext,
                                                                      "VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
                print_VkPhysicalDeviceOpacityMicromapFeaturesEXT((VkPhysicalDeviceOpacityMicromapFeaturesEXT*)pNext,
                                                                 "VkPhysicalDeviceOpacityMicromapFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT:
                print_VkPhysicalDeviceOpacityMicromapPropertiesEXT((VkPhysicalDeviceOpacityMicromapPropertiesEXT*)pNext,
                                                                   "VkPhysicalDeviceOpacityMicromapPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT:
                print_VkAccelerationStructureTrianglesOpacityMicromapEXT((VkAccelerationStructureTrianglesOpacityMicromapEXT*)pNext,
                                                                         "VkAccelerationStructureTrianglesOpacityMicromapEXT",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
                print_VkPhysicalDevicePipelinePropertiesFeaturesEXT((VkPhysicalDevicePipelinePropertiesFeaturesEXT*)pNext,
                                                                    "VkPhysicalDevicePipelinePropertiesFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
                print_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(
                    (VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*)pNext,
                    "VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD", true);
                break;
            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
                print_VkExternalMemoryAcquireUnmodifiedEXT((VkExternalMemoryAcquireUnmodifiedEXT*)pNext,
                                                           "VkExternalMemoryAcquireUnmodifiedEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
                print_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT((VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*)pNext,
                                                                    "VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES:
                print_VkPhysicalDevicePipelineRobustnessFeatures((VkPhysicalDevicePipelineRobustnessFeatures*)pNext,
                                                                 "VkPhysicalDevicePipelineRobustnessFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO:
                print_VkPipelineRobustnessCreateInfo((VkPipelineRobustnessCreateInfo*)pNext, "VkPipelineRobustnessCreateInfo",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES:
                print_VkPhysicalDevicePipelineRobustnessProperties((VkPhysicalDevicePipelineRobustnessProperties*)pNext,
                                                                   "VkPhysicalDevicePipelineRobustnessProperties", true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM:
                print_VkImageViewSampleWeightCreateInfoQCOM((VkImageViewSampleWeightCreateInfoQCOM*)pNext,
                                                            "VkImageViewSampleWeightCreateInfoQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
                print_VkPhysicalDeviceImageProcessingFeaturesQCOM((VkPhysicalDeviceImageProcessingFeaturesQCOM*)pNext,
                                                                  "VkPhysicalDeviceImageProcessingFeaturesQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM:
                print_VkPhysicalDeviceImageProcessingPropertiesQCOM((VkPhysicalDeviceImageProcessingPropertiesQCOM*)pNext,
                                                                    "VkPhysicalDeviceImageProcessingPropertiesQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
                print_VkPhysicalDeviceTilePropertiesFeaturesQCOM((VkPhysicalDeviceTilePropertiesFeaturesQCOM*)pNext,
                                                                 "VkPhysicalDeviceTilePropertiesFeaturesQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC:
                print_VkPhysicalDeviceAmigoProfilingFeaturesSEC((VkPhysicalDeviceAmigoProfilingFeaturesSEC*)pNext,
                                                                "VkPhysicalDeviceAmigoProfilingFeaturesSEC", true);
                break;
            case VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC:
                print_VkAmigoProfilingSubmitInfoSEC((VkAmigoProfilingSubmitInfoSEC*)pNext, "VkAmigoProfilingSubmitInfoSEC", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
                print_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(
                    (VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*)pNext,
                    "VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
                print_VkPhysicalDeviceAddressBindingReportFeaturesEXT((VkPhysicalDeviceAddressBindingReportFeaturesEXT*)pNext,
                                                                      "VkPhysicalDeviceAddressBindingReportFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT:
                print_VkDeviceAddressBindingCallbackDataEXT((VkDeviceAddressBindingCallbackDataEXT*)pNext,
                                                            "VkDeviceAddressBindingCallbackDataEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
                print_VkPhysicalDeviceOpticalFlowFeaturesNV((VkPhysicalDeviceOpticalFlowFeaturesNV*)pNext,
                                                            "VkPhysicalDeviceOpticalFlowFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV:
                print_VkPhysicalDeviceOpticalFlowPropertiesNV((VkPhysicalDeviceOpticalFlowPropertiesNV*)pNext,
                                                              "VkPhysicalDeviceOpticalFlowPropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
                print_VkOpticalFlowImageFormatInfoNV((VkOpticalFlowImageFormatInfoNV*)pNext, "VkOpticalFlowImageFormatInfoNV",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV:
                print_VkOpticalFlowSessionCreatePrivateDataInfoNV((VkOpticalFlowSessionCreatePrivateDataInfoNV*)pNext,
                                                                  "VkOpticalFlowSessionCreatePrivateDataInfoNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
                print_VkPhysicalDeviceFaultFeaturesEXT((VkPhysicalDeviceFaultFeaturesEXT*)pNext, "VkPhysicalDeviceFaultFeaturesEXT",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
                print_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(
                    (VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*)pNext,
                    "VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT:
                print_VkDepthBiasRepresentationInfoEXT((VkDepthBiasRepresentationInfoEXT*)pNext, "VkDepthBiasRepresentationInfoEXT",
                                                       true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM:
                print_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM((VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM*)pNext,
                                                                      "VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
                print_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM((VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*)pNext,
                                                                    "VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM", true);
                break;
            case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
                print_VkFrameBoundaryEXT((VkFrameBoundaryEXT*)pNext, "VkFrameBoundaryEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
                print_VkPhysicalDeviceFrameBoundaryFeaturesEXT((VkPhysicalDeviceFrameBoundaryFeaturesEXT*)pNext,
                                                               "VkPhysicalDeviceFrameBoundaryFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
                print_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(
                    (VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*)pNext,
                    "VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT:
                print_VkSurfacePresentModeEXT((VkSurfacePresentModeEXT*)pNext, "VkSurfacePresentModeEXT", true);
                break;
            case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT:
                print_VkSurfacePresentScalingCapabilitiesEXT((VkSurfacePresentScalingCapabilitiesEXT*)pNext,
                                                             "VkSurfacePresentScalingCapabilitiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT:
                print_VkSurfacePresentModeCompatibilityEXT((VkSurfacePresentModeCompatibilityEXT*)pNext,
                                                           "VkSurfacePresentModeCompatibilityEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT:
                print_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT((VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*)pNext,
                                                                       "VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT:
                print_VkSwapchainPresentFenceInfoEXT((VkSwapchainPresentFenceInfoEXT*)pNext, "VkSwapchainPresentFenceInfoEXT",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT:
                print_VkSwapchainPresentModesCreateInfoEXT((VkSwapchainPresentModesCreateInfoEXT*)pNext,
                                                           "VkSwapchainPresentModesCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT:
                print_VkSwapchainPresentModeInfoEXT((VkSwapchainPresentModeInfoEXT*)pNext, "VkSwapchainPresentModeInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT:
                print_VkSwapchainPresentScalingCreateInfoEXT((VkSwapchainPresentScalingCreateInfoEXT*)pNext,
                                                             "VkSwapchainPresentScalingCreateInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
                print_VkPhysicalDeviceDepthBiasControlFeaturesEXT((VkPhysicalDeviceDepthBiasControlFeaturesEXT*)pNext,
                                                                  "VkPhysicalDeviceDepthBiasControlFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
                print_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(
                    (VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*)pNext,
                    "VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV:
                print_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(
                    (VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV*)pNext,
                    "VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV:
                print_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV(
                    (VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV*)pNext,
                    "VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV:
                print_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV(
                    (VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV*)pNext,
                    "VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG:
                print_VkDirectDriverLoadingListLUNARG((VkDirectDriverLoadingListLUNARG*)pNext, "VkDirectDriverLoadingListLUNARG",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
                print_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(
                    (VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*)pNext,
                    "VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
                print_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR((VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*)pNext,
                                                                         "VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM:
                print_VkPhysicalDeviceShaderCorePropertiesARM((VkPhysicalDeviceShaderCorePropertiesARM*)pNext,
                                                              "VkPhysicalDeviceShaderCorePropertiesARM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
                print_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(
                    (VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*)pNext,
                    "VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM:
                print_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(
                    (VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*)pNext,
                    "VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV:
                print_VkQueryLowLatencySupportNV((VkQueryLowLatencySupportNV*)pNext, "VkQueryLowLatencySupportNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
                print_VkPhysicalDeviceShaderObjectFeaturesEXT((VkPhysicalDeviceShaderObjectFeaturesEXT*)pNext,
                                                              "VkPhysicalDeviceShaderObjectFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT:
                print_VkPhysicalDeviceShaderObjectPropertiesEXT((VkPhysicalDeviceShaderObjectPropertiesEXT*)pNext,
                                                                "VkPhysicalDeviceShaderObjectPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
                print_VkPhysicalDeviceShaderTileImageFeaturesEXT((VkPhysicalDeviceShaderTileImageFeaturesEXT*)pNext,
                                                                 "VkPhysicalDeviceShaderTileImageFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT:
                print_VkPhysicalDeviceShaderTileImagePropertiesEXT((VkPhysicalDeviceShaderTileImagePropertiesEXT*)pNext,
                                                                   "VkPhysicalDeviceShaderTileImagePropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
                print_VkPhysicalDeviceCooperativeMatrixFeaturesKHR((VkPhysicalDeviceCooperativeMatrixFeaturesKHR*)pNext,
                                                                   "VkPhysicalDeviceCooperativeMatrixFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
                print_VkPhysicalDeviceCooperativeMatrixPropertiesKHR((VkPhysicalDeviceCooperativeMatrixPropertiesKHR*)pNext,
                                                                     "VkPhysicalDeviceCooperativeMatrixPropertiesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD:
                print_VkPhysicalDeviceAntiLagFeaturesAMD((VkPhysicalDeviceAntiLagFeaturesAMD*)pNext,
                                                         "VkPhysicalDeviceAntiLagFeaturesAMD", true);
                break;
            case VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS:
                print_VkBindMemoryStatus((VkBindMemoryStatus*)pNext, "VkBindMemoryStatus", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
                print_VkPhysicalDeviceCubicClampFeaturesQCOM((VkPhysicalDeviceCubicClampFeaturesQCOM*)pNext,
                                                             "VkPhysicalDeviceCubicClampFeaturesQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
                print_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM((VkPhysicalDeviceYcbcrDegammaFeaturesQCOM*)pNext,
                                                               "VkPhysicalDeviceYcbcrDegammaFeaturesQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM:
                print_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM((VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*)pNext,
                                                                         "VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
                print_VkPhysicalDeviceCubicWeightsFeaturesQCOM((VkPhysicalDeviceCubicWeightsFeaturesQCOM*)pNext,
                                                               "VkPhysicalDeviceCubicWeightsFeaturesQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM:
                print_VkSamplerCubicWeightsCreateInfoQCOM((VkSamplerCubicWeightsCreateInfoQCOM*)pNext,
                                                          "VkSamplerCubicWeightsCreateInfoQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM:
                print_VkBlitImageCubicWeightsInfoQCOM((VkBlitImageCubicWeightsInfoQCOM*)pNext, "VkBlitImageCubicWeightsInfoQCOM",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
                print_VkPhysicalDeviceImageProcessing2FeaturesQCOM((VkPhysicalDeviceImageProcessing2FeaturesQCOM*)pNext,
                                                                   "VkPhysicalDeviceImageProcessing2FeaturesQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM:
                print_VkPhysicalDeviceImageProcessing2PropertiesQCOM((VkPhysicalDeviceImageProcessing2PropertiesQCOM*)pNext,
                                                                     "VkPhysicalDeviceImageProcessing2PropertiesQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM:
                print_VkSamplerBlockMatchWindowCreateInfoQCOM((VkSamplerBlockMatchWindowCreateInfoQCOM*)pNext,
                                                              "VkSamplerBlockMatchWindowCreateInfoQCOM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
                print_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV(
                    (VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*)pNext,
                    "VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT:
                print_VkPhysicalDeviceLayeredDriverPropertiesMSFT((VkPhysicalDeviceLayeredDriverPropertiesMSFT*)pNext,
                                                                  "VkPhysicalDeviceLayeredDriverPropertiesMSFT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV:
                print_VkPhysicalDevicePerStageDescriptorSetFeaturesNV((VkPhysicalDevicePerStageDescriptorSetFeaturesNV*)pNext,
                                                                      "VkPhysicalDevicePerStageDescriptorSetFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
                print_VkLatencySubmissionPresentIdNV((VkLatencySubmissionPresentIdNV*)pNext, "VkLatencySubmissionPresentIdNV",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV:
                print_VkSwapchainLatencyCreateInfoNV((VkSwapchainLatencyCreateInfoNV*)pNext, "VkSwapchainLatencyCreateInfoNV",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV:
                print_VkLatencySurfaceCapabilitiesNV((VkLatencySurfaceCapabilitiesNV*)pNext, "VkLatencySurfaceCapabilitiesNV",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV:
                print_VkPhysicalDeviceCudaKernelLaunchFeaturesNV((VkPhysicalDeviceCudaKernelLaunchFeaturesNV*)pNext,
                                                                 "VkPhysicalDeviceCudaKernelLaunchFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV:
                print_VkPhysicalDeviceCudaKernelLaunchPropertiesNV((VkPhysicalDeviceCudaKernelLaunchPropertiesNV*)pNext,
                                                                   "VkPhysicalDeviceCudaKernelLaunchPropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM:
                print_VkDeviceQueueShaderCoreControlCreateInfoARM((VkDeviceQueueShaderCoreControlCreateInfoARM*)pNext,
                                                                  "VkDeviceQueueShaderCoreControlCreateInfoARM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM:
                print_VkPhysicalDeviceSchedulingControlsFeaturesARM((VkPhysicalDeviceSchedulingControlsFeaturesARM*)pNext,
                                                                    "VkPhysicalDeviceSchedulingControlsFeaturesARM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM:
                print_VkPhysicalDeviceSchedulingControlsPropertiesARM((VkPhysicalDeviceSchedulingControlsPropertiesARM*)pNext,
                                                                      "VkPhysicalDeviceSchedulingControlsPropertiesARM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG:
                print_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(
                    (VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG*)pNext,
                    "VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM:
                print_VkPhysicalDeviceRenderPassStripedFeaturesARM((VkPhysicalDeviceRenderPassStripedFeaturesARM*)pNext,
                                                                   "VkPhysicalDeviceRenderPassStripedFeaturesARM", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM:
                print_VkPhysicalDeviceRenderPassStripedPropertiesARM((VkPhysicalDeviceRenderPassStripedPropertiesARM*)pNext,
                                                                     "VkPhysicalDeviceRenderPassStripedPropertiesARM", true);
                break;
            case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM:
                print_VkRenderPassStripeBeginInfoARM((VkRenderPassStripeBeginInfoARM*)pNext, "VkRenderPassStripeBeginInfoARM",
                                                     true);
                break;
            case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM:
                print_VkRenderPassStripeSubmitInfoARM((VkRenderPassStripeSubmitInfoARM*)pNext, "VkRenderPassStripeSubmitInfoARM",
                                                      true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM:
                print_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM((VkPhysicalDevicePipelineOpacityMicromapFeaturesARM*)pNext,
                                                                         "VkPhysicalDevicePipelineOpacityMicromapFeaturesARM",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR:
                print_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(
                    (VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR*)pNext,
                    "VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES:
                print_VkPhysicalDeviceShaderSubgroupRotateFeatures((VkPhysicalDeviceShaderSubgroupRotateFeatures*)pNext,
                                                                   "VkPhysicalDeviceShaderSubgroupRotateFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES:
                print_VkPhysicalDeviceShaderExpectAssumeFeatures((VkPhysicalDeviceShaderExpectAssumeFeatures*)pNext,
                                                                 "VkPhysicalDeviceShaderExpectAssumeFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES:
                print_VkPhysicalDeviceShaderFloatControls2Features((VkPhysicalDeviceShaderFloatControls2Features*)pNext,
                                                                   "VkPhysicalDeviceShaderFloatControls2Features", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES:
                print_VkPhysicalDeviceDynamicRenderingLocalReadFeatures((VkPhysicalDeviceDynamicRenderingLocalReadFeatures*)pNext,
                                                                        "VkPhysicalDeviceDynamicRenderingLocalReadFeatures", true);
                break;
            case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO:
                print_VkRenderingAttachmentLocationInfo((VkRenderingAttachmentLocationInfo*)pNext,
                                                        "VkRenderingAttachmentLocationInfo", true);
                break;
            case VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO:
                print_VkRenderingInputAttachmentIndexInfo((VkRenderingInputAttachmentIndexInfo*)pNext,
                                                          "VkRenderingInputAttachmentIndexInfo", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR:
                print_VkPhysicalDeviceShaderQuadControlFeaturesKHR((VkPhysicalDeviceShaderQuadControlFeaturesKHR*)pNext,
                                                                   "VkPhysicalDeviceShaderQuadControlFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV:
                print_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV(
                    (VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV*)pNext,
                    "VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT:
                print_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT((VkPhysicalDeviceMapMemoryPlacedFeaturesEXT*)pNext,
                                                                 "VkPhysicalDeviceMapMemoryPlacedFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT:
                print_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT((VkPhysicalDeviceMapMemoryPlacedPropertiesEXT*)pNext,
                                                                   "VkPhysicalDeviceMapMemoryPlacedPropertiesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT:
                print_VkMemoryMapPlacedInfoEXT((VkMemoryMapPlacedInfoEXT*)pNext, "VkMemoryMapPlacedInfoEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV:
                print_VkPhysicalDeviceRawAccessChainsFeaturesNV((VkPhysicalDeviceRawAccessChainsFeaturesNV*)pNext,
                                                                "VkPhysicalDeviceRawAccessChainsFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV:
                print_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV((VkPhysicalDeviceCommandBufferInheritanceFeaturesNV*)pNext,
                                                                         "VkPhysicalDeviceCommandBufferInheritanceFeaturesNV",
                                                                         true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA:
                print_VkPhysicalDeviceImageAlignmentControlFeaturesMESA((VkPhysicalDeviceImageAlignmentControlFeaturesMESA*)pNext,
                                                                        "VkPhysicalDeviceImageAlignmentControlFeaturesMESA", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA:
                print_VkPhysicalDeviceImageAlignmentControlPropertiesMESA(
                    (VkPhysicalDeviceImageAlignmentControlPropertiesMESA*)pNext,
                    "VkPhysicalDeviceImageAlignmentControlPropertiesMESA", true);
                break;
            case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA:
                print_VkImageAlignmentControlCreateInfoMESA((VkImageAlignmentControlCreateInfoMESA*)pNext,
                                                            "VkImageAlignmentControlCreateInfoMESA", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT:
                print_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(
                    (VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT*)pNext,
                    "VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT:
                print_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT(
                    (VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT*)pNext,
                    "VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV:
                print_VkPhysicalDeviceCooperativeMatrix2FeaturesNV((VkPhysicalDeviceCooperativeMatrix2FeaturesNV*)pNext,
                                                                   "VkPhysicalDeviceCooperativeMatrix2FeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV:
                print_VkPhysicalDeviceCooperativeMatrix2PropertiesNV((VkPhysicalDeviceCooperativeMatrix2PropertiesNV*)pNext,
                                                                     "VkPhysicalDeviceCooperativeMatrix2PropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI:
                print_VkPhysicalDeviceHdrVividFeaturesHUAWEI((VkPhysicalDeviceHdrVividFeaturesHUAWEI*)pNext,
                                                             "VkPhysicalDeviceHdrVividFeaturesHUAWEI", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT:
                print_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(
                    (VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT*)pNext,
                    "VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR:
                print_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR((VkPhysicalDeviceDepthClampZeroOneFeaturesKHR*)pNext,
                                                                   "VkPhysicalDeviceDepthClampZeroOneFeaturesKHR", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV:
                print_VkPhysicalDeviceCooperativeVectorFeaturesNV((VkPhysicalDeviceCooperativeVectorFeaturesNV*)pNext,
                                                                  "VkPhysicalDeviceCooperativeVectorFeaturesNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV:
                print_VkPhysicalDeviceCooperativeVectorPropertiesNV((VkPhysicalDeviceCooperativeVectorPropertiesNV*)pNext,
                                                                    "VkPhysicalDeviceCooperativeVectorPropertiesNV", true);
                break;
            case VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV:
                print_VkSetPresentConfigNV((VkSetPresentConfigNV*)pNext, "VkSetPresentConfigNV", true);
                break;
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV:
                print_VkPhysicalDevicePresentMeteringFeaturesNV((VkPhysicalDevicePresentMeteringFeaturesNV*)pNext,
                                                                "VkPhysicalDevicePresentMeteringFeaturesNV", true);
                break;
            default:
                assert(false);  // No structure type matching
        }
    }
}

}  // End of namespace vk_json

#endif  // _VULKAN_JSON_DATA_HPP