
// *** THIS FILE IS GENERATED - DO NOT EDIT ***
// See json_parse_generator.py for modifications

/*
 * Copyright (c) 2024-2025 The Khronos Group Inc.
 * Copyright (c) 2024-2025 RasterGrid Kft.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#pragma once
// NOLINTBEGIN
#include <json/json.h>
#include <vulkan/vulkan.h>

#include <string>
#include <sstream>
#include <string_view>
#include <unordered_map>
#include <algorithm>
#include <limits>

#include "vksc_pipeline_json_base.hpp"

namespace pcjson {

class ParserBase : protected Base {
  private:
    VkShaderModule parse_VkShaderModule(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "") == 0) {
                return VK_NULL_HANDLE;
            } else {
                return reinterpret_cast<VkShaderModule>((void*)parse_string(json, l));
            }
        } else if (json.isUInt64()) {
            return VkShaderModule(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkShaderModule(0);
        }
    }

    VkPipelineLayout parse_VkPipelineLayout(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "") == 0) {
                return VK_NULL_HANDLE;
            } else {
                return reinterpret_cast<VkPipelineLayout>((void*)parse_string(json, l));
            }
        } else if (json.isUInt64()) {
            return VkPipelineLayout(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkPipelineLayout(0);
        }
    }

    VkRenderPass parse_VkRenderPass(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "") == 0) {
                return VK_NULL_HANDLE;
            } else {
                return reinterpret_cast<VkRenderPass>((void*)parse_string(json, l));
            }
        } else if (json.isUInt64()) {
            return VkRenderPass(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkRenderPass(0);
        }
    }

    VkPipeline parse_VkPipeline(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "") == 0) {
                return VK_NULL_HANDLE;
            } else {
                return reinterpret_cast<VkPipeline>((void*)parse_string(json, l));
            }
        } else if (json.isUInt64()) {
            return VkPipeline(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkPipeline(0);
        }
    }

    VkSamplerYcbcrConversion parse_VkSamplerYcbcrConversion(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "") == 0) {
                return VK_NULL_HANDLE;
            } else {
                return reinterpret_cast<VkSamplerYcbcrConversion>((void*)parse_string(json, l));
            }
        } else if (json.isUInt64()) {
            return VkSamplerYcbcrConversion(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkSamplerYcbcrConversion(0);
        }
    }

    VkSampler parse_VkSampler(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "") == 0) {
                return VK_NULL_HANDLE;
            } else {
                return reinterpret_cast<VkSampler>((void*)parse_string(json, l));
            }
        } else if (json.isUInt64()) {
            return VkSampler(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkSampler(0);
        }
    }

    VkDescriptorSetLayout parse_VkDescriptorSetLayout(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "") == 0) {
                return VK_NULL_HANDLE;
            } else {
                return reinterpret_cast<VkDescriptorSetLayout>((void*)parse_string(json, l));
            }
        } else if (json.isUInt64()) {
            return VkDescriptorSetLayout(parse_uint64_t(json, l));
        } else {
            Error() << "Invalid handle";
            return VkDescriptorSetLayout(0);
        }
    }

    VkStructureType parse_VkStructureType_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkStructureType> map = {
            std::make_pair("VK_STRUCTURE_TYPE_APPLICATION_INFO", VK_STRUCTURE_TYPE_APPLICATION_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO", VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO", VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO", VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SUBMIT_INFO", VK_STRUCTURE_TYPE_SUBMIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO", VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE", VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE),
            std::make_pair("VK_STRUCTURE_TYPE_FENCE_CREATE_INFO", VK_STRUCTURE_TYPE_FENCE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO", VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EVENT_CREATE_INFO", VK_STRUCTURE_TYPE_EVENT_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO", VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO", VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO", VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO", VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO", VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO", VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO", VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO", VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO", VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO",
                           VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO", VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO", VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET", VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET", VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET),
            std::make_pair("VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO", VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO", VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO", VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO", VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO", VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO", VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO", VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER", VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER", VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_BARRIER", VK_STRUCTURE_TYPE_MEMORY_BARRIER),
            std::make_pair("VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO", VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO", VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO", VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO", VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS", VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO", VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO", VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO",
                           VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO",
                           VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO", VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO",
                           VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO",
                           VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO", VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2",
                           VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2",
                           VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2", VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2", VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2", VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2),
            std::make_pair("VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2", VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2", VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2", VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO",
                           VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO", VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO",
                           VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO", VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2", VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO",
                           VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO", VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO", VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO",
                           VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES",
                           VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES",
                           VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES", VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES", VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO",
                           VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO", VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES", VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO", VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO", VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES", VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT", VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO", VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2", VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2),
            std::make_pair("VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2", VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2),
            std::make_pair("VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2", VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2),
            std::make_pair("VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2", VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2", VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO", VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SUBPASS_END_INFO", VK_STRUCTURE_TYPE_SUBPASS_END_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO",
                           VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO",
                           VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT",
                           VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE",
                           VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO", VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO",
                           VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO",
                           VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO",
                           VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT",
                           VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT),
            std::make_pair("VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT",
                           VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO", VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO", VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO", VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO", VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO", VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO",
                           VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO",
                           VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO",
                           VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES", VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO", VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO", VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_BARRIER_2", VK_STRUCTURE_TYPE_MEMORY_BARRIER_2),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR", VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2", VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR", VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2", VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR", VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DEPENDENCY_INFO", VK_STRUCTURE_TYPE_DEPENDENCY_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR", VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_SUBMIT_INFO_2", VK_STRUCTURE_TYPE_SUBMIT_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR", VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO", VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR", VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO", VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR", VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2", VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR", VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2", VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR", VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2", VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR", VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2", VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR", VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2", VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR", VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2", VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2),
            std::make_pair("VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR", VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_COPY_2", VK_STRUCTURE_TYPE_BUFFER_COPY_2),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR", VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_COPY_2", VK_STRUCTURE_TYPE_IMAGE_COPY_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR", VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_BLIT_2", VK_STRUCTURE_TYPE_IMAGE_BLIT_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR", VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2", VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR", VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2", VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR", VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK",
                           VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK),
            std::make_pair("VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO",
                           VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_RENDERING_INFO", VK_STRUCTURE_TYPE_RENDERING_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO", VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO", VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO",
                           VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3", VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS",
                           VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS",
                           VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO",
                           VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR",
                           VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES",
                           VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR",
                           VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR",
                           VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR",
                           VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_MAP_INFO", VK_STRUCTURE_TYPE_MEMORY_MAP_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO", VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_RENDERING_AREA_INFO", VK_STRUCTURE_TYPE_RENDERING_AREA_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO", VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2", VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2", VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO",
                           VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO",
                           VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO",
                           VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO",
                           VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS", VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO", VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO", VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO", VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO", VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY", VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY", VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO", VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO", VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO",
                           VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO", VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE", VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE),
            std::make_pair("VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY",
                           VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO",
                           VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO",
                           VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION", VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE", VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE),
            std::make_pair("VK_STRUCTURE_TYPE_FAULT_DATA", VK_STRUCTURE_TYPE_FAULT_DATA),
            std::make_pair("VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO", VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO", VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO),
            std::make_pair("VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR", VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PRESENT_INFO_KHR", VK_STRUCTURE_TYPE_PRESENT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR",
                           VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR", VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR",
                           VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR", VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR", VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR",
                           VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR", VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR", VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR", VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV",
                           VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT", VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR", VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR", VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR", VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR", VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR", VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR", VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT", VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT", VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT", VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT", VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_HDR_METADATA_EXT", VK_STRUCTURE_TYPE_HDR_METADATA_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR",
                           VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR", VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR", VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR",
                           VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR",
                           VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR", VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR", VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR",
                           VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR",
                           VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR", VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR", VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR", VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR", VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR", VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR", VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR",
                           VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT",
                           VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT", VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT", VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT",
                           VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT", VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT",
                           VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT", VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT",
                           VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT",
                           VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT",
                           VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR",
                           VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR",
                           VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR",
                           VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT", VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR", VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT",
                           VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT",
                           VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV", VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV", VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV", VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV", VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV",
                           VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV",
                           VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV", VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV", VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV", VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV", VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV", VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_BUF_FEATURES_NV",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_BUF_FEATURES_NV),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT",
                           VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT", VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV",
                           VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV",
                           VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV),
            std::make_pair("VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV",
                           VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV),
            std::make_pair("VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT", VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX", VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX),
            std::make_pair("VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX",
                           VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX),
            std::make_pair("VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX", VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX),
            std::make_pair("VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX", VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX),
            std::make_pair("VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR", VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR),
            std::make_pair("VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT",
                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT),
            std::make_pair("VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO", VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkStructureType constant: " << v;
            return static_cast<VkStructureType>(0);
        }
    }

    VkPipelineCreateFlagBits parse_VkPipelineCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkPipelineCreateFlagBits>(0)),
            std::make_pair("VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT", VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT),
            std::make_pair("VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT",
                           VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT),
            std::make_pair("VK_PIPELINE_CREATE_DISPATCH_BASE_BIT", VK_PIPELINE_CREATE_DISPATCH_BASE_BIT),
            std::make_pair("VK_PIPELINE_CREATE_DISPATCH_BASE", VK_PIPELINE_CREATE_DISPATCH_BASE),
            std::make_pair("VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT",
                           VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT),
            std::make_pair("VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT", VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT),
            std::make_pair("VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT", VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT),
            std::make_pair("VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT", VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineCreateFlagBits bit: " << v;
            return static_cast<VkPipelineCreateFlagBits>(0);
        }
    }

    VkPipelineShaderStageCreateFlagBits parse_VkPipelineShaderStageCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineShaderStageCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkPipelineShaderStageCreateFlagBits>(0)),
            std::make_pair("VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT",
                           VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT),
            std::make_pair("VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT",
                           VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT),
            std::make_pair("VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT",
                           VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT),
            std::make_pair("VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT",
                           VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineShaderStageCreateFlagBits bit: " << v;
            return static_cast<VkPipelineShaderStageCreateFlagBits>(0);
        }
    }

    VkShaderStageFlagBits parse_VkShaderStageFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkShaderStageFlagBits> map = {
            std::make_pair("0", static_cast<VkShaderStageFlagBits>(0)),
            std::make_pair("VK_SHADER_STAGE_VERTEX_BIT", VK_SHADER_STAGE_VERTEX_BIT),
            std::make_pair("VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT", VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT),
            std::make_pair("VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT", VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT),
            std::make_pair("VK_SHADER_STAGE_GEOMETRY_BIT", VK_SHADER_STAGE_GEOMETRY_BIT),
            std::make_pair("VK_SHADER_STAGE_FRAGMENT_BIT", VK_SHADER_STAGE_FRAGMENT_BIT),
            std::make_pair("VK_SHADER_STAGE_COMPUTE_BIT", VK_SHADER_STAGE_COMPUTE_BIT),
            std::make_pair("VK_SHADER_STAGE_ALL_GRAPHICS", VK_SHADER_STAGE_ALL_GRAPHICS),
            std::make_pair("VK_SHADER_STAGE_ALL", VK_SHADER_STAGE_ALL)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkShaderStageFlagBits bit: " << v;
            return static_cast<VkShaderStageFlagBits>(0);
        }
    }

    VkObjectType parse_VkObjectType_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkObjectType> map = {
            std::make_pair("VK_OBJECT_TYPE_UNKNOWN", VK_OBJECT_TYPE_UNKNOWN),
            std::make_pair("VK_OBJECT_TYPE_INSTANCE", VK_OBJECT_TYPE_INSTANCE),
            std::make_pair("VK_OBJECT_TYPE_PHYSICAL_DEVICE", VK_OBJECT_TYPE_PHYSICAL_DEVICE),
            std::make_pair("VK_OBJECT_TYPE_DEVICE", VK_OBJECT_TYPE_DEVICE),
            std::make_pair("VK_OBJECT_TYPE_QUEUE", VK_OBJECT_TYPE_QUEUE),
            std::make_pair("VK_OBJECT_TYPE_SEMAPHORE", VK_OBJECT_TYPE_SEMAPHORE),
            std::make_pair("VK_OBJECT_TYPE_COMMAND_BUFFER", VK_OBJECT_TYPE_COMMAND_BUFFER),
            std::make_pair("VK_OBJECT_TYPE_FENCE", VK_OBJECT_TYPE_FENCE),
            std::make_pair("VK_OBJECT_TYPE_DEVICE_MEMORY", VK_OBJECT_TYPE_DEVICE_MEMORY),
            std::make_pair("VK_OBJECT_TYPE_BUFFER", VK_OBJECT_TYPE_BUFFER),
            std::make_pair("VK_OBJECT_TYPE_IMAGE", VK_OBJECT_TYPE_IMAGE),
            std::make_pair("VK_OBJECT_TYPE_EVENT", VK_OBJECT_TYPE_EVENT),
            std::make_pair("VK_OBJECT_TYPE_QUERY_POOL", VK_OBJECT_TYPE_QUERY_POOL),
            std::make_pair("VK_OBJECT_TYPE_BUFFER_VIEW", VK_OBJECT_TYPE_BUFFER_VIEW),
            std::make_pair("VK_OBJECT_TYPE_IMAGE_VIEW", VK_OBJECT_TYPE_IMAGE_VIEW),
            std::make_pair("VK_OBJECT_TYPE_SHADER_MODULE", VK_OBJECT_TYPE_SHADER_MODULE),
            std::make_pair("VK_OBJECT_TYPE_PIPELINE_CACHE", VK_OBJECT_TYPE_PIPELINE_CACHE),
            std::make_pair("VK_OBJECT_TYPE_PIPELINE_LAYOUT", VK_OBJECT_TYPE_PIPELINE_LAYOUT),
            std::make_pair("VK_OBJECT_TYPE_RENDER_PASS", VK_OBJECT_TYPE_RENDER_PASS),
            std::make_pair("VK_OBJECT_TYPE_PIPELINE", VK_OBJECT_TYPE_PIPELINE),
            std::make_pair("VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT", VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT),
            std::make_pair("VK_OBJECT_TYPE_SAMPLER", VK_OBJECT_TYPE_SAMPLER),
            std::make_pair("VK_OBJECT_TYPE_DESCRIPTOR_POOL", VK_OBJECT_TYPE_DESCRIPTOR_POOL),
            std::make_pair("VK_OBJECT_TYPE_DESCRIPTOR_SET", VK_OBJECT_TYPE_DESCRIPTOR_SET),
            std::make_pair("VK_OBJECT_TYPE_FRAMEBUFFER", VK_OBJECT_TYPE_FRAMEBUFFER),
            std::make_pair("VK_OBJECT_TYPE_COMMAND_POOL", VK_OBJECT_TYPE_COMMAND_POOL),
            std::make_pair("VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION", VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION),
            std::make_pair("VK_OBJECT_TYPE_PRIVATE_DATA_SLOT", VK_OBJECT_TYPE_PRIVATE_DATA_SLOT),
            std::make_pair("VK_OBJECT_TYPE_SURFACE_KHR", VK_OBJECT_TYPE_SURFACE_KHR),
            std::make_pair("VK_OBJECT_TYPE_SWAPCHAIN_KHR", VK_OBJECT_TYPE_SWAPCHAIN_KHR),
            std::make_pair("VK_OBJECT_TYPE_DISPLAY_KHR", VK_OBJECT_TYPE_DISPLAY_KHR),
            std::make_pair("VK_OBJECT_TYPE_DISPLAY_MODE_KHR", VK_OBJECT_TYPE_DISPLAY_MODE_KHR),
            std::make_pair("VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT", VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT),
            std::make_pair("VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV", VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkObjectType constant: " << v;
            return static_cast<VkObjectType>(0);
        }
    }

    VkPipelineRobustnessBufferBehavior parse_VkPipelineRobustnessBufferBehavior_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineRobustnessBufferBehavior> map = {
            std::make_pair("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT",
                           VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT),
            std::make_pair("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED", VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED),
            std::make_pair("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS",
                           VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS),
            std::make_pair("VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2",
                           VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineRobustnessBufferBehavior constant: " << v;
            return static_cast<VkPipelineRobustnessBufferBehavior>(0);
        }
    }

    VkPipelineRobustnessImageBehavior parse_VkPipelineRobustnessImageBehavior_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineRobustnessImageBehavior> map = {
            std::make_pair("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT",
                           VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT),
            std::make_pair("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED", VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED),
            std::make_pair("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS",
                           VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS),
            std::make_pair("VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2",
                           VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineRobustnessImageBehavior constant: " << v;
            return static_cast<VkPipelineRobustnessImageBehavior>(0);
        }
    }

    VkVertexInputRate parse_VkVertexInputRate_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkVertexInputRate> map = {
            std::make_pair("VK_VERTEX_INPUT_RATE_VERTEX", VK_VERTEX_INPUT_RATE_VERTEX),
            std::make_pair("VK_VERTEX_INPUT_RATE_INSTANCE", VK_VERTEX_INPUT_RATE_INSTANCE)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkVertexInputRate constant: " << v;
            return static_cast<VkVertexInputRate>(0);
        }
    }

    VkFormat parse_VkFormat_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkFormat> map = {
            std::make_pair("VK_FORMAT_UNDEFINED", VK_FORMAT_UNDEFINED),
            std::make_pair("VK_FORMAT_R4G4_UNORM_PACK8", VK_FORMAT_R4G4_UNORM_PACK8),
            std::make_pair("VK_FORMAT_R4G4B4A4_UNORM_PACK16", VK_FORMAT_R4G4B4A4_UNORM_PACK16),
            std::make_pair("VK_FORMAT_B4G4R4A4_UNORM_PACK16", VK_FORMAT_B4G4R4A4_UNORM_PACK16),
            std::make_pair("VK_FORMAT_R5G6B5_UNORM_PACK16", VK_FORMAT_R5G6B5_UNORM_PACK16),
            std::make_pair("VK_FORMAT_B5G6R5_UNORM_PACK16", VK_FORMAT_B5G6R5_UNORM_PACK16),
            std::make_pair("VK_FORMAT_R5G5B5A1_UNORM_PACK16", VK_FORMAT_R5G5B5A1_UNORM_PACK16),
            std::make_pair("VK_FORMAT_B5G5R5A1_UNORM_PACK16", VK_FORMAT_B5G5R5A1_UNORM_PACK16),
            std::make_pair("VK_FORMAT_A1R5G5B5_UNORM_PACK16", VK_FORMAT_A1R5G5B5_UNORM_PACK16),
            std::make_pair("VK_FORMAT_R8_UNORM", VK_FORMAT_R8_UNORM),
            std::make_pair("VK_FORMAT_R8_SNORM", VK_FORMAT_R8_SNORM),
            std::make_pair("VK_FORMAT_R8_USCALED", VK_FORMAT_R8_USCALED),
            std::make_pair("VK_FORMAT_R8_SSCALED", VK_FORMAT_R8_SSCALED),
            std::make_pair("VK_FORMAT_R8_UINT", VK_FORMAT_R8_UINT),
            std::make_pair("VK_FORMAT_R8_SINT", VK_FORMAT_R8_SINT),
            std::make_pair("VK_FORMAT_R8_SRGB", VK_FORMAT_R8_SRGB),
            std::make_pair("VK_FORMAT_R8G8_UNORM", VK_FORMAT_R8G8_UNORM),
            std::make_pair("VK_FORMAT_R8G8_SNORM", VK_FORMAT_R8G8_SNORM),
            std::make_pair("VK_FORMAT_R8G8_USCALED", VK_FORMAT_R8G8_USCALED),
            std::make_pair("VK_FORMAT_R8G8_SSCALED", VK_FORMAT_R8G8_SSCALED),
            std::make_pair("VK_FORMAT_R8G8_UINT", VK_FORMAT_R8G8_UINT),
            std::make_pair("VK_FORMAT_R8G8_SINT", VK_FORMAT_R8G8_SINT),
            std::make_pair("VK_FORMAT_R8G8_SRGB", VK_FORMAT_R8G8_SRGB),
            std::make_pair("VK_FORMAT_R8G8B8_UNORM", VK_FORMAT_R8G8B8_UNORM),
            std::make_pair("VK_FORMAT_R8G8B8_SNORM", VK_FORMAT_R8G8B8_SNORM),
            std::make_pair("VK_FORMAT_R8G8B8_USCALED", VK_FORMAT_R8G8B8_USCALED),
            std::make_pair("VK_FORMAT_R8G8B8_SSCALED", VK_FORMAT_R8G8B8_SSCALED),
            std::make_pair("VK_FORMAT_R8G8B8_UINT", VK_FORMAT_R8G8B8_UINT),
            std::make_pair("VK_FORMAT_R8G8B8_SINT", VK_FORMAT_R8G8B8_SINT),
            std::make_pair("VK_FORMAT_R8G8B8_SRGB", VK_FORMAT_R8G8B8_SRGB),
            std::make_pair("VK_FORMAT_B8G8R8_UNORM", VK_FORMAT_B8G8R8_UNORM),
            std::make_pair("VK_FORMAT_B8G8R8_SNORM", VK_FORMAT_B8G8R8_SNORM),
            std::make_pair("VK_FORMAT_B8G8R8_USCALED", VK_FORMAT_B8G8R8_USCALED),
            std::make_pair("VK_FORMAT_B8G8R8_SSCALED", VK_FORMAT_B8G8R8_SSCALED),
            std::make_pair("VK_FORMAT_B8G8R8_UINT", VK_FORMAT_B8G8R8_UINT),
            std::make_pair("VK_FORMAT_B8G8R8_SINT", VK_FORMAT_B8G8R8_SINT),
            std::make_pair("VK_FORMAT_B8G8R8_SRGB", VK_FORMAT_B8G8R8_SRGB),
            std::make_pair("VK_FORMAT_R8G8B8A8_UNORM", VK_FORMAT_R8G8B8A8_UNORM),
            std::make_pair("VK_FORMAT_R8G8B8A8_SNORM", VK_FORMAT_R8G8B8A8_SNORM),
            std::make_pair("VK_FORMAT_R8G8B8A8_USCALED", VK_FORMAT_R8G8B8A8_USCALED),
            std::make_pair("VK_FORMAT_R8G8B8A8_SSCALED", VK_FORMAT_R8G8B8A8_SSCALED),
            std::make_pair("VK_FORMAT_R8G8B8A8_UINT", VK_FORMAT_R8G8B8A8_UINT),
            std::make_pair("VK_FORMAT_R8G8B8A8_SINT", VK_FORMAT_R8G8B8A8_SINT),
            std::make_pair("VK_FORMAT_R8G8B8A8_SRGB", VK_FORMAT_R8G8B8A8_SRGB),
            std::make_pair("VK_FORMAT_B8G8R8A8_UNORM", VK_FORMAT_B8G8R8A8_UNORM),
            std::make_pair("VK_FORMAT_B8G8R8A8_SNORM", VK_FORMAT_B8G8R8A8_SNORM),
            std::make_pair("VK_FORMAT_B8G8R8A8_USCALED", VK_FORMAT_B8G8R8A8_USCALED),
            std::make_pair("VK_FORMAT_B8G8R8A8_SSCALED", VK_FORMAT_B8G8R8A8_SSCALED),
            std::make_pair("VK_FORMAT_B8G8R8A8_UINT", VK_FORMAT_B8G8R8A8_UINT),
            std::make_pair("VK_FORMAT_B8G8R8A8_SINT", VK_FORMAT_B8G8R8A8_SINT),
            std::make_pair("VK_FORMAT_B8G8R8A8_SRGB", VK_FORMAT_B8G8R8A8_SRGB),
            std::make_pair("VK_FORMAT_A8B8G8R8_UNORM_PACK32", VK_FORMAT_A8B8G8R8_UNORM_PACK32),
            std::make_pair("VK_FORMAT_A8B8G8R8_SNORM_PACK32", VK_FORMAT_A8B8G8R8_SNORM_PACK32),
            std::make_pair("VK_FORMAT_A8B8G8R8_USCALED_PACK32", VK_FORMAT_A8B8G8R8_USCALED_PACK32),
            std::make_pair("VK_FORMAT_A8B8G8R8_SSCALED_PACK32", VK_FORMAT_A8B8G8R8_SSCALED_PACK32),
            std::make_pair("VK_FORMAT_A8B8G8R8_UINT_PACK32", VK_FORMAT_A8B8G8R8_UINT_PACK32),
            std::make_pair("VK_FORMAT_A8B8G8R8_SINT_PACK32", VK_FORMAT_A8B8G8R8_SINT_PACK32),
            std::make_pair("VK_FORMAT_A8B8G8R8_SRGB_PACK32", VK_FORMAT_A8B8G8R8_SRGB_PACK32),
            std::make_pair("VK_FORMAT_A2R10G10B10_UNORM_PACK32", VK_FORMAT_A2R10G10B10_UNORM_PACK32),
            std::make_pair("VK_FORMAT_A2R10G10B10_SNORM_PACK32", VK_FORMAT_A2R10G10B10_SNORM_PACK32),
            std::make_pair("VK_FORMAT_A2R10G10B10_USCALED_PACK32", VK_FORMAT_A2R10G10B10_USCALED_PACK32),
            std::make_pair("VK_FORMAT_A2R10G10B10_SSCALED_PACK32", VK_FORMAT_A2R10G10B10_SSCALED_PACK32),
            std::make_pair("VK_FORMAT_A2R10G10B10_UINT_PACK32", VK_FORMAT_A2R10G10B10_UINT_PACK32),
            std::make_pair("VK_FORMAT_A2R10G10B10_SINT_PACK32", VK_FORMAT_A2R10G10B10_SINT_PACK32),
            std::make_pair("VK_FORMAT_A2B10G10R10_UNORM_PACK32", VK_FORMAT_A2B10G10R10_UNORM_PACK32),
            std::make_pair("VK_FORMAT_A2B10G10R10_SNORM_PACK32", VK_FORMAT_A2B10G10R10_SNORM_PACK32),
            std::make_pair("VK_FORMAT_A2B10G10R10_USCALED_PACK32", VK_FORMAT_A2B10G10R10_USCALED_PACK32),
            std::make_pair("VK_FORMAT_A2B10G10R10_SSCALED_PACK32", VK_FORMAT_A2B10G10R10_SSCALED_PACK32),
            std::make_pair("VK_FORMAT_A2B10G10R10_UINT_PACK32", VK_FORMAT_A2B10G10R10_UINT_PACK32),
            std::make_pair("VK_FORMAT_A2B10G10R10_SINT_PACK32", VK_FORMAT_A2B10G10R10_SINT_PACK32),
            std::make_pair("VK_FORMAT_R16_UNORM", VK_FORMAT_R16_UNORM),
            std::make_pair("VK_FORMAT_R16_SNORM", VK_FORMAT_R16_SNORM),
            std::make_pair("VK_FORMAT_R16_USCALED", VK_FORMAT_R16_USCALED),
            std::make_pair("VK_FORMAT_R16_SSCALED", VK_FORMAT_R16_SSCALED),
            std::make_pair("VK_FORMAT_R16_UINT", VK_FORMAT_R16_UINT),
            std::make_pair("VK_FORMAT_R16_SINT", VK_FORMAT_R16_SINT),
            std::make_pair("VK_FORMAT_R16_SFLOAT", VK_FORMAT_R16_SFLOAT),
            std::make_pair("VK_FORMAT_R16G16_UNORM", VK_FORMAT_R16G16_UNORM),
            std::make_pair("VK_FORMAT_R16G16_SNORM", VK_FORMAT_R16G16_SNORM),
            std::make_pair("VK_FORMAT_R16G16_USCALED", VK_FORMAT_R16G16_USCALED),
            std::make_pair("VK_FORMAT_R16G16_SSCALED", VK_FORMAT_R16G16_SSCALED),
            std::make_pair("VK_FORMAT_R16G16_UINT", VK_FORMAT_R16G16_UINT),
            std::make_pair("VK_FORMAT_R16G16_SINT", VK_FORMAT_R16G16_SINT),
            std::make_pair("VK_FORMAT_R16G16_SFLOAT", VK_FORMAT_R16G16_SFLOAT),
            std::make_pair("VK_FORMAT_R16G16B16_UNORM", VK_FORMAT_R16G16B16_UNORM),
            std::make_pair("VK_FORMAT_R16G16B16_SNORM", VK_FORMAT_R16G16B16_SNORM),
            std::make_pair("VK_FORMAT_R16G16B16_USCALED", VK_FORMAT_R16G16B16_USCALED),
            std::make_pair("VK_FORMAT_R16G16B16_SSCALED", VK_FORMAT_R16G16B16_SSCALED),
            std::make_pair("VK_FORMAT_R16G16B16_UINT", VK_FORMAT_R16G16B16_UINT),
            std::make_pair("VK_FORMAT_R16G16B16_SINT", VK_FORMAT_R16G16B16_SINT),
            std::make_pair("VK_FORMAT_R16G16B16_SFLOAT", VK_FORMAT_R16G16B16_SFLOAT),
            std::make_pair("VK_FORMAT_R16G16B16A16_UNORM", VK_FORMAT_R16G16B16A16_UNORM),
            std::make_pair("VK_FORMAT_R16G16B16A16_SNORM", VK_FORMAT_R16G16B16A16_SNORM),
            std::make_pair("VK_FORMAT_R16G16B16A16_USCALED", VK_FORMAT_R16G16B16A16_USCALED),
            std::make_pair("VK_FORMAT_R16G16B16A16_SSCALED", VK_FORMAT_R16G16B16A16_SSCALED),
            std::make_pair("VK_FORMAT_R16G16B16A16_UINT", VK_FORMAT_R16G16B16A16_UINT),
            std::make_pair("VK_FORMAT_R16G16B16A16_SINT", VK_FORMAT_R16G16B16A16_SINT),
            std::make_pair("VK_FORMAT_R16G16B16A16_SFLOAT", VK_FORMAT_R16G16B16A16_SFLOAT),
            std::make_pair("VK_FORMAT_R32_UINT", VK_FORMAT_R32_UINT),
            std::make_pair("VK_FORMAT_R32_SINT", VK_FORMAT_R32_SINT),
            std::make_pair("VK_FORMAT_R32_SFLOAT", VK_FORMAT_R32_SFLOAT),
            std::make_pair("VK_FORMAT_R32G32_UINT", VK_FORMAT_R32G32_UINT),
            std::make_pair("VK_FORMAT_R32G32_SINT", VK_FORMAT_R32G32_SINT),
            std::make_pair("VK_FORMAT_R32G32_SFLOAT", VK_FORMAT_R32G32_SFLOAT),
            std::make_pair("VK_FORMAT_R32G32B32_UINT", VK_FORMAT_R32G32B32_UINT),
            std::make_pair("VK_FORMAT_R32G32B32_SINT", VK_FORMAT_R32G32B32_SINT),
            std::make_pair("VK_FORMAT_R32G32B32_SFLOAT", VK_FORMAT_R32G32B32_SFLOAT),
            std::make_pair("VK_FORMAT_R32G32B32A32_UINT", VK_FORMAT_R32G32B32A32_UINT),
            std::make_pair("VK_FORMAT_R32G32B32A32_SINT", VK_FORMAT_R32G32B32A32_SINT),
            std::make_pair("VK_FORMAT_R32G32B32A32_SFLOAT", VK_FORMAT_R32G32B32A32_SFLOAT),
            std::make_pair("VK_FORMAT_R64_UINT", VK_FORMAT_R64_UINT),
            std::make_pair("VK_FORMAT_R64_SINT", VK_FORMAT_R64_SINT),
            std::make_pair("VK_FORMAT_R64_SFLOAT", VK_FORMAT_R64_SFLOAT),
            std::make_pair("VK_FORMAT_R64G64_UINT", VK_FORMAT_R64G64_UINT),
            std::make_pair("VK_FORMAT_R64G64_SINT", VK_FORMAT_R64G64_SINT),
            std::make_pair("VK_FORMAT_R64G64_SFLOAT", VK_FORMAT_R64G64_SFLOAT),
            std::make_pair("VK_FORMAT_R64G64B64_UINT", VK_FORMAT_R64G64B64_UINT),
            std::make_pair("VK_FORMAT_R64G64B64_SINT", VK_FORMAT_R64G64B64_SINT),
            std::make_pair("VK_FORMAT_R64G64B64_SFLOAT", VK_FORMAT_R64G64B64_SFLOAT),
            std::make_pair("VK_FORMAT_R64G64B64A64_UINT", VK_FORMAT_R64G64B64A64_UINT),
            std::make_pair("VK_FORMAT_R64G64B64A64_SINT", VK_FORMAT_R64G64B64A64_SINT),
            std::make_pair("VK_FORMAT_R64G64B64A64_SFLOAT", VK_FORMAT_R64G64B64A64_SFLOAT),
            std::make_pair("VK_FORMAT_B10G11R11_UFLOAT_PACK32", VK_FORMAT_B10G11R11_UFLOAT_PACK32),
            std::make_pair("VK_FORMAT_E5B9G9R9_UFLOAT_PACK32", VK_FORMAT_E5B9G9R9_UFLOAT_PACK32),
            std::make_pair("VK_FORMAT_D16_UNORM", VK_FORMAT_D16_UNORM),
            std::make_pair("VK_FORMAT_X8_D24_UNORM_PACK32", VK_FORMAT_X8_D24_UNORM_PACK32),
            std::make_pair("VK_FORMAT_D32_SFLOAT", VK_FORMAT_D32_SFLOAT),
            std::make_pair("VK_FORMAT_S8_UINT", VK_FORMAT_S8_UINT),
            std::make_pair("VK_FORMAT_D16_UNORM_S8_UINT", VK_FORMAT_D16_UNORM_S8_UINT),
            std::make_pair("VK_FORMAT_D24_UNORM_S8_UINT", VK_FORMAT_D24_UNORM_S8_UINT),
            std::make_pair("VK_FORMAT_D32_SFLOAT_S8_UINT", VK_FORMAT_D32_SFLOAT_S8_UINT),
            std::make_pair("VK_FORMAT_BC1_RGB_UNORM_BLOCK", VK_FORMAT_BC1_RGB_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC1_RGB_SRGB_BLOCK", VK_FORMAT_BC1_RGB_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_BC1_RGBA_UNORM_BLOCK", VK_FORMAT_BC1_RGBA_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC1_RGBA_SRGB_BLOCK", VK_FORMAT_BC1_RGBA_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_BC2_UNORM_BLOCK", VK_FORMAT_BC2_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC2_SRGB_BLOCK", VK_FORMAT_BC2_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_BC3_UNORM_BLOCK", VK_FORMAT_BC3_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC3_SRGB_BLOCK", VK_FORMAT_BC3_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_BC4_UNORM_BLOCK", VK_FORMAT_BC4_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC4_SNORM_BLOCK", VK_FORMAT_BC4_SNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC5_UNORM_BLOCK", VK_FORMAT_BC5_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC5_SNORM_BLOCK", VK_FORMAT_BC5_SNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC6H_UFLOAT_BLOCK", VK_FORMAT_BC6H_UFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_BC6H_SFLOAT_BLOCK", VK_FORMAT_BC6H_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_BC7_UNORM_BLOCK", VK_FORMAT_BC7_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_BC7_SRGB_BLOCK", VK_FORMAT_BC7_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK", VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK", VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK", VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK", VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK", VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK", VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_EAC_R11_UNORM_BLOCK", VK_FORMAT_EAC_R11_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_EAC_R11_SNORM_BLOCK", VK_FORMAT_EAC_R11_SNORM_BLOCK),
            std::make_pair("VK_FORMAT_EAC_R11G11_UNORM_BLOCK", VK_FORMAT_EAC_R11G11_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_EAC_R11G11_SNORM_BLOCK", VK_FORMAT_EAC_R11G11_SNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_4x4_UNORM_BLOCK", VK_FORMAT_ASTC_4x4_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_4x4_SRGB_BLOCK", VK_FORMAT_ASTC_4x4_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_5x4_UNORM_BLOCK", VK_FORMAT_ASTC_5x4_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_5x4_SRGB_BLOCK", VK_FORMAT_ASTC_5x4_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_5x5_UNORM_BLOCK", VK_FORMAT_ASTC_5x5_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_5x5_SRGB_BLOCK", VK_FORMAT_ASTC_5x5_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_6x5_UNORM_BLOCK", VK_FORMAT_ASTC_6x5_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_6x5_SRGB_BLOCK", VK_FORMAT_ASTC_6x5_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_6x6_UNORM_BLOCK", VK_FORMAT_ASTC_6x6_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_6x6_SRGB_BLOCK", VK_FORMAT_ASTC_6x6_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x5_UNORM_BLOCK", VK_FORMAT_ASTC_8x5_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x5_SRGB_BLOCK", VK_FORMAT_ASTC_8x5_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x6_UNORM_BLOCK", VK_FORMAT_ASTC_8x6_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x6_SRGB_BLOCK", VK_FORMAT_ASTC_8x6_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x8_UNORM_BLOCK", VK_FORMAT_ASTC_8x8_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x8_SRGB_BLOCK", VK_FORMAT_ASTC_8x8_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x5_UNORM_BLOCK", VK_FORMAT_ASTC_10x5_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x5_SRGB_BLOCK", VK_FORMAT_ASTC_10x5_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x6_UNORM_BLOCK", VK_FORMAT_ASTC_10x6_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x6_SRGB_BLOCK", VK_FORMAT_ASTC_10x6_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x8_UNORM_BLOCK", VK_FORMAT_ASTC_10x8_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x8_SRGB_BLOCK", VK_FORMAT_ASTC_10x8_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x10_UNORM_BLOCK", VK_FORMAT_ASTC_10x10_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x10_SRGB_BLOCK", VK_FORMAT_ASTC_10x10_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_12x10_UNORM_BLOCK", VK_FORMAT_ASTC_12x10_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_12x10_SRGB_BLOCK", VK_FORMAT_ASTC_12x10_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_12x12_UNORM_BLOCK", VK_FORMAT_ASTC_12x12_UNORM_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_12x12_SRGB_BLOCK", VK_FORMAT_ASTC_12x12_SRGB_BLOCK),
            std::make_pair("VK_FORMAT_G8B8G8R8_422_UNORM", VK_FORMAT_G8B8G8R8_422_UNORM),
            std::make_pair("VK_FORMAT_B8G8R8G8_422_UNORM", VK_FORMAT_B8G8R8G8_422_UNORM),
            std::make_pair("VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM", VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM),
            std::make_pair("VK_FORMAT_G8_B8R8_2PLANE_420_UNORM", VK_FORMAT_G8_B8R8_2PLANE_420_UNORM),
            std::make_pair("VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM", VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM),
            std::make_pair("VK_FORMAT_G8_B8R8_2PLANE_422_UNORM", VK_FORMAT_G8_B8R8_2PLANE_422_UNORM),
            std::make_pair("VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM", VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM),
            std::make_pair("VK_FORMAT_R10X6_UNORM_PACK16", VK_FORMAT_R10X6_UNORM_PACK16),
            std::make_pair("VK_FORMAT_R10X6G10X6_UNORM_2PACK16", VK_FORMAT_R10X6G10X6_UNORM_2PACK16),
            std::make_pair("VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16", VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16),
            std::make_pair("VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16", VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16),
            std::make_pair("VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16", VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16),
            std::make_pair("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16",
                           VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16",
                           VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16",
                           VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16",
                           VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16",
                           VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_R12X4_UNORM_PACK16", VK_FORMAT_R12X4_UNORM_PACK16),
            std::make_pair("VK_FORMAT_R12X4G12X4_UNORM_2PACK16", VK_FORMAT_R12X4G12X4_UNORM_2PACK16),
            std::make_pair("VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16", VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16),
            std::make_pair("VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16", VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16),
            std::make_pair("VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16", VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16),
            std::make_pair("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16",
                           VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16",
                           VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16",
                           VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16",
                           VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16",
                           VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G16B16G16R16_422_UNORM", VK_FORMAT_G16B16G16R16_422_UNORM),
            std::make_pair("VK_FORMAT_B16G16R16G16_422_UNORM", VK_FORMAT_B16G16R16G16_422_UNORM),
            std::make_pair("VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM", VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM),
            std::make_pair("VK_FORMAT_G16_B16R16_2PLANE_420_UNORM", VK_FORMAT_G16_B16R16_2PLANE_420_UNORM),
            std::make_pair("VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM", VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM),
            std::make_pair("VK_FORMAT_G16_B16R16_2PLANE_422_UNORM", VK_FORMAT_G16_B16R16_2PLANE_422_UNORM),
            std::make_pair("VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM", VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM),
            std::make_pair("VK_FORMAT_G8_B8R8_2PLANE_444_UNORM", VK_FORMAT_G8_B8R8_2PLANE_444_UNORM),
            std::make_pair("VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT", VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT),
            std::make_pair("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16",
                           VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT",
                           VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT),
            std::make_pair("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16",
                           VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16),
            std::make_pair("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT",
                           VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT),
            std::make_pair("VK_FORMAT_G16_B16R16_2PLANE_444_UNORM", VK_FORMAT_G16_B16R16_2PLANE_444_UNORM),
            std::make_pair("VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT", VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT),
            std::make_pair("VK_FORMAT_A4R4G4B4_UNORM_PACK16", VK_FORMAT_A4R4G4B4_UNORM_PACK16),
            std::make_pair("VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT", VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT),
            std::make_pair("VK_FORMAT_A4B4G4R4_UNORM_PACK16", VK_FORMAT_A4B4G4R4_UNORM_PACK16),
            std::make_pair("VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT", VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT),
            std::make_pair("VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK", VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK", VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK", VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK", VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK", VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK", VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK", VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK", VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK", VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK", VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK", VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK", VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK", VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK", VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK),
            std::make_pair("VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT", VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT),
            std::make_pair("VK_FORMAT_A1B5G5R5_UNORM_PACK16", VK_FORMAT_A1B5G5R5_UNORM_PACK16),
            std::make_pair("VK_FORMAT_A8_UNORM", VK_FORMAT_A8_UNORM)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkFormat constant: " << v;
            return static_cast<VkFormat>(0);
        }
    }

    VkPrimitiveTopology parse_VkPrimitiveTopology_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPrimitiveTopology> map = {
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_POINT_LIST", VK_PRIMITIVE_TOPOLOGY_POINT_LIST),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_LINE_LIST", VK_PRIMITIVE_TOPOLOGY_LINE_LIST),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_LINE_STRIP", VK_PRIMITIVE_TOPOLOGY_LINE_STRIP),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST", VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP", VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN", VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY", VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY", VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY",
                           VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY",
                           VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY),
            std::make_pair("VK_PRIMITIVE_TOPOLOGY_PATCH_LIST", VK_PRIMITIVE_TOPOLOGY_PATCH_LIST)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPrimitiveTopology constant: " << v;
            return static_cast<VkPrimitiveTopology>(0);
        }
    }

    VkTessellationDomainOrigin parse_VkTessellationDomainOrigin_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkTessellationDomainOrigin> map = {
            std::make_pair("VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT", VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT),
            std::make_pair("VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT", VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkTessellationDomainOrigin constant: " << v;
            return static_cast<VkTessellationDomainOrigin>(0);
        }
    }

    VkPolygonMode parse_VkPolygonMode_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPolygonMode> map = {
            std::make_pair("VK_POLYGON_MODE_FILL", VK_POLYGON_MODE_FILL),
            std::make_pair("VK_POLYGON_MODE_LINE", VK_POLYGON_MODE_LINE),
            std::make_pair("VK_POLYGON_MODE_POINT", VK_POLYGON_MODE_POINT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPolygonMode constant: " << v;
            return static_cast<VkPolygonMode>(0);
        }
    }

    VkCullModeFlagBits parse_VkCullModeFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkCullModeFlagBits> map = {
            std::make_pair("0", static_cast<VkCullModeFlagBits>(0)), std::make_pair("VK_CULL_MODE_NONE", VK_CULL_MODE_NONE),
            std::make_pair("VK_CULL_MODE_FRONT_BIT", VK_CULL_MODE_FRONT_BIT),
            std::make_pair("VK_CULL_MODE_BACK_BIT", VK_CULL_MODE_BACK_BIT),
            std::make_pair("VK_CULL_MODE_FRONT_AND_BACK", VK_CULL_MODE_FRONT_AND_BACK)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkCullModeFlagBits bit: " << v;
            return static_cast<VkCullModeFlagBits>(0);
        }
    }

    VkFrontFace parse_VkFrontFace_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkFrontFace> map = {
            std::make_pair("VK_FRONT_FACE_COUNTER_CLOCKWISE", VK_FRONT_FACE_COUNTER_CLOCKWISE),
            std::make_pair("VK_FRONT_FACE_CLOCKWISE", VK_FRONT_FACE_CLOCKWISE)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkFrontFace constant: " << v;
            return static_cast<VkFrontFace>(0);
        }
    }

    VkConservativeRasterizationModeEXT parse_VkConservativeRasterizationModeEXT_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkConservativeRasterizationModeEXT> map = {
            std::make_pair("VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT),
            std::make_pair("VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT",
                           VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT),
            std::make_pair("VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT",
                           VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkConservativeRasterizationModeEXT constant: " << v;
            return static_cast<VkConservativeRasterizationModeEXT>(0);
        }
    }

    VkLineRasterizationMode parse_VkLineRasterizationMode_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkLineRasterizationMode> map = {
            std::make_pair("VK_LINE_RASTERIZATION_MODE_DEFAULT", VK_LINE_RASTERIZATION_MODE_DEFAULT),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT", VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR", VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_RECTANGULAR", VK_LINE_RASTERIZATION_MODE_RECTANGULAR),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT", VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR", VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_BRESENHAM", VK_LINE_RASTERIZATION_MODE_BRESENHAM),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT", VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR", VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH", VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT", VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT),
            std::make_pair("VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR", VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkLineRasterizationMode constant: " << v;
            return static_cast<VkLineRasterizationMode>(0);
        }
    }

    VkSampleCountFlagBits parse_VkSampleCountFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSampleCountFlagBits> map = {
            std::make_pair("0", static_cast<VkSampleCountFlagBits>(0)),
            std::make_pair("VK_SAMPLE_COUNT_1_BIT", VK_SAMPLE_COUNT_1_BIT),
            std::make_pair("VK_SAMPLE_COUNT_2_BIT", VK_SAMPLE_COUNT_2_BIT),
            std::make_pair("VK_SAMPLE_COUNT_4_BIT", VK_SAMPLE_COUNT_4_BIT),
            std::make_pair("VK_SAMPLE_COUNT_8_BIT", VK_SAMPLE_COUNT_8_BIT),
            std::make_pair("VK_SAMPLE_COUNT_16_BIT", VK_SAMPLE_COUNT_16_BIT),
            std::make_pair("VK_SAMPLE_COUNT_32_BIT", VK_SAMPLE_COUNT_32_BIT),
            std::make_pair("VK_SAMPLE_COUNT_64_BIT", VK_SAMPLE_COUNT_64_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSampleCountFlagBits bit: " << v;
            return static_cast<VkSampleCountFlagBits>(0);
        }
    }

    VkCompareOp parse_VkCompareOp_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkCompareOp> map = {
            std::make_pair("VK_COMPARE_OP_NEVER", VK_COMPARE_OP_NEVER),
            std::make_pair("VK_COMPARE_OP_LESS", VK_COMPARE_OP_LESS),
            std::make_pair("VK_COMPARE_OP_EQUAL", VK_COMPARE_OP_EQUAL),
            std::make_pair("VK_COMPARE_OP_LESS_OR_EQUAL", VK_COMPARE_OP_LESS_OR_EQUAL),
            std::make_pair("VK_COMPARE_OP_GREATER", VK_COMPARE_OP_GREATER),
            std::make_pair("VK_COMPARE_OP_NOT_EQUAL", VK_COMPARE_OP_NOT_EQUAL),
            std::make_pair("VK_COMPARE_OP_GREATER_OR_EQUAL", VK_COMPARE_OP_GREATER_OR_EQUAL),
            std::make_pair("VK_COMPARE_OP_ALWAYS", VK_COMPARE_OP_ALWAYS)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkCompareOp constant: " << v;
            return static_cast<VkCompareOp>(0);
        }
    }

    VkStencilOp parse_VkStencilOp_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkStencilOp> map = {
            std::make_pair("VK_STENCIL_OP_KEEP", VK_STENCIL_OP_KEEP),
            std::make_pair("VK_STENCIL_OP_ZERO", VK_STENCIL_OP_ZERO),
            std::make_pair("VK_STENCIL_OP_REPLACE", VK_STENCIL_OP_REPLACE),
            std::make_pair("VK_STENCIL_OP_INCREMENT_AND_CLAMP", VK_STENCIL_OP_INCREMENT_AND_CLAMP),
            std::make_pair("VK_STENCIL_OP_DECREMENT_AND_CLAMP", VK_STENCIL_OP_DECREMENT_AND_CLAMP),
            std::make_pair("VK_STENCIL_OP_INVERT", VK_STENCIL_OP_INVERT),
            std::make_pair("VK_STENCIL_OP_INCREMENT_AND_WRAP", VK_STENCIL_OP_INCREMENT_AND_WRAP),
            std::make_pair("VK_STENCIL_OP_DECREMENT_AND_WRAP", VK_STENCIL_OP_DECREMENT_AND_WRAP)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkStencilOp constant: " << v;
            return static_cast<VkStencilOp>(0);
        }
    }

    VkLogicOp parse_VkLogicOp_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkLogicOp> map = {
            std::make_pair("VK_LOGIC_OP_CLEAR", VK_LOGIC_OP_CLEAR),
            std::make_pair("VK_LOGIC_OP_AND", VK_LOGIC_OP_AND),
            std::make_pair("VK_LOGIC_OP_AND_REVERSE", VK_LOGIC_OP_AND_REVERSE),
            std::make_pair("VK_LOGIC_OP_COPY", VK_LOGIC_OP_COPY),
            std::make_pair("VK_LOGIC_OP_AND_INVERTED", VK_LOGIC_OP_AND_INVERTED),
            std::make_pair("VK_LOGIC_OP_NO_OP", VK_LOGIC_OP_NO_OP),
            std::make_pair("VK_LOGIC_OP_XOR", VK_LOGIC_OP_XOR),
            std::make_pair("VK_LOGIC_OP_OR", VK_LOGIC_OP_OR),
            std::make_pair("VK_LOGIC_OP_NOR", VK_LOGIC_OP_NOR),
            std::make_pair("VK_LOGIC_OP_EQUIVALENT", VK_LOGIC_OP_EQUIVALENT),
            std::make_pair("VK_LOGIC_OP_INVERT", VK_LOGIC_OP_INVERT),
            std::make_pair("VK_LOGIC_OP_OR_REVERSE", VK_LOGIC_OP_OR_REVERSE),
            std::make_pair("VK_LOGIC_OP_COPY_INVERTED", VK_LOGIC_OP_COPY_INVERTED),
            std::make_pair("VK_LOGIC_OP_OR_INVERTED", VK_LOGIC_OP_OR_INVERTED),
            std::make_pair("VK_LOGIC_OP_NAND", VK_LOGIC_OP_NAND),
            std::make_pair("VK_LOGIC_OP_SET", VK_LOGIC_OP_SET)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkLogicOp constant: " << v;
            return static_cast<VkLogicOp>(0);
        }
    }

    VkBlendFactor parse_VkBlendFactor_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkBlendFactor> map = {
            std::make_pair("VK_BLEND_FACTOR_ZERO", VK_BLEND_FACTOR_ZERO),
            std::make_pair("VK_BLEND_FACTOR_ONE", VK_BLEND_FACTOR_ONE),
            std::make_pair("VK_BLEND_FACTOR_SRC_COLOR", VK_BLEND_FACTOR_SRC_COLOR),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR", VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR),
            std::make_pair("VK_BLEND_FACTOR_DST_COLOR", VK_BLEND_FACTOR_DST_COLOR),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR", VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR),
            std::make_pair("VK_BLEND_FACTOR_SRC_ALPHA", VK_BLEND_FACTOR_SRC_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA", VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_DST_ALPHA", VK_BLEND_FACTOR_DST_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA", VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_CONSTANT_COLOR", VK_BLEND_FACTOR_CONSTANT_COLOR),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR", VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR),
            std::make_pair("VK_BLEND_FACTOR_CONSTANT_ALPHA", VK_BLEND_FACTOR_CONSTANT_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA", VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_SRC_ALPHA_SATURATE", VK_BLEND_FACTOR_SRC_ALPHA_SATURATE),
            std::make_pair("VK_BLEND_FACTOR_SRC1_COLOR", VK_BLEND_FACTOR_SRC1_COLOR),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR", VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR),
            std::make_pair("VK_BLEND_FACTOR_SRC1_ALPHA", VK_BLEND_FACTOR_SRC1_ALPHA),
            std::make_pair("VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkBlendFactor constant: " << v;
            return static_cast<VkBlendFactor>(0);
        }
    }

    VkBlendOp parse_VkBlendOp_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkBlendOp> map = {
            std::make_pair("VK_BLEND_OP_ADD", VK_BLEND_OP_ADD),
            std::make_pair("VK_BLEND_OP_SUBTRACT", VK_BLEND_OP_SUBTRACT),
            std::make_pair("VK_BLEND_OP_REVERSE_SUBTRACT", VK_BLEND_OP_REVERSE_SUBTRACT),
            std::make_pair("VK_BLEND_OP_MIN", VK_BLEND_OP_MIN),
            std::make_pair("VK_BLEND_OP_MAX", VK_BLEND_OP_MAX),
            std::make_pair("VK_BLEND_OP_ZERO_EXT", VK_BLEND_OP_ZERO_EXT),
            std::make_pair("VK_BLEND_OP_SRC_EXT", VK_BLEND_OP_SRC_EXT),
            std::make_pair("VK_BLEND_OP_DST_EXT", VK_BLEND_OP_DST_EXT),
            std::make_pair("VK_BLEND_OP_SRC_OVER_EXT", VK_BLEND_OP_SRC_OVER_EXT),
            std::make_pair("VK_BLEND_OP_DST_OVER_EXT", VK_BLEND_OP_DST_OVER_EXT),
            std::make_pair("VK_BLEND_OP_SRC_IN_EXT", VK_BLEND_OP_SRC_IN_EXT),
            std::make_pair("VK_BLEND_OP_DST_IN_EXT", VK_BLEND_OP_DST_IN_EXT),
            std::make_pair("VK_BLEND_OP_SRC_OUT_EXT", VK_BLEND_OP_SRC_OUT_EXT),
            std::make_pair("VK_BLEND_OP_DST_OUT_EXT", VK_BLEND_OP_DST_OUT_EXT),
            std::make_pair("VK_BLEND_OP_SRC_ATOP_EXT", VK_BLEND_OP_SRC_ATOP_EXT),
            std::make_pair("VK_BLEND_OP_DST_ATOP_EXT", VK_BLEND_OP_DST_ATOP_EXT),
            std::make_pair("VK_BLEND_OP_XOR_EXT", VK_BLEND_OP_XOR_EXT),
            std::make_pair("VK_BLEND_OP_MULTIPLY_EXT", VK_BLEND_OP_MULTIPLY_EXT),
            std::make_pair("VK_BLEND_OP_SCREEN_EXT", VK_BLEND_OP_SCREEN_EXT),
            std::make_pair("VK_BLEND_OP_OVERLAY_EXT", VK_BLEND_OP_OVERLAY_EXT),
            std::make_pair("VK_BLEND_OP_DARKEN_EXT", VK_BLEND_OP_DARKEN_EXT),
            std::make_pair("VK_BLEND_OP_LIGHTEN_EXT", VK_BLEND_OP_LIGHTEN_EXT),
            std::make_pair("VK_BLEND_OP_COLORDODGE_EXT", VK_BLEND_OP_COLORDODGE_EXT),
            std::make_pair("VK_BLEND_OP_COLORBURN_EXT", VK_BLEND_OP_COLORBURN_EXT),
            std::make_pair("VK_BLEND_OP_HARDLIGHT_EXT", VK_BLEND_OP_HARDLIGHT_EXT),
            std::make_pair("VK_BLEND_OP_SOFTLIGHT_EXT", VK_BLEND_OP_SOFTLIGHT_EXT),
            std::make_pair("VK_BLEND_OP_DIFFERENCE_EXT", VK_BLEND_OP_DIFFERENCE_EXT),
            std::make_pair("VK_BLEND_OP_EXCLUSION_EXT", VK_BLEND_OP_EXCLUSION_EXT),
            std::make_pair("VK_BLEND_OP_INVERT_EXT", VK_BLEND_OP_INVERT_EXT),
            std::make_pair("VK_BLEND_OP_INVERT_RGB_EXT", VK_BLEND_OP_INVERT_RGB_EXT),
            std::make_pair("VK_BLEND_OP_LINEARDODGE_EXT", VK_BLEND_OP_LINEARDODGE_EXT),
            std::make_pair("VK_BLEND_OP_LINEARBURN_EXT", VK_BLEND_OP_LINEARBURN_EXT),
            std::make_pair("VK_BLEND_OP_VIVIDLIGHT_EXT", VK_BLEND_OP_VIVIDLIGHT_EXT),
            std::make_pair("VK_BLEND_OP_LINEARLIGHT_EXT", VK_BLEND_OP_LINEARLIGHT_EXT),
            std::make_pair("VK_BLEND_OP_PINLIGHT_EXT", VK_BLEND_OP_PINLIGHT_EXT),
            std::make_pair("VK_BLEND_OP_HARDMIX_EXT", VK_BLEND_OP_HARDMIX_EXT),
            std::make_pair("VK_BLEND_OP_HSL_HUE_EXT", VK_BLEND_OP_HSL_HUE_EXT),
            std::make_pair("VK_BLEND_OP_HSL_SATURATION_EXT", VK_BLEND_OP_HSL_SATURATION_EXT),
            std::make_pair("VK_BLEND_OP_HSL_COLOR_EXT", VK_BLEND_OP_HSL_COLOR_EXT),
            std::make_pair("VK_BLEND_OP_HSL_LUMINOSITY_EXT", VK_BLEND_OP_HSL_LUMINOSITY_EXT),
            std::make_pair("VK_BLEND_OP_PLUS_EXT", VK_BLEND_OP_PLUS_EXT),
            std::make_pair("VK_BLEND_OP_PLUS_CLAMPED_EXT", VK_BLEND_OP_PLUS_CLAMPED_EXT),
            std::make_pair("VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT", VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT),
            std::make_pair("VK_BLEND_OP_PLUS_DARKER_EXT", VK_BLEND_OP_PLUS_DARKER_EXT),
            std::make_pair("VK_BLEND_OP_MINUS_EXT", VK_BLEND_OP_MINUS_EXT),
            std::make_pair("VK_BLEND_OP_MINUS_CLAMPED_EXT", VK_BLEND_OP_MINUS_CLAMPED_EXT),
            std::make_pair("VK_BLEND_OP_CONTRAST_EXT", VK_BLEND_OP_CONTRAST_EXT),
            std::make_pair("VK_BLEND_OP_INVERT_OVG_EXT", VK_BLEND_OP_INVERT_OVG_EXT),
            std::make_pair("VK_BLEND_OP_RED_EXT", VK_BLEND_OP_RED_EXT),
            std::make_pair("VK_BLEND_OP_GREEN_EXT", VK_BLEND_OP_GREEN_EXT),
            std::make_pair("VK_BLEND_OP_BLUE_EXT", VK_BLEND_OP_BLUE_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkBlendOp constant: " << v;
            return static_cast<VkBlendOp>(0);
        }
    }

    VkColorComponentFlagBits parse_VkColorComponentFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkColorComponentFlagBits> map = {
            std::make_pair("0", static_cast<VkColorComponentFlagBits>(0)),
            std::make_pair("VK_COLOR_COMPONENT_R_BIT", VK_COLOR_COMPONENT_R_BIT),
            std::make_pair("VK_COLOR_COMPONENT_G_BIT", VK_COLOR_COMPONENT_G_BIT),
            std::make_pair("VK_COLOR_COMPONENT_B_BIT", VK_COLOR_COMPONENT_B_BIT),
            std::make_pair("VK_COLOR_COMPONENT_A_BIT", VK_COLOR_COMPONENT_A_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkColorComponentFlagBits bit: " << v;
            return static_cast<VkColorComponentFlagBits>(0);
        }
    }

    VkBlendOverlapEXT parse_VkBlendOverlapEXT_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkBlendOverlapEXT> map = {
            std::make_pair("VK_BLEND_OVERLAP_UNCORRELATED_EXT", VK_BLEND_OVERLAP_UNCORRELATED_EXT),
            std::make_pair("VK_BLEND_OVERLAP_DISJOINT_EXT", VK_BLEND_OVERLAP_DISJOINT_EXT),
            std::make_pair("VK_BLEND_OVERLAP_CONJOINT_EXT", VK_BLEND_OVERLAP_CONJOINT_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkBlendOverlapEXT constant: " << v;
            return static_cast<VkBlendOverlapEXT>(0);
        }
    }

    VkDynamicState parse_VkDynamicState_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkDynamicState> map = {
            std::make_pair("VK_DYNAMIC_STATE_VIEWPORT", VK_DYNAMIC_STATE_VIEWPORT),
            std::make_pair("VK_DYNAMIC_STATE_SCISSOR", VK_DYNAMIC_STATE_SCISSOR),
            std::make_pair("VK_DYNAMIC_STATE_LINE_WIDTH", VK_DYNAMIC_STATE_LINE_WIDTH),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_BIAS", VK_DYNAMIC_STATE_DEPTH_BIAS),
            std::make_pair("VK_DYNAMIC_STATE_BLEND_CONSTANTS", VK_DYNAMIC_STATE_BLEND_CONSTANTS),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_BOUNDS", VK_DYNAMIC_STATE_DEPTH_BOUNDS),
            std::make_pair("VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK", VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK),
            std::make_pair("VK_DYNAMIC_STATE_STENCIL_WRITE_MASK", VK_DYNAMIC_STATE_STENCIL_WRITE_MASK),
            std::make_pair("VK_DYNAMIC_STATE_STENCIL_REFERENCE", VK_DYNAMIC_STATE_STENCIL_REFERENCE),
            std::make_pair("VK_DYNAMIC_STATE_CULL_MODE", VK_DYNAMIC_STATE_CULL_MODE),
            std::make_pair("VK_DYNAMIC_STATE_CULL_MODE_EXT", VK_DYNAMIC_STATE_CULL_MODE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_FRONT_FACE", VK_DYNAMIC_STATE_FRONT_FACE),
            std::make_pair("VK_DYNAMIC_STATE_FRONT_FACE_EXT", VK_DYNAMIC_STATE_FRONT_FACE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY", VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY),
            std::make_pair("VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT", VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT),
            std::make_pair("VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT", VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT),
            std::make_pair("VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT", VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT),
            std::make_pair("VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT", VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT),
            std::make_pair("VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT", VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT),
            std::make_pair("VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE", VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE),
            std::make_pair("VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT", VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE", VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT", VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE", VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT", VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_COMPARE_OP", VK_DYNAMIC_STATE_DEPTH_COMPARE_OP),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT", VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE", VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT", VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE", VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT", VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_STENCIL_OP", VK_DYNAMIC_STATE_STENCIL_OP),
            std::make_pair("VK_DYNAMIC_STATE_STENCIL_OP_EXT", VK_DYNAMIC_STATE_STENCIL_OP_EXT),
            std::make_pair("VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE", VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT", VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE", VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT", VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE", VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE),
            std::make_pair("VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT", VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_LINE_STIPPLE", VK_DYNAMIC_STATE_LINE_STIPPLE),
            std::make_pair("VK_DYNAMIC_STATE_LINE_STIPPLE_EXT", VK_DYNAMIC_STATE_LINE_STIPPLE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_LINE_STIPPLE_KHR", VK_DYNAMIC_STATE_LINE_STIPPLE_KHR),
            std::make_pair("VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT", VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT", VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT", VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT),
            std::make_pair("VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT", VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT),
            std::make_pair("VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR", VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR),
            std::make_pair("VK_DYNAMIC_STATE_VERTEX_INPUT_EXT", VK_DYNAMIC_STATE_VERTEX_INPUT_EXT),
            std::make_pair("VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT", VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT),
            std::make_pair("VK_DYNAMIC_STATE_LOGIC_OP_EXT", VK_DYNAMIC_STATE_LOGIC_OP_EXT),
            std::make_pair("VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT", VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkDynamicState constant: " << v;
            return static_cast<VkDynamicState>(0);
        }
    }

    VkPipelineCreateFlagBits2 parse_VkPipelineCreateFlagBits2_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineCreateFlagBits2> map = {
            std::make_pair("0", static_cast<VkPipelineCreateFlagBits2>(0)),
            std::make_pair("VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT", VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT", VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_DERIVATIVE_BIT", VK_PIPELINE_CREATE_2_DERIVATIVE_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT",
                           VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT", VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT",
                           VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT", VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT", VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT),
            std::make_pair("VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT", VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineCreateFlagBits2 bit: " << v;
            return static_cast<VkPipelineCreateFlagBits2>(0);
        }
    }

    VkPipelineCreationFeedbackFlagBits parse_VkPipelineCreationFeedbackFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineCreationFeedbackFlagBits> map = {
            std::make_pair("0", static_cast<VkPipelineCreationFeedbackFlagBits>(0)),
            std::make_pair("VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT", VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT),
            std::make_pair("VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT",
                           VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT),
            std::make_pair("VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT",
                           VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineCreationFeedbackFlagBits bit: " << v;
            return static_cast<VkPipelineCreationFeedbackFlagBits>(0);
        }
    }

    VkDiscardRectangleModeEXT parse_VkDiscardRectangleModeEXT_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkDiscardRectangleModeEXT> map = {
            std::make_pair("VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT", VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT),
            std::make_pair("VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT", VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkDiscardRectangleModeEXT constant: " << v;
            return static_cast<VkDiscardRectangleModeEXT>(0);
        }
    }

    VkFragmentShadingRateCombinerOpKHR parse_VkFragmentShadingRateCombinerOpKHR_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkFragmentShadingRateCombinerOpKHR> map = {
            std::make_pair("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR", VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR),
            std::make_pair("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR", VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR),
            std::make_pair("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR", VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR),
            std::make_pair("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR", VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR),
            std::make_pair("VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR", VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkFragmentShadingRateCombinerOpKHR constant: " << v;
            return static_cast<VkFragmentShadingRateCombinerOpKHR>(0);
        }
    }

    VkPipelineMatchControl parse_VkPipelineMatchControl_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineMatchControl> map = {std::make_pair(
            "VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH", VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineMatchControl constant: " << v;
            return static_cast<VkPipelineMatchControl>(0);
        }
    }

    VkSamplerYcbcrModelConversion parse_VkSamplerYcbcrModelConversion_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSamplerYcbcrModelConversion> map = {
            std::make_pair("VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY", VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY),
            std::make_pair("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY", VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY),
            std::make_pair("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709", VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709),
            std::make_pair("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601", VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601),
            std::make_pair("VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020", VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSamplerYcbcrModelConversion constant: " << v;
            return static_cast<VkSamplerYcbcrModelConversion>(0);
        }
    }

    VkSamplerYcbcrRange parse_VkSamplerYcbcrRange_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSamplerYcbcrRange> map = {
            std::make_pair("VK_SAMPLER_YCBCR_RANGE_ITU_FULL", VK_SAMPLER_YCBCR_RANGE_ITU_FULL),
            std::make_pair("VK_SAMPLER_YCBCR_RANGE_ITU_NARROW", VK_SAMPLER_YCBCR_RANGE_ITU_NARROW)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSamplerYcbcrRange constant: " << v;
            return static_cast<VkSamplerYcbcrRange>(0);
        }
    }

    VkComponentSwizzle parse_VkComponentSwizzle_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkComponentSwizzle> map = {
            std::make_pair("VK_COMPONENT_SWIZZLE_IDENTITY", VK_COMPONENT_SWIZZLE_IDENTITY),
            std::make_pair("VK_COMPONENT_SWIZZLE_ZERO", VK_COMPONENT_SWIZZLE_ZERO),
            std::make_pair("VK_COMPONENT_SWIZZLE_ONE", VK_COMPONENT_SWIZZLE_ONE),
            std::make_pair("VK_COMPONENT_SWIZZLE_R", VK_COMPONENT_SWIZZLE_R),
            std::make_pair("VK_COMPONENT_SWIZZLE_G", VK_COMPONENT_SWIZZLE_G),
            std::make_pair("VK_COMPONENT_SWIZZLE_B", VK_COMPONENT_SWIZZLE_B),
            std::make_pair("VK_COMPONENT_SWIZZLE_A", VK_COMPONENT_SWIZZLE_A)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkComponentSwizzle constant: " << v;
            return static_cast<VkComponentSwizzle>(0);
        }
    }

    VkChromaLocation parse_VkChromaLocation_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkChromaLocation> map = {
            std::make_pair("VK_CHROMA_LOCATION_COSITED_EVEN", VK_CHROMA_LOCATION_COSITED_EVEN),
            std::make_pair("VK_CHROMA_LOCATION_MIDPOINT", VK_CHROMA_LOCATION_MIDPOINT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkChromaLocation constant: " << v;
            return static_cast<VkChromaLocation>(0);
        }
    }

    VkFilter parse_VkFilter_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkFilter> map = {std::make_pair("VK_FILTER_NEAREST", VK_FILTER_NEAREST),
                                                                     std::make_pair("VK_FILTER_LINEAR", VK_FILTER_LINEAR),
                                                                     std::make_pair("VK_FILTER_CUBIC_EXT", VK_FILTER_CUBIC_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkFilter constant: " << v;
            return static_cast<VkFilter>(0);
        }
    }

    VkSamplerCreateFlagBits parse_VkSamplerCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSamplerCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkSamplerCreateFlagBits>(0)),

        };
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSamplerCreateFlagBits bit: " << v;
            return static_cast<VkSamplerCreateFlagBits>(0);
        }
    }

    VkSamplerMipmapMode parse_VkSamplerMipmapMode_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSamplerMipmapMode> map = {
            std::make_pair("VK_SAMPLER_MIPMAP_MODE_NEAREST", VK_SAMPLER_MIPMAP_MODE_NEAREST),
            std::make_pair("VK_SAMPLER_MIPMAP_MODE_LINEAR", VK_SAMPLER_MIPMAP_MODE_LINEAR)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSamplerMipmapMode constant: " << v;
            return static_cast<VkSamplerMipmapMode>(0);
        }
    }

    VkSamplerAddressMode parse_VkSamplerAddressMode_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSamplerAddressMode> map = {
            std::make_pair("VK_SAMPLER_ADDRESS_MODE_REPEAT", VK_SAMPLER_ADDRESS_MODE_REPEAT),
            std::make_pair("VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT", VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT),
            std::make_pair("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE),
            std::make_pair("VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER", VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER),
            std::make_pair("VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE", VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSamplerAddressMode constant: " << v;
            return static_cast<VkSamplerAddressMode>(0);
        }
    }

    VkBorderColor parse_VkBorderColor_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkBorderColor> map = {
            std::make_pair("VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK", VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK),
            std::make_pair("VK_BORDER_COLOR_INT_TRANSPARENT_BLACK", VK_BORDER_COLOR_INT_TRANSPARENT_BLACK),
            std::make_pair("VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK", VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK),
            std::make_pair("VK_BORDER_COLOR_INT_OPAQUE_BLACK", VK_BORDER_COLOR_INT_OPAQUE_BLACK),
            std::make_pair("VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE", VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE),
            std::make_pair("VK_BORDER_COLOR_INT_OPAQUE_WHITE", VK_BORDER_COLOR_INT_OPAQUE_WHITE),
            std::make_pair("VK_BORDER_COLOR_FLOAT_CUSTOM_EXT", VK_BORDER_COLOR_FLOAT_CUSTOM_EXT),
            std::make_pair("VK_BORDER_COLOR_INT_CUSTOM_EXT", VK_BORDER_COLOR_INT_CUSTOM_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkBorderColor constant: " << v;
            return static_cast<VkBorderColor>(0);
        }
    }

    VkSamplerReductionMode parse_VkSamplerReductionMode_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSamplerReductionMode> map = {
            std::make_pair("VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE", VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE),
            std::make_pair("VK_SAMPLER_REDUCTION_MODE_MIN", VK_SAMPLER_REDUCTION_MODE_MIN),
            std::make_pair("VK_SAMPLER_REDUCTION_MODE_MAX", VK_SAMPLER_REDUCTION_MODE_MAX)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSamplerReductionMode constant: " << v;
            return static_cast<VkSamplerReductionMode>(0);
        }
    }

    VkDescriptorSetLayoutCreateFlagBits parse_VkDescriptorSetLayoutCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkDescriptorSetLayoutCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkDescriptorSetLayoutCreateFlagBits>(0)),
            std::make_pair("VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT",
                           VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT),
            std::make_pair("VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT",
                           VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkDescriptorSetLayoutCreateFlagBits bit: " << v;
            return static_cast<VkDescriptorSetLayoutCreateFlagBits>(0);
        }
    }

    VkDescriptorType parse_VkDescriptorType_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkDescriptorType> map = {
            std::make_pair("VK_DESCRIPTOR_TYPE_SAMPLER", VK_DESCRIPTOR_TYPE_SAMPLER),
            std::make_pair("VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER", VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER),
            std::make_pair("VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE", VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE),
            std::make_pair("VK_DESCRIPTOR_TYPE_STORAGE_IMAGE", VK_DESCRIPTOR_TYPE_STORAGE_IMAGE),
            std::make_pair("VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER", VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER),
            std::make_pair("VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER", VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER),
            std::make_pair("VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER", VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER),
            std::make_pair("VK_DESCRIPTOR_TYPE_STORAGE_BUFFER", VK_DESCRIPTOR_TYPE_STORAGE_BUFFER),
            std::make_pair("VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC", VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC),
            std::make_pair("VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC", VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC),
            std::make_pair("VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT", VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT),
            std::make_pair("VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK", VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkDescriptorType constant: " << v;
            return static_cast<VkDescriptorType>(0);
        }
    }

    VkDescriptorBindingFlagBits parse_VkDescriptorBindingFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkDescriptorBindingFlagBits> map = {
            std::make_pair("0", static_cast<VkDescriptorBindingFlagBits>(0)),
            std::make_pair("VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT", VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT),
            std::make_pair("VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT",
                           VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT),
            std::make_pair("VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT", VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT),
            std::make_pair("VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT",
                           VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkDescriptorBindingFlagBits bit: " << v;
            return static_cast<VkDescriptorBindingFlagBits>(0);
        }
    }

    VkPipelineLayoutCreateFlagBits parse_VkPipelineLayoutCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineLayoutCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkPipelineLayoutCreateFlagBits>(0)),

        };
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineLayoutCreateFlagBits bit: " << v;
            return static_cast<VkPipelineLayoutCreateFlagBits>(0);
        }
    }

    VkRenderPassCreateFlagBits parse_VkRenderPassCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkRenderPassCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkRenderPassCreateFlagBits>(0)),

        };
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkRenderPassCreateFlagBits bit: " << v;
            return static_cast<VkRenderPassCreateFlagBits>(0);
        }
    }

    VkAttachmentDescriptionFlagBits parse_VkAttachmentDescriptionFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkAttachmentDescriptionFlagBits> map = {
            std::make_pair("0", static_cast<VkAttachmentDescriptionFlagBits>(0)),
            std::make_pair("VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT", VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkAttachmentDescriptionFlagBits bit: " << v;
            return static_cast<VkAttachmentDescriptionFlagBits>(0);
        }
    }

    VkAttachmentLoadOp parse_VkAttachmentLoadOp_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkAttachmentLoadOp> map = {
            std::make_pair("VK_ATTACHMENT_LOAD_OP_LOAD", VK_ATTACHMENT_LOAD_OP_LOAD),
            std::make_pair("VK_ATTACHMENT_LOAD_OP_CLEAR", VK_ATTACHMENT_LOAD_OP_CLEAR),
            std::make_pair("VK_ATTACHMENT_LOAD_OP_DONT_CARE", VK_ATTACHMENT_LOAD_OP_DONT_CARE),
            std::make_pair("VK_ATTACHMENT_LOAD_OP_NONE", VK_ATTACHMENT_LOAD_OP_NONE)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkAttachmentLoadOp constant: " << v;
            return static_cast<VkAttachmentLoadOp>(0);
        }
    }

    VkAttachmentStoreOp parse_VkAttachmentStoreOp_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkAttachmentStoreOp> map = {
            std::make_pair("VK_ATTACHMENT_STORE_OP_STORE", VK_ATTACHMENT_STORE_OP_STORE),
            std::make_pair("VK_ATTACHMENT_STORE_OP_DONT_CARE", VK_ATTACHMENT_STORE_OP_DONT_CARE),
            std::make_pair("VK_ATTACHMENT_STORE_OP_NONE", VK_ATTACHMENT_STORE_OP_NONE)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkAttachmentStoreOp constant: " << v;
            return static_cast<VkAttachmentStoreOp>(0);
        }
    }

    VkImageLayout parse_VkImageLayout_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkImageLayout> map = {
            std::make_pair("VK_IMAGE_LAYOUT_UNDEFINED", VK_IMAGE_LAYOUT_UNDEFINED),
            std::make_pair("VK_IMAGE_LAYOUT_GENERAL", VK_IMAGE_LAYOUT_GENERAL),
            std::make_pair("VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL", VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL", VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL", VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL", VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_PREINITIALIZED", VK_IMAGE_LAYOUT_PREINITIALIZED),
            std::make_pair("VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL",
                           VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL",
                           VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL", VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL", VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL", VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL", VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR),
            std::make_pair("VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL", VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL),
            std::make_pair("VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR", VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR),
            std::make_pair("VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ", VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ),
            std::make_pair("VK_IMAGE_LAYOUT_PRESENT_SRC_KHR", VK_IMAGE_LAYOUT_PRESENT_SRC_KHR),
            std::make_pair("VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR", VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR),
            std::make_pair("VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR",
                           VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkImageLayout constant: " << v;
            return static_cast<VkImageLayout>(0);
        }
    }

    VkSubpassDescriptionFlagBits parse_VkSubpassDescriptionFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkSubpassDescriptionFlagBits> map = {
            std::make_pair("0", static_cast<VkSubpassDescriptionFlagBits>(0)),

        };
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkSubpassDescriptionFlagBits bit: " << v;
            return static_cast<VkSubpassDescriptionFlagBits>(0);
        }
    }

    VkPipelineBindPoint parse_VkPipelineBindPoint_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineBindPoint> map = {
            std::make_pair("VK_PIPELINE_BIND_POINT_GRAPHICS", VK_PIPELINE_BIND_POINT_GRAPHICS),
            std::make_pair("VK_PIPELINE_BIND_POINT_COMPUTE", VK_PIPELINE_BIND_POINT_COMPUTE)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineBindPoint constant: " << v;
            return static_cast<VkPipelineBindPoint>(0);
        }
    }

    VkPipelineStageFlagBits parse_VkPipelineStageFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineStageFlagBits> map = {
            std::make_pair("0", static_cast<VkPipelineStageFlagBits>(0)),
            std::make_pair("VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT", VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT),
            std::make_pair("VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT", VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_VERTEX_INPUT_BIT", VK_PIPELINE_STAGE_VERTEX_INPUT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_VERTEX_SHADER_BIT", VK_PIPELINE_STAGE_VERTEX_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT", VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT",
                           VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT", VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT", VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT", VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT", VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT", VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_TRANSFER_BIT", VK_PIPELINE_STAGE_TRANSFER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT", VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT),
            std::make_pair("VK_PIPELINE_STAGE_HOST_BIT", VK_PIPELINE_STAGE_HOST_BIT),
            std::make_pair("VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT", VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_ALL_COMMANDS_BIT", VK_PIPELINE_STAGE_ALL_COMMANDS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_NONE", VK_PIPELINE_STAGE_NONE),
            std::make_pair("VK_PIPELINE_STAGE_NONE_KHR", VK_PIPELINE_STAGE_NONE_KHR),
            std::make_pair("VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR",
                           VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineStageFlagBits bit: " << v;
            return static_cast<VkPipelineStageFlagBits>(0);
        }
    }

    VkAccessFlagBits parse_VkAccessFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkAccessFlagBits> map = {
            std::make_pair("0", static_cast<VkAccessFlagBits>(0)),
            std::make_pair("VK_ACCESS_INDIRECT_COMMAND_READ_BIT", VK_ACCESS_INDIRECT_COMMAND_READ_BIT),
            std::make_pair("VK_ACCESS_INDEX_READ_BIT", VK_ACCESS_INDEX_READ_BIT),
            std::make_pair("VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT", VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT),
            std::make_pair("VK_ACCESS_UNIFORM_READ_BIT", VK_ACCESS_UNIFORM_READ_BIT),
            std::make_pair("VK_ACCESS_INPUT_ATTACHMENT_READ_BIT", VK_ACCESS_INPUT_ATTACHMENT_READ_BIT),
            std::make_pair("VK_ACCESS_SHADER_READ_BIT", VK_ACCESS_SHADER_READ_BIT),
            std::make_pair("VK_ACCESS_SHADER_WRITE_BIT", VK_ACCESS_SHADER_WRITE_BIT),
            std::make_pair("VK_ACCESS_COLOR_ATTACHMENT_READ_BIT", VK_ACCESS_COLOR_ATTACHMENT_READ_BIT),
            std::make_pair("VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT", VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT),
            std::make_pair("VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT", VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT),
            std::make_pair("VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT", VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT),
            std::make_pair("VK_ACCESS_TRANSFER_READ_BIT", VK_ACCESS_TRANSFER_READ_BIT),
            std::make_pair("VK_ACCESS_TRANSFER_WRITE_BIT", VK_ACCESS_TRANSFER_WRITE_BIT),
            std::make_pair("VK_ACCESS_HOST_READ_BIT", VK_ACCESS_HOST_READ_BIT),
            std::make_pair("VK_ACCESS_HOST_WRITE_BIT", VK_ACCESS_HOST_WRITE_BIT),
            std::make_pair("VK_ACCESS_MEMORY_READ_BIT", VK_ACCESS_MEMORY_READ_BIT),
            std::make_pair("VK_ACCESS_MEMORY_WRITE_BIT", VK_ACCESS_MEMORY_WRITE_BIT),
            std::make_pair("VK_ACCESS_NONE", VK_ACCESS_NONE),
            std::make_pair("VK_ACCESS_NONE_KHR", VK_ACCESS_NONE_KHR),
            std::make_pair("VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT",
                           VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT),
            std::make_pair("VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR",
                           VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkAccessFlagBits bit: " << v;
            return static_cast<VkAccessFlagBits>(0);
        }
    }

    VkDependencyFlagBits parse_VkDependencyFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkDependencyFlagBits> map = {
            std::make_pair("0", static_cast<VkDependencyFlagBits>(0)),
            std::make_pair("VK_DEPENDENCY_BY_REGION_BIT", VK_DEPENDENCY_BY_REGION_BIT),
            std::make_pair("VK_DEPENDENCY_DEVICE_GROUP_BIT", VK_DEPENDENCY_DEVICE_GROUP_BIT),
            std::make_pair("VK_DEPENDENCY_VIEW_LOCAL_BIT", VK_DEPENDENCY_VIEW_LOCAL_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkDependencyFlagBits bit: " << v;
            return static_cast<VkDependencyFlagBits>(0);
        }
    }

    VkImageAspectFlagBits parse_VkImageAspectFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkImageAspectFlagBits> map = {
            std::make_pair("0", static_cast<VkImageAspectFlagBits>(0)),
            std::make_pair("VK_IMAGE_ASPECT_COLOR_BIT", VK_IMAGE_ASPECT_COLOR_BIT),
            std::make_pair("VK_IMAGE_ASPECT_DEPTH_BIT", VK_IMAGE_ASPECT_DEPTH_BIT),
            std::make_pair("VK_IMAGE_ASPECT_STENCIL_BIT", VK_IMAGE_ASPECT_STENCIL_BIT),
            std::make_pair("VK_IMAGE_ASPECT_METADATA_BIT", VK_IMAGE_ASPECT_METADATA_BIT),
            std::make_pair("VK_IMAGE_ASPECT_PLANE_0_BIT", VK_IMAGE_ASPECT_PLANE_0_BIT),
            std::make_pair("VK_IMAGE_ASPECT_PLANE_1_BIT", VK_IMAGE_ASPECT_PLANE_1_BIT),
            std::make_pair("VK_IMAGE_ASPECT_PLANE_2_BIT", VK_IMAGE_ASPECT_PLANE_2_BIT),
            std::make_pair("VK_IMAGE_ASPECT_NONE", VK_IMAGE_ASPECT_NONE),
            std::make_pair("VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT", VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT),
            std::make_pair("VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT", VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT),
            std::make_pair("VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT", VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT),
            std::make_pair("VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT", VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkImageAspectFlagBits bit: " << v;
            return static_cast<VkImageAspectFlagBits>(0);
        }
    }

    VkResolveModeFlagBits parse_VkResolveModeFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkResolveModeFlagBits> map = {
            std::make_pair("0", static_cast<VkResolveModeFlagBits>(0)),
            std::make_pair("VK_RESOLVE_MODE_NONE", VK_RESOLVE_MODE_NONE),
            std::make_pair("VK_RESOLVE_MODE_SAMPLE_ZERO_BIT", VK_RESOLVE_MODE_SAMPLE_ZERO_BIT),
            std::make_pair("VK_RESOLVE_MODE_AVERAGE_BIT", VK_RESOLVE_MODE_AVERAGE_BIT),
            std::make_pair("VK_RESOLVE_MODE_MIN_BIT", VK_RESOLVE_MODE_MIN_BIT),
            std::make_pair("VK_RESOLVE_MODE_MAX_BIT", VK_RESOLVE_MODE_MAX_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkResolveModeFlagBits bit: " << v;
            return static_cast<VkResolveModeFlagBits>(0);
        }
    }

    VkPipelineStageFlagBits2 parse_VkPipelineStageFlagBits2_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineStageFlagBits2> map = {
            std::make_pair("0", static_cast<VkPipelineStageFlagBits2>(0)),
            std::make_pair("VK_PIPELINE_STAGE_2_NONE", VK_PIPELINE_STAGE_2_NONE),
            std::make_pair("VK_PIPELINE_STAGE_2_NONE_KHR", VK_PIPELINE_STAGE_2_NONE_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT", VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR", VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT", VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR", VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT", VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR", VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT", VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR", VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT",
                           VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR",
                           VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT",
                           VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR",
                           VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT", VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR", VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT", VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR", VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT", VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR", VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT", VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR", VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT", VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR",
                           VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT", VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR", VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT", VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_TRANSFER_BIT", VK_PIPELINE_STAGE_2_TRANSFER_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR", VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR", VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT", VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR", VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_HOST_BIT", VK_PIPELINE_STAGE_2_HOST_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_HOST_BIT_KHR", VK_PIPELINE_STAGE_2_HOST_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT", VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR", VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR", VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_COPY_BIT", VK_PIPELINE_STAGE_2_COPY_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_COPY_BIT_KHR", VK_PIPELINE_STAGE_2_COPY_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_RESOLVE_BIT", VK_PIPELINE_STAGE_2_RESOLVE_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR", VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_BLIT_BIT", VK_PIPELINE_STAGE_2_BLIT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_BLIT_BIT_KHR", VK_PIPELINE_STAGE_2_BLIT_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_CLEAR_BIT", VK_PIPELINE_STAGE_2_CLEAR_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR", VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT", VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR", VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT", VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR",
                           VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT", VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT),
            std::make_pair("VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR",
                           VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT", VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT),
            std::make_pair("VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT", VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT),
            std::make_pair("VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT", VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT),
            std::make_pair("VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV", VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV),
            std::make_pair("VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR",
                           VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV", VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV),
            std::make_pair("VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR",
                           VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV",
                           VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV),
            std::make_pair("VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR),
            std::make_pair("VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV", VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV),
            std::make_pair("VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT",
                           VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT),
            std::make_pair("VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT", VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT),
            std::make_pair("VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV", VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV),
            std::make_pair("VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT", VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT),
            std::make_pair("VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV", VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineStageFlagBits2 bit: " << v;
            return static_cast<VkPipelineStageFlagBits2>(0);
        }
    }

    VkAccessFlagBits2 parse_VkAccessFlagBits2_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkAccessFlagBits2> map = {
            std::make_pair("0", static_cast<VkAccessFlagBits2>(0)),
            std::make_pair("VK_ACCESS_2_NONE", VK_ACCESS_2_NONE),
            std::make_pair("VK_ACCESS_2_NONE_KHR", VK_ACCESS_2_NONE_KHR),
            std::make_pair("VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT", VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT),
            std::make_pair("VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR", VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_INDEX_READ_BIT", VK_ACCESS_2_INDEX_READ_BIT),
            std::make_pair("VK_ACCESS_2_INDEX_READ_BIT_KHR", VK_ACCESS_2_INDEX_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT", VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT),
            std::make_pair("VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR", VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_UNIFORM_READ_BIT", VK_ACCESS_2_UNIFORM_READ_BIT),
            std::make_pair("VK_ACCESS_2_UNIFORM_READ_BIT_KHR", VK_ACCESS_2_UNIFORM_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT", VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT),
            std::make_pair("VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR", VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_SHADER_READ_BIT", VK_ACCESS_2_SHADER_READ_BIT),
            std::make_pair("VK_ACCESS_2_SHADER_READ_BIT_KHR", VK_ACCESS_2_SHADER_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_SHADER_WRITE_BIT", VK_ACCESS_2_SHADER_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_SHADER_WRITE_BIT_KHR", VK_ACCESS_2_SHADER_WRITE_BIT_KHR),
            std::make_pair("VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT", VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT),
            std::make_pair("VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR", VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT", VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR", VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR),
            std::make_pair("VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT", VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT),
            std::make_pair("VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR", VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT", VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR",
                           VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR),
            std::make_pair("VK_ACCESS_2_TRANSFER_READ_BIT", VK_ACCESS_2_TRANSFER_READ_BIT),
            std::make_pair("VK_ACCESS_2_TRANSFER_READ_BIT_KHR", VK_ACCESS_2_TRANSFER_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_TRANSFER_WRITE_BIT", VK_ACCESS_2_TRANSFER_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR", VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR),
            std::make_pair("VK_ACCESS_2_HOST_READ_BIT", VK_ACCESS_2_HOST_READ_BIT),
            std::make_pair("VK_ACCESS_2_HOST_READ_BIT_KHR", VK_ACCESS_2_HOST_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_HOST_WRITE_BIT", VK_ACCESS_2_HOST_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_HOST_WRITE_BIT_KHR", VK_ACCESS_2_HOST_WRITE_BIT_KHR),
            std::make_pair("VK_ACCESS_2_MEMORY_READ_BIT", VK_ACCESS_2_MEMORY_READ_BIT),
            std::make_pair("VK_ACCESS_2_MEMORY_READ_BIT_KHR", VK_ACCESS_2_MEMORY_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_MEMORY_WRITE_BIT", VK_ACCESS_2_MEMORY_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_MEMORY_WRITE_BIT_KHR", VK_ACCESS_2_MEMORY_WRITE_BIT_KHR),
            std::make_pair("VK_ACCESS_2_SHADER_SAMPLED_READ_BIT", VK_ACCESS_2_SHADER_SAMPLED_READ_BIT),
            std::make_pair("VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR", VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_SHADER_STORAGE_READ_BIT", VK_ACCESS_2_SHADER_STORAGE_READ_BIT),
            std::make_pair("VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR", VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT", VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT),
            std::make_pair("VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR", VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR),
            std::make_pair("VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT", VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT),
            std::make_pair("VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT",
                           VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT),
            std::make_pair("VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT",
                           VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT),
            std::make_pair("VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT", VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT),
            std::make_pair("VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT", VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT),
            std::make_pair("VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV", VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV),
            std::make_pair("VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT", VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT),
            std::make_pair("VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV", VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV),
            std::make_pair("VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR",
                           VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV", VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV),
            std::make_pair("VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR", VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR),
            std::make_pair("VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV", VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV),
            std::make_pair("VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR", VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR),
            std::make_pair("VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV", VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV),
            std::make_pair("VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT", VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT),
            std::make_pair("VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT",
                           VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkAccessFlagBits2 bit: " << v;
            return static_cast<VkAccessFlagBits2>(0);
        }
    }

    VkPipelineCacheCreateFlagBits parse_VkPipelineCacheCreateFlagBits_c_str(const char* v) {
        static std::unordered_map<std::string_view, VkPipelineCacheCreateFlagBits> map = {
            std::make_pair("0", static_cast<VkPipelineCacheCreateFlagBits>(0)),
            std::make_pair("VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT",
                           VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT),
            std::make_pair("VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT", VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT),
            std::make_pair("VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT",
                           VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT)};
        auto it = map.find(v);
        if (it != map.end()) {
            return it->second;
        } else {
            Error() << "Invalid VkPipelineCacheCreateFlagBits bit: " << v;
            return static_cast<VkPipelineCacheCreateFlagBits>(0);
        }
    }

  protected:
    int8_t parse_int8_t(const Json::Value& v, const LocationScope&) {
        if (v.isInt() && v.asInt() >= INT8_MIN && v.asInt() <= INT8_MAX) {
            return v.asInt();
        } else {
            Error() << "Not an 8-bit signed integer";
            return 0;
        }
    }

    int16_t parse_int16_t(const Json::Value& v, const LocationScope&) {
        if (v.isInt() && v.asInt() >= INT16_MIN && v.asInt() <= INT16_MAX) {
            return v.asInt();
        } else {
            Error() << "Not a 16-bit signed integer";
            return 0;
        }
    }

    int32_t parse_int32_t(const Json::Value& v, const LocationScope&) {
        if (v.isInt() && v.asInt() >= INT32_MIN && v.asInt() <= INT32_MAX) {
            return v.asInt();
        } else {
            Error() << "Not a 32-bit signed integer";
            return 0;
        }
    }

    int64_t parse_int64_t(const Json::Value& v, const LocationScope&) {
        if (v.isInt64()) {
            return v.asInt64();
        } else {
            Error() << "Not a 64-bit signed integer";
            return 0;
        }
    }

    uint8_t parse_uint8_t(const Json::Value& v, const LocationScope&) {
        if (v.isUInt() && v.asUInt() <= UINT8_MAX) {
            return v.asUInt();
        } else {
            Error() << "Not an 8-bit unsigned integer";
            return 0;
        }
    }

    uint16_t parse_uint16_t(const Json::Value& v, const LocationScope&) {
        if (v.isUInt() && v.asUInt() <= UINT16_MAX) {
            return v.asUInt();
        } else {
            Error() << "Not a 16-bit unsigned integer";
            return 0;
        }
    }

    uint32_t parse_uint32_t(const Json::Value& v, const LocationScope&) {
        if (v.isUInt() && v.asUInt() <= UINT32_MAX) {
            return v.asUInt();
        } else if (v.isString()) {
            const char *first, *last;
            v.getString(&first, &last);
            auto str_size = std::distance(first, last);
            std::string_view str(first, str_size);
            if (str == "VK_MAX_PHYSICAL_DEVICE_NAME_SIZE") return VK_MAX_PHYSICAL_DEVICE_NAME_SIZE;
            if (str == "VK_UUID_SIZE") return VK_UUID_SIZE;
            if (str == "VK_LUID_SIZE") return VK_LUID_SIZE;
            if (str == "VK_MAX_EXTENSION_NAME_SIZE") return VK_MAX_EXTENSION_NAME_SIZE;
            if (str == "VK_MAX_DESCRIPTION_SIZE") return VK_MAX_DESCRIPTION_SIZE;
            if (str == "VK_MAX_MEMORY_TYPES") return VK_MAX_MEMORY_TYPES;
            if (str == "VK_MAX_MEMORY_HEAPS") return VK_MAX_MEMORY_HEAPS;
            if (str == "VK_REMAINING_MIP_LEVELS") return VK_REMAINING_MIP_LEVELS;
            if (str == "VK_REMAINING_ARRAY_LAYERS") return VK_REMAINING_ARRAY_LAYERS;
            if (str == "VK_REMAINING_3D_SLICES_EXT") return VK_REMAINING_3D_SLICES_EXT;
            if (str == "VK_ATTACHMENT_UNUSED") return VK_ATTACHMENT_UNUSED;
            if (str == "VK_TRUE") return VK_TRUE;
            if (str == "VK_FALSE") return VK_FALSE;
            if (str == "VK_QUEUE_FAMILY_IGNORED") return VK_QUEUE_FAMILY_IGNORED;
            if (str == "VK_QUEUE_FAMILY_EXTERNAL") return VK_QUEUE_FAMILY_EXTERNAL;
            if (str == "VK_QUEUE_FAMILY_FOREIGN_EXT") return VK_QUEUE_FAMILY_FOREIGN_EXT;
            if (str == "VK_SUBPASS_EXTERNAL") return VK_SUBPASS_EXTERNAL;
            if (str == "VK_MAX_DEVICE_GROUP_SIZE") return VK_MAX_DEVICE_GROUP_SIZE;
            if (str == "VK_MAX_DRIVER_NAME_SIZE") return VK_MAX_DRIVER_NAME_SIZE;
            if (str == "VK_MAX_DRIVER_INFO_SIZE") return VK_MAX_DRIVER_INFO_SIZE;
            if (str == "VK_SHADER_UNUSED_KHR") return VK_SHADER_UNUSED_KHR;
            if (str == "VK_MAX_GLOBAL_PRIORITY_SIZE") return VK_MAX_GLOBAL_PRIORITY_SIZE;
            if (str == "VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT") return VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT;
            if (str == "VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR") return VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR;
            if (str == "VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR") return VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR;
            if (str == "VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR") return VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR;
            if (str == "VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV")
                return VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV;
            if (str == "VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM")
                return VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM;
            else {
                Error() << "String is not a known 32-bit unsigned integer constant";
                return 0;
            }
        } else {
            Error() << "Not a 32-bit unsigned integer";
            return 0;
        }
    }

    uint64_t parse_uint64_t(const Json::Value& v, const LocationScope&) {
        if (v.isUInt64()) {
            return v.asUInt64();
        } else if (v.isString()) {
            const char *first, *last;
            v.getString(&first, &last);
            auto str_size = std::distance(first, last);
            std::string_view str(first, str_size);
            if (str == "VK_WHOLE_SIZE")
                return VK_WHOLE_SIZE;
            else {
                Error() << "String is not a known 64-bit unsigned integer constant";
                return 0;
            }
        } else {
            Error() << "Not a 64-bit unsigned integer";
            return 0;
        }
    }

    float parse_float(const Json::Value& v, const LocationScope& l) {
        if (v.isDouble()) {
            return v.asFloat();
        } else if (v.isString()) {
            const char *first, *last;
            v.getString(&first, &last);
            auto str_size = std::distance(first, last);
            std::string_view str(first, str_size);
            if (str == "NaN") return std::numeric_limits<float>::quiet_NaN();
            if (str == "VK_LOD_CLAMP_NONE")
                return VK_LOD_CLAMP_NONE;
            else {
                Error() << "String is not a known 32-bit floating-point constant";
                return 0;
            }
        } else {
            Error() << "Not a 32-bit floating-point value";
            return 0;
        }
    }

    size_t parse_size_t(const Json::Value& v, const LocationScope& l) {
        if constexpr (sizeof(&v) == 8) {
            return parse_uint64_t(v, l);
        } else {
            return parse_uint32_t(v, l);
        }
    }

    VkDeviceSize parse_VkDeviceSize(const Json::Value& v, const LocationScope& l) { return parse_uint64_t(v, l); }

    const char* parse_string(const Json::Value& v, const LocationScope&) {
        if (v.isString()) {
            const char *first, *last;
            v.getString(&first, &last);
            auto str_size = std::distance(first, last);
            auto dst = AllocMem<char>(str_size + 1);  // null-terminator
            std::copy(first, last, dst);
            dst[str_size] = '\0';
            return dst;
        } else {
            Error() << "Not a string";
            return nullptr;
        }
    }

    void* parse_binary(const Json::Value& v, const LocationScope&, size_t& size) {
        if (v.isArray()) {  // TODO: Consider removing. Array path is preserved for historical reasons.
            if (v.size() == 0) {
                size = 0;
                return nullptr;
            }
            uint8_t* result = AllocMem<uint8_t>(v.size());
            for (Json::Value::ArrayIndex i = 0; i < v.size(); ++i) {
                if (v[i].isUInt() && v[i].asUInt() <= 255) {
                    result[i] = v[i].asUInt();
                } else {
                    Error() << "Binary array has non-unsigned integral value or is out of [0-255] range.";
                    return nullptr;
                }
            }
            size = v.size();
            return result;
        }
        if (!v.isString()) {
            Error() << "Base64 encoded binary not a string";
            return nullptr;
        }

        const char *first, *last;
        v.getString(&first, &last);
        auto str_size = std::distance(first, last);
        std::string_view str(first, str_size);

        static const std::string_view base64_alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        auto init_base64_lookup_table = [&] {
            std::array<uint8_t, UINT8_MAX + 1> lookup_table{};
            for (size_t i = 0; i <= UINT8_MAX; ++i) {
                lookup_table[i] = UINT8_MAX;
            }
            for (size_t i = 0; i < base64_alphabet.size(); ++i) {
                lookup_table[base64_alphabet[i]] = static_cast<uint8_t>(i);
            }
            return lookup_table;
        };
        static const std::array<uint8_t, UINT8_MAX + 1> base64_lookup_table = init_base64_lookup_table();

        constexpr uint32_t bits_in_base64 = 6;
        constexpr uint32_t bits_in_byte = 8;

        uint8_t* result = AllocMem<uint8_t>((str.size() * bits_in_base64 + bits_in_byte - 1) / bits_in_byte);
        size = 0;
        uint32_t current_word = 0;
        uint32_t current_bits = 0;
        for (auto ch : str) {
            if (ch == '=') {
                // End of data padding
                break;
            } else if (base64_lookup_table[ch] == UINT8_MAX) {
                Error() << "Invalid base64 character '" << ch << "'";
                return nullptr;
            }
            current_word = (current_word << bits_in_base64) + base64_lookup_table[ch];
            current_bits += bits_in_base64;
            if (current_bits >= bits_in_byte) {
                result[size++] = static_cast<uint8_t>((current_word >> (current_bits - bits_in_byte)) & ((1 << bits_in_byte) - 1));
                current_bits -= bits_in_byte;
            }
        }
        return result;
    }

    VkBool32 parse_VkBool32(const Json::Value& v, const LocationScope&) {
        if (v.isString()) {
            auto value = v.asCString();
            if (strcmp(value, "VK_TRUE") == 0) {
                return VK_TRUE;
            } else if (strcmp(value, "VK_FALSE") == 0) {
                return VK_FALSE;
            } else {
                Error() << "VKBool32 string is neither VK_TRUE nor VK_FALSE";
                return 0;
            }
        } else if (v.isUInt() && v.asUInt() <= UINT32_MAX) {
            return v.asUInt();
        } else {
            Error() << "Not a 32-bit unsigned integer";
            return 0;
        }
    }

    VkSampleMask parse_VkSampleMask(const Json::Value& v, const LocationScope& l) { return parse_uint32_t(v, l); }

    VkStructureType parse_VkStructureType(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkStructureType_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkStructureType>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkStructureType>(0);
        }
    }

    VkPipelineCreateFlagBits parse_VkPipelineCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineCreateFlagBits>(0);
        }
    }

    VkPipelineShaderStageCreateFlagBits parse_VkPipelineShaderStageCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineShaderStageCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineShaderStageCreateFlagBits>(0);
        }
    }

    VkShaderStageFlagBits parse_VkShaderStageFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkShaderStageFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkShaderStageFlagBits>(0);
        }
    }

    VkObjectType parse_VkObjectType(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkObjectType_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkObjectType>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkObjectType>(0);
        }
    }

    VkPipelineRobustnessBufferBehavior parse_VkPipelineRobustnessBufferBehavior(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineRobustnessBufferBehavior_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkPipelineRobustnessBufferBehavior>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineRobustnessBufferBehavior>(0);
        }
    }

    VkPipelineRobustnessImageBehavior parse_VkPipelineRobustnessImageBehavior(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineRobustnessImageBehavior_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkPipelineRobustnessImageBehavior>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineRobustnessImageBehavior>(0);
        }
    }

    VkVertexInputRate parse_VkVertexInputRate(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkVertexInputRate_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkVertexInputRate>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkVertexInputRate>(0);
        }
    }

    VkFormat parse_VkFormat(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkFormat_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkFormat>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkFormat>(0);
        }
    }

    VkPrimitiveTopology parse_VkPrimitiveTopology(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPrimitiveTopology_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkPrimitiveTopology>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPrimitiveTopology>(0);
        }
    }

    VkTessellationDomainOrigin parse_VkTessellationDomainOrigin(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkTessellationDomainOrigin_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkTessellationDomainOrigin>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkTessellationDomainOrigin>(0);
        }
    }

    VkPolygonMode parse_VkPolygonMode(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPolygonMode_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkPolygonMode>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPolygonMode>(0);
        }
    }

    VkCullModeFlagBits parse_VkCullModeFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkCullModeFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkCullModeFlagBits>(0);
        }
    }

    VkFrontFace parse_VkFrontFace(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkFrontFace_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkFrontFace>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkFrontFace>(0);
        }
    }

    VkConservativeRasterizationModeEXT parse_VkConservativeRasterizationModeEXT(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkConservativeRasterizationModeEXT_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkConservativeRasterizationModeEXT>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkConservativeRasterizationModeEXT>(0);
        }
    }

    VkLineRasterizationMode parse_VkLineRasterizationMode(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkLineRasterizationMode_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkLineRasterizationMode>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkLineRasterizationMode>(0);
        }
    }

    VkSampleCountFlagBits parse_VkSampleCountFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSampleCountFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSampleCountFlagBits>(0);
        }
    }

    VkCompareOp parse_VkCompareOp(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkCompareOp_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkCompareOp>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkCompareOp>(0);
        }
    }

    VkStencilOp parse_VkStencilOp(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkStencilOp_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkStencilOp>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkStencilOp>(0);
        }
    }

    VkLogicOp parse_VkLogicOp(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkLogicOp_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkLogicOp>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkLogicOp>(0);
        }
    }

    VkBlendFactor parse_VkBlendFactor(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkBlendFactor_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkBlendFactor>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkBlendFactor>(0);
        }
    }

    VkBlendOp parse_VkBlendOp(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkBlendOp_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkBlendOp>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkBlendOp>(0);
        }
    }

    VkColorComponentFlagBits parse_VkColorComponentFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkColorComponentFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkColorComponentFlagBits>(0);
        }
    }

    VkBlendOverlapEXT parse_VkBlendOverlapEXT(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkBlendOverlapEXT_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkBlendOverlapEXT>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkBlendOverlapEXT>(0);
        }
    }

    VkDynamicState parse_VkDynamicState(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkDynamicState_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkDynamicState>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkDynamicState>(0);
        }
    }

    VkPipelineCreateFlagBits2 parse_VkPipelineCreateFlagBits2(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineCreateFlagBits2_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineCreateFlagBits2>(0);
        }
    }

    VkPipelineCreationFeedbackFlagBits parse_VkPipelineCreationFeedbackFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineCreationFeedbackFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineCreationFeedbackFlagBits>(0);
        }
    }

    VkDiscardRectangleModeEXT parse_VkDiscardRectangleModeEXT(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkDiscardRectangleModeEXT_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkDiscardRectangleModeEXT>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkDiscardRectangleModeEXT>(0);
        }
    }

    VkFragmentShadingRateCombinerOpKHR parse_VkFragmentShadingRateCombinerOpKHR(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkFragmentShadingRateCombinerOpKHR_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkFragmentShadingRateCombinerOpKHR>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkFragmentShadingRateCombinerOpKHR>(0);
        }
    }

    VkPipelineMatchControl parse_VkPipelineMatchControl(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineMatchControl_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkPipelineMatchControl>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineMatchControl>(0);
        }
    }

    VkSamplerYcbcrModelConversion parse_VkSamplerYcbcrModelConversion(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSamplerYcbcrModelConversion_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkSamplerYcbcrModelConversion>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSamplerYcbcrModelConversion>(0);
        }
    }

    VkSamplerYcbcrRange parse_VkSamplerYcbcrRange(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSamplerYcbcrRange_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkSamplerYcbcrRange>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSamplerYcbcrRange>(0);
        }
    }

    VkComponentSwizzle parse_VkComponentSwizzle(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkComponentSwizzle_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkComponentSwizzle>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkComponentSwizzle>(0);
        }
    }

    VkChromaLocation parse_VkChromaLocation(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkChromaLocation_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkChromaLocation>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkChromaLocation>(0);
        }
    }

    VkFilter parse_VkFilter(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkFilter_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkFilter>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkFilter>(0);
        }
    }

    VkSamplerCreateFlagBits parse_VkSamplerCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSamplerCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSamplerCreateFlagBits>(0);
        }
    }

    VkSamplerMipmapMode parse_VkSamplerMipmapMode(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSamplerMipmapMode_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkSamplerMipmapMode>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSamplerMipmapMode>(0);
        }
    }

    VkSamplerAddressMode parse_VkSamplerAddressMode(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSamplerAddressMode_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkSamplerAddressMode>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSamplerAddressMode>(0);
        }
    }

    VkBorderColor parse_VkBorderColor(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkBorderColor_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkBorderColor>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkBorderColor>(0);
        }
    }

    VkSamplerReductionMode parse_VkSamplerReductionMode(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSamplerReductionMode_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkSamplerReductionMode>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSamplerReductionMode>(0);
        }
    }

    VkDescriptorSetLayoutCreateFlagBits parse_VkDescriptorSetLayoutCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkDescriptorSetLayoutCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkDescriptorSetLayoutCreateFlagBits>(0);
        }
    }

    VkDescriptorType parse_VkDescriptorType(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkDescriptorType_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkDescriptorType>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkDescriptorType>(0);
        }
    }

    VkDescriptorBindingFlagBits parse_VkDescriptorBindingFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkDescriptorBindingFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkDescriptorBindingFlagBits>(0);
        }
    }

    VkPipelineLayoutCreateFlagBits parse_VkPipelineLayoutCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineLayoutCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineLayoutCreateFlagBits>(0);
        }
    }

    VkRenderPassCreateFlagBits parse_VkRenderPassCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkRenderPassCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkRenderPassCreateFlagBits>(0);
        }
    }

    VkAttachmentDescriptionFlagBits parse_VkAttachmentDescriptionFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkAttachmentDescriptionFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkAttachmentDescriptionFlagBits>(0);
        }
    }

    VkAttachmentLoadOp parse_VkAttachmentLoadOp(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkAttachmentLoadOp_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkAttachmentLoadOp>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkAttachmentLoadOp>(0);
        }
    }

    VkAttachmentStoreOp parse_VkAttachmentStoreOp(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkAttachmentStoreOp_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkAttachmentStoreOp>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkAttachmentStoreOp>(0);
        }
    }

    VkImageLayout parse_VkImageLayout(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkImageLayout_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkImageLayout>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkImageLayout>(0);
        }
    }

    VkSubpassDescriptionFlagBits parse_VkSubpassDescriptionFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkSubpassDescriptionFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkSubpassDescriptionFlagBits>(0);
        }
    }

    VkPipelineBindPoint parse_VkPipelineBindPoint(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineBindPoint_c_str(json.asCString());
        } else if (json.isInt()) {
            return static_cast<VkPipelineBindPoint>(json.asInt());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineBindPoint>(0);
        }
    }

    VkPipelineStageFlagBits parse_VkPipelineStageFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineStageFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineStageFlagBits>(0);
        }
    }

    VkAccessFlagBits parse_VkAccessFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkAccessFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkAccessFlagBits>(0);
        }
    }

    VkDependencyFlagBits parse_VkDependencyFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkDependencyFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkDependencyFlagBits>(0);
        }
    }

    VkImageAspectFlagBits parse_VkImageAspectFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkImageAspectFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkImageAspectFlagBits>(0);
        }
    }

    VkResolveModeFlagBits parse_VkResolveModeFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkResolveModeFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkResolveModeFlagBits>(0);
        }
    }

    VkPipelineStageFlagBits2 parse_VkPipelineStageFlagBits2(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineStageFlagBits2_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineStageFlagBits2>(0);
        }
    }

    VkAccessFlagBits2 parse_VkAccessFlagBits2(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkAccessFlagBits2_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkAccessFlagBits2>(0);
        }
    }

    VkPipelineCacheCreateFlagBits parse_VkPipelineCacheCreateFlagBits(const Json::Value& json, const LocationScope& l) {
        if (json.isString()) {
            return parse_VkPipelineCacheCreateFlagBits_c_str(json.asCString());
        } else {
            Error() << "Invalid format";
            return static_cast<VkPipelineCacheCreateFlagBits>(0);
        }
    }

    VkPipelineCreateFlags parse_VkPipelineCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkPipelineCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineShaderStageCreateFlags parse_VkPipelineShaderStageCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkPipelineShaderStageCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineShaderStageCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineVertexInputStateCreateFlags parse_VkPipelineVertexInputStateCreateFlags(const Json::Value& json,
                                                                                      const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineVertexInputStateCreateFlags>(0);
    }

    VkPipelineInputAssemblyStateCreateFlags parse_VkPipelineInputAssemblyStateCreateFlags(const Json::Value& json,
                                                                                          const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineInputAssemblyStateCreateFlags>(0);
    }

    VkPipelineTessellationStateCreateFlags parse_VkPipelineTessellationStateCreateFlags(const Json::Value& json,
                                                                                        const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineTessellationStateCreateFlags>(0);
    }

    VkPipelineViewportStateCreateFlags parse_VkPipelineViewportStateCreateFlags(const Json::Value& json, const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineViewportStateCreateFlags>(0);
    }

    VkPipelineRasterizationStateCreateFlags parse_VkPipelineRasterizationStateCreateFlags(const Json::Value& json,
                                                                                          const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineRasterizationStateCreateFlags>(0);
    }

    VkCullModeFlags parse_VkCullModeFlags(const Json::Value& json, const LocationScope& l) {
        VkCullModeFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkCullModeFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineRasterizationConservativeStateCreateFlagsEXT parse_VkPipelineRasterizationConservativeStateCreateFlagsEXT(
        const Json::Value& json, const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineRasterizationConservativeStateCreateFlagsEXT>(0);
    }

    VkPipelineRasterizationDepthClipStateCreateFlagsEXT parse_VkPipelineRasterizationDepthClipStateCreateFlagsEXT(
        const Json::Value& json, const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineRasterizationDepthClipStateCreateFlagsEXT>(0);
    }

    VkPipelineMultisampleStateCreateFlags parse_VkPipelineMultisampleStateCreateFlags(const Json::Value& json,
                                                                                      const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineMultisampleStateCreateFlags>(0);
    }

    VkPipelineDepthStencilStateCreateFlags parse_VkPipelineDepthStencilStateCreateFlags(const Json::Value& json,
                                                                                        const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineDepthStencilStateCreateFlags>(0);
    }

    VkPipelineColorBlendStateCreateFlags parse_VkPipelineColorBlendStateCreateFlags(const Json::Value& json,
                                                                                    const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineColorBlendStateCreateFlags>(0);
    }

    VkColorComponentFlags parse_VkColorComponentFlags(const Json::Value& json, const LocationScope& l) {
        VkColorComponentFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkColorComponentFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineDynamicStateCreateFlags parse_VkPipelineDynamicStateCreateFlags(const Json::Value& json, const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineDynamicStateCreateFlags>(0);
    }

    VkPipelineCreateFlags2 parse_VkPipelineCreateFlags2(const Json::Value& json, const LocationScope& l) {
        VkPipelineCreateFlags2 result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineCreateFlagBits2_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineCreationFeedbackFlags parse_VkPipelineCreationFeedbackFlags(const Json::Value& json, const LocationScope& l) {
        VkPipelineCreationFeedbackFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineCreationFeedbackFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineDiscardRectangleStateCreateFlagsEXT parse_VkPipelineDiscardRectangleStateCreateFlagsEXT(const Json::Value& json,
                                                                                                      const LocationScope& l) {
        if (!((json.isUInt() && json.asUInt() == 0) || (json.isString() && strcmp(json.asCString(), "0") == 0))) {
            Error() << "Invalid format";
        }
        return static_cast<VkPipelineDiscardRectangleStateCreateFlagsEXT>(0);
    }

    VkSamplerCreateFlags parse_VkSamplerCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkSamplerCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkSamplerCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkDescriptorSetLayoutCreateFlags parse_VkDescriptorSetLayoutCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkDescriptorSetLayoutCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkDescriptorSetLayoutCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkShaderStageFlags parse_VkShaderStageFlags(const Json::Value& json, const LocationScope& l) {
        VkShaderStageFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkShaderStageFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkDescriptorBindingFlags parse_VkDescriptorBindingFlags(const Json::Value& json, const LocationScope& l) {
        VkDescriptorBindingFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkDescriptorBindingFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineLayoutCreateFlags parse_VkPipelineLayoutCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkPipelineLayoutCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineLayoutCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkRenderPassCreateFlags parse_VkRenderPassCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkRenderPassCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkRenderPassCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkAttachmentDescriptionFlags parse_VkAttachmentDescriptionFlags(const Json::Value& json, const LocationScope& l) {
        VkAttachmentDescriptionFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkAttachmentDescriptionFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkSubpassDescriptionFlags parse_VkSubpassDescriptionFlags(const Json::Value& json, const LocationScope& l) {
        VkSubpassDescriptionFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkSubpassDescriptionFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineStageFlags parse_VkPipelineStageFlags(const Json::Value& json, const LocationScope& l) {
        VkPipelineStageFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineStageFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkAccessFlags parse_VkAccessFlags(const Json::Value& json, const LocationScope& l) {
        VkAccessFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkAccessFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkDependencyFlags parse_VkDependencyFlags(const Json::Value& json, const LocationScope& l) {
        VkDependencyFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkDependencyFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkImageAspectFlags parse_VkImageAspectFlags(const Json::Value& json, const LocationScope& l) {
        VkImageAspectFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkImageAspectFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineStageFlags2 parse_VkPipelineStageFlags2(const Json::Value& json, const LocationScope& l) {
        VkPipelineStageFlags2 result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineStageFlagBits2_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkAccessFlags2 parse_VkAccessFlags2(const Json::Value& json, const LocationScope& l) {
        VkAccessFlags2 result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkAccessFlagBits2_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkPipelineCacheCreateFlags parse_VkPipelineCacheCreateFlags(const Json::Value& json, const LocationScope& l) {
        VkPipelineCacheCreateFlags result = 0;
        if (json.isUInt() && json.asUInt() == 0) {
            return result;
        } else if (json.isString()) {
            auto json_str = json.asCString();
            if (strcmp(json_str, "NULL") == 0 || strcmp(json_str, "0") == 0) {
                return result;
            }
            std::stringstream strm(json_str);
            std::string str;
            while (std::getline(strm, str, '|')) {
                str.erase(std::remove_if(str.begin(), str.end(), isspace), str.end());
                result |= parse_VkPipelineCacheCreateFlagBits_c_str(str.c_str());
            }
        } else {
            Error() << "Invalid format";
        }
        return result;
    }

    VkShaderModuleCreateInfo parse_VkShaderModuleCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkShaderModuleCreateInfo s{VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, nullptr};

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        const auto& json_pnext = json["pNext"];
        if (!json_pnext.isString() || strcmp(json_pnext.asCString(), "NULL") != 0) {
            Error() << "Unexpected non-NULL pNext";
        }

        const auto& json_flags = json["flags"];
        if (!json_flags.isUInt() || json_flags.asUInt() != 0) {
            Error() << "Unexpected non-zero flags";
        }

        s.codeSize = parse_size_t(json["codeSize"], CreateScope("codeSize"));
        const auto& json_pcode = json["pCode"];

        if (s.codeSize == 0) {
            s.pCode = nullptr;
            if (!(json_pcode.isNull() ||
                  (json_pcode.isString() && ((json_pcode.asString() == "") || (json_pcode.asString() == "NULL"))))) {
                Error() << "pCode is not empty or not NULL but codeSize is zero";
            }
        } else {
            size_t size = 0;
            s.pCode = reinterpret_cast<const uint32_t*>(parse_binary(json_pcode, CreateScope("pCode"), size));
            if (size != s.codeSize) {
                Error() << "pCode binary size (" << size << ") does not match expected size (" << s.codeSize << ")";
            }
        }

        return s;
    }

    VkPipelineShaderStageCreateInfo parse_VkPipelineShaderStageCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineShaderStageCreateInfo s = parse_VkPipelineShaderStageCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: {
                    auto next = AllocMem<VkDebugUtilsObjectNameInfoEXT>();
                    current_pnext_ref = "pNext<VkDebugUtilsObjectNameInfoEXT>";
                    *next = parse_VkDebugUtilsObjectNameInfoEXT_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineRobustnessCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineRobustnessCreateInfo>";
                    *next = parse_VkPipelineRobustnessCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>";
                    *next = parse_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkPipelineShaderStageCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineVertexInputStateCreateInfo parse_VkPipelineVertexInputStateCreateInfo(const Json::Value& json,
                                                                                    const LocationScope& l) {
        VkPipelineVertexInputStateCreateInfo s = parse_VkPipelineVertexInputStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineVertexInputDivisorStateCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineVertexInputDivisorStateCreateInfo>";
                    *next = parse_VkPipelineVertexInputDivisorStateCreateInfo_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkPipelineVertexInputStateCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineInputAssemblyStateCreateInfo parse_VkPipelineInputAssemblyStateCreateInfo(const Json::Value& json,
                                                                                        const LocationScope& l) {
        VkPipelineInputAssemblyStateCreateInfo s = parse_VkPipelineInputAssemblyStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkPipelineInputAssemblyStateCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineTessellationStateCreateInfo parse_VkPipelineTessellationStateCreateInfo(const Json::Value& json,
                                                                                      const LocationScope& l) {
        VkPipelineTessellationStateCreateInfo s = parse_VkPipelineTessellationStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineTessellationDomainOriginStateCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineTessellationDomainOriginStateCreateInfo>";
                    *next = parse_VkPipelineTessellationDomainOriginStateCreateInfo_contents(*json_next,
                                                                                             CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkPipelineTessellationStateCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineViewportStateCreateInfo parse_VkPipelineViewportStateCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineViewportStateCreateInfo s = parse_VkPipelineViewportStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkPipelineViewportStateCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineRasterizationStateCreateInfo parse_VkPipelineRasterizationStateCreateInfo(const Json::Value& json,
                                                                                        const LocationScope& l) {
        VkPipelineRasterizationStateCreateInfo s = parse_VkPipelineRasterizationStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkPipelineRasterizationConservativeStateCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkPipelineRasterizationConservativeStateCreateInfoEXT>";
                    *next = parse_VkPipelineRasterizationConservativeStateCreateInfoEXT_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkPipelineRasterizationDepthClipStateCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkPipelineRasterizationDepthClipStateCreateInfoEXT>";
                    *next = parse_VkPipelineRasterizationDepthClipStateCreateInfoEXT_contents(*json_next,
                                                                                              CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineRasterizationLineStateCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineRasterizationLineStateCreateInfo>";
                    *next =
                        parse_VkPipelineRasterizationLineStateCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkPipelineRasterizationStateCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkSampleLocationsInfoEXT parse_VkSampleLocationsInfoEXT(const Json::Value& json, const LocationScope& l) {
        VkSampleLocationsInfoEXT s = parse_VkSampleLocationsInfoEXT_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT") == 0) {
                s.sType = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkSampleLocationsInfoEXT: " << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineMultisampleStateCreateInfo parse_VkPipelineMultisampleStateCreateInfo(const Json::Value& json,
                                                                                    const LocationScope& l) {
        VkPipelineMultisampleStateCreateInfo s = parse_VkPipelineMultisampleStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkPipelineSampleLocationsStateCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkPipelineSampleLocationsStateCreateInfoEXT>";
                    *next = parse_VkPipelineSampleLocationsStateCreateInfoEXT_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkPipelineMultisampleStateCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineDepthStencilStateCreateInfo parse_VkPipelineDepthStencilStateCreateInfo(const Json::Value& json,
                                                                                      const LocationScope& l) {
        VkPipelineDepthStencilStateCreateInfo s = parse_VkPipelineDepthStencilStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkPipelineDepthStencilStateCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineColorBlendStateCreateInfo parse_VkPipelineColorBlendStateCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineColorBlendStateCreateInfo s = parse_VkPipelineColorBlendStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkPipelineColorBlendAdvancedStateCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkPipelineColorBlendAdvancedStateCreateInfoEXT>";
                    *next = parse_VkPipelineColorBlendAdvancedStateCreateInfoEXT_contents(*json_next,
                                                                                          CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkPipelineColorWriteCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkPipelineColorWriteCreateInfoEXT>";
                    *next = parse_VkPipelineColorWriteCreateInfoEXT_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkPipelineColorBlendStateCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineDynamicStateCreateInfo parse_VkPipelineDynamicStateCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineDynamicStateCreateInfo s = parse_VkPipelineDynamicStateCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkPipelineDynamicStateCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkGraphicsPipelineCreateInfo parse_VkGraphicsPipelineCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkGraphicsPipelineCreateInfo s = parse_VkGraphicsPipelineCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineCreateFlags2CreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineCreateFlags2CreateInfo>";
                    *next = parse_VkPipelineCreateFlags2CreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineCreationFeedbackCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineCreationFeedbackCreateInfo>";
                    *next = parse_VkPipelineCreationFeedbackCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkPipelineDiscardRectangleStateCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkPipelineDiscardRectangleStateCreateInfoEXT>";
                    *next = parse_VkPipelineDiscardRectangleStateCreateInfoEXT_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR: {
                    auto next = AllocMem<VkPipelineFragmentShadingRateStateCreateInfoKHR>();
                    current_pnext_ref = "pNext<VkPipelineFragmentShadingRateStateCreateInfoKHR>";
                    *next = parse_VkPipelineFragmentShadingRateStateCreateInfoKHR_contents(*json_next,
                                                                                           CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineOfflineCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineOfflineCreateInfo>";
                    *next = parse_VkPipelineOfflineCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineRenderingCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineRenderingCreateInfo>";
                    *next = parse_VkPipelineRenderingCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineRobustnessCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineRobustnessCreateInfo>";
                    *next = parse_VkPipelineRobustnessCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO: {
                    auto next = AllocMem<VkRenderingAttachmentLocationInfo>();
                    current_pnext_ref = "pNext<VkRenderingAttachmentLocationInfo>";
                    *next = parse_VkRenderingAttachmentLocationInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO: {
                    auto next = AllocMem<VkRenderingInputAttachmentIndexInfo>();
                    current_pnext_ref = "pNext<VkRenderingInputAttachmentIndexInfo>";
                    *next = parse_VkRenderingInputAttachmentIndexInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkGraphicsPipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkComputePipelineCreateInfo parse_VkComputePipelineCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkComputePipelineCreateInfo s = parse_VkComputePipelineCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineCreateFlags2CreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineCreateFlags2CreateInfo>";
                    *next = parse_VkPipelineCreateFlags2CreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineCreationFeedbackCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineCreationFeedbackCreateInfo>";
                    *next = parse_VkPipelineCreationFeedbackCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineOfflineCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineOfflineCreateInfo>";
                    *next = parse_VkPipelineOfflineCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO: {
                    auto next = AllocMem<VkPipelineRobustnessCreateInfo>();
                    current_pnext_ref = "pNext<VkPipelineRobustnessCreateInfo>";
                    *next = parse_VkPipelineRobustnessCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkComputePipelineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkSamplerYcbcrConversionCreateInfo parse_VkSamplerYcbcrConversionCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkSamplerYcbcrConversionCreateInfo s = parse_VkSamplerYcbcrConversionCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
#ifdef VK_USE_PLATFORM_SCREEN_QNX

                case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX: {
                    auto next = AllocMem<VkExternalFormatQNX>();
                    current_pnext_ref = "pNext<VkExternalFormatQNX>";
                    *next = parse_VkExternalFormatQNX_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }
#endif  // VK_USE_PLATFORM_SCREEN_QNX

                default:
                    Error() << "Invalid structure type extending VkSamplerYcbcrConversionCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkSamplerCreateInfo parse_VkSamplerCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkSamplerCreateInfo s = parse_VkSamplerCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: {
                    auto next = AllocMem<VkSamplerCustomBorderColorCreateInfoEXT>();
                    current_pnext_ref = "pNext<VkSamplerCustomBorderColorCreateInfoEXT>";
                    *next =
                        parse_VkSamplerCustomBorderColorCreateInfoEXT_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: {
                    auto next = AllocMem<VkSamplerReductionModeCreateInfo>();
                    current_pnext_ref = "pNext<VkSamplerReductionModeCreateInfo>";
                    *next = parse_VkSamplerReductionModeCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: {
                    auto next = AllocMem<VkSamplerYcbcrConversionInfo>();
                    current_pnext_ref = "pNext<VkSamplerYcbcrConversionInfo>";
                    *next = parse_VkSamplerYcbcrConversionInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkSamplerCreateInfo: " << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkDescriptorSetLayoutCreateInfo parse_VkDescriptorSetLayoutCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkDescriptorSetLayoutCreateInfo s = parse_VkDescriptorSetLayoutCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: {
                    auto next = AllocMem<VkDescriptorSetLayoutBindingFlagsCreateInfo>();
                    current_pnext_ref = "pNext<VkDescriptorSetLayoutBindingFlagsCreateInfo>";
                    *next = parse_VkDescriptorSetLayoutBindingFlagsCreateInfo_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkDescriptorSetLayoutCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineLayoutCreateInfo parse_VkPipelineLayoutCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineLayoutCreateInfo s = parse_VkPipelineLayoutCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkPipelineLayoutCreateInfo: " << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPhysicalDeviceFeatures2 parse_VkPhysicalDeviceFeatures2(const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceFeatures2 s = parse_VkPhysicalDeviceFeatures2_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: {
                    auto next = AllocMem<VkPhysicalDevice16BitStorageFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDevice16BitStorageFeatures>";
                    *next = parse_VkPhysicalDevice16BitStorageFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDevice4444FormatsFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDevice4444FormatsFeaturesEXT>";
                    *next = parse_VkPhysicalDevice4444FormatsFeaturesEXT_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: {
                    auto next = AllocMem<VkPhysicalDevice8BitStorageFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDevice8BitStorageFeatures>";
                    *next = parse_VkPhysicalDevice8BitStorageFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceASTCDecodeFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceASTCDecodeFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceASTCDecodeFeaturesEXT_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT_contents(*json_next,
                                                                                             CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceBufferDeviceAddressFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceBufferDeviceAddressFeatures>";
                    *next = parse_VkPhysicalDeviceBufferDeviceAddressFeatures_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceColorWriteEnableFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceColorWriteEnableFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceColorWriteEnableFeaturesEXT_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceCustomBorderColorFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceCustomBorderColorFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceCustomBorderColorFeaturesEXT_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceDepthClipEnableFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceDepthClipEnableFeaturesEXT>";
                    *next =
                        parse_VkPhysicalDeviceDepthClipEnableFeaturesEXT_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceDescriptorIndexingFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceDescriptorIndexingFeatures>";
                    *next =
                        parse_VkPhysicalDeviceDescriptorIndexingFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceDynamicRenderingFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceDynamicRenderingFeatures>";
                    *next =
                        parse_VkPhysicalDeviceDynamicRenderingFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceDynamicRenderingLocalReadFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceDynamicRenderingLocalReadFeatures>";
                    *next = parse_VkPhysicalDeviceDynamicRenderingLocalReadFeatures_contents(*json_next,
                                                                                             CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>";
                    *next = parse_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT_contents(*json_next,
                                                                                            CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT_contents(*json_next,
                                                                                           CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

#ifdef VK_USE_PLATFORM_SCI

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV: {
                    auto next = AllocMem<VkPhysicalDeviceExternalMemorySciBufFeaturesNV>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceExternalMemorySciBufFeaturesNV>";
                    *next = parse_VkPhysicalDeviceExternalMemorySciBufFeaturesNV_contents(*json_next,
                                                                                          CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }
#endif  // VK_USE_PLATFORM_SCI

#ifdef VK_USE_PLATFORM_SCREEN_QNX

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX: {
                    auto next = AllocMem<VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>";
                    *next = parse_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }
#endif  // VK_USE_PLATFORM_SCREEN_QNX

#ifdef VK_USE_PLATFORM_SCI

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV: {
                    auto next = AllocMem<VkPhysicalDeviceExternalSciSync2FeaturesNV>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceExternalSciSync2FeaturesNV>";
                    *next =
                        parse_VkPhysicalDeviceExternalSciSync2FeaturesNV_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }
#endif  // VK_USE_PLATFORM_SCI

#ifdef VK_USE_PLATFORM_SCI

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV: {
                    auto next = AllocMem<VkPhysicalDeviceExternalSciSyncFeaturesNV>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceExternalSciSyncFeaturesNV>";
                    *next =
                        parse_VkPhysicalDeviceExternalSciSyncFeaturesNV_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }
#endif  // VK_USE_PLATFORM_SCI

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT_contents(*json_next,
                                                                                              CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: {
                    auto next = AllocMem<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>";
                    *next = parse_VkPhysicalDeviceFragmentShadingRateFeaturesKHR_contents(*json_next,
                                                                                          CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceGlobalPriorityQueryFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceGlobalPriorityQueryFeatures>";
                    *next = parse_VkPhysicalDeviceGlobalPriorityQueryFeatures_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceHostImageCopyFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceHostImageCopyFeatures>";
                    *next = parse_VkPhysicalDeviceHostImageCopyFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceHostQueryResetFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceHostQueryResetFeatures>";
                    *next = parse_VkPhysicalDeviceHostQueryResetFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceImageRobustnessFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceImageRobustnessFeatures>";
                    *next =
                        parse_VkPhysicalDeviceImageRobustnessFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceImagelessFramebufferFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceImagelessFramebufferFeatures>";
                    *next = parse_VkPhysicalDeviceImagelessFramebufferFeatures_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceIndexTypeUint8Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceIndexTypeUint8Features>";
                    *next = parse_VkPhysicalDeviceIndexTypeUint8Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceInlineUniformBlockFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceInlineUniformBlockFeatures>";
                    *next =
                        parse_VkPhysicalDeviceInlineUniformBlockFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceLineRasterizationFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceLineRasterizationFeatures>";
                    *next =
                        parse_VkPhysicalDeviceLineRasterizationFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceMaintenance4Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceMaintenance4Features>";
                    *next = parse_VkPhysicalDeviceMaintenance4Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceMaintenance5Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceMaintenance5Features>";
                    *next = parse_VkPhysicalDeviceMaintenance5Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceMaintenance6Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceMaintenance6Features>";
                    *next = parse_VkPhysicalDeviceMaintenance6Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceMultiviewFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceMultiviewFeatures>";
                    *next = parse_VkPhysicalDeviceMultiviewFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: {
                    auto next = AllocMem<VkPhysicalDevicePerformanceQueryFeaturesKHR>();
                    current_pnext_ref = "pNext<VkPhysicalDevicePerformanceQueryFeaturesKHR>";
                    *next = parse_VkPhysicalDevicePerformanceQueryFeaturesKHR_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES: {
                    auto next = AllocMem<VkPhysicalDevicePipelineCreationCacheControlFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDevicePipelineCreationCacheControlFeatures>";
                    *next = parse_VkPhysicalDevicePipelineCreationCacheControlFeatures_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDevicePipelineProtectedAccessFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDevicePipelineProtectedAccessFeatures>";
                    *next = parse_VkPhysicalDevicePipelineProtectedAccessFeatures_contents(*json_next,
                                                                                           CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDevicePipelineRobustnessFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDevicePipelineRobustnessFeatures>";
                    *next =
                        parse_VkPhysicalDevicePipelineRobustnessFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: {
                    auto next = AllocMem<VkPhysicalDevicePrivateDataFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDevicePrivateDataFeatures>";
                    *next = parse_VkPhysicalDevicePrivateDataFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceProtectedMemoryFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceProtectedMemoryFeatures>";
                    *next =
                        parse_VkPhysicalDeviceProtectedMemoryFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR: {
                    auto next = AllocMem<VkPhysicalDeviceRobustness2FeaturesKHR>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceRobustness2FeaturesKHR>";
                    *next = parse_VkPhysicalDeviceRobustness2FeaturesKHR_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceSamplerYcbcrConversionFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceSamplerYcbcrConversionFeatures>";
                    *next = parse_VkPhysicalDeviceSamplerYcbcrConversionFeatures_contents(*json_next,
                                                                                          CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceScalarBlockLayoutFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceScalarBlockLayoutFeatures>";
                    *next =
                        parse_VkPhysicalDeviceScalarBlockLayoutFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>";
                    *next = parse_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderAtomicInt64Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderAtomicInt64Features>";
                    *next =
                        parse_VkPhysicalDeviceShaderAtomicInt64Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: {
                    auto next = AllocMem<VkPhysicalDeviceShaderClockFeaturesKHR>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderClockFeaturesKHR>";
                    *next = parse_VkPhysicalDeviceShaderClockFeaturesKHR_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>";
                    *next = parse_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderDrawParametersFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderDrawParametersFeatures>";
                    *next = parse_VkPhysicalDeviceShaderDrawParametersFeatures_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderExpectAssumeFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderExpectAssumeFeatures>";
                    *next =
                        parse_VkPhysicalDeviceShaderExpectAssumeFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderFloat16Int8Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderFloat16Int8Features>";
                    *next =
                        parse_VkPhysicalDeviceShaderFloat16Int8Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderFloatControls2Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderFloatControls2Features>";
                    *next = parse_VkPhysicalDeviceShaderFloatControls2Features_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>";
                    *next = parse_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT_contents(*json_next,
                                                                                             CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderIntegerDotProductFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderIntegerDotProductFeatures>";
                    *next = parse_VkPhysicalDeviceShaderIntegerDotProductFeatures_contents(*json_next,
                                                                                           CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>";
                    *next = parse_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderSubgroupRotateFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderSubgroupRotateFeatures>";
                    *next = parse_VkPhysicalDeviceShaderSubgroupRotateFeatures_contents(*json_next,
                                                                                        CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceShaderTerminateInvocationFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceShaderTerminateInvocationFeatures>";
                    *next = parse_VkPhysicalDeviceShaderTerminateInvocationFeatures_contents(*json_next,
                                                                                             CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceSubgroupSizeControlFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceSubgroupSizeControlFeatures>";
                    *next = parse_VkPhysicalDeviceSubgroupSizeControlFeatures_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceSynchronization2Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceSynchronization2Features>";
                    *next =
                        parse_VkPhysicalDeviceSynchronization2Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT_contents(*json_next,
                                                                                           CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceTextureCompressionASTCHDRFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceTextureCompressionASTCHDRFeatures>";
                    *next = parse_VkPhysicalDeviceTextureCompressionASTCHDRFeatures_contents(*json_next,
                                                                                             CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceTimelineSemaphoreFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceTimelineSemaphoreFeatures>";
                    *next =
                        parse_VkPhysicalDeviceTimelineSemaphoreFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>";
                    *next = parse_VkPhysicalDeviceUniformBufferStandardLayoutFeatures_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVariablePointersFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVariablePointersFeatures>";
                    *next =
                        parse_VkPhysicalDeviceVariablePointersFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVertexAttributeDivisorFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVertexAttributeDivisorFeatures>";
                    *next = parse_VkPhysicalDeviceVertexAttributeDivisorFeatures_contents(*json_next,
                                                                                          CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT_contents(*json_next,
                                                                                              CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVulkan11Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVulkan11Features>";
                    *next = parse_VkPhysicalDeviceVulkan11Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVulkan12Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVulkan12Features>";
                    *next = parse_VkPhysicalDeviceVulkan12Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVulkan13Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVulkan13Features>";
                    *next = parse_VkPhysicalDeviceVulkan13Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVulkan14Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVulkan14Features>";
                    *next = parse_VkPhysicalDeviceVulkan14Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVulkanMemoryModelFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVulkanMemoryModelFeatures>";
                    *next =
                        parse_VkPhysicalDeviceVulkanMemoryModelFeatures_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceVulkanSC10Features>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceVulkanSC10Features>";
                    *next = parse_VkPhysicalDeviceVulkanSC10Features_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT_contents(*json_next,
                                                                                            CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: {
                    auto next = AllocMem<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>";
                    *next = parse_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES: {
                    auto next = AllocMem<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>();
                    current_pnext_ref = "pNext<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>";
                    *next = parse_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures_contents(
                        *json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkPhysicalDeviceFeatures2: " << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkRenderPassCreateInfo parse_VkRenderPassCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkRenderPassCreateInfo s = parse_VkRenderPassCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: {
                    auto next = AllocMem<VkRenderPassInputAttachmentAspectCreateInfo>();
                    current_pnext_ref = "pNext<VkRenderPassInputAttachmentAspectCreateInfo>";
                    *next = parse_VkRenderPassInputAttachmentAspectCreateInfo_contents(*json_next,
                                                                                       CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: {
                    auto next = AllocMem<VkRenderPassMultiviewCreateInfo>();
                    current_pnext_ref = "pNext<VkRenderPassMultiviewCreateInfo>";
                    *next = parse_VkRenderPassMultiviewCreateInfo_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkRenderPassCreateInfo: " << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkAttachmentDescription2 parse_VkAttachmentDescription2(const Json::Value& json, const LocationScope& l) {
        VkAttachmentDescription2 s = parse_VkAttachmentDescription2_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2") == 0) {
                s.sType = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: {
                    auto next = AllocMem<VkAttachmentDescriptionStencilLayout>();
                    current_pnext_ref = "pNext<VkAttachmentDescriptionStencilLayout>";
                    *next = parse_VkAttachmentDescriptionStencilLayout_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkAttachmentDescription2: " << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkAttachmentReference2 parse_VkAttachmentReference2(const Json::Value& json, const LocationScope& l) {
        VkAttachmentReference2 s = parse_VkAttachmentReference2_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2") == 0) {
                s.sType = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: {
                    auto next = AllocMem<VkAttachmentReferenceStencilLayout>();
                    current_pnext_ref = "pNext<VkAttachmentReferenceStencilLayout>";
                    *next = parse_VkAttachmentReferenceStencilLayout_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkAttachmentReference2: " << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkSubpassDescription2 parse_VkSubpassDescription2(const Json::Value& json, const LocationScope& l) {
        VkSubpassDescription2 s = parse_VkSubpassDescription2_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2") == 0) {
                s.sType = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: {
                    auto next = AllocMem<VkFragmentShadingRateAttachmentInfoKHR>();
                    current_pnext_ref = "pNext<VkFragmentShadingRateAttachmentInfoKHR>";
                    *next = parse_VkFragmentShadingRateAttachmentInfoKHR_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: {
                    auto next = AllocMem<VkSubpassDescriptionDepthStencilResolve>();
                    current_pnext_ref = "pNext<VkSubpassDescriptionDepthStencilResolve>";
                    *next =
                        parse_VkSubpassDescriptionDepthStencilResolve_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkSubpassDescription2: " << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkSubpassDependency2 parse_VkSubpassDependency2(const Json::Value& json, const LocationScope& l) {
        VkSubpassDependency2 s = parse_VkSubpassDependency2_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2") == 0) {
                s.sType = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2: {
                    auto next = AllocMem<VkMemoryBarrier2>();
                    current_pnext_ref = "pNext<VkMemoryBarrier2>";
                    *next = parse_VkMemoryBarrier2_contents(*json_next, CreateScope(current_pnext_ref, true));
                    next->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
                    prev->pNext = reinterpret_cast<VkBaseOutStructure*>(next);
                    break;
                }

                default:
                    Error() << "Invalid structure type extending VkSubpassDependency2: " << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkRenderPassCreateInfo2 parse_VkRenderPassCreateInfo2(const Json::Value& json, const LocationScope& l) {
        VkRenderPassCreateInfo2 s = parse_VkRenderPassCreateInfo2_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2") == 0) {
                s.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkRenderPassCreateInfo2: " << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineCacheCreateInfo parse_VkPipelineCacheCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineCacheCreateInfo s = parse_VkPipelineCacheCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkPipelineCacheCreateInfo: " << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelinePoolSize parse_VkPipelinePoolSize(const Json::Value& json, const LocationScope& l) {
        VkPipelinePoolSize s = parse_VkPipelinePoolSize_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkPipelinePoolSize: " << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkDeviceObjectReservationCreateInfo parse_VkDeviceObjectReservationCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkDeviceObjectReservationCreateInfo s = parse_VkDeviceObjectReservationCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkDeviceObjectReservationCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

    VkPipelineOfflineCreateInfo parse_VkPipelineOfflineCreateInfo(const Json::Value& json, const LocationScope& l) {
        VkPipelineOfflineCreateInfo s = parse_VkPipelineOfflineCreateInfo_contents(json, l);

        const auto& json_stype = json["sType"];
        if (json_stype.isString()) {
            if (strcmp(json_stype.asCString(), "VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO") == 0) {
                s.sType = VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO;
            } else {
                Error() << "Invalid sType value: " << json_stype.asCString();
            }
        } else {
            Error() << "Invalid sType format";
        }

        [[maybe_unused]] auto prev = reinterpret_cast<VkBaseOutStructure*>(&s);
        const Json::Value* json_next = &json["pNext"];
        const char* current_pnext_ref = "pNext";
        while (json_next->isObject()) {
            auto next_stype = parse_VkStructureType((*json_next)["sType"], CreateScope(current_pnext_ref));
            switch (next_stype) {
                default:
                    Error() << "Invalid structure type extending VkPipelineOfflineCreateInfo: "
                            << (*json_next)["sType"].asCString();
                    break;
            }
            json_next = &(*json_next)["pNext"];
            if (prev->pNext != nullptr) prev = prev->pNext;
        }

        if (!json_next->isString() || strcmp(json_next->asCString(), "NULL") != 0) {
            Error() << "Invalid pNext format";
        }
        return s;
    }

  private:
    VkSpecializationMapEntry parse_VkSpecializationMapEntry_contents(const Json::Value& json, const LocationScope& l) {
        VkSpecializationMapEntry s{};
        s.constantID = parse_uint32_t(json["constantID"], CreateScope("constantID"));
        s.offset = parse_uint32_t(json["offset"], CreateScope("offset"));
        s.size = parse_size_t(json["size"], CreateScope("size"));
        return s;
    }

    VkSpecializationInfo parse_VkSpecializationInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkSpecializationInfo s{};
        s.mapEntryCount = parse_uint32_t(json["mapEntryCount"], CreateScope("mapEntryCount"));
        {
            const Json::Value& json_member = json["pMapEntries"];

            if (s.mapEntryCount == 0) {
                s.pMapEntries = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pMapEntries is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.mapEntryCount) {
                        auto dst_buffer = AllocMem<VkSpecializationMapEntry>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkSpecializationMapEntry_contents(json_member[i], CreateScope("pMapEntries", i));
                        }
                        s.pMapEntries = dst_buffer;
                    } else {
                        Error() << "pMapEntries array size (" << json_member.size() << ") does not match expected length ("
                                << s.mapEntryCount << ")";
                    }
                } else {
                    Error() << "pMapEntries is not an array";
                }
            }
        }
        s.dataSize = parse_size_t(json["dataSize"], CreateScope("dataSize"));
        {
            const Json::Value& json_member = json["pData"];
            if (s.dataSize == 0) {
                s.pData = nullptr;
                if (!(json_member.isNull() ||
                      (json_member.isString() && ((json_member.asString() == "") || (json_member.asString() == "NULL"))))) {
                    Error() << "pData is not empty or not NULL but its length is zero";
                }
            } else {
                size_t size = 0;
                s.pData = parse_binary(json_member, CreateScope("pData"), size);
                if (size != s.dataSize) {
                    Error() << "pData binary size (" << size << ") does not match expected size (" << s.dataSize << ")";
                }
            }
        }

        return s;
    }

    VkPipelineShaderStageCreateInfo parse_VkPipelineShaderStageCreateInfo_contents(const Json::Value& json,
                                                                                   const LocationScope& l) {
        VkPipelineShaderStageCreateInfo s{};
        s.flags = parse_VkPipelineShaderStageCreateFlags(json["flags"], CreateScope("flags"));
        s.stage = parse_VkShaderStageFlagBits(json["stage"], CreateScope("stage"));
        s.module = parse_VkShaderModule(json["module"], CreateScope("module"));
        s.pName = parse_string(json["pName"], CreateScope("pName"));
        {
            const Json::Value& json_member = json["pSpecializationInfo"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pSpecializationInfo = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkSpecializationInfo>();
                *dst_buffer = parse_VkSpecializationInfo_contents(json_member, CreateScope("pSpecializationInfo", true));
                s.pSpecializationInfo = dst_buffer;
            }
        }

        return s;
    }

    VkDebugUtilsObjectNameInfoEXT parse_VkDebugUtilsObjectNameInfoEXT_contents(const Json::Value& json, const LocationScope& l) {
        VkDebugUtilsObjectNameInfoEXT s{};
        s.objectType = parse_VkObjectType(json["objectType"], CreateScope("objectType"));
        s.objectHandle = parse_uint64_t(json["objectHandle"], CreateScope("objectHandle"));
        s.pObjectName = parse_string(json["pObjectName"], CreateScope("pObjectName"));
        return s;
    }

    VkPipelineRobustnessCreateInfo parse_VkPipelineRobustnessCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelineRobustnessCreateInfo s{};
        s.storageBuffers = parse_VkPipelineRobustnessBufferBehavior(json["storageBuffers"], CreateScope("storageBuffers"));
        s.uniformBuffers = parse_VkPipelineRobustnessBufferBehavior(json["uniformBuffers"], CreateScope("uniformBuffers"));
        s.vertexInputs = parse_VkPipelineRobustnessBufferBehavior(json["vertexInputs"], CreateScope("vertexInputs"));
        s.images = parse_VkPipelineRobustnessImageBehavior(json["images"], CreateScope("images"));
        return s;
    }

    VkPipelineShaderStageRequiredSubgroupSizeCreateInfo parse_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineShaderStageRequiredSubgroupSizeCreateInfo s{};
        s.requiredSubgroupSize = parse_uint32_t(json["requiredSubgroupSize"], CreateScope("requiredSubgroupSize"));
        return s;
    }

    VkVertexInputBindingDescription parse_VkVertexInputBindingDescription_contents(const Json::Value& json,
                                                                                   const LocationScope& l) {
        VkVertexInputBindingDescription s{};
        s.binding = parse_uint32_t(json["binding"], CreateScope("binding"));
        s.stride = parse_uint32_t(json["stride"], CreateScope("stride"));
        s.inputRate = parse_VkVertexInputRate(json["inputRate"], CreateScope("inputRate"));
        return s;
    }

    VkVertexInputAttributeDescription parse_VkVertexInputAttributeDescription_contents(const Json::Value& json,
                                                                                       const LocationScope& l) {
        VkVertexInputAttributeDescription s{};
        s.location = parse_uint32_t(json["location"], CreateScope("location"));
        s.binding = parse_uint32_t(json["binding"], CreateScope("binding"));
        s.format = parse_VkFormat(json["format"], CreateScope("format"));
        s.offset = parse_uint32_t(json["offset"], CreateScope("offset"));
        return s;
    }

    VkPipelineVertexInputStateCreateInfo parse_VkPipelineVertexInputStateCreateInfo_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPipelineVertexInputStateCreateInfo s{};
        s.flags = parse_VkPipelineVertexInputStateCreateFlags(json["flags"], CreateScope("flags"));
        s.vertexBindingDescriptionCount =
            parse_uint32_t(json["vertexBindingDescriptionCount"], CreateScope("vertexBindingDescriptionCount"));
        {
            const Json::Value& json_member = json["pVertexBindingDescriptions"];

            if (s.vertexBindingDescriptionCount == 0) {
                s.pVertexBindingDescriptions = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pVertexBindingDescriptions is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.vertexBindingDescriptionCount) {
                        auto dst_buffer = AllocMem<VkVertexInputBindingDescription>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkVertexInputBindingDescription_contents(
                                json_member[i], CreateScope("pVertexBindingDescriptions", i));
                        }
                        s.pVertexBindingDescriptions = dst_buffer;
                    } else {
                        Error() << "pVertexBindingDescriptions array size (" << json_member.size()
                                << ") does not match expected length (" << s.vertexBindingDescriptionCount << ")";
                    }
                } else {
                    Error() << "pVertexBindingDescriptions is not an array";
                }
            }
        }
        s.vertexAttributeDescriptionCount =
            parse_uint32_t(json["vertexAttributeDescriptionCount"], CreateScope("vertexAttributeDescriptionCount"));
        {
            const Json::Value& json_member = json["pVertexAttributeDescriptions"];

            if (s.vertexAttributeDescriptionCount == 0) {
                s.pVertexAttributeDescriptions = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pVertexAttributeDescriptions is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.vertexAttributeDescriptionCount) {
                        auto dst_buffer = AllocMem<VkVertexInputAttributeDescription>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkVertexInputAttributeDescription_contents(
                                json_member[i], CreateScope("pVertexAttributeDescriptions", i));
                        }
                        s.pVertexAttributeDescriptions = dst_buffer;
                    } else {
                        Error() << "pVertexAttributeDescriptions array size (" << json_member.size()
                                << ") does not match expected length (" << s.vertexAttributeDescriptionCount << ")";
                    }
                } else {
                    Error() << "pVertexAttributeDescriptions is not an array";
                }
            }
        }

        return s;
    }

    VkVertexInputBindingDivisorDescription parse_VkVertexInputBindingDivisorDescription_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkVertexInputBindingDivisorDescription s{};
        s.binding = parse_uint32_t(json["binding"], CreateScope("binding"));
        s.divisor = parse_uint32_t(json["divisor"], CreateScope("divisor"));
        return s;
    }

    VkPipelineVertexInputDivisorStateCreateInfo parse_VkPipelineVertexInputDivisorStateCreateInfo_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPipelineVertexInputDivisorStateCreateInfo s{};
        s.vertexBindingDivisorCount = parse_uint32_t(json["vertexBindingDivisorCount"], CreateScope("vertexBindingDivisorCount"));
        {
            const Json::Value& json_member = json["pVertexBindingDivisors"];

            if (s.vertexBindingDivisorCount == 0) {
                s.pVertexBindingDivisors = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pVertexBindingDivisors is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.vertexBindingDivisorCount) {
                        auto dst_buffer = AllocMem<VkVertexInputBindingDivisorDescription>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkVertexInputBindingDivisorDescription_contents(
                                json_member[i], CreateScope("pVertexBindingDivisors", i));
                        }
                        s.pVertexBindingDivisors = dst_buffer;
                    } else {
                        Error() << "pVertexBindingDivisors array size (" << json_member.size()
                                << ") does not match expected length (" << s.vertexBindingDivisorCount << ")";
                    }
                } else {
                    Error() << "pVertexBindingDivisors is not an array";
                }
            }
        }

        return s;
    }

    VkPipelineInputAssemblyStateCreateInfo parse_VkPipelineInputAssemblyStateCreateInfo_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPipelineInputAssemblyStateCreateInfo s{};
        s.flags = parse_VkPipelineInputAssemblyStateCreateFlags(json["flags"], CreateScope("flags"));
        s.topology = parse_VkPrimitiveTopology(json["topology"], CreateScope("topology"));
        s.primitiveRestartEnable = parse_VkBool32(json["primitiveRestartEnable"], CreateScope("primitiveRestartEnable"));
        return s;
    }

    VkPipelineTessellationStateCreateInfo parse_VkPipelineTessellationStateCreateInfo_contents(const Json::Value& json,
                                                                                               const LocationScope& l) {
        VkPipelineTessellationStateCreateInfo s{};
        s.flags = parse_VkPipelineTessellationStateCreateFlags(json["flags"], CreateScope("flags"));
        s.patchControlPoints = parse_uint32_t(json["patchControlPoints"], CreateScope("patchControlPoints"));
        return s;
    }

    VkPipelineTessellationDomainOriginStateCreateInfo parse_VkPipelineTessellationDomainOriginStateCreateInfo_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineTessellationDomainOriginStateCreateInfo s{};
        s.domainOrigin = parse_VkTessellationDomainOrigin(json["domainOrigin"], CreateScope("domainOrigin"));
        return s;
    }

    VkViewport parse_VkViewport_contents(const Json::Value& json, const LocationScope& l) {
        VkViewport s{};
        s.x = parse_float(json["x"], CreateScope("x"));
        s.y = parse_float(json["y"], CreateScope("y"));
        s.width = parse_float(json["width"], CreateScope("width"));
        s.height = parse_float(json["height"], CreateScope("height"));
        s.minDepth = parse_float(json["minDepth"], CreateScope("minDepth"));
        s.maxDepth = parse_float(json["maxDepth"], CreateScope("maxDepth"));
        return s;
    }

    VkOffset2D parse_VkOffset2D_contents(const Json::Value& json, const LocationScope& l) {
        VkOffset2D s{};
        s.x = parse_int32_t(json["x"], CreateScope("x"));
        s.y = parse_int32_t(json["y"], CreateScope("y"));
        return s;
    }

    VkExtent2D parse_VkExtent2D_contents(const Json::Value& json, const LocationScope& l) {
        VkExtent2D s{};
        s.width = parse_uint32_t(json["width"], CreateScope("width"));
        s.height = parse_uint32_t(json["height"], CreateScope("height"));
        return s;
    }

    VkRect2D parse_VkRect2D_contents(const Json::Value& json, const LocationScope& l) {
        VkRect2D s{};
        s.offset = parse_VkOffset2D_contents(json["offset"], CreateScope("offset"));
        s.extent = parse_VkExtent2D_contents(json["extent"], CreateScope("extent"));
        return s;
    }

    VkPipelineViewportStateCreateInfo parse_VkPipelineViewportStateCreateInfo_contents(const Json::Value& json,
                                                                                       const LocationScope& l) {
        VkPipelineViewportStateCreateInfo s{};
        s.flags = parse_VkPipelineViewportStateCreateFlags(json["flags"], CreateScope("flags"));
        s.viewportCount = parse_uint32_t(json["viewportCount"], CreateScope("viewportCount"));
        {
            const Json::Value& json_member = json["pViewports"];

            if (s.viewportCount == 0) {
                s.pViewports = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pViewports is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.viewportCount) {
                        auto dst_buffer = AllocMem<VkViewport>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkViewport_contents(json_member[i], CreateScope("pViewports", i));
                        }
                        s.pViewports = dst_buffer;
                    } else {
                        Error() << "pViewports array size (" << json_member.size() << ") does not match expected length ("
                                << s.viewportCount << ")";
                    }
                } else if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                    s.pViewports = nullptr;
                } else {
                    Error() << "pViewports is not an array and is not NULL";
                }
            }
        }
        s.scissorCount = parse_uint32_t(json["scissorCount"], CreateScope("scissorCount"));
        {
            const Json::Value& json_member = json["pScissors"];

            if (s.scissorCount == 0) {
                s.pScissors = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pScissors is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.scissorCount) {
                        auto dst_buffer = AllocMem<VkRect2D>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkRect2D_contents(json_member[i], CreateScope("pScissors", i));
                        }
                        s.pScissors = dst_buffer;
                    } else {
                        Error() << "pScissors array size (" << json_member.size() << ") does not match expected length ("
                                << s.scissorCount << ")";
                    }
                } else if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                    s.pScissors = nullptr;
                } else {
                    Error() << "pScissors is not an array and is not NULL";
                }
            }
        }

        return s;
    }

    VkPipelineRasterizationStateCreateInfo parse_VkPipelineRasterizationStateCreateInfo_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPipelineRasterizationStateCreateInfo s{};
        s.flags = parse_VkPipelineRasterizationStateCreateFlags(json["flags"], CreateScope("flags"));
        s.depthClampEnable = parse_VkBool32(json["depthClampEnable"], CreateScope("depthClampEnable"));
        s.rasterizerDiscardEnable = parse_VkBool32(json["rasterizerDiscardEnable"], CreateScope("rasterizerDiscardEnable"));
        s.polygonMode = parse_VkPolygonMode(json["polygonMode"], CreateScope("polygonMode"));
        s.cullMode = parse_VkCullModeFlags(json["cullMode"], CreateScope("cullMode"));
        s.frontFace = parse_VkFrontFace(json["frontFace"], CreateScope("frontFace"));
        s.depthBiasEnable = parse_VkBool32(json["depthBiasEnable"], CreateScope("depthBiasEnable"));
        s.depthBiasConstantFactor = parse_float(json["depthBiasConstantFactor"], CreateScope("depthBiasConstantFactor"));
        s.depthBiasClamp = parse_float(json["depthBiasClamp"], CreateScope("depthBiasClamp"));
        s.depthBiasSlopeFactor = parse_float(json["depthBiasSlopeFactor"], CreateScope("depthBiasSlopeFactor"));
        s.lineWidth = parse_float(json["lineWidth"], CreateScope("lineWidth"));
        return s;
    }

    VkPipelineRasterizationConservativeStateCreateInfoEXT parse_VkPipelineRasterizationConservativeStateCreateInfoEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineRasterizationConservativeStateCreateInfoEXT s{};
        s.flags = parse_VkPipelineRasterizationConservativeStateCreateFlagsEXT(json["flags"], CreateScope("flags"));
        s.conservativeRasterizationMode = parse_VkConservativeRasterizationModeEXT(json["conservativeRasterizationMode"],
                                                                                   CreateScope("conservativeRasterizationMode"));
        s.extraPrimitiveOverestimationSize =
            parse_float(json["extraPrimitiveOverestimationSize"], CreateScope("extraPrimitiveOverestimationSize"));
        return s;
    }

    VkPipelineRasterizationDepthClipStateCreateInfoEXT parse_VkPipelineRasterizationDepthClipStateCreateInfoEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineRasterizationDepthClipStateCreateInfoEXT s{};
        s.flags = parse_VkPipelineRasterizationDepthClipStateCreateFlagsEXT(json["flags"], CreateScope("flags"));
        s.depthClipEnable = parse_VkBool32(json["depthClipEnable"], CreateScope("depthClipEnable"));
        return s;
    }

    VkPipelineRasterizationLineStateCreateInfo parse_VkPipelineRasterizationLineStateCreateInfo_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPipelineRasterizationLineStateCreateInfo s{};
        s.lineRasterizationMode =
            parse_VkLineRasterizationMode(json["lineRasterizationMode"], CreateScope("lineRasterizationMode"));
        s.stippledLineEnable = parse_VkBool32(json["stippledLineEnable"], CreateScope("stippledLineEnable"));
        s.lineStippleFactor = parse_uint32_t(json["lineStippleFactor"], CreateScope("lineStippleFactor"));
        s.lineStipplePattern = parse_uint16_t(json["lineStipplePattern"], CreateScope("lineStipplePattern"));
        return s;
    }

    VkPipelineMultisampleStateCreateInfo parse_VkPipelineMultisampleStateCreateInfo_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPipelineMultisampleStateCreateInfo s{};
        s.flags = parse_VkPipelineMultisampleStateCreateFlags(json["flags"], CreateScope("flags"));
        s.rasterizationSamples = parse_VkSampleCountFlagBits(json["rasterizationSamples"], CreateScope("rasterizationSamples"));
        s.sampleShadingEnable = parse_VkBool32(json["sampleShadingEnable"], CreateScope("sampleShadingEnable"));
        s.minSampleShading = parse_float(json["minSampleShading"], CreateScope("minSampleShading"));
        {
            const Json::Value& json_member = json["pSampleMask"];

            if (size_t((s.rasterizationSamples + 31) / 32) == 0) {
                s.pSampleMask = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pSampleMask is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == size_t((s.rasterizationSamples + 31) / 32)) {
                        auto dst_buffer = AllocMem<VkSampleMask>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkSampleMask(json_member[i], CreateScope("pSampleMask", i));
                        }
                        s.pSampleMask = dst_buffer;
                    } else {
                        Error() << "pSampleMask array size (" << json_member.size() << ") does not match expected length ("
                                << size_t((s.rasterizationSamples + 31) / 32) << ")";
                    }
                } else if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                    s.pSampleMask = nullptr;
                } else {
                    Error() << "pSampleMask is not an array and is not NULL";
                }
            }
        }
        s.alphaToCoverageEnable = parse_VkBool32(json["alphaToCoverageEnable"], CreateScope("alphaToCoverageEnable"));
        s.alphaToOneEnable = parse_VkBool32(json["alphaToOneEnable"], CreateScope("alphaToOneEnable"));
        return s;
    }

    VkSampleLocationEXT parse_VkSampleLocationEXT_contents(const Json::Value& json, const LocationScope& l) {
        VkSampleLocationEXT s{};
        s.x = parse_float(json["x"], CreateScope("x"));
        s.y = parse_float(json["y"], CreateScope("y"));
        return s;
    }

    VkSampleLocationsInfoEXT parse_VkSampleLocationsInfoEXT_contents(const Json::Value& json, const LocationScope& l) {
        VkSampleLocationsInfoEXT s{};
        s.sampleLocationsPerPixel =
            parse_VkSampleCountFlagBits(json["sampleLocationsPerPixel"], CreateScope("sampleLocationsPerPixel"));
        s.sampleLocationGridSize = parse_VkExtent2D_contents(json["sampleLocationGridSize"], CreateScope("sampleLocationGridSize"));
        s.sampleLocationsCount = parse_uint32_t(json["sampleLocationsCount"], CreateScope("sampleLocationsCount"));
        {
            const Json::Value& json_member = json["pSampleLocations"];

            if (s.sampleLocationsCount == 0) {
                s.pSampleLocations = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pSampleLocations is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.sampleLocationsCount) {
                        auto dst_buffer = AllocMem<VkSampleLocationEXT>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkSampleLocationEXT_contents(json_member[i], CreateScope("pSampleLocations", i));
                        }
                        s.pSampleLocations = dst_buffer;
                    } else {
                        Error() << "pSampleLocations array size (" << json_member.size() << ") does not match expected length ("
                                << s.sampleLocationsCount << ")";
                    }
                } else {
                    Error() << "pSampleLocations is not an array";
                }
            }
        }

        return s;
    }

    VkPipelineSampleLocationsStateCreateInfoEXT parse_VkPipelineSampleLocationsStateCreateInfoEXT_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPipelineSampleLocationsStateCreateInfoEXT s{};
        s.sampleLocationsEnable = parse_VkBool32(json["sampleLocationsEnable"], CreateScope("sampleLocationsEnable"));
        s.sampleLocationsInfo = parse_VkSampleLocationsInfoEXT(json["sampleLocationsInfo"], CreateScope("sampleLocationsInfo"));
        return s;
    }

    VkStencilOpState parse_VkStencilOpState_contents(const Json::Value& json, const LocationScope& l) {
        VkStencilOpState s{};
        s.failOp = parse_VkStencilOp(json["failOp"], CreateScope("failOp"));
        s.passOp = parse_VkStencilOp(json["passOp"], CreateScope("passOp"));
        s.depthFailOp = parse_VkStencilOp(json["depthFailOp"], CreateScope("depthFailOp"));
        s.compareOp = parse_VkCompareOp(json["compareOp"], CreateScope("compareOp"));
        s.compareMask = parse_uint32_t(json["compareMask"], CreateScope("compareMask"));
        s.writeMask = parse_uint32_t(json["writeMask"], CreateScope("writeMask"));
        s.reference = parse_uint32_t(json["reference"], CreateScope("reference"));
        return s;
    }

    VkPipelineDepthStencilStateCreateInfo parse_VkPipelineDepthStencilStateCreateInfo_contents(const Json::Value& json,
                                                                                               const LocationScope& l) {
        VkPipelineDepthStencilStateCreateInfo s{};
        s.flags = parse_VkPipelineDepthStencilStateCreateFlags(json["flags"], CreateScope("flags"));
        s.depthTestEnable = parse_VkBool32(json["depthTestEnable"], CreateScope("depthTestEnable"));
        s.depthWriteEnable = parse_VkBool32(json["depthWriteEnable"], CreateScope("depthWriteEnable"));
        s.depthCompareOp = parse_VkCompareOp(json["depthCompareOp"], CreateScope("depthCompareOp"));
        s.depthBoundsTestEnable = parse_VkBool32(json["depthBoundsTestEnable"], CreateScope("depthBoundsTestEnable"));
        s.stencilTestEnable = parse_VkBool32(json["stencilTestEnable"], CreateScope("stencilTestEnable"));
        s.front = parse_VkStencilOpState_contents(json["front"], CreateScope("front"));
        s.back = parse_VkStencilOpState_contents(json["back"], CreateScope("back"));
        s.minDepthBounds = parse_float(json["minDepthBounds"], CreateScope("minDepthBounds"));
        s.maxDepthBounds = parse_float(json["maxDepthBounds"], CreateScope("maxDepthBounds"));
        return s;
    }

    VkPipelineColorBlendAttachmentState parse_VkPipelineColorBlendAttachmentState_contents(const Json::Value& json,
                                                                                           const LocationScope& l) {
        VkPipelineColorBlendAttachmentState s{};
        s.blendEnable = parse_VkBool32(json["blendEnable"], CreateScope("blendEnable"));
        s.srcColorBlendFactor = parse_VkBlendFactor(json["srcColorBlendFactor"], CreateScope("srcColorBlendFactor"));
        s.dstColorBlendFactor = parse_VkBlendFactor(json["dstColorBlendFactor"], CreateScope("dstColorBlendFactor"));
        s.colorBlendOp = parse_VkBlendOp(json["colorBlendOp"], CreateScope("colorBlendOp"));
        s.srcAlphaBlendFactor = parse_VkBlendFactor(json["srcAlphaBlendFactor"], CreateScope("srcAlphaBlendFactor"));
        s.dstAlphaBlendFactor = parse_VkBlendFactor(json["dstAlphaBlendFactor"], CreateScope("dstAlphaBlendFactor"));
        s.alphaBlendOp = parse_VkBlendOp(json["alphaBlendOp"], CreateScope("alphaBlendOp"));
        s.colorWriteMask = parse_VkColorComponentFlags(json["colorWriteMask"], CreateScope("colorWriteMask"));
        return s;
    }

    VkPipelineColorBlendStateCreateInfo parse_VkPipelineColorBlendStateCreateInfo_contents(const Json::Value& json,
                                                                                           const LocationScope& l) {
        VkPipelineColorBlendStateCreateInfo s{};
        s.flags = parse_VkPipelineColorBlendStateCreateFlags(json["flags"], CreateScope("flags"));
        s.logicOpEnable = parse_VkBool32(json["logicOpEnable"], CreateScope("logicOpEnable"));
        s.logicOp = parse_VkLogicOp(json["logicOp"], CreateScope("logicOp"));
        s.attachmentCount = parse_uint32_t(json["attachmentCount"], CreateScope("attachmentCount"));
        {
            const Json::Value& json_member = json["pAttachments"];

            if (s.attachmentCount == 0) {
                s.pAttachments = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pAttachments is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.attachmentCount) {
                        auto dst_buffer = AllocMem<VkPipelineColorBlendAttachmentState>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] =
                                parse_VkPipelineColorBlendAttachmentState_contents(json_member[i], CreateScope("pAttachments", i));
                        }
                        s.pAttachments = dst_buffer;
                    } else {
                        Error() << "pAttachments array size (" << json_member.size() << ") does not match expected length ("
                                << s.attachmentCount << ")";
                    }
                } else if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                    s.pAttachments = nullptr;
                } else {
                    Error() << "pAttachments is not an array and is not NULL";
                }
            }
        }

        {
            const Json::Value& json_member = json["blendConstants"];
            {
                if (json_member.isArray()) {
                    if (json_member.size() == 4) {
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            s.blendConstants[i] = parse_float(json_member[i], CreateScope("blendConstants", i));
                        }
                    } else {
                        Error() << "blendConstants array size (" << json_member.size() << ") does not match expected length (" << 4
                                << ")";
                    }
                } else {
                    Error() << "blendConstants is not an array";
                }
            }
        }

        return s;
    }

    VkPipelineColorBlendAdvancedStateCreateInfoEXT parse_VkPipelineColorBlendAdvancedStateCreateInfoEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineColorBlendAdvancedStateCreateInfoEXT s{};
        s.srcPremultiplied = parse_VkBool32(json["srcPremultiplied"], CreateScope("srcPremultiplied"));
        s.dstPremultiplied = parse_VkBool32(json["dstPremultiplied"], CreateScope("dstPremultiplied"));
        s.blendOverlap = parse_VkBlendOverlapEXT(json["blendOverlap"], CreateScope("blendOverlap"));
        return s;
    }

    VkPipelineColorWriteCreateInfoEXT parse_VkPipelineColorWriteCreateInfoEXT_contents(const Json::Value& json,
                                                                                       const LocationScope& l) {
        VkPipelineColorWriteCreateInfoEXT s{};
        s.attachmentCount = parse_uint32_t(json["attachmentCount"], CreateScope("attachmentCount"));
        {
            const Json::Value& json_member = json["pColorWriteEnables"];

            if (s.attachmentCount == 0) {
                s.pColorWriteEnables = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pColorWriteEnables is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.attachmentCount) {
                        auto dst_buffer = AllocMem<VkBool32>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkBool32(json_member[i], CreateScope("pColorWriteEnables", i));
                        }
                        s.pColorWriteEnables = dst_buffer;
                    } else {
                        Error() << "pColorWriteEnables array size (" << json_member.size() << ") does not match expected length ("
                                << s.attachmentCount << ")";
                    }
                } else {
                    Error() << "pColorWriteEnables is not an array";
                }
            }
        }

        return s;
    }

    VkPipelineDynamicStateCreateInfo parse_VkPipelineDynamicStateCreateInfo_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkPipelineDynamicStateCreateInfo s{};
        s.flags = parse_VkPipelineDynamicStateCreateFlags(json["flags"], CreateScope("flags"));
        s.dynamicStateCount = parse_uint32_t(json["dynamicStateCount"], CreateScope("dynamicStateCount"));
        {
            const Json::Value& json_member = json["pDynamicStates"];

            if (s.dynamicStateCount == 0) {
                s.pDynamicStates = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pDynamicStates is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.dynamicStateCount) {
                        auto dst_buffer = AllocMem<VkDynamicState>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkDynamicState(json_member[i], CreateScope("pDynamicStates", i));
                        }
                        s.pDynamicStates = dst_buffer;
                    } else {
                        Error() << "pDynamicStates array size (" << json_member.size() << ") does not match expected length ("
                                << s.dynamicStateCount << ")";
                    }
                } else {
                    Error() << "pDynamicStates is not an array";
                }
            }
        }

        return s;
    }

    VkGraphicsPipelineCreateInfo parse_VkGraphicsPipelineCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkGraphicsPipelineCreateInfo s{};
        s.flags = parse_VkPipelineCreateFlags(json["flags"], CreateScope("flags"));
        s.stageCount = parse_uint32_t(json["stageCount"], CreateScope("stageCount"));
        {
            const Json::Value& json_member = json["pStages"];

            if (s.stageCount == 0) {
                s.pStages = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pStages is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.stageCount) {
                        auto dst_buffer = AllocMem<VkPipelineShaderStageCreateInfo>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkPipelineShaderStageCreateInfo(json_member[i], CreateScope("pStages", i));
                        }
                        s.pStages = dst_buffer;
                    } else {
                        Error() << "pStages array size (" << json_member.size() << ") does not match expected length ("
                                << s.stageCount << ")";
                    }
                } else if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                    s.pStages = nullptr;
                } else {
                    Error() << "pStages is not an array and is not NULL";
                }
            }
        }

        {
            const Json::Value& json_member = json["pVertexInputState"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pVertexInputState = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkPipelineVertexInputStateCreateInfo>();
                *dst_buffer = parse_VkPipelineVertexInputStateCreateInfo(json_member, CreateScope("pVertexInputState", true));
                s.pVertexInputState = dst_buffer;
            }
        }

        {
            const Json::Value& json_member = json["pInputAssemblyState"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pInputAssemblyState = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkPipelineInputAssemblyStateCreateInfo>();
                *dst_buffer = parse_VkPipelineInputAssemblyStateCreateInfo(json_member, CreateScope("pInputAssemblyState", true));
                s.pInputAssemblyState = dst_buffer;
            }
        }

        {
            const Json::Value& json_member = json["pTessellationState"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pTessellationState = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkPipelineTessellationStateCreateInfo>();
                *dst_buffer = parse_VkPipelineTessellationStateCreateInfo(json_member, CreateScope("pTessellationState", true));
                s.pTessellationState = dst_buffer;
            }
        }

        {
            const Json::Value& json_member = json["pViewportState"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pViewportState = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkPipelineViewportStateCreateInfo>();
                *dst_buffer = parse_VkPipelineViewportStateCreateInfo(json_member, CreateScope("pViewportState", true));
                s.pViewportState = dst_buffer;
            }
        }

        {
            const Json::Value& json_member = json["pRasterizationState"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pRasterizationState = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkPipelineRasterizationStateCreateInfo>();
                *dst_buffer = parse_VkPipelineRasterizationStateCreateInfo(json_member, CreateScope("pRasterizationState", true));
                s.pRasterizationState = dst_buffer;
            }
        }

        {
            const Json::Value& json_member = json["pMultisampleState"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pMultisampleState = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkPipelineMultisampleStateCreateInfo>();
                *dst_buffer = parse_VkPipelineMultisampleStateCreateInfo(json_member, CreateScope("pMultisampleState", true));
                s.pMultisampleState = dst_buffer;
            }
        }

        {
            const Json::Value& json_member = json["pDepthStencilState"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pDepthStencilState = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkPipelineDepthStencilStateCreateInfo>();
                *dst_buffer = parse_VkPipelineDepthStencilStateCreateInfo(json_member, CreateScope("pDepthStencilState", true));
                s.pDepthStencilState = dst_buffer;
            }
        }

        {
            const Json::Value& json_member = json["pColorBlendState"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pColorBlendState = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkPipelineColorBlendStateCreateInfo>();
                *dst_buffer = parse_VkPipelineColorBlendStateCreateInfo(json_member, CreateScope("pColorBlendState", true));
                s.pColorBlendState = dst_buffer;
            }
        }

        {
            const Json::Value& json_member = json["pDynamicState"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pDynamicState = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkPipelineDynamicStateCreateInfo>();
                *dst_buffer = parse_VkPipelineDynamicStateCreateInfo(json_member, CreateScope("pDynamicState", true));
                s.pDynamicState = dst_buffer;
            }
        }
        s.layout = parse_VkPipelineLayout(json["layout"], CreateScope("layout"));
        s.renderPass = parse_VkRenderPass(json["renderPass"], CreateScope("renderPass"));
        s.subpass = parse_uint32_t(json["subpass"], CreateScope("subpass"));
        s.basePipelineHandle = parse_VkPipeline(json["basePipelineHandle"], CreateScope("basePipelineHandle"));
        s.basePipelineIndex = parse_int32_t(json["basePipelineIndex"], CreateScope("basePipelineIndex"));
        return s;
    }

    VkPipelineCreateFlags2CreateInfo parse_VkPipelineCreateFlags2CreateInfo_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkPipelineCreateFlags2CreateInfo s{};
        s.flags = parse_VkPipelineCreateFlags2(json["flags"], CreateScope("flags"));
        return s;
    }

    VkPipelineCreationFeedback parse_VkPipelineCreationFeedback_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelineCreationFeedback s{};
        s.flags = parse_VkPipelineCreationFeedbackFlags(json["flags"], CreateScope("flags"));
        s.duration = parse_uint64_t(json["duration"], CreateScope("duration"));
        return s;
    }

    VkPipelineCreationFeedbackCreateInfo parse_VkPipelineCreationFeedbackCreateInfo_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPipelineCreationFeedbackCreateInfo s{};

        {
            const Json::Value& json_member = json["pPipelineCreationFeedback"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pPipelineCreationFeedback = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkPipelineCreationFeedback>();
                *dst_buffer =
                    parse_VkPipelineCreationFeedback_contents(json_member, CreateScope("pPipelineCreationFeedback", true));
                s.pPipelineCreationFeedback = dst_buffer;
            }
        }
        s.pipelineStageCreationFeedbackCount =
            parse_uint32_t(json["pipelineStageCreationFeedbackCount"], CreateScope("pipelineStageCreationFeedbackCount"));
        {
            const Json::Value& json_member = json["pPipelineStageCreationFeedbacks"];

            if (s.pipelineStageCreationFeedbackCount == 0) {
                s.pPipelineStageCreationFeedbacks = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pPipelineStageCreationFeedbacks is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.pipelineStageCreationFeedbackCount) {
                        auto dst_buffer = AllocMem<VkPipelineCreationFeedback>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkPipelineCreationFeedback_contents(
                                json_member[i], CreateScope("pPipelineStageCreationFeedbacks", i));
                        }
                        s.pPipelineStageCreationFeedbacks = dst_buffer;
                    } else {
                        Error() << "pPipelineStageCreationFeedbacks array size (" << json_member.size()
                                << ") does not match expected length (" << s.pipelineStageCreationFeedbackCount << ")";
                    }
                } else {
                    Error() << "pPipelineStageCreationFeedbacks is not an array";
                }
            }
        }

        return s;
    }

    VkPipelineDiscardRectangleStateCreateInfoEXT parse_VkPipelineDiscardRectangleStateCreateInfoEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineDiscardRectangleStateCreateInfoEXT s{};
        s.flags = parse_VkPipelineDiscardRectangleStateCreateFlagsEXT(json["flags"], CreateScope("flags"));
        s.discardRectangleMode = parse_VkDiscardRectangleModeEXT(json["discardRectangleMode"], CreateScope("discardRectangleMode"));
        s.discardRectangleCount = parse_uint32_t(json["discardRectangleCount"], CreateScope("discardRectangleCount"));
        {
            const Json::Value& json_member = json["pDiscardRectangles"];

            if (s.discardRectangleCount == 0) {
                s.pDiscardRectangles = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pDiscardRectangles is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.discardRectangleCount) {
                        auto dst_buffer = AllocMem<VkRect2D>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkRect2D_contents(json_member[i], CreateScope("pDiscardRectangles", i));
                        }
                        s.pDiscardRectangles = dst_buffer;
                    } else {
                        Error() << "pDiscardRectangles array size (" << json_member.size() << ") does not match expected length ("
                                << s.discardRectangleCount << ")";
                    }
                } else if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                    s.pDiscardRectangles = nullptr;
                } else {
                    Error() << "pDiscardRectangles is not an array and is not NULL";
                }
            }
        }

        return s;
    }

    VkPipelineFragmentShadingRateStateCreateInfoKHR parse_VkPipelineFragmentShadingRateStateCreateInfoKHR_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPipelineFragmentShadingRateStateCreateInfoKHR s{};
        s.fragmentSize = parse_VkExtent2D_contents(json["fragmentSize"], CreateScope("fragmentSize"));
        {
            const Json::Value& json_member = json["combinerOps"];
            {
                if (json_member.isArray()) {
                    if (json_member.size() == 2) {
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            s.combinerOps[i] =
                                parse_VkFragmentShadingRateCombinerOpKHR(json_member[i], CreateScope("combinerOps", i));
                        }
                    } else {
                        Error() << "combinerOps array size (" << json_member.size() << ") does not match expected length (" << 2
                                << ")";
                    }
                } else {
                    Error() << "combinerOps is not an array";
                }
            }
        }

        return s;
    }

    VkPipelineOfflineCreateInfo parse_VkPipelineOfflineCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelineOfflineCreateInfo s{};

        {
            const Json::Value& json_member = json["pipelineIdentifier"];
            {
                if (json_member.isArray()) {
                    if (json_member.size() == VK_UUID_SIZE) {
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            s.pipelineIdentifier[i] = parse_uint8_t(json_member[i], CreateScope("pipelineIdentifier", i));
                        }
                    } else {
                        Error() << "pipelineIdentifier array size (" << json_member.size() << ") does not match expected length ("
                                << VK_UUID_SIZE << ")";
                    }
                } else {
                    Error() << "pipelineIdentifier is not an array";
                }
            }
        }
        s.matchControl = parse_VkPipelineMatchControl(json["matchControl"], CreateScope("matchControl"));
        s.poolEntrySize = parse_VkDeviceSize(json["poolEntrySize"], CreateScope("poolEntrySize"));
        return s;
    }

    VkPipelineRenderingCreateInfo parse_VkPipelineRenderingCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelineRenderingCreateInfo s{};
        s.viewMask = parse_uint32_t(json["viewMask"], CreateScope("viewMask"));
        s.colorAttachmentCount = parse_uint32_t(json["colorAttachmentCount"], CreateScope("colorAttachmentCount"));
        {
            const Json::Value& json_member = json["pColorAttachmentFormats"];

            if (s.colorAttachmentCount == 0) {
                s.pColorAttachmentFormats = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pColorAttachmentFormats is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.colorAttachmentCount) {
                        auto dst_buffer = AllocMem<VkFormat>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkFormat(json_member[i], CreateScope("pColorAttachmentFormats", i));
                        }
                        s.pColorAttachmentFormats = dst_buffer;
                    } else {
                        Error() << "pColorAttachmentFormats array size (" << json_member.size()
                                << ") does not match expected length (" << s.colorAttachmentCount << ")";
                    }
                } else if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                    s.pColorAttachmentFormats = nullptr;
                } else {
                    Error() << "pColorAttachmentFormats is not an array and is not NULL";
                }
            }
        }
        s.depthAttachmentFormat = parse_VkFormat(json["depthAttachmentFormat"], CreateScope("depthAttachmentFormat"));
        s.stencilAttachmentFormat = parse_VkFormat(json["stencilAttachmentFormat"], CreateScope("stencilAttachmentFormat"));
        return s;
    }

    VkRenderingAttachmentLocationInfo parse_VkRenderingAttachmentLocationInfo_contents(const Json::Value& json,
                                                                                       const LocationScope& l) {
        VkRenderingAttachmentLocationInfo s{};
        s.colorAttachmentCount = parse_uint32_t(json["colorAttachmentCount"], CreateScope("colorAttachmentCount"));
        {
            const Json::Value& json_member = json["pColorAttachmentLocations"];

            if (s.colorAttachmentCount == 0) {
                s.pColorAttachmentLocations = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pColorAttachmentLocations is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.colorAttachmentCount) {
                        auto dst_buffer = AllocMem<uint32_t>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_uint32_t(json_member[i], CreateScope("pColorAttachmentLocations", i));
                        }
                        s.pColorAttachmentLocations = dst_buffer;
                    } else {
                        Error() << "pColorAttachmentLocations array size (" << json_member.size()
                                << ") does not match expected length (" << s.colorAttachmentCount << ")";
                    }
                } else if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                    s.pColorAttachmentLocations = nullptr;
                } else {
                    Error() << "pColorAttachmentLocations is not an array and is not NULL";
                }
            }
        }

        return s;
    }

    VkRenderingInputAttachmentIndexInfo parse_VkRenderingInputAttachmentIndexInfo_contents(const Json::Value& json,
                                                                                           const LocationScope& l) {
        VkRenderingInputAttachmentIndexInfo s{};
        s.colorAttachmentCount = parse_uint32_t(json["colorAttachmentCount"], CreateScope("colorAttachmentCount"));
        {
            const Json::Value& json_member = json["pColorAttachmentInputIndices"];

            if (s.colorAttachmentCount == 0) {
                s.pColorAttachmentInputIndices = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pColorAttachmentInputIndices is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.colorAttachmentCount) {
                        auto dst_buffer = AllocMem<uint32_t>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_uint32_t(json_member[i], CreateScope("pColorAttachmentInputIndices", i));
                        }
                        s.pColorAttachmentInputIndices = dst_buffer;
                    } else {
                        Error() << "pColorAttachmentInputIndices array size (" << json_member.size()
                                << ") does not match expected length (" << s.colorAttachmentCount << ")";
                    }
                } else if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                    s.pColorAttachmentInputIndices = nullptr;
                } else {
                    Error() << "pColorAttachmentInputIndices is not an array and is not NULL";
                }
            }
        }

        {
            const Json::Value& json_member = json["pDepthInputAttachmentIndex"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pDepthInputAttachmentIndex = nullptr;
            } else {
                auto dst_buffer = AllocMem<uint32_t>();
                *dst_buffer = parse_uint32_t(json_member, CreateScope("pDepthInputAttachmentIndex", true));
                s.pDepthInputAttachmentIndex = dst_buffer;
            }
        }

        {
            const Json::Value& json_member = json["pStencilInputAttachmentIndex"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pStencilInputAttachmentIndex = nullptr;
            } else {
                auto dst_buffer = AllocMem<uint32_t>();
                *dst_buffer = parse_uint32_t(json_member, CreateScope("pStencilInputAttachmentIndex", true));
                s.pStencilInputAttachmentIndex = dst_buffer;
            }
        }

        return s;
    }

    VkComputePipelineCreateInfo parse_VkComputePipelineCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkComputePipelineCreateInfo s{};
        s.flags = parse_VkPipelineCreateFlags(json["flags"], CreateScope("flags"));
        s.stage = parse_VkPipelineShaderStageCreateInfo(json["stage"], CreateScope("stage"));
        s.layout = parse_VkPipelineLayout(json["layout"], CreateScope("layout"));
        s.basePipelineHandle = parse_VkPipeline(json["basePipelineHandle"], CreateScope("basePipelineHandle"));
        s.basePipelineIndex = parse_int32_t(json["basePipelineIndex"], CreateScope("basePipelineIndex"));
        return s;
    }

    VkComponentMapping parse_VkComponentMapping_contents(const Json::Value& json, const LocationScope& l) {
        VkComponentMapping s{};
        s.r = parse_VkComponentSwizzle(json["r"], CreateScope("r"));
        s.g = parse_VkComponentSwizzle(json["g"], CreateScope("g"));
        s.b = parse_VkComponentSwizzle(json["b"], CreateScope("b"));
        s.a = parse_VkComponentSwizzle(json["a"], CreateScope("a"));
        return s;
    }

    VkSamplerYcbcrConversionCreateInfo parse_VkSamplerYcbcrConversionCreateInfo_contents(const Json::Value& json,
                                                                                         const LocationScope& l) {
        VkSamplerYcbcrConversionCreateInfo s{};
        s.format = parse_VkFormat(json["format"], CreateScope("format"));
        s.ycbcrModel = parse_VkSamplerYcbcrModelConversion(json["ycbcrModel"], CreateScope("ycbcrModel"));
        s.ycbcrRange = parse_VkSamplerYcbcrRange(json["ycbcrRange"], CreateScope("ycbcrRange"));
        s.components = parse_VkComponentMapping_contents(json["components"], CreateScope("components"));
        s.xChromaOffset = parse_VkChromaLocation(json["xChromaOffset"], CreateScope("xChromaOffset"));
        s.yChromaOffset = parse_VkChromaLocation(json["yChromaOffset"], CreateScope("yChromaOffset"));
        s.chromaFilter = parse_VkFilter(json["chromaFilter"], CreateScope("chromaFilter"));
        s.forceExplicitReconstruction =
            parse_VkBool32(json["forceExplicitReconstruction"], CreateScope("forceExplicitReconstruction"));
        return s;
    }
#ifdef VK_USE_PLATFORM_SCREEN_QNX

    VkExternalFormatQNX parse_VkExternalFormatQNX_contents(const Json::Value& json, const LocationScope& l) {
        VkExternalFormatQNX s{};
        s.externalFormat = parse_uint64_t(json["externalFormat"], CreateScope("externalFormat"));
        return s;
    }
#endif  // VK_USE_PLATFORM_SCREEN_QNX

    VkSamplerCreateInfo parse_VkSamplerCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkSamplerCreateInfo s{};
        s.flags = parse_VkSamplerCreateFlags(json["flags"], CreateScope("flags"));
        s.magFilter = parse_VkFilter(json["magFilter"], CreateScope("magFilter"));
        s.minFilter = parse_VkFilter(json["minFilter"], CreateScope("minFilter"));
        s.mipmapMode = parse_VkSamplerMipmapMode(json["mipmapMode"], CreateScope("mipmapMode"));
        s.addressModeU = parse_VkSamplerAddressMode(json["addressModeU"], CreateScope("addressModeU"));
        s.addressModeV = parse_VkSamplerAddressMode(json["addressModeV"], CreateScope("addressModeV"));
        s.addressModeW = parse_VkSamplerAddressMode(json["addressModeW"], CreateScope("addressModeW"));
        s.mipLodBias = parse_float(json["mipLodBias"], CreateScope("mipLodBias"));
        s.anisotropyEnable = parse_VkBool32(json["anisotropyEnable"], CreateScope("anisotropyEnable"));
        s.maxAnisotropy = parse_float(json["maxAnisotropy"], CreateScope("maxAnisotropy"));
        s.compareEnable = parse_VkBool32(json["compareEnable"], CreateScope("compareEnable"));
        s.compareOp = parse_VkCompareOp(json["compareOp"], CreateScope("compareOp"));
        s.minLod = parse_float(json["minLod"], CreateScope("minLod"));
        s.maxLod = parse_float(json["maxLod"], CreateScope("maxLod"));
        s.borderColor = parse_VkBorderColor(json["borderColor"], CreateScope("borderColor"));
        s.unnormalizedCoordinates = parse_VkBool32(json["unnormalizedCoordinates"], CreateScope("unnormalizedCoordinates"));
        return s;
    }

    VkClearColorValue parse_VkClearColorValue_contents(const Json::Value& json, const LocationScope& l) {
        VkClearColorValue s{};

        {
            const Json::Value& json_member = json["float32"];
            {
                if (json_member.isArray()) {
                    if (json_member.size() == 4) {
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            s.float32[i] = parse_float(json_member[i], CreateScope("float32", i));
                        }
                    } else {
                        Error() << "float32 array size (" << json_member.size() << ") does not match expected length (" << 4 << ")";
                    }
                } else {
                    Error() << "float32 is not an array";
                }
            }
        }

        {
            const Json::Value& json_member = json["int32"];
            {
                if (json_member.isArray()) {
                    if (json_member.size() == 4) {
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            s.int32[i] = parse_int32_t(json_member[i], CreateScope("int32", i));
                        }
                    } else {
                        Error() << "int32 array size (" << json_member.size() << ") does not match expected length (" << 4 << ")";
                    }
                } else {
                    Error() << "int32 is not an array";
                }
            }
        }

        {
            const Json::Value& json_member = json["uint32"];
            {
                if (json_member.isArray()) {
                    if (json_member.size() == 4) {
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            s.uint32[i] = parse_uint32_t(json_member[i], CreateScope("uint32", i));
                        }
                    } else {
                        Error() << "uint32 array size (" << json_member.size() << ") does not match expected length (" << 4 << ")";
                    }
                } else {
                    Error() << "uint32 is not an array";
                }
            }
        }

        return s;
    }

    VkSamplerCustomBorderColorCreateInfoEXT parse_VkSamplerCustomBorderColorCreateInfoEXT_contents(const Json::Value& json,
                                                                                                   const LocationScope& l) {
        VkSamplerCustomBorderColorCreateInfoEXT s{};
        s.customBorderColor = parse_VkClearColorValue_contents(json["customBorderColor"], CreateScope("customBorderColor"));
        s.format = parse_VkFormat(json["format"], CreateScope("format"));
        return s;
    }

    VkSamplerReductionModeCreateInfo parse_VkSamplerReductionModeCreateInfo_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkSamplerReductionModeCreateInfo s{};
        s.reductionMode = parse_VkSamplerReductionMode(json["reductionMode"], CreateScope("reductionMode"));
        return s;
    }

    VkSamplerYcbcrConversionInfo parse_VkSamplerYcbcrConversionInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkSamplerYcbcrConversionInfo s{};
        s.conversion = parse_VkSamplerYcbcrConversion(json["conversion"], CreateScope("conversion"));
        return s;
    }

    VkDescriptorSetLayoutBinding parse_VkDescriptorSetLayoutBinding_contents(const Json::Value& json, const LocationScope& l) {
        VkDescriptorSetLayoutBinding s{};
        s.binding = parse_uint32_t(json["binding"], CreateScope("binding"));
        s.descriptorType = parse_VkDescriptorType(json["descriptorType"], CreateScope("descriptorType"));
        s.descriptorCount = parse_uint32_t(json["descriptorCount"], CreateScope("descriptorCount"));
        s.stageFlags = parse_VkShaderStageFlags(json["stageFlags"], CreateScope("stageFlags"));
        {
            const Json::Value& json_member = json["pImmutableSamplers"];

            if (s.descriptorCount == 0) {
                s.pImmutableSamplers = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pImmutableSamplers is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.descriptorCount) {
                        auto dst_buffer = AllocMem<VkSampler>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkSampler(json_member[i], CreateScope("pImmutableSamplers", i));
                        }
                        s.pImmutableSamplers = dst_buffer;
                    } else {
                        Error() << "pImmutableSamplers array size (" << json_member.size() << ") does not match expected length ("
                                << s.descriptorCount << ")";
                    }
                } else if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                    s.pImmutableSamplers = nullptr;
                } else {
                    Error() << "pImmutableSamplers is not an array and is not NULL";
                }
            }
        }

        return s;
    }

    VkDescriptorSetLayoutCreateInfo parse_VkDescriptorSetLayoutCreateInfo_contents(const Json::Value& json,
                                                                                   const LocationScope& l) {
        VkDescriptorSetLayoutCreateInfo s{};
        s.flags = parse_VkDescriptorSetLayoutCreateFlags(json["flags"], CreateScope("flags"));
        s.bindingCount = parse_uint32_t(json["bindingCount"], CreateScope("bindingCount"));
        {
            const Json::Value& json_member = json["pBindings"];

            if (s.bindingCount == 0) {
                s.pBindings = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pBindings is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.bindingCount) {
                        auto dst_buffer = AllocMem<VkDescriptorSetLayoutBinding>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] =
                                parse_VkDescriptorSetLayoutBinding_contents(json_member[i], CreateScope("pBindings", i));
                        }
                        s.pBindings = dst_buffer;
                    } else {
                        Error() << "pBindings array size (" << json_member.size() << ") does not match expected length ("
                                << s.bindingCount << ")";
                    }
                } else {
                    Error() << "pBindings is not an array";
                }
            }
        }

        return s;
    }

    VkDescriptorSetLayoutBindingFlagsCreateInfo parse_VkDescriptorSetLayoutBindingFlagsCreateInfo_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkDescriptorSetLayoutBindingFlagsCreateInfo s{};
        s.bindingCount = parse_uint32_t(json["bindingCount"], CreateScope("bindingCount"));
        {
            const Json::Value& json_member = json["pBindingFlags"];

            if (s.bindingCount == 0) {
                s.pBindingFlags = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pBindingFlags is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.bindingCount) {
                        auto dst_buffer = AllocMem<VkDescriptorBindingFlags>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkDescriptorBindingFlags(json_member[i], CreateScope("pBindingFlags", i));
                        }
                        s.pBindingFlags = dst_buffer;
                    } else {
                        Error() << "pBindingFlags array size (" << json_member.size() << ") does not match expected length ("
                                << s.bindingCount << ")";
                    }
                } else {
                    Error() << "pBindingFlags is not an array";
                }
            }
        }

        return s;
    }

    VkPushConstantRange parse_VkPushConstantRange_contents(const Json::Value& json, const LocationScope& l) {
        VkPushConstantRange s{};
        s.stageFlags = parse_VkShaderStageFlags(json["stageFlags"], CreateScope("stageFlags"));
        s.offset = parse_uint32_t(json["offset"], CreateScope("offset"));
        s.size = parse_uint32_t(json["size"], CreateScope("size"));
        return s;
    }

    VkPipelineLayoutCreateInfo parse_VkPipelineLayoutCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelineLayoutCreateInfo s{};
        s.flags = parse_VkPipelineLayoutCreateFlags(json["flags"], CreateScope("flags"));
        s.setLayoutCount = parse_uint32_t(json["setLayoutCount"], CreateScope("setLayoutCount"));
        {
            const Json::Value& json_member = json["pSetLayouts"];

            if (s.setLayoutCount == 0) {
                s.pSetLayouts = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pSetLayouts is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.setLayoutCount) {
                        auto dst_buffer = AllocMem<VkDescriptorSetLayout>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkDescriptorSetLayout(json_member[i], CreateScope("pSetLayouts", i));
                        }
                        s.pSetLayouts = dst_buffer;
                    } else {
                        Error() << "pSetLayouts array size (" << json_member.size() << ") does not match expected length ("
                                << s.setLayoutCount << ")";
                    }
                } else {
                    Error() << "pSetLayouts is not an array";
                }
            }
        }
        s.pushConstantRangeCount = parse_uint32_t(json["pushConstantRangeCount"], CreateScope("pushConstantRangeCount"));
        {
            const Json::Value& json_member = json["pPushConstantRanges"];

            if (s.pushConstantRangeCount == 0) {
                s.pPushConstantRanges = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pPushConstantRanges is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.pushConstantRangeCount) {
                        auto dst_buffer = AllocMem<VkPushConstantRange>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] =
                                parse_VkPushConstantRange_contents(json_member[i], CreateScope("pPushConstantRanges", i));
                        }
                        s.pPushConstantRanges = dst_buffer;
                    } else {
                        Error() << "pPushConstantRanges array size (" << json_member.size() << ") does not match expected length ("
                                << s.pushConstantRangeCount << ")";
                    }
                } else {
                    Error() << "pPushConstantRanges is not an array";
                }
            }
        }

        return s;
    }

    VkPhysicalDeviceFeatures parse_VkPhysicalDeviceFeatures_contents(const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceFeatures s{};
        s.robustBufferAccess = parse_VkBool32(json["robustBufferAccess"], CreateScope("robustBufferAccess"));
        s.fullDrawIndexUint32 = parse_VkBool32(json["fullDrawIndexUint32"], CreateScope("fullDrawIndexUint32"));
        s.imageCubeArray = parse_VkBool32(json["imageCubeArray"], CreateScope("imageCubeArray"));
        s.independentBlend = parse_VkBool32(json["independentBlend"], CreateScope("independentBlend"));
        s.geometryShader = parse_VkBool32(json["geometryShader"], CreateScope("geometryShader"));
        s.tessellationShader = parse_VkBool32(json["tessellationShader"], CreateScope("tessellationShader"));
        s.sampleRateShading = parse_VkBool32(json["sampleRateShading"], CreateScope("sampleRateShading"));
        s.dualSrcBlend = parse_VkBool32(json["dualSrcBlend"], CreateScope("dualSrcBlend"));
        s.logicOp = parse_VkBool32(json["logicOp"], CreateScope("logicOp"));
        s.multiDrawIndirect = parse_VkBool32(json["multiDrawIndirect"], CreateScope("multiDrawIndirect"));
        s.drawIndirectFirstInstance = parse_VkBool32(json["drawIndirectFirstInstance"], CreateScope("drawIndirectFirstInstance"));
        s.depthClamp = parse_VkBool32(json["depthClamp"], CreateScope("depthClamp"));
        s.depthBiasClamp = parse_VkBool32(json["depthBiasClamp"], CreateScope("depthBiasClamp"));
        s.fillModeNonSolid = parse_VkBool32(json["fillModeNonSolid"], CreateScope("fillModeNonSolid"));
        s.depthBounds = parse_VkBool32(json["depthBounds"], CreateScope("depthBounds"));
        s.wideLines = parse_VkBool32(json["wideLines"], CreateScope("wideLines"));
        s.largePoints = parse_VkBool32(json["largePoints"], CreateScope("largePoints"));
        s.alphaToOne = parse_VkBool32(json["alphaToOne"], CreateScope("alphaToOne"));
        s.multiViewport = parse_VkBool32(json["multiViewport"], CreateScope("multiViewport"));
        s.samplerAnisotropy = parse_VkBool32(json["samplerAnisotropy"], CreateScope("samplerAnisotropy"));
        s.textureCompressionETC2 = parse_VkBool32(json["textureCompressionETC2"], CreateScope("textureCompressionETC2"));
        s.textureCompressionASTC_LDR =
            parse_VkBool32(json["textureCompressionASTC_LDR"], CreateScope("textureCompressionASTC_LDR"));
        s.textureCompressionBC = parse_VkBool32(json["textureCompressionBC"], CreateScope("textureCompressionBC"));
        s.occlusionQueryPrecise = parse_VkBool32(json["occlusionQueryPrecise"], CreateScope("occlusionQueryPrecise"));
        s.pipelineStatisticsQuery = parse_VkBool32(json["pipelineStatisticsQuery"], CreateScope("pipelineStatisticsQuery"));
        s.vertexPipelineStoresAndAtomics =
            parse_VkBool32(json["vertexPipelineStoresAndAtomics"], CreateScope("vertexPipelineStoresAndAtomics"));
        s.fragmentStoresAndAtomics = parse_VkBool32(json["fragmentStoresAndAtomics"], CreateScope("fragmentStoresAndAtomics"));
        s.shaderTessellationAndGeometryPointSize =
            parse_VkBool32(json["shaderTessellationAndGeometryPointSize"], CreateScope("shaderTessellationAndGeometryPointSize"));
        s.shaderImageGatherExtended = parse_VkBool32(json["shaderImageGatherExtended"], CreateScope("shaderImageGatherExtended"));
        s.shaderStorageImageExtendedFormats =
            parse_VkBool32(json["shaderStorageImageExtendedFormats"], CreateScope("shaderStorageImageExtendedFormats"));
        s.shaderStorageImageMultisample =
            parse_VkBool32(json["shaderStorageImageMultisample"], CreateScope("shaderStorageImageMultisample"));
        s.shaderStorageImageReadWithoutFormat =
            parse_VkBool32(json["shaderStorageImageReadWithoutFormat"], CreateScope("shaderStorageImageReadWithoutFormat"));
        s.shaderStorageImageWriteWithoutFormat =
            parse_VkBool32(json["shaderStorageImageWriteWithoutFormat"], CreateScope("shaderStorageImageWriteWithoutFormat"));
        s.shaderUniformBufferArrayDynamicIndexing =
            parse_VkBool32(json["shaderUniformBufferArrayDynamicIndexing"], CreateScope("shaderUniformBufferArrayDynamicIndexing"));
        s.shaderSampledImageArrayDynamicIndexing =
            parse_VkBool32(json["shaderSampledImageArrayDynamicIndexing"], CreateScope("shaderSampledImageArrayDynamicIndexing"));
        s.shaderStorageBufferArrayDynamicIndexing =
            parse_VkBool32(json["shaderStorageBufferArrayDynamicIndexing"], CreateScope("shaderStorageBufferArrayDynamicIndexing"));
        s.shaderStorageImageArrayDynamicIndexing =
            parse_VkBool32(json["shaderStorageImageArrayDynamicIndexing"], CreateScope("shaderStorageImageArrayDynamicIndexing"));
        s.shaderClipDistance = parse_VkBool32(json["shaderClipDistance"], CreateScope("shaderClipDistance"));
        s.shaderCullDistance = parse_VkBool32(json["shaderCullDistance"], CreateScope("shaderCullDistance"));
        s.shaderFloat64 = parse_VkBool32(json["shaderFloat64"], CreateScope("shaderFloat64"));
        s.shaderInt64 = parse_VkBool32(json["shaderInt64"], CreateScope("shaderInt64"));
        s.shaderInt16 = parse_VkBool32(json["shaderInt16"], CreateScope("shaderInt16"));
        s.shaderResourceResidency = parse_VkBool32(json["shaderResourceResidency"], CreateScope("shaderResourceResidency"));
        s.shaderResourceMinLod = parse_VkBool32(json["shaderResourceMinLod"], CreateScope("shaderResourceMinLod"));
        s.sparseBinding = parse_VkBool32(json["sparseBinding"], CreateScope("sparseBinding"));
        s.sparseResidencyBuffer = parse_VkBool32(json["sparseResidencyBuffer"], CreateScope("sparseResidencyBuffer"));
        s.sparseResidencyImage2D = parse_VkBool32(json["sparseResidencyImage2D"], CreateScope("sparseResidencyImage2D"));
        s.sparseResidencyImage3D = parse_VkBool32(json["sparseResidencyImage3D"], CreateScope("sparseResidencyImage3D"));
        s.sparseResidency2Samples = parse_VkBool32(json["sparseResidency2Samples"], CreateScope("sparseResidency2Samples"));
        s.sparseResidency4Samples = parse_VkBool32(json["sparseResidency4Samples"], CreateScope("sparseResidency4Samples"));
        s.sparseResidency8Samples = parse_VkBool32(json["sparseResidency8Samples"], CreateScope("sparseResidency8Samples"));
        s.sparseResidency16Samples = parse_VkBool32(json["sparseResidency16Samples"], CreateScope("sparseResidency16Samples"));
        s.sparseResidencyAliased = parse_VkBool32(json["sparseResidencyAliased"], CreateScope("sparseResidencyAliased"));
        s.variableMultisampleRate = parse_VkBool32(json["variableMultisampleRate"], CreateScope("variableMultisampleRate"));
        s.inheritedQueries = parse_VkBool32(json["inheritedQueries"], CreateScope("inheritedQueries"));
        return s;
    }

    VkPhysicalDeviceFeatures2 parse_VkPhysicalDeviceFeatures2_contents(const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceFeatures2 s{};
        s.features = parse_VkPhysicalDeviceFeatures_contents(json["features"], CreateScope("features"));
        return s;
    }

    VkPhysicalDevice16BitStorageFeatures parse_VkPhysicalDevice16BitStorageFeatures_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPhysicalDevice16BitStorageFeatures s{};
        s.storageBuffer16BitAccess = parse_VkBool32(json["storageBuffer16BitAccess"], CreateScope("storageBuffer16BitAccess"));
        s.uniformAndStorageBuffer16BitAccess =
            parse_VkBool32(json["uniformAndStorageBuffer16BitAccess"], CreateScope("uniformAndStorageBuffer16BitAccess"));
        s.storagePushConstant16 = parse_VkBool32(json["storagePushConstant16"], CreateScope("storagePushConstant16"));
        s.storageInputOutput16 = parse_VkBool32(json["storageInputOutput16"], CreateScope("storageInputOutput16"));
        return s;
    }

    VkPhysicalDevice4444FormatsFeaturesEXT parse_VkPhysicalDevice4444FormatsFeaturesEXT_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPhysicalDevice4444FormatsFeaturesEXT s{};
        s.formatA4R4G4B4 = parse_VkBool32(json["formatA4R4G4B4"], CreateScope("formatA4R4G4B4"));
        s.formatA4B4G4R4 = parse_VkBool32(json["formatA4B4G4R4"], CreateScope("formatA4B4G4R4"));
        return s;
    }

    VkPhysicalDevice8BitStorageFeatures parse_VkPhysicalDevice8BitStorageFeatures_contents(const Json::Value& json,
                                                                                           const LocationScope& l) {
        VkPhysicalDevice8BitStorageFeatures s{};
        s.storageBuffer8BitAccess = parse_VkBool32(json["storageBuffer8BitAccess"], CreateScope("storageBuffer8BitAccess"));
        s.uniformAndStorageBuffer8BitAccess =
            parse_VkBool32(json["uniformAndStorageBuffer8BitAccess"], CreateScope("uniformAndStorageBuffer8BitAccess"));
        s.storagePushConstant8 = parse_VkBool32(json["storagePushConstant8"], CreateScope("storagePushConstant8"));
        return s;
    }

    VkPhysicalDeviceASTCDecodeFeaturesEXT parse_VkPhysicalDeviceASTCDecodeFeaturesEXT_contents(const Json::Value& json,
                                                                                               const LocationScope& l) {
        VkPhysicalDeviceASTCDecodeFeaturesEXT s{};
        s.decodeModeSharedExponent = parse_VkBool32(json["decodeModeSharedExponent"], CreateScope("decodeModeSharedExponent"));
        return s;
    }

    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT parse_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT s{};
        s.advancedBlendCoherentOperations =
            parse_VkBool32(json["advancedBlendCoherentOperations"], CreateScope("advancedBlendCoherentOperations"));
        return s;
    }

    VkPhysicalDeviceBufferDeviceAddressFeatures parse_VkPhysicalDeviceBufferDeviceAddressFeatures_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPhysicalDeviceBufferDeviceAddressFeatures s{};
        s.bufferDeviceAddress = parse_VkBool32(json["bufferDeviceAddress"], CreateScope("bufferDeviceAddress"));
        s.bufferDeviceAddressCaptureReplay =
            parse_VkBool32(json["bufferDeviceAddressCaptureReplay"], CreateScope("bufferDeviceAddressCaptureReplay"));
        s.bufferDeviceAddressMultiDevice =
            parse_VkBool32(json["bufferDeviceAddressMultiDevice"], CreateScope("bufferDeviceAddressMultiDevice"));
        return s;
    }

    VkPhysicalDeviceColorWriteEnableFeaturesEXT parse_VkPhysicalDeviceColorWriteEnableFeaturesEXT_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPhysicalDeviceColorWriteEnableFeaturesEXT s{};
        s.colorWriteEnable = parse_VkBool32(json["colorWriteEnable"], CreateScope("colorWriteEnable"));
        return s;
    }

    VkPhysicalDeviceCustomBorderColorFeaturesEXT parse_VkPhysicalDeviceCustomBorderColorFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceCustomBorderColorFeaturesEXT s{};
        s.customBorderColors = parse_VkBool32(json["customBorderColors"], CreateScope("customBorderColors"));
        s.customBorderColorWithoutFormat =
            parse_VkBool32(json["customBorderColorWithoutFormat"], CreateScope("customBorderColorWithoutFormat"));
        return s;
    }

    VkPhysicalDeviceDepthClipEnableFeaturesEXT parse_VkPhysicalDeviceDepthClipEnableFeaturesEXT_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPhysicalDeviceDepthClipEnableFeaturesEXT s{};
        s.depthClipEnable = parse_VkBool32(json["depthClipEnable"], CreateScope("depthClipEnable"));
        return s;
    }

    VkPhysicalDeviceDescriptorIndexingFeatures parse_VkPhysicalDeviceDescriptorIndexingFeatures_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPhysicalDeviceDescriptorIndexingFeatures s{};
        s.shaderInputAttachmentArrayDynamicIndexing = parse_VkBool32(json["shaderInputAttachmentArrayDynamicIndexing"],
                                                                     CreateScope("shaderInputAttachmentArrayDynamicIndexing"));
        s.shaderUniformTexelBufferArrayDynamicIndexing = parse_VkBool32(
            json["shaderUniformTexelBufferArrayDynamicIndexing"], CreateScope("shaderUniformTexelBufferArrayDynamicIndexing"));
        s.shaderStorageTexelBufferArrayDynamicIndexing = parse_VkBool32(
            json["shaderStorageTexelBufferArrayDynamicIndexing"], CreateScope("shaderStorageTexelBufferArrayDynamicIndexing"));
        s.shaderUniformBufferArrayNonUniformIndexing = parse_VkBool32(json["shaderUniformBufferArrayNonUniformIndexing"],
                                                                      CreateScope("shaderUniformBufferArrayNonUniformIndexing"));
        s.shaderSampledImageArrayNonUniformIndexing = parse_VkBool32(json["shaderSampledImageArrayNonUniformIndexing"],
                                                                     CreateScope("shaderSampledImageArrayNonUniformIndexing"));
        s.shaderStorageBufferArrayNonUniformIndexing = parse_VkBool32(json["shaderStorageBufferArrayNonUniformIndexing"],
                                                                      CreateScope("shaderStorageBufferArrayNonUniformIndexing"));
        s.shaderStorageImageArrayNonUniformIndexing = parse_VkBool32(json["shaderStorageImageArrayNonUniformIndexing"],
                                                                     CreateScope("shaderStorageImageArrayNonUniformIndexing"));
        s.shaderInputAttachmentArrayNonUniformIndexing = parse_VkBool32(
            json["shaderInputAttachmentArrayNonUniformIndexing"], CreateScope("shaderInputAttachmentArrayNonUniformIndexing"));
        s.shaderUniformTexelBufferArrayNonUniformIndexing =
            parse_VkBool32(json["shaderUniformTexelBufferArrayNonUniformIndexing"],
                           CreateScope("shaderUniformTexelBufferArrayNonUniformIndexing"));
        s.shaderStorageTexelBufferArrayNonUniformIndexing =
            parse_VkBool32(json["shaderStorageTexelBufferArrayNonUniformIndexing"],
                           CreateScope("shaderStorageTexelBufferArrayNonUniformIndexing"));
        s.descriptorBindingUniformBufferUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingUniformBufferUpdateAfterBind"], CreateScope("descriptorBindingUniformBufferUpdateAfterBind"));
        s.descriptorBindingSampledImageUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingSampledImageUpdateAfterBind"], CreateScope("descriptorBindingSampledImageUpdateAfterBind"));
        s.descriptorBindingStorageImageUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingStorageImageUpdateAfterBind"], CreateScope("descriptorBindingStorageImageUpdateAfterBind"));
        s.descriptorBindingStorageBufferUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingStorageBufferUpdateAfterBind"], CreateScope("descriptorBindingStorageBufferUpdateAfterBind"));
        s.descriptorBindingUniformTexelBufferUpdateAfterBind =
            parse_VkBool32(json["descriptorBindingUniformTexelBufferUpdateAfterBind"],
                           CreateScope("descriptorBindingUniformTexelBufferUpdateAfterBind"));
        s.descriptorBindingStorageTexelBufferUpdateAfterBind =
            parse_VkBool32(json["descriptorBindingStorageTexelBufferUpdateAfterBind"],
                           CreateScope("descriptorBindingStorageTexelBufferUpdateAfterBind"));
        s.descriptorBindingUpdateUnusedWhilePending = parse_VkBool32(json["descriptorBindingUpdateUnusedWhilePending"],
                                                                     CreateScope("descriptorBindingUpdateUnusedWhilePending"));
        s.descriptorBindingPartiallyBound =
            parse_VkBool32(json["descriptorBindingPartiallyBound"], CreateScope("descriptorBindingPartiallyBound"));
        s.descriptorBindingVariableDescriptorCount = parse_VkBool32(json["descriptorBindingVariableDescriptorCount"],
                                                                    CreateScope("descriptorBindingVariableDescriptorCount"));
        s.runtimeDescriptorArray = parse_VkBool32(json["runtimeDescriptorArray"], CreateScope("runtimeDescriptorArray"));
        return s;
    }

    VkPhysicalDeviceDynamicRenderingFeatures parse_VkPhysicalDeviceDynamicRenderingFeatures_contents(const Json::Value& json,
                                                                                                     const LocationScope& l) {
        VkPhysicalDeviceDynamicRenderingFeatures s{};
        s.dynamicRendering = parse_VkBool32(json["dynamicRendering"], CreateScope("dynamicRendering"));
        return s;
    }

    VkPhysicalDeviceDynamicRenderingLocalReadFeatures parse_VkPhysicalDeviceDynamicRenderingLocalReadFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceDynamicRenderingLocalReadFeatures s{};
        s.dynamicRenderingLocalRead = parse_VkBool32(json["dynamicRenderingLocalRead"], CreateScope("dynamicRenderingLocalRead"));
        return s;
    }

    VkPhysicalDeviceExtendedDynamicState2FeaturesEXT parse_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceExtendedDynamicState2FeaturesEXT s{};
        s.extendedDynamicState2 = parse_VkBool32(json["extendedDynamicState2"], CreateScope("extendedDynamicState2"));
        s.extendedDynamicState2LogicOp =
            parse_VkBool32(json["extendedDynamicState2LogicOp"], CreateScope("extendedDynamicState2LogicOp"));
        s.extendedDynamicState2PatchControlPoints =
            parse_VkBool32(json["extendedDynamicState2PatchControlPoints"], CreateScope("extendedDynamicState2PatchControlPoints"));
        return s;
    }

    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT parse_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceExtendedDynamicStateFeaturesEXT s{};
        s.extendedDynamicState = parse_VkBool32(json["extendedDynamicState"], CreateScope("extendedDynamicState"));
        return s;
    }
#ifdef VK_USE_PLATFORM_SCI

    VkPhysicalDeviceExternalMemorySciBufFeaturesNV parse_VkPhysicalDeviceExternalMemorySciBufFeaturesNV_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceExternalMemorySciBufFeaturesNV s{};
        s.sciBufImport = parse_VkBool32(json["sciBufImport"], CreateScope("sciBufImport"));
        s.sciBufExport = parse_VkBool32(json["sciBufExport"], CreateScope("sciBufExport"));
        return s;
    }
#endif  // VK_USE_PLATFORM_SCI
#ifdef VK_USE_PLATFORM_SCREEN_QNX

    VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX parse_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX s{};
        s.screenBufferImport = parse_VkBool32(json["screenBufferImport"], CreateScope("screenBufferImport"));
        return s;
    }
#endif  // VK_USE_PLATFORM_SCREEN_QNX
#ifdef VK_USE_PLATFORM_SCI

    VkPhysicalDeviceExternalSciSync2FeaturesNV parse_VkPhysicalDeviceExternalSciSync2FeaturesNV_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPhysicalDeviceExternalSciSync2FeaturesNV s{};
        s.sciSyncFence = parse_VkBool32(json["sciSyncFence"], CreateScope("sciSyncFence"));
        s.sciSyncSemaphore2 = parse_VkBool32(json["sciSyncSemaphore2"], CreateScope("sciSyncSemaphore2"));
        s.sciSyncImport = parse_VkBool32(json["sciSyncImport"], CreateScope("sciSyncImport"));
        s.sciSyncExport = parse_VkBool32(json["sciSyncExport"], CreateScope("sciSyncExport"));
        return s;
    }
#endif  // VK_USE_PLATFORM_SCI
#ifdef VK_USE_PLATFORM_SCI

    VkPhysicalDeviceExternalSciSyncFeaturesNV parse_VkPhysicalDeviceExternalSciSyncFeaturesNV_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceExternalSciSyncFeaturesNV s{};
        s.sciSyncFence = parse_VkBool32(json["sciSyncFence"], CreateScope("sciSyncFence"));
        s.sciSyncSemaphore = parse_VkBool32(json["sciSyncSemaphore"], CreateScope("sciSyncSemaphore"));
        s.sciSyncImport = parse_VkBool32(json["sciSyncImport"], CreateScope("sciSyncImport"));
        s.sciSyncExport = parse_VkBool32(json["sciSyncExport"], CreateScope("sciSyncExport"));
        return s;
    }
#endif  // VK_USE_PLATFORM_SCI

    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT parse_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT s{};
        s.fragmentShaderSampleInterlock =
            parse_VkBool32(json["fragmentShaderSampleInterlock"], CreateScope("fragmentShaderSampleInterlock"));
        s.fragmentShaderPixelInterlock =
            parse_VkBool32(json["fragmentShaderPixelInterlock"], CreateScope("fragmentShaderPixelInterlock"));
        s.fragmentShaderShadingRateInterlock =
            parse_VkBool32(json["fragmentShaderShadingRateInterlock"], CreateScope("fragmentShaderShadingRateInterlock"));
        return s;
    }

    VkPhysicalDeviceFragmentShadingRateFeaturesKHR parse_VkPhysicalDeviceFragmentShadingRateFeaturesKHR_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceFragmentShadingRateFeaturesKHR s{};
        s.pipelineFragmentShadingRate =
            parse_VkBool32(json["pipelineFragmentShadingRate"], CreateScope("pipelineFragmentShadingRate"));
        s.primitiveFragmentShadingRate =
            parse_VkBool32(json["primitiveFragmentShadingRate"], CreateScope("primitiveFragmentShadingRate"));
        s.attachmentFragmentShadingRate =
            parse_VkBool32(json["attachmentFragmentShadingRate"], CreateScope("attachmentFragmentShadingRate"));
        return s;
    }

    VkPhysicalDeviceGlobalPriorityQueryFeatures parse_VkPhysicalDeviceGlobalPriorityQueryFeatures_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPhysicalDeviceGlobalPriorityQueryFeatures s{};
        s.globalPriorityQuery = parse_VkBool32(json["globalPriorityQuery"], CreateScope("globalPriorityQuery"));
        return s;
    }

    VkPhysicalDeviceHostImageCopyFeatures parse_VkPhysicalDeviceHostImageCopyFeatures_contents(const Json::Value& json,
                                                                                               const LocationScope& l) {
        VkPhysicalDeviceHostImageCopyFeatures s{};
        s.hostImageCopy = parse_VkBool32(json["hostImageCopy"], CreateScope("hostImageCopy"));
        return s;
    }

    VkPhysicalDeviceHostQueryResetFeatures parse_VkPhysicalDeviceHostQueryResetFeatures_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPhysicalDeviceHostQueryResetFeatures s{};
        s.hostQueryReset = parse_VkBool32(json["hostQueryReset"], CreateScope("hostQueryReset"));
        return s;
    }

    VkPhysicalDeviceImageRobustnessFeatures parse_VkPhysicalDeviceImageRobustnessFeatures_contents(const Json::Value& json,
                                                                                                   const LocationScope& l) {
        VkPhysicalDeviceImageRobustnessFeatures s{};
        s.robustImageAccess = parse_VkBool32(json["robustImageAccess"], CreateScope("robustImageAccess"));
        return s;
    }

    VkPhysicalDeviceImagelessFramebufferFeatures parse_VkPhysicalDeviceImagelessFramebufferFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceImagelessFramebufferFeatures s{};
        s.imagelessFramebuffer = parse_VkBool32(json["imagelessFramebuffer"], CreateScope("imagelessFramebuffer"));
        return s;
    }

    VkPhysicalDeviceIndexTypeUint8Features parse_VkPhysicalDeviceIndexTypeUint8Features_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPhysicalDeviceIndexTypeUint8Features s{};
        s.indexTypeUint8 = parse_VkBool32(json["indexTypeUint8"], CreateScope("indexTypeUint8"));
        return s;
    }

    VkPhysicalDeviceInlineUniformBlockFeatures parse_VkPhysicalDeviceInlineUniformBlockFeatures_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPhysicalDeviceInlineUniformBlockFeatures s{};
        s.inlineUniformBlock = parse_VkBool32(json["inlineUniformBlock"], CreateScope("inlineUniformBlock"));
        s.descriptorBindingInlineUniformBlockUpdateAfterBind =
            parse_VkBool32(json["descriptorBindingInlineUniformBlockUpdateAfterBind"],
                           CreateScope("descriptorBindingInlineUniformBlockUpdateAfterBind"));
        return s;
    }

    VkPhysicalDeviceLineRasterizationFeatures parse_VkPhysicalDeviceLineRasterizationFeatures_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceLineRasterizationFeatures s{};
        s.rectangularLines = parse_VkBool32(json["rectangularLines"], CreateScope("rectangularLines"));
        s.bresenhamLines = parse_VkBool32(json["bresenhamLines"], CreateScope("bresenhamLines"));
        s.smoothLines = parse_VkBool32(json["smoothLines"], CreateScope("smoothLines"));
        s.stippledRectangularLines = parse_VkBool32(json["stippledRectangularLines"], CreateScope("stippledRectangularLines"));
        s.stippledBresenhamLines = parse_VkBool32(json["stippledBresenhamLines"], CreateScope("stippledBresenhamLines"));
        s.stippledSmoothLines = parse_VkBool32(json["stippledSmoothLines"], CreateScope("stippledSmoothLines"));
        return s;
    }

    VkPhysicalDeviceMaintenance4Features parse_VkPhysicalDeviceMaintenance4Features_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPhysicalDeviceMaintenance4Features s{};
        s.maintenance4 = parse_VkBool32(json["maintenance4"], CreateScope("maintenance4"));
        return s;
    }

    VkPhysicalDeviceMaintenance5Features parse_VkPhysicalDeviceMaintenance5Features_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPhysicalDeviceMaintenance5Features s{};
        s.maintenance5 = parse_VkBool32(json["maintenance5"], CreateScope("maintenance5"));
        return s;
    }

    VkPhysicalDeviceMaintenance6Features parse_VkPhysicalDeviceMaintenance6Features_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkPhysicalDeviceMaintenance6Features s{};
        s.maintenance6 = parse_VkBool32(json["maintenance6"], CreateScope("maintenance6"));
        return s;
    }

    VkPhysicalDeviceMultiviewFeatures parse_VkPhysicalDeviceMultiviewFeatures_contents(const Json::Value& json,
                                                                                       const LocationScope& l) {
        VkPhysicalDeviceMultiviewFeatures s{};
        s.multiview = parse_VkBool32(json["multiview"], CreateScope("multiview"));
        s.multiviewGeometryShader = parse_VkBool32(json["multiviewGeometryShader"], CreateScope("multiviewGeometryShader"));
        s.multiviewTessellationShader =
            parse_VkBool32(json["multiviewTessellationShader"], CreateScope("multiviewTessellationShader"));
        return s;
    }

    VkPhysicalDevicePerformanceQueryFeaturesKHR parse_VkPhysicalDevicePerformanceQueryFeaturesKHR_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPhysicalDevicePerformanceQueryFeaturesKHR s{};
        s.performanceCounterQueryPools =
            parse_VkBool32(json["performanceCounterQueryPools"], CreateScope("performanceCounterQueryPools"));
        s.performanceCounterMultipleQueryPools =
            parse_VkBool32(json["performanceCounterMultipleQueryPools"], CreateScope("performanceCounterMultipleQueryPools"));
        return s;
    }

    VkPhysicalDevicePipelineCreationCacheControlFeatures parse_VkPhysicalDevicePipelineCreationCacheControlFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDevicePipelineCreationCacheControlFeatures s{};
        s.pipelineCreationCacheControl =
            parse_VkBool32(json["pipelineCreationCacheControl"], CreateScope("pipelineCreationCacheControl"));
        return s;
    }

    VkPhysicalDevicePipelineProtectedAccessFeatures parse_VkPhysicalDevicePipelineProtectedAccessFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDevicePipelineProtectedAccessFeatures s{};
        s.pipelineProtectedAccess = parse_VkBool32(json["pipelineProtectedAccess"], CreateScope("pipelineProtectedAccess"));
        return s;
    }

    VkPhysicalDevicePipelineRobustnessFeatures parse_VkPhysicalDevicePipelineRobustnessFeatures_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPhysicalDevicePipelineRobustnessFeatures s{};
        s.pipelineRobustness = parse_VkBool32(json["pipelineRobustness"], CreateScope("pipelineRobustness"));
        return s;
    }

    VkPhysicalDevicePrivateDataFeatures parse_VkPhysicalDevicePrivateDataFeatures_contents(const Json::Value& json,
                                                                                           const LocationScope& l) {
        VkPhysicalDevicePrivateDataFeatures s{};
        s.privateData = parse_VkBool32(json["privateData"], CreateScope("privateData"));
        return s;
    }

    VkPhysicalDeviceProtectedMemoryFeatures parse_VkPhysicalDeviceProtectedMemoryFeatures_contents(const Json::Value& json,
                                                                                                   const LocationScope& l) {
        VkPhysicalDeviceProtectedMemoryFeatures s{};
        s.protectedMemory = parse_VkBool32(json["protectedMemory"], CreateScope("protectedMemory"));
        return s;
    }

    VkPhysicalDeviceRobustness2FeaturesKHR parse_VkPhysicalDeviceRobustness2FeaturesKHR_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPhysicalDeviceRobustness2FeaturesKHR s{};
        s.robustBufferAccess2 = parse_VkBool32(json["robustBufferAccess2"], CreateScope("robustBufferAccess2"));
        s.robustImageAccess2 = parse_VkBool32(json["robustImageAccess2"], CreateScope("robustImageAccess2"));
        s.nullDescriptor = parse_VkBool32(json["nullDescriptor"], CreateScope("nullDescriptor"));
        return s;
    }

    VkPhysicalDeviceSamplerYcbcrConversionFeatures parse_VkPhysicalDeviceSamplerYcbcrConversionFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceSamplerYcbcrConversionFeatures s{};
        s.samplerYcbcrConversion = parse_VkBool32(json["samplerYcbcrConversion"], CreateScope("samplerYcbcrConversion"));
        return s;
    }

    VkPhysicalDeviceScalarBlockLayoutFeatures parse_VkPhysicalDeviceScalarBlockLayoutFeatures_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceScalarBlockLayoutFeatures s{};
        s.scalarBlockLayout = parse_VkBool32(json["scalarBlockLayout"], CreateScope("scalarBlockLayout"));
        return s;
    }

    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures parse_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures s{};
        s.separateDepthStencilLayouts =
            parse_VkBool32(json["separateDepthStencilLayouts"], CreateScope("separateDepthStencilLayouts"));
        return s;
    }

    VkPhysicalDeviceShaderAtomicFloatFeaturesEXT parse_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderAtomicFloatFeaturesEXT s{};
        s.shaderBufferFloat32Atomics =
            parse_VkBool32(json["shaderBufferFloat32Atomics"], CreateScope("shaderBufferFloat32Atomics"));
        s.shaderBufferFloat32AtomicAdd =
            parse_VkBool32(json["shaderBufferFloat32AtomicAdd"], CreateScope("shaderBufferFloat32AtomicAdd"));
        s.shaderBufferFloat64Atomics =
            parse_VkBool32(json["shaderBufferFloat64Atomics"], CreateScope("shaderBufferFloat64Atomics"));
        s.shaderBufferFloat64AtomicAdd =
            parse_VkBool32(json["shaderBufferFloat64AtomicAdd"], CreateScope("shaderBufferFloat64AtomicAdd"));
        s.shaderSharedFloat32Atomics =
            parse_VkBool32(json["shaderSharedFloat32Atomics"], CreateScope("shaderSharedFloat32Atomics"));
        s.shaderSharedFloat32AtomicAdd =
            parse_VkBool32(json["shaderSharedFloat32AtomicAdd"], CreateScope("shaderSharedFloat32AtomicAdd"));
        s.shaderSharedFloat64Atomics =
            parse_VkBool32(json["shaderSharedFloat64Atomics"], CreateScope("shaderSharedFloat64Atomics"));
        s.shaderSharedFloat64AtomicAdd =
            parse_VkBool32(json["shaderSharedFloat64AtomicAdd"], CreateScope("shaderSharedFloat64AtomicAdd"));
        s.shaderImageFloat32Atomics = parse_VkBool32(json["shaderImageFloat32Atomics"], CreateScope("shaderImageFloat32Atomics"));
        s.shaderImageFloat32AtomicAdd =
            parse_VkBool32(json["shaderImageFloat32AtomicAdd"], CreateScope("shaderImageFloat32AtomicAdd"));
        s.sparseImageFloat32Atomics = parse_VkBool32(json["sparseImageFloat32Atomics"], CreateScope("sparseImageFloat32Atomics"));
        s.sparseImageFloat32AtomicAdd =
            parse_VkBool32(json["sparseImageFloat32AtomicAdd"], CreateScope("sparseImageFloat32AtomicAdd"));
        return s;
    }

    VkPhysicalDeviceShaderAtomicInt64Features parse_VkPhysicalDeviceShaderAtomicInt64Features_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceShaderAtomicInt64Features s{};
        s.shaderBufferInt64Atomics = parse_VkBool32(json["shaderBufferInt64Atomics"], CreateScope("shaderBufferInt64Atomics"));
        s.shaderSharedInt64Atomics = parse_VkBool32(json["shaderSharedInt64Atomics"], CreateScope("shaderSharedInt64Atomics"));
        return s;
    }

    VkPhysicalDeviceShaderClockFeaturesKHR parse_VkPhysicalDeviceShaderClockFeaturesKHR_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkPhysicalDeviceShaderClockFeaturesKHR s{};
        s.shaderSubgroupClock = parse_VkBool32(json["shaderSubgroupClock"], CreateScope("shaderSubgroupClock"));
        s.shaderDeviceClock = parse_VkBool32(json["shaderDeviceClock"], CreateScope("shaderDeviceClock"));
        return s;
    }

    VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures parse_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures s{};
        s.shaderDemoteToHelperInvocation =
            parse_VkBool32(json["shaderDemoteToHelperInvocation"], CreateScope("shaderDemoteToHelperInvocation"));
        return s;
    }

    VkPhysicalDeviceShaderDrawParametersFeatures parse_VkPhysicalDeviceShaderDrawParametersFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderDrawParametersFeatures s{};
        s.shaderDrawParameters = parse_VkBool32(json["shaderDrawParameters"], CreateScope("shaderDrawParameters"));
        return s;
    }

    VkPhysicalDeviceShaderExpectAssumeFeatures parse_VkPhysicalDeviceShaderExpectAssumeFeatures_contents(const Json::Value& json,
                                                                                                         const LocationScope& l) {
        VkPhysicalDeviceShaderExpectAssumeFeatures s{};
        s.shaderExpectAssume = parse_VkBool32(json["shaderExpectAssume"], CreateScope("shaderExpectAssume"));
        return s;
    }

    VkPhysicalDeviceShaderFloat16Int8Features parse_VkPhysicalDeviceShaderFloat16Int8Features_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceShaderFloat16Int8Features s{};
        s.shaderFloat16 = parse_VkBool32(json["shaderFloat16"], CreateScope("shaderFloat16"));
        s.shaderInt8 = parse_VkBool32(json["shaderInt8"], CreateScope("shaderInt8"));
        return s;
    }

    VkPhysicalDeviceShaderFloatControls2Features parse_VkPhysicalDeviceShaderFloatControls2Features_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderFloatControls2Features s{};
        s.shaderFloatControls2 = parse_VkBool32(json["shaderFloatControls2"], CreateScope("shaderFloatControls2"));
        return s;
    }

    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT parse_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT s{};
        s.shaderImageInt64Atomics = parse_VkBool32(json["shaderImageInt64Atomics"], CreateScope("shaderImageInt64Atomics"));
        s.sparseImageInt64Atomics = parse_VkBool32(json["sparseImageInt64Atomics"], CreateScope("sparseImageInt64Atomics"));
        return s;
    }

    VkPhysicalDeviceShaderIntegerDotProductFeatures parse_VkPhysicalDeviceShaderIntegerDotProductFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderIntegerDotProductFeatures s{};
        s.shaderIntegerDotProduct = parse_VkBool32(json["shaderIntegerDotProduct"], CreateScope("shaderIntegerDotProduct"));
        return s;
    }

    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures parse_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures s{};
        s.shaderSubgroupExtendedTypes =
            parse_VkBool32(json["shaderSubgroupExtendedTypes"], CreateScope("shaderSubgroupExtendedTypes"));
        return s;
    }

    VkPhysicalDeviceShaderSubgroupRotateFeatures parse_VkPhysicalDeviceShaderSubgroupRotateFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderSubgroupRotateFeatures s{};
        s.shaderSubgroupRotate = parse_VkBool32(json["shaderSubgroupRotate"], CreateScope("shaderSubgroupRotate"));
        s.shaderSubgroupRotateClustered =
            parse_VkBool32(json["shaderSubgroupRotateClustered"], CreateScope("shaderSubgroupRotateClustered"));
        return s;
    }

    VkPhysicalDeviceShaderTerminateInvocationFeatures parse_VkPhysicalDeviceShaderTerminateInvocationFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceShaderTerminateInvocationFeatures s{};
        s.shaderTerminateInvocation = parse_VkBool32(json["shaderTerminateInvocation"], CreateScope("shaderTerminateInvocation"));
        return s;
    }

    VkPhysicalDeviceSubgroupSizeControlFeatures parse_VkPhysicalDeviceSubgroupSizeControlFeatures_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPhysicalDeviceSubgroupSizeControlFeatures s{};
        s.subgroupSizeControl = parse_VkBool32(json["subgroupSizeControl"], CreateScope("subgroupSizeControl"));
        s.computeFullSubgroups = parse_VkBool32(json["computeFullSubgroups"], CreateScope("computeFullSubgroups"));
        return s;
    }

    VkPhysicalDeviceSynchronization2Features parse_VkPhysicalDeviceSynchronization2Features_contents(const Json::Value& json,
                                                                                                     const LocationScope& l) {
        VkPhysicalDeviceSynchronization2Features s{};
        s.synchronization2 = parse_VkBool32(json["synchronization2"], CreateScope("synchronization2"));
        return s;
    }

    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT parse_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT s{};
        s.texelBufferAlignment = parse_VkBool32(json["texelBufferAlignment"], CreateScope("texelBufferAlignment"));
        return s;
    }

    VkPhysicalDeviceTextureCompressionASTCHDRFeatures parse_VkPhysicalDeviceTextureCompressionASTCHDRFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceTextureCompressionASTCHDRFeatures s{};
        s.textureCompressionASTC_HDR =
            parse_VkBool32(json["textureCompressionASTC_HDR"], CreateScope("textureCompressionASTC_HDR"));
        return s;
    }

    VkPhysicalDeviceTimelineSemaphoreFeatures parse_VkPhysicalDeviceTimelineSemaphoreFeatures_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceTimelineSemaphoreFeatures s{};
        s.timelineSemaphore = parse_VkBool32(json["timelineSemaphore"], CreateScope("timelineSemaphore"));
        return s;
    }

    VkPhysicalDeviceUniformBufferStandardLayoutFeatures parse_VkPhysicalDeviceUniformBufferStandardLayoutFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceUniformBufferStandardLayoutFeatures s{};
        s.uniformBufferStandardLayout =
            parse_VkBool32(json["uniformBufferStandardLayout"], CreateScope("uniformBufferStandardLayout"));
        return s;
    }

    VkPhysicalDeviceVariablePointersFeatures parse_VkPhysicalDeviceVariablePointersFeatures_contents(const Json::Value& json,
                                                                                                     const LocationScope& l) {
        VkPhysicalDeviceVariablePointersFeatures s{};
        s.variablePointersStorageBuffer =
            parse_VkBool32(json["variablePointersStorageBuffer"], CreateScope("variablePointersStorageBuffer"));
        s.variablePointers = parse_VkBool32(json["variablePointers"], CreateScope("variablePointers"));
        return s;
    }

    VkPhysicalDeviceVertexAttributeDivisorFeatures parse_VkPhysicalDeviceVertexAttributeDivisorFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceVertexAttributeDivisorFeatures s{};
        s.vertexAttributeInstanceRateDivisor =
            parse_VkBool32(json["vertexAttributeInstanceRateDivisor"], CreateScope("vertexAttributeInstanceRateDivisor"));
        s.vertexAttributeInstanceRateZeroDivisor =
            parse_VkBool32(json["vertexAttributeInstanceRateZeroDivisor"], CreateScope("vertexAttributeInstanceRateZeroDivisor"));
        return s;
    }

    VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT parse_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT s{};
        s.vertexInputDynamicState = parse_VkBool32(json["vertexInputDynamicState"], CreateScope("vertexInputDynamicState"));
        return s;
    }

    VkPhysicalDeviceVulkan11Features parse_VkPhysicalDeviceVulkan11Features_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkPhysicalDeviceVulkan11Features s{};
        s.storageBuffer16BitAccess = parse_VkBool32(json["storageBuffer16BitAccess"], CreateScope("storageBuffer16BitAccess"));
        s.uniformAndStorageBuffer16BitAccess =
            parse_VkBool32(json["uniformAndStorageBuffer16BitAccess"], CreateScope("uniformAndStorageBuffer16BitAccess"));
        s.storagePushConstant16 = parse_VkBool32(json["storagePushConstant16"], CreateScope("storagePushConstant16"));
        s.storageInputOutput16 = parse_VkBool32(json["storageInputOutput16"], CreateScope("storageInputOutput16"));
        s.multiview = parse_VkBool32(json["multiview"], CreateScope("multiview"));
        s.multiviewGeometryShader = parse_VkBool32(json["multiviewGeometryShader"], CreateScope("multiviewGeometryShader"));
        s.multiviewTessellationShader =
            parse_VkBool32(json["multiviewTessellationShader"], CreateScope("multiviewTessellationShader"));
        s.variablePointersStorageBuffer =
            parse_VkBool32(json["variablePointersStorageBuffer"], CreateScope("variablePointersStorageBuffer"));
        s.variablePointers = parse_VkBool32(json["variablePointers"], CreateScope("variablePointers"));
        s.protectedMemory = parse_VkBool32(json["protectedMemory"], CreateScope("protectedMemory"));
        s.samplerYcbcrConversion = parse_VkBool32(json["samplerYcbcrConversion"], CreateScope("samplerYcbcrConversion"));
        s.shaderDrawParameters = parse_VkBool32(json["shaderDrawParameters"], CreateScope("shaderDrawParameters"));
        return s;
    }

    VkPhysicalDeviceVulkan12Features parse_VkPhysicalDeviceVulkan12Features_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkPhysicalDeviceVulkan12Features s{};
        s.samplerMirrorClampToEdge = parse_VkBool32(json["samplerMirrorClampToEdge"], CreateScope("samplerMirrorClampToEdge"));
        s.drawIndirectCount = parse_VkBool32(json["drawIndirectCount"], CreateScope("drawIndirectCount"));
        s.storageBuffer8BitAccess = parse_VkBool32(json["storageBuffer8BitAccess"], CreateScope("storageBuffer8BitAccess"));
        s.uniformAndStorageBuffer8BitAccess =
            parse_VkBool32(json["uniformAndStorageBuffer8BitAccess"], CreateScope("uniformAndStorageBuffer8BitAccess"));
        s.storagePushConstant8 = parse_VkBool32(json["storagePushConstant8"], CreateScope("storagePushConstant8"));
        s.shaderBufferInt64Atomics = parse_VkBool32(json["shaderBufferInt64Atomics"], CreateScope("shaderBufferInt64Atomics"));
        s.shaderSharedInt64Atomics = parse_VkBool32(json["shaderSharedInt64Atomics"], CreateScope("shaderSharedInt64Atomics"));
        s.shaderFloat16 = parse_VkBool32(json["shaderFloat16"], CreateScope("shaderFloat16"));
        s.shaderInt8 = parse_VkBool32(json["shaderInt8"], CreateScope("shaderInt8"));
        s.descriptorIndexing = parse_VkBool32(json["descriptorIndexing"], CreateScope("descriptorIndexing"));
        s.shaderInputAttachmentArrayDynamicIndexing = parse_VkBool32(json["shaderInputAttachmentArrayDynamicIndexing"],
                                                                     CreateScope("shaderInputAttachmentArrayDynamicIndexing"));
        s.shaderUniformTexelBufferArrayDynamicIndexing = parse_VkBool32(
            json["shaderUniformTexelBufferArrayDynamicIndexing"], CreateScope("shaderUniformTexelBufferArrayDynamicIndexing"));
        s.shaderStorageTexelBufferArrayDynamicIndexing = parse_VkBool32(
            json["shaderStorageTexelBufferArrayDynamicIndexing"], CreateScope("shaderStorageTexelBufferArrayDynamicIndexing"));
        s.shaderUniformBufferArrayNonUniformIndexing = parse_VkBool32(json["shaderUniformBufferArrayNonUniformIndexing"],
                                                                      CreateScope("shaderUniformBufferArrayNonUniformIndexing"));
        s.shaderSampledImageArrayNonUniformIndexing = parse_VkBool32(json["shaderSampledImageArrayNonUniformIndexing"],
                                                                     CreateScope("shaderSampledImageArrayNonUniformIndexing"));
        s.shaderStorageBufferArrayNonUniformIndexing = parse_VkBool32(json["shaderStorageBufferArrayNonUniformIndexing"],
                                                                      CreateScope("shaderStorageBufferArrayNonUniformIndexing"));
        s.shaderStorageImageArrayNonUniformIndexing = parse_VkBool32(json["shaderStorageImageArrayNonUniformIndexing"],
                                                                     CreateScope("shaderStorageImageArrayNonUniformIndexing"));
        s.shaderInputAttachmentArrayNonUniformIndexing = parse_VkBool32(
            json["shaderInputAttachmentArrayNonUniformIndexing"], CreateScope("shaderInputAttachmentArrayNonUniformIndexing"));
        s.shaderUniformTexelBufferArrayNonUniformIndexing =
            parse_VkBool32(json["shaderUniformTexelBufferArrayNonUniformIndexing"],
                           CreateScope("shaderUniformTexelBufferArrayNonUniformIndexing"));
        s.shaderStorageTexelBufferArrayNonUniformIndexing =
            parse_VkBool32(json["shaderStorageTexelBufferArrayNonUniformIndexing"],
                           CreateScope("shaderStorageTexelBufferArrayNonUniformIndexing"));
        s.descriptorBindingUniformBufferUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingUniformBufferUpdateAfterBind"], CreateScope("descriptorBindingUniformBufferUpdateAfterBind"));
        s.descriptorBindingSampledImageUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingSampledImageUpdateAfterBind"], CreateScope("descriptorBindingSampledImageUpdateAfterBind"));
        s.descriptorBindingStorageImageUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingStorageImageUpdateAfterBind"], CreateScope("descriptorBindingStorageImageUpdateAfterBind"));
        s.descriptorBindingStorageBufferUpdateAfterBind = parse_VkBool32(
            json["descriptorBindingStorageBufferUpdateAfterBind"], CreateScope("descriptorBindingStorageBufferUpdateAfterBind"));
        s.descriptorBindingUniformTexelBufferUpdateAfterBind =
            parse_VkBool32(json["descriptorBindingUniformTexelBufferUpdateAfterBind"],
                           CreateScope("descriptorBindingUniformTexelBufferUpdateAfterBind"));
        s.descriptorBindingStorageTexelBufferUpdateAfterBind =
            parse_VkBool32(json["descriptorBindingStorageTexelBufferUpdateAfterBind"],
                           CreateScope("descriptorBindingStorageTexelBufferUpdateAfterBind"));
        s.descriptorBindingUpdateUnusedWhilePending = parse_VkBool32(json["descriptorBindingUpdateUnusedWhilePending"],
                                                                     CreateScope("descriptorBindingUpdateUnusedWhilePending"));
        s.descriptorBindingPartiallyBound =
            parse_VkBool32(json["descriptorBindingPartiallyBound"], CreateScope("descriptorBindingPartiallyBound"));
        s.descriptorBindingVariableDescriptorCount = parse_VkBool32(json["descriptorBindingVariableDescriptorCount"],
                                                                    CreateScope("descriptorBindingVariableDescriptorCount"));
        s.runtimeDescriptorArray = parse_VkBool32(json["runtimeDescriptorArray"], CreateScope("runtimeDescriptorArray"));
        s.samplerFilterMinmax = parse_VkBool32(json["samplerFilterMinmax"], CreateScope("samplerFilterMinmax"));
        s.scalarBlockLayout = parse_VkBool32(json["scalarBlockLayout"], CreateScope("scalarBlockLayout"));
        s.imagelessFramebuffer = parse_VkBool32(json["imagelessFramebuffer"], CreateScope("imagelessFramebuffer"));
        s.uniformBufferStandardLayout =
            parse_VkBool32(json["uniformBufferStandardLayout"], CreateScope("uniformBufferStandardLayout"));
        s.shaderSubgroupExtendedTypes =
            parse_VkBool32(json["shaderSubgroupExtendedTypes"], CreateScope("shaderSubgroupExtendedTypes"));
        s.separateDepthStencilLayouts =
            parse_VkBool32(json["separateDepthStencilLayouts"], CreateScope("separateDepthStencilLayouts"));
        s.hostQueryReset = parse_VkBool32(json["hostQueryReset"], CreateScope("hostQueryReset"));
        s.timelineSemaphore = parse_VkBool32(json["timelineSemaphore"], CreateScope("timelineSemaphore"));
        s.bufferDeviceAddress = parse_VkBool32(json["bufferDeviceAddress"], CreateScope("bufferDeviceAddress"));
        s.bufferDeviceAddressCaptureReplay =
            parse_VkBool32(json["bufferDeviceAddressCaptureReplay"], CreateScope("bufferDeviceAddressCaptureReplay"));
        s.bufferDeviceAddressMultiDevice =
            parse_VkBool32(json["bufferDeviceAddressMultiDevice"], CreateScope("bufferDeviceAddressMultiDevice"));
        s.vulkanMemoryModel = parse_VkBool32(json["vulkanMemoryModel"], CreateScope("vulkanMemoryModel"));
        s.vulkanMemoryModelDeviceScope =
            parse_VkBool32(json["vulkanMemoryModelDeviceScope"], CreateScope("vulkanMemoryModelDeviceScope"));
        s.vulkanMemoryModelAvailabilityVisibilityChains = parse_VkBool32(
            json["vulkanMemoryModelAvailabilityVisibilityChains"], CreateScope("vulkanMemoryModelAvailabilityVisibilityChains"));
        s.shaderOutputViewportIndex = parse_VkBool32(json["shaderOutputViewportIndex"], CreateScope("shaderOutputViewportIndex"));
        s.shaderOutputLayer = parse_VkBool32(json["shaderOutputLayer"], CreateScope("shaderOutputLayer"));
        s.subgroupBroadcastDynamicId =
            parse_VkBool32(json["subgroupBroadcastDynamicId"], CreateScope("subgroupBroadcastDynamicId"));
        return s;
    }

    VkPhysicalDeviceVulkan13Features parse_VkPhysicalDeviceVulkan13Features_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkPhysicalDeviceVulkan13Features s{};
        s.robustImageAccess = parse_VkBool32(json["robustImageAccess"], CreateScope("robustImageAccess"));
        s.inlineUniformBlock = parse_VkBool32(json["inlineUniformBlock"], CreateScope("inlineUniformBlock"));
        s.descriptorBindingInlineUniformBlockUpdateAfterBind =
            parse_VkBool32(json["descriptorBindingInlineUniformBlockUpdateAfterBind"],
                           CreateScope("descriptorBindingInlineUniformBlockUpdateAfterBind"));
        s.pipelineCreationCacheControl =
            parse_VkBool32(json["pipelineCreationCacheControl"], CreateScope("pipelineCreationCacheControl"));
        s.privateData = parse_VkBool32(json["privateData"], CreateScope("privateData"));
        s.shaderDemoteToHelperInvocation =
            parse_VkBool32(json["shaderDemoteToHelperInvocation"], CreateScope("shaderDemoteToHelperInvocation"));
        s.shaderTerminateInvocation = parse_VkBool32(json["shaderTerminateInvocation"], CreateScope("shaderTerminateInvocation"));
        s.subgroupSizeControl = parse_VkBool32(json["subgroupSizeControl"], CreateScope("subgroupSizeControl"));
        s.computeFullSubgroups = parse_VkBool32(json["computeFullSubgroups"], CreateScope("computeFullSubgroups"));
        s.synchronization2 = parse_VkBool32(json["synchronization2"], CreateScope("synchronization2"));
        s.textureCompressionASTC_HDR =
            parse_VkBool32(json["textureCompressionASTC_HDR"], CreateScope("textureCompressionASTC_HDR"));
        s.shaderZeroInitializeWorkgroupMemory =
            parse_VkBool32(json["shaderZeroInitializeWorkgroupMemory"], CreateScope("shaderZeroInitializeWorkgroupMemory"));
        s.dynamicRendering = parse_VkBool32(json["dynamicRendering"], CreateScope("dynamicRendering"));
        s.shaderIntegerDotProduct = parse_VkBool32(json["shaderIntegerDotProduct"], CreateScope("shaderIntegerDotProduct"));
        s.maintenance4 = parse_VkBool32(json["maintenance4"], CreateScope("maintenance4"));
        return s;
    }

    VkPhysicalDeviceVulkan14Features parse_VkPhysicalDeviceVulkan14Features_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkPhysicalDeviceVulkan14Features s{};
        s.globalPriorityQuery = parse_VkBool32(json["globalPriorityQuery"], CreateScope("globalPriorityQuery"));
        s.shaderSubgroupRotate = parse_VkBool32(json["shaderSubgroupRotate"], CreateScope("shaderSubgroupRotate"));
        s.shaderSubgroupRotateClustered =
            parse_VkBool32(json["shaderSubgroupRotateClustered"], CreateScope("shaderSubgroupRotateClustered"));
        s.shaderFloatControls2 = parse_VkBool32(json["shaderFloatControls2"], CreateScope("shaderFloatControls2"));
        s.shaderExpectAssume = parse_VkBool32(json["shaderExpectAssume"], CreateScope("shaderExpectAssume"));
        s.rectangularLines = parse_VkBool32(json["rectangularLines"], CreateScope("rectangularLines"));
        s.bresenhamLines = parse_VkBool32(json["bresenhamLines"], CreateScope("bresenhamLines"));
        s.smoothLines = parse_VkBool32(json["smoothLines"], CreateScope("smoothLines"));
        s.stippledRectangularLines = parse_VkBool32(json["stippledRectangularLines"], CreateScope("stippledRectangularLines"));
        s.stippledBresenhamLines = parse_VkBool32(json["stippledBresenhamLines"], CreateScope("stippledBresenhamLines"));
        s.stippledSmoothLines = parse_VkBool32(json["stippledSmoothLines"], CreateScope("stippledSmoothLines"));
        s.vertexAttributeInstanceRateDivisor =
            parse_VkBool32(json["vertexAttributeInstanceRateDivisor"], CreateScope("vertexAttributeInstanceRateDivisor"));
        s.vertexAttributeInstanceRateZeroDivisor =
            parse_VkBool32(json["vertexAttributeInstanceRateZeroDivisor"], CreateScope("vertexAttributeInstanceRateZeroDivisor"));
        s.indexTypeUint8 = parse_VkBool32(json["indexTypeUint8"], CreateScope("indexTypeUint8"));
        s.dynamicRenderingLocalRead = parse_VkBool32(json["dynamicRenderingLocalRead"], CreateScope("dynamicRenderingLocalRead"));
        s.maintenance5 = parse_VkBool32(json["maintenance5"], CreateScope("maintenance5"));
        s.maintenance6 = parse_VkBool32(json["maintenance6"], CreateScope("maintenance6"));
        s.pipelineProtectedAccess = parse_VkBool32(json["pipelineProtectedAccess"], CreateScope("pipelineProtectedAccess"));
        s.pipelineRobustness = parse_VkBool32(json["pipelineRobustness"], CreateScope("pipelineRobustness"));
        s.hostImageCopy = parse_VkBool32(json["hostImageCopy"], CreateScope("hostImageCopy"));
        s.pushDescriptor = parse_VkBool32(json["pushDescriptor"], CreateScope("pushDescriptor"));
        return s;
    }

    VkPhysicalDeviceVulkanMemoryModelFeatures parse_VkPhysicalDeviceVulkanMemoryModelFeatures_contents(const Json::Value& json,
                                                                                                       const LocationScope& l) {
        VkPhysicalDeviceVulkanMemoryModelFeatures s{};
        s.vulkanMemoryModel = parse_VkBool32(json["vulkanMemoryModel"], CreateScope("vulkanMemoryModel"));
        s.vulkanMemoryModelDeviceScope =
            parse_VkBool32(json["vulkanMemoryModelDeviceScope"], CreateScope("vulkanMemoryModelDeviceScope"));
        s.vulkanMemoryModelAvailabilityVisibilityChains = parse_VkBool32(
            json["vulkanMemoryModelAvailabilityVisibilityChains"], CreateScope("vulkanMemoryModelAvailabilityVisibilityChains"));
        return s;
    }

    VkPhysicalDeviceVulkanSC10Features parse_VkPhysicalDeviceVulkanSC10Features_contents(const Json::Value& json,
                                                                                         const LocationScope& l) {
        VkPhysicalDeviceVulkanSC10Features s{};
        s.shaderAtomicInstructions = parse_VkBool32(json["shaderAtomicInstructions"], CreateScope("shaderAtomicInstructions"));
        return s;
    }

    VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT parse_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT s{};
        s.ycbcr2plane444Formats = parse_VkBool32(json["ycbcr2plane444Formats"], CreateScope("ycbcr2plane444Formats"));
        return s;
    }

    VkPhysicalDeviceYcbcrImageArraysFeaturesEXT parse_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkPhysicalDeviceYcbcrImageArraysFeaturesEXT s{};
        s.ycbcrImageArrays = parse_VkBool32(json["ycbcrImageArrays"], CreateScope("ycbcrImageArrays"));
        return s;
    }

    VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures parse_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures_contents(
        const Json::Value& json, const LocationScope& l) {
        VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures s{};
        s.shaderZeroInitializeWorkgroupMemory =
            parse_VkBool32(json["shaderZeroInitializeWorkgroupMemory"], CreateScope("shaderZeroInitializeWorkgroupMemory"));
        return s;
    }

    VkAttachmentDescription parse_VkAttachmentDescription_contents(const Json::Value& json, const LocationScope& l) {
        VkAttachmentDescription s{};
        s.flags = parse_VkAttachmentDescriptionFlags(json["flags"], CreateScope("flags"));
        s.format = parse_VkFormat(json["format"], CreateScope("format"));
        s.samples = parse_VkSampleCountFlagBits(json["samples"], CreateScope("samples"));
        s.loadOp = parse_VkAttachmentLoadOp(json["loadOp"], CreateScope("loadOp"));
        s.storeOp = parse_VkAttachmentStoreOp(json["storeOp"], CreateScope("storeOp"));
        s.stencilLoadOp = parse_VkAttachmentLoadOp(json["stencilLoadOp"], CreateScope("stencilLoadOp"));
        s.stencilStoreOp = parse_VkAttachmentStoreOp(json["stencilStoreOp"], CreateScope("stencilStoreOp"));
        s.initialLayout = parse_VkImageLayout(json["initialLayout"], CreateScope("initialLayout"));
        s.finalLayout = parse_VkImageLayout(json["finalLayout"], CreateScope("finalLayout"));
        return s;
    }

    VkAttachmentReference parse_VkAttachmentReference_contents(const Json::Value& json, const LocationScope& l) {
        VkAttachmentReference s{};
        s.attachment = parse_uint32_t(json["attachment"], CreateScope("attachment"));
        s.layout = parse_VkImageLayout(json["layout"], CreateScope("layout"));
        return s;
    }

    VkSubpassDescription parse_VkSubpassDescription_contents(const Json::Value& json, const LocationScope& l) {
        VkSubpassDescription s{};
        s.flags = parse_VkSubpassDescriptionFlags(json["flags"], CreateScope("flags"));
        s.pipelineBindPoint = parse_VkPipelineBindPoint(json["pipelineBindPoint"], CreateScope("pipelineBindPoint"));
        s.inputAttachmentCount = parse_uint32_t(json["inputAttachmentCount"], CreateScope("inputAttachmentCount"));
        {
            const Json::Value& json_member = json["pInputAttachments"];

            if (s.inputAttachmentCount == 0) {
                s.pInputAttachments = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pInputAttachments is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.inputAttachmentCount) {
                        auto dst_buffer = AllocMem<VkAttachmentReference>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] =
                                parse_VkAttachmentReference_contents(json_member[i], CreateScope("pInputAttachments", i));
                        }
                        s.pInputAttachments = dst_buffer;
                    } else {
                        Error() << "pInputAttachments array size (" << json_member.size() << ") does not match expected length ("
                                << s.inputAttachmentCount << ")";
                    }
                } else {
                    Error() << "pInputAttachments is not an array";
                }
            }
        }
        s.colorAttachmentCount = parse_uint32_t(json["colorAttachmentCount"], CreateScope("colorAttachmentCount"));
        {
            const Json::Value& json_member = json["pColorAttachments"];

            if (s.colorAttachmentCount == 0) {
                s.pColorAttachments = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pColorAttachments is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.colorAttachmentCount) {
                        auto dst_buffer = AllocMem<VkAttachmentReference>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] =
                                parse_VkAttachmentReference_contents(json_member[i], CreateScope("pColorAttachments", i));
                        }
                        s.pColorAttachments = dst_buffer;
                    } else {
                        Error() << "pColorAttachments array size (" << json_member.size() << ") does not match expected length ("
                                << s.colorAttachmentCount << ")";
                    }
                } else {
                    Error() << "pColorAttachments is not an array";
                }
            }
        }

        {
            const Json::Value& json_member = json["pResolveAttachments"];

            if (s.colorAttachmentCount == 0) {
                s.pResolveAttachments = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pResolveAttachments is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.colorAttachmentCount) {
                        auto dst_buffer = AllocMem<VkAttachmentReference>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] =
                                parse_VkAttachmentReference_contents(json_member[i], CreateScope("pResolveAttachments", i));
                        }
                        s.pResolveAttachments = dst_buffer;
                    } else {
                        Error() << "pResolveAttachments array size (" << json_member.size() << ") does not match expected length ("
                                << s.colorAttachmentCount << ")";
                    }
                } else if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                    s.pResolveAttachments = nullptr;
                } else {
                    Error() << "pResolveAttachments is not an array and is not NULL";
                }
            }
        }

        {
            const Json::Value& json_member = json["pDepthStencilAttachment"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pDepthStencilAttachment = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkAttachmentReference>();
                *dst_buffer = parse_VkAttachmentReference_contents(json_member, CreateScope("pDepthStencilAttachment", true));
                s.pDepthStencilAttachment = dst_buffer;
            }
        }
        s.preserveAttachmentCount = parse_uint32_t(json["preserveAttachmentCount"], CreateScope("preserveAttachmentCount"));
        {
            const Json::Value& json_member = json["pPreserveAttachments"];

            if (s.preserveAttachmentCount == 0) {
                s.pPreserveAttachments = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pPreserveAttachments is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.preserveAttachmentCount) {
                        auto dst_buffer = AllocMem<uint32_t>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_uint32_t(json_member[i], CreateScope("pPreserveAttachments", i));
                        }
                        s.pPreserveAttachments = dst_buffer;
                    } else {
                        Error() << "pPreserveAttachments array size (" << json_member.size() << ") does not match expected length ("
                                << s.preserveAttachmentCount << ")";
                    }
                } else {
                    Error() << "pPreserveAttachments is not an array";
                }
            }
        }

        return s;
    }

    VkSubpassDependency parse_VkSubpassDependency_contents(const Json::Value& json, const LocationScope& l) {
        VkSubpassDependency s{};
        s.srcSubpass = parse_uint32_t(json["srcSubpass"], CreateScope("srcSubpass"));
        s.dstSubpass = parse_uint32_t(json["dstSubpass"], CreateScope("dstSubpass"));
        s.srcStageMask = parse_VkPipelineStageFlags(json["srcStageMask"], CreateScope("srcStageMask"));
        s.dstStageMask = parse_VkPipelineStageFlags(json["dstStageMask"], CreateScope("dstStageMask"));
        s.srcAccessMask = parse_VkAccessFlags(json["srcAccessMask"], CreateScope("srcAccessMask"));
        s.dstAccessMask = parse_VkAccessFlags(json["dstAccessMask"], CreateScope("dstAccessMask"));
        s.dependencyFlags = parse_VkDependencyFlags(json["dependencyFlags"], CreateScope("dependencyFlags"));
        return s;
    }

    VkRenderPassCreateInfo parse_VkRenderPassCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkRenderPassCreateInfo s{};
        s.flags = parse_VkRenderPassCreateFlags(json["flags"], CreateScope("flags"));
        s.attachmentCount = parse_uint32_t(json["attachmentCount"], CreateScope("attachmentCount"));
        {
            const Json::Value& json_member = json["pAttachments"];

            if (s.attachmentCount == 0) {
                s.pAttachments = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pAttachments is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.attachmentCount) {
                        auto dst_buffer = AllocMem<VkAttachmentDescription>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkAttachmentDescription_contents(json_member[i], CreateScope("pAttachments", i));
                        }
                        s.pAttachments = dst_buffer;
                    } else {
                        Error() << "pAttachments array size (" << json_member.size() << ") does not match expected length ("
                                << s.attachmentCount << ")";
                    }
                } else {
                    Error() << "pAttachments is not an array";
                }
            }
        }
        s.subpassCount = parse_uint32_t(json["subpassCount"], CreateScope("subpassCount"));
        {
            const Json::Value& json_member = json["pSubpasses"];

            if (s.subpassCount == 0) {
                s.pSubpasses = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pSubpasses is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.subpassCount) {
                        auto dst_buffer = AllocMem<VkSubpassDescription>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkSubpassDescription_contents(json_member[i], CreateScope("pSubpasses", i));
                        }
                        s.pSubpasses = dst_buffer;
                    } else {
                        Error() << "pSubpasses array size (" << json_member.size() << ") does not match expected length ("
                                << s.subpassCount << ")";
                    }
                } else {
                    Error() << "pSubpasses is not an array";
                }
            }
        }
        s.dependencyCount = parse_uint32_t(json["dependencyCount"], CreateScope("dependencyCount"));
        {
            const Json::Value& json_member = json["pDependencies"];

            if (s.dependencyCount == 0) {
                s.pDependencies = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pDependencies is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.dependencyCount) {
                        auto dst_buffer = AllocMem<VkSubpassDependency>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkSubpassDependency_contents(json_member[i], CreateScope("pDependencies", i));
                        }
                        s.pDependencies = dst_buffer;
                    } else {
                        Error() << "pDependencies array size (" << json_member.size() << ") does not match expected length ("
                                << s.dependencyCount << ")";
                    }
                } else {
                    Error() << "pDependencies is not an array";
                }
            }
        }

        return s;
    }

    VkInputAttachmentAspectReference parse_VkInputAttachmentAspectReference_contents(const Json::Value& json,
                                                                                     const LocationScope& l) {
        VkInputAttachmentAspectReference s{};
        s.subpass = parse_uint32_t(json["subpass"], CreateScope("subpass"));
        s.inputAttachmentIndex = parse_uint32_t(json["inputAttachmentIndex"], CreateScope("inputAttachmentIndex"));
        s.aspectMask = parse_VkImageAspectFlags(json["aspectMask"], CreateScope("aspectMask"));
        return s;
    }

    VkRenderPassInputAttachmentAspectCreateInfo parse_VkRenderPassInputAttachmentAspectCreateInfo_contents(const Json::Value& json,
                                                                                                           const LocationScope& l) {
        VkRenderPassInputAttachmentAspectCreateInfo s{};
        s.aspectReferenceCount = parse_uint32_t(json["aspectReferenceCount"], CreateScope("aspectReferenceCount"));
        {
            const Json::Value& json_member = json["pAspectReferences"];

            if (s.aspectReferenceCount == 0) {
                s.pAspectReferences = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pAspectReferences is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.aspectReferenceCount) {
                        auto dst_buffer = AllocMem<VkInputAttachmentAspectReference>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkInputAttachmentAspectReference_contents(json_member[i],
                                                                                            CreateScope("pAspectReferences", i));
                        }
                        s.pAspectReferences = dst_buffer;
                    } else {
                        Error() << "pAspectReferences array size (" << json_member.size() << ") does not match expected length ("
                                << s.aspectReferenceCount << ")";
                    }
                } else {
                    Error() << "pAspectReferences is not an array";
                }
            }
        }

        return s;
    }

    VkRenderPassMultiviewCreateInfo parse_VkRenderPassMultiviewCreateInfo_contents(const Json::Value& json,
                                                                                   const LocationScope& l) {
        VkRenderPassMultiviewCreateInfo s{};
        s.subpassCount = parse_uint32_t(json["subpassCount"], CreateScope("subpassCount"));
        {
            const Json::Value& json_member = json["pViewMasks"];

            if (s.subpassCount == 0) {
                s.pViewMasks = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pViewMasks is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.subpassCount) {
                        auto dst_buffer = AllocMem<uint32_t>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_uint32_t(json_member[i], CreateScope("pViewMasks", i));
                        }
                        s.pViewMasks = dst_buffer;
                    } else {
                        Error() << "pViewMasks array size (" << json_member.size() << ") does not match expected length ("
                                << s.subpassCount << ")";
                    }
                } else {
                    Error() << "pViewMasks is not an array";
                }
            }
        }
        s.dependencyCount = parse_uint32_t(json["dependencyCount"], CreateScope("dependencyCount"));
        {
            const Json::Value& json_member = json["pViewOffsets"];

            if (s.dependencyCount == 0) {
                s.pViewOffsets = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pViewOffsets is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.dependencyCount) {
                        auto dst_buffer = AllocMem<int32_t>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_int32_t(json_member[i], CreateScope("pViewOffsets", i));
                        }
                        s.pViewOffsets = dst_buffer;
                    } else {
                        Error() << "pViewOffsets array size (" << json_member.size() << ") does not match expected length ("
                                << s.dependencyCount << ")";
                    }
                } else {
                    Error() << "pViewOffsets is not an array";
                }
            }
        }
        s.correlationMaskCount = parse_uint32_t(json["correlationMaskCount"], CreateScope("correlationMaskCount"));
        {
            const Json::Value& json_member = json["pCorrelationMasks"];

            if (s.correlationMaskCount == 0) {
                s.pCorrelationMasks = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pCorrelationMasks is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.correlationMaskCount) {
                        auto dst_buffer = AllocMem<uint32_t>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_uint32_t(json_member[i], CreateScope("pCorrelationMasks", i));
                        }
                        s.pCorrelationMasks = dst_buffer;
                    } else {
                        Error() << "pCorrelationMasks array size (" << json_member.size() << ") does not match expected length ("
                                << s.correlationMaskCount << ")";
                    }
                } else {
                    Error() << "pCorrelationMasks is not an array";
                }
            }
        }

        return s;
    }

    VkAttachmentDescription2 parse_VkAttachmentDescription2_contents(const Json::Value& json, const LocationScope& l) {
        VkAttachmentDescription2 s{};
        s.flags = parse_VkAttachmentDescriptionFlags(json["flags"], CreateScope("flags"));
        s.format = parse_VkFormat(json["format"], CreateScope("format"));
        s.samples = parse_VkSampleCountFlagBits(json["samples"], CreateScope("samples"));
        s.loadOp = parse_VkAttachmentLoadOp(json["loadOp"], CreateScope("loadOp"));
        s.storeOp = parse_VkAttachmentStoreOp(json["storeOp"], CreateScope("storeOp"));
        s.stencilLoadOp = parse_VkAttachmentLoadOp(json["stencilLoadOp"], CreateScope("stencilLoadOp"));
        s.stencilStoreOp = parse_VkAttachmentStoreOp(json["stencilStoreOp"], CreateScope("stencilStoreOp"));
        s.initialLayout = parse_VkImageLayout(json["initialLayout"], CreateScope("initialLayout"));
        s.finalLayout = parse_VkImageLayout(json["finalLayout"], CreateScope("finalLayout"));
        return s;
    }

    VkAttachmentDescriptionStencilLayout parse_VkAttachmentDescriptionStencilLayout_contents(const Json::Value& json,
                                                                                             const LocationScope& l) {
        VkAttachmentDescriptionStencilLayout s{};
        s.stencilInitialLayout = parse_VkImageLayout(json["stencilInitialLayout"], CreateScope("stencilInitialLayout"));
        s.stencilFinalLayout = parse_VkImageLayout(json["stencilFinalLayout"], CreateScope("stencilFinalLayout"));
        return s;
    }

    VkAttachmentReference2 parse_VkAttachmentReference2_contents(const Json::Value& json, const LocationScope& l) {
        VkAttachmentReference2 s{};
        s.attachment = parse_uint32_t(json["attachment"], CreateScope("attachment"));
        s.layout = parse_VkImageLayout(json["layout"], CreateScope("layout"));
        s.aspectMask = parse_VkImageAspectFlags(json["aspectMask"], CreateScope("aspectMask"));
        return s;
    }

    VkAttachmentReferenceStencilLayout parse_VkAttachmentReferenceStencilLayout_contents(const Json::Value& json,
                                                                                         const LocationScope& l) {
        VkAttachmentReferenceStencilLayout s{};
        s.stencilLayout = parse_VkImageLayout(json["stencilLayout"], CreateScope("stencilLayout"));
        return s;
    }

    VkSubpassDescription2 parse_VkSubpassDescription2_contents(const Json::Value& json, const LocationScope& l) {
        VkSubpassDescription2 s{};
        s.flags = parse_VkSubpassDescriptionFlags(json["flags"], CreateScope("flags"));
        s.pipelineBindPoint = parse_VkPipelineBindPoint(json["pipelineBindPoint"], CreateScope("pipelineBindPoint"));
        s.viewMask = parse_uint32_t(json["viewMask"], CreateScope("viewMask"));
        s.inputAttachmentCount = parse_uint32_t(json["inputAttachmentCount"], CreateScope("inputAttachmentCount"));
        {
            const Json::Value& json_member = json["pInputAttachments"];

            if (s.inputAttachmentCount == 0) {
                s.pInputAttachments = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pInputAttachments is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.inputAttachmentCount) {
                        auto dst_buffer = AllocMem<VkAttachmentReference2>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkAttachmentReference2(json_member[i], CreateScope("pInputAttachments", i));
                        }
                        s.pInputAttachments = dst_buffer;
                    } else {
                        Error() << "pInputAttachments array size (" << json_member.size() << ") does not match expected length ("
                                << s.inputAttachmentCount << ")";
                    }
                } else {
                    Error() << "pInputAttachments is not an array";
                }
            }
        }
        s.colorAttachmentCount = parse_uint32_t(json["colorAttachmentCount"], CreateScope("colorAttachmentCount"));
        {
            const Json::Value& json_member = json["pColorAttachments"];

            if (s.colorAttachmentCount == 0) {
                s.pColorAttachments = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pColorAttachments is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.colorAttachmentCount) {
                        auto dst_buffer = AllocMem<VkAttachmentReference2>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkAttachmentReference2(json_member[i], CreateScope("pColorAttachments", i));
                        }
                        s.pColorAttachments = dst_buffer;
                    } else {
                        Error() << "pColorAttachments array size (" << json_member.size() << ") does not match expected length ("
                                << s.colorAttachmentCount << ")";
                    }
                } else {
                    Error() << "pColorAttachments is not an array";
                }
            }
        }

        {
            const Json::Value& json_member = json["pResolveAttachments"];

            if (s.colorAttachmentCount == 0) {
                s.pResolveAttachments = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pResolveAttachments is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.colorAttachmentCount) {
                        auto dst_buffer = AllocMem<VkAttachmentReference2>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkAttachmentReference2(json_member[i], CreateScope("pResolveAttachments", i));
                        }
                        s.pResolveAttachments = dst_buffer;
                    } else {
                        Error() << "pResolveAttachments array size (" << json_member.size() << ") does not match expected length ("
                                << s.colorAttachmentCount << ")";
                    }
                } else if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                    s.pResolveAttachments = nullptr;
                } else {
                    Error() << "pResolveAttachments is not an array and is not NULL";
                }
            }
        }

        {
            const Json::Value& json_member = json["pDepthStencilAttachment"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pDepthStencilAttachment = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkAttachmentReference2>();
                *dst_buffer = parse_VkAttachmentReference2(json_member, CreateScope("pDepthStencilAttachment", true));
                s.pDepthStencilAttachment = dst_buffer;
            }
        }
        s.preserveAttachmentCount = parse_uint32_t(json["preserveAttachmentCount"], CreateScope("preserveAttachmentCount"));
        {
            const Json::Value& json_member = json["pPreserveAttachments"];

            if (s.preserveAttachmentCount == 0) {
                s.pPreserveAttachments = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pPreserveAttachments is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.preserveAttachmentCount) {
                        auto dst_buffer = AllocMem<uint32_t>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_uint32_t(json_member[i], CreateScope("pPreserveAttachments", i));
                        }
                        s.pPreserveAttachments = dst_buffer;
                    } else {
                        Error() << "pPreserveAttachments array size (" << json_member.size() << ") does not match expected length ("
                                << s.preserveAttachmentCount << ")";
                    }
                } else {
                    Error() << "pPreserveAttachments is not an array";
                }
            }
        }

        return s;
    }

    VkFragmentShadingRateAttachmentInfoKHR parse_VkFragmentShadingRateAttachmentInfoKHR_contents(const Json::Value& json,
                                                                                                 const LocationScope& l) {
        VkFragmentShadingRateAttachmentInfoKHR s{};

        {
            const Json::Value& json_member = json["pFragmentShadingRateAttachment"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pFragmentShadingRateAttachment = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkAttachmentReference2>();
                *dst_buffer = parse_VkAttachmentReference2(json_member, CreateScope("pFragmentShadingRateAttachment", true));
                s.pFragmentShadingRateAttachment = dst_buffer;
            }
        }
        s.shadingRateAttachmentTexelSize =
            parse_VkExtent2D_contents(json["shadingRateAttachmentTexelSize"], CreateScope("shadingRateAttachmentTexelSize"));
        return s;
    }

    VkSubpassDescriptionDepthStencilResolve parse_VkSubpassDescriptionDepthStencilResolve_contents(const Json::Value& json,
                                                                                                   const LocationScope& l) {
        VkSubpassDescriptionDepthStencilResolve s{};
        s.depthResolveMode = parse_VkResolveModeFlagBits(json["depthResolveMode"], CreateScope("depthResolveMode"));
        s.stencilResolveMode = parse_VkResolveModeFlagBits(json["stencilResolveMode"], CreateScope("stencilResolveMode"));
        {
            const Json::Value& json_member = json["pDepthStencilResolveAttachment"];
            if (json_member.isString() && strcmp(json_member.asCString(), "NULL") == 0) {
                s.pDepthStencilResolveAttachment = nullptr;
            } else {
                auto dst_buffer = AllocMem<VkAttachmentReference2>();
                *dst_buffer = parse_VkAttachmentReference2(json_member, CreateScope("pDepthStencilResolveAttachment", true));
                s.pDepthStencilResolveAttachment = dst_buffer;
            }
        }

        return s;
    }

    VkSubpassDependency2 parse_VkSubpassDependency2_contents(const Json::Value& json, const LocationScope& l) {
        VkSubpassDependency2 s{};
        s.srcSubpass = parse_uint32_t(json["srcSubpass"], CreateScope("srcSubpass"));
        s.dstSubpass = parse_uint32_t(json["dstSubpass"], CreateScope("dstSubpass"));
        s.srcStageMask = parse_VkPipelineStageFlags(json["srcStageMask"], CreateScope("srcStageMask"));
        s.dstStageMask = parse_VkPipelineStageFlags(json["dstStageMask"], CreateScope("dstStageMask"));
        s.srcAccessMask = parse_VkAccessFlags(json["srcAccessMask"], CreateScope("srcAccessMask"));
        s.dstAccessMask = parse_VkAccessFlags(json["dstAccessMask"], CreateScope("dstAccessMask"));
        s.dependencyFlags = parse_VkDependencyFlags(json["dependencyFlags"], CreateScope("dependencyFlags"));
        s.viewOffset = parse_int32_t(json["viewOffset"], CreateScope("viewOffset"));
        return s;
    }

    VkMemoryBarrier2 parse_VkMemoryBarrier2_contents(const Json::Value& json, const LocationScope& l) {
        VkMemoryBarrier2 s{};
        s.srcStageMask = parse_VkPipelineStageFlags2(json["srcStageMask"], CreateScope("srcStageMask"));
        s.srcAccessMask = parse_VkAccessFlags2(json["srcAccessMask"], CreateScope("srcAccessMask"));
        s.dstStageMask = parse_VkPipelineStageFlags2(json["dstStageMask"], CreateScope("dstStageMask"));
        s.dstAccessMask = parse_VkAccessFlags2(json["dstAccessMask"], CreateScope("dstAccessMask"));
        return s;
    }

    VkRenderPassCreateInfo2 parse_VkRenderPassCreateInfo2_contents(const Json::Value& json, const LocationScope& l) {
        VkRenderPassCreateInfo2 s{};
        s.flags = parse_VkRenderPassCreateFlags(json["flags"], CreateScope("flags"));
        s.attachmentCount = parse_uint32_t(json["attachmentCount"], CreateScope("attachmentCount"));
        {
            const Json::Value& json_member = json["pAttachments"];

            if (s.attachmentCount == 0) {
                s.pAttachments = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pAttachments is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.attachmentCount) {
                        auto dst_buffer = AllocMem<VkAttachmentDescription2>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkAttachmentDescription2(json_member[i], CreateScope("pAttachments", i));
                        }
                        s.pAttachments = dst_buffer;
                    } else {
                        Error() << "pAttachments array size (" << json_member.size() << ") does not match expected length ("
                                << s.attachmentCount << ")";
                    }
                } else {
                    Error() << "pAttachments is not an array";
                }
            }
        }
        s.subpassCount = parse_uint32_t(json["subpassCount"], CreateScope("subpassCount"));
        {
            const Json::Value& json_member = json["pSubpasses"];

            if (s.subpassCount == 0) {
                s.pSubpasses = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pSubpasses is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.subpassCount) {
                        auto dst_buffer = AllocMem<VkSubpassDescription2>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkSubpassDescription2(json_member[i], CreateScope("pSubpasses", i));
                        }
                        s.pSubpasses = dst_buffer;
                    } else {
                        Error() << "pSubpasses array size (" << json_member.size() << ") does not match expected length ("
                                << s.subpassCount << ")";
                    }
                } else {
                    Error() << "pSubpasses is not an array";
                }
            }
        }
        s.dependencyCount = parse_uint32_t(json["dependencyCount"], CreateScope("dependencyCount"));
        {
            const Json::Value& json_member = json["pDependencies"];

            if (s.dependencyCount == 0) {
                s.pDependencies = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pDependencies is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.dependencyCount) {
                        auto dst_buffer = AllocMem<VkSubpassDependency2>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkSubpassDependency2(json_member[i], CreateScope("pDependencies", i));
                        }
                        s.pDependencies = dst_buffer;
                    } else {
                        Error() << "pDependencies array size (" << json_member.size() << ") does not match expected length ("
                                << s.dependencyCount << ")";
                    }
                } else {
                    Error() << "pDependencies is not an array";
                }
            }
        }
        s.correlatedViewMaskCount = parse_uint32_t(json["correlatedViewMaskCount"], CreateScope("correlatedViewMaskCount"));
        {
            const Json::Value& json_member = json["pCorrelatedViewMasks"];

            if (s.correlatedViewMaskCount == 0) {
                s.pCorrelatedViewMasks = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pCorrelatedViewMasks is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.correlatedViewMaskCount) {
                        auto dst_buffer = AllocMem<uint32_t>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_uint32_t(json_member[i], CreateScope("pCorrelatedViewMasks", i));
                        }
                        s.pCorrelatedViewMasks = dst_buffer;
                    } else {
                        Error() << "pCorrelatedViewMasks array size (" << json_member.size() << ") does not match expected length ("
                                << s.correlatedViewMaskCount << ")";
                    }
                } else {
                    Error() << "pCorrelatedViewMasks is not an array";
                }
            }
        }

        return s;
    }

    VkPipelineCacheCreateInfo parse_VkPipelineCacheCreateInfo_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelineCacheCreateInfo s{};
        s.flags = parse_VkPipelineCacheCreateFlags(json["flags"], CreateScope("flags"));
        s.initialDataSize = parse_size_t(json["initialDataSize"], CreateScope("initialDataSize"));
        {
            const Json::Value& json_member = json["pInitialData"];
            if (s.initialDataSize == 0) {
                s.pInitialData = nullptr;
                if (!(json_member.isNull() ||
                      (json_member.isString() && ((json_member.asString() == "") || (json_member.asString() == "NULL"))))) {
                    Error() << "pInitialData is not empty or not NULL but its length is zero";
                }
            } else {
                size_t size = 0;
                s.pInitialData = parse_binary(json_member, CreateScope("pInitialData"), size);
                if (size != s.initialDataSize) {
                    Error() << "pInitialData binary size (" << size << ") does not match expected size (" << s.initialDataSize
                            << ")";
                }
            }
        }

        return s;
    }

    VkPipelinePoolSize parse_VkPipelinePoolSize_contents(const Json::Value& json, const LocationScope& l) {
        VkPipelinePoolSize s{};
        s.poolEntrySize = parse_VkDeviceSize(json["poolEntrySize"], CreateScope("poolEntrySize"));
        s.poolEntryCount = parse_uint32_t(json["poolEntryCount"], CreateScope("poolEntryCount"));
        return s;
    }

    VkDeviceObjectReservationCreateInfo parse_VkDeviceObjectReservationCreateInfo_contents(const Json::Value& json,
                                                                                           const LocationScope& l) {
        VkDeviceObjectReservationCreateInfo s{};
        s.pipelineCacheCreateInfoCount =
            parse_uint32_t(json["pipelineCacheCreateInfoCount"], CreateScope("pipelineCacheCreateInfoCount"));
        {
            const Json::Value& json_member = json["pPipelineCacheCreateInfos"];

            if (s.pipelineCacheCreateInfoCount == 0) {
                s.pPipelineCacheCreateInfos = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pPipelineCacheCreateInfos is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.pipelineCacheCreateInfoCount) {
                        auto dst_buffer = AllocMem<VkPipelineCacheCreateInfo>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] =
                                parse_VkPipelineCacheCreateInfo(json_member[i], CreateScope("pPipelineCacheCreateInfos", i));
                        }
                        s.pPipelineCacheCreateInfos = dst_buffer;
                    } else {
                        Error() << "pPipelineCacheCreateInfos array size (" << json_member.size()
                                << ") does not match expected length (" << s.pipelineCacheCreateInfoCount << ")";
                    }
                } else {
                    Error() << "pPipelineCacheCreateInfos is not an array";
                }
            }
        }
        s.pipelinePoolSizeCount = parse_uint32_t(json["pipelinePoolSizeCount"], CreateScope("pipelinePoolSizeCount"));
        {
            const Json::Value& json_member = json["pPipelinePoolSizes"];

            if (s.pipelinePoolSizeCount == 0) {
                s.pPipelinePoolSizes = nullptr;
                if (!json_member.isString() || strcmp(json_member.asCString(), "NULL") != 0) {
                    Warn() << "pPipelinePoolSizes is not NULL but its length is zero";
                }
            } else {
                if (json_member.isArray()) {
                    if (json_member.size() == s.pipelinePoolSizeCount) {
                        auto dst_buffer = AllocMem<VkPipelinePoolSize>(json_member.size());
                        for (Json::Value::ArrayIndex i = 0; i < json_member.size(); ++i) {
                            dst_buffer[i] = parse_VkPipelinePoolSize(json_member[i], CreateScope("pPipelinePoolSizes", i));
                        }
                        s.pPipelinePoolSizes = dst_buffer;
                    } else {
                        Error() << "pPipelinePoolSizes array size (" << json_member.size() << ") does not match expected length ("
                                << s.pipelinePoolSizeCount << ")";
                    }
                } else {
                    Error() << "pPipelinePoolSizes is not an array";
                }
            }
        }
        s.semaphoreRequestCount = parse_uint32_t(json["semaphoreRequestCount"], CreateScope("semaphoreRequestCount"));
        s.commandBufferRequestCount = parse_uint32_t(json["commandBufferRequestCount"], CreateScope("commandBufferRequestCount"));
        s.fenceRequestCount = parse_uint32_t(json["fenceRequestCount"], CreateScope("fenceRequestCount"));
        s.deviceMemoryRequestCount = parse_uint32_t(json["deviceMemoryRequestCount"], CreateScope("deviceMemoryRequestCount"));
        s.bufferRequestCount = parse_uint32_t(json["bufferRequestCount"], CreateScope("bufferRequestCount"));
        s.imageRequestCount = parse_uint32_t(json["imageRequestCount"], CreateScope("imageRequestCount"));
        s.eventRequestCount = parse_uint32_t(json["eventRequestCount"], CreateScope("eventRequestCount"));
        s.queryPoolRequestCount = parse_uint32_t(json["queryPoolRequestCount"], CreateScope("queryPoolRequestCount"));
        s.bufferViewRequestCount = parse_uint32_t(json["bufferViewRequestCount"], CreateScope("bufferViewRequestCount"));
        s.imageViewRequestCount = parse_uint32_t(json["imageViewRequestCount"], CreateScope("imageViewRequestCount"));
        s.layeredImageViewRequestCount =
            parse_uint32_t(json["layeredImageViewRequestCount"], CreateScope("layeredImageViewRequestCount"));
        s.pipelineCacheRequestCount = parse_uint32_t(json["pipelineCacheRequestCount"], CreateScope("pipelineCacheRequestCount"));
        s.pipelineLayoutRequestCount =
            parse_uint32_t(json["pipelineLayoutRequestCount"], CreateScope("pipelineLayoutRequestCount"));
        s.renderPassRequestCount = parse_uint32_t(json["renderPassRequestCount"], CreateScope("renderPassRequestCount"));
        s.graphicsPipelineRequestCount =
            parse_uint32_t(json["graphicsPipelineRequestCount"], CreateScope("graphicsPipelineRequestCount"));
        s.computePipelineRequestCount =
            parse_uint32_t(json["computePipelineRequestCount"], CreateScope("computePipelineRequestCount"));
        s.descriptorSetLayoutRequestCount =
            parse_uint32_t(json["descriptorSetLayoutRequestCount"], CreateScope("descriptorSetLayoutRequestCount"));
        s.samplerRequestCount = parse_uint32_t(json["samplerRequestCount"], CreateScope("samplerRequestCount"));
        s.descriptorPoolRequestCount =
            parse_uint32_t(json["descriptorPoolRequestCount"], CreateScope("descriptorPoolRequestCount"));
        s.descriptorSetRequestCount = parse_uint32_t(json["descriptorSetRequestCount"], CreateScope("descriptorSetRequestCount"));
        s.framebufferRequestCount = parse_uint32_t(json["framebufferRequestCount"], CreateScope("framebufferRequestCount"));
        s.commandPoolRequestCount = parse_uint32_t(json["commandPoolRequestCount"], CreateScope("commandPoolRequestCount"));
        s.samplerYcbcrConversionRequestCount =
            parse_uint32_t(json["samplerYcbcrConversionRequestCount"], CreateScope("samplerYcbcrConversionRequestCount"));
        s.surfaceRequestCount = parse_uint32_t(json["surfaceRequestCount"], CreateScope("surfaceRequestCount"));
        s.swapchainRequestCount = parse_uint32_t(json["swapchainRequestCount"], CreateScope("swapchainRequestCount"));
        s.displayModeRequestCount = parse_uint32_t(json["displayModeRequestCount"], CreateScope("displayModeRequestCount"));
        s.subpassDescriptionRequestCount =
            parse_uint32_t(json["subpassDescriptionRequestCount"], CreateScope("subpassDescriptionRequestCount"));
        s.attachmentDescriptionRequestCount =
            parse_uint32_t(json["attachmentDescriptionRequestCount"], CreateScope("attachmentDescriptionRequestCount"));
        s.descriptorSetLayoutBindingRequestCount =
            parse_uint32_t(json["descriptorSetLayoutBindingRequestCount"], CreateScope("descriptorSetLayoutBindingRequestCount"));
        s.descriptorSetLayoutBindingLimit =
            parse_uint32_t(json["descriptorSetLayoutBindingLimit"], CreateScope("descriptorSetLayoutBindingLimit"));
        s.maxImageViewMipLevels = parse_uint32_t(json["maxImageViewMipLevels"], CreateScope("maxImageViewMipLevels"));
        s.maxImageViewArrayLayers = parse_uint32_t(json["maxImageViewArrayLayers"], CreateScope("maxImageViewArrayLayers"));
        s.maxLayeredImageViewMipLevels =
            parse_uint32_t(json["maxLayeredImageViewMipLevels"], CreateScope("maxLayeredImageViewMipLevels"));
        s.maxOcclusionQueriesPerPool =
            parse_uint32_t(json["maxOcclusionQueriesPerPool"], CreateScope("maxOcclusionQueriesPerPool"));
        s.maxPipelineStatisticsQueriesPerPool =
            parse_uint32_t(json["maxPipelineStatisticsQueriesPerPool"], CreateScope("maxPipelineStatisticsQueriesPerPool"));
        s.maxTimestampQueriesPerPool =
            parse_uint32_t(json["maxTimestampQueriesPerPool"], CreateScope("maxTimestampQueriesPerPool"));
        s.maxImmutableSamplersPerDescriptorSetLayout = parse_uint32_t(json["maxImmutableSamplersPerDescriptorSetLayout"],
                                                                      CreateScope("maxImmutableSamplersPerDescriptorSetLayout"));
        return s;
    }
};

}  // namespace pcjson
   // NOLINTEND
